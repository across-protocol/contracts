# Foundry Address Extraction Scripts

This directory contains scripts to extract deployed contract addresses from Foundry broadcast files and generate useful artifacts for use in other deployment scripts.

## Prerequisites

The extraction script requires the `eth-utils` Python package for proper EIP-55 address checksumming.

### Installation

```bash
# Install eth-utils using pip
pip3 install eth-utils

# Or if you prefer using pip
pip install eth-utils
```

**Note**: `eth-utils` is a lightweight, well-maintained library that provides Ethereum utilities including proper EIP-55 checksum address formatting. It's the standard library used by the Ethereum Python ecosystem.

## Files

- `extract_foundry_addresses.sh` - Bash script to run the extraction process
- `ExtractDeployedFoundryAddresses.py` - Python script that does the actual extraction
- `DeployedAddresses.sol` - Auto-generated Solidity contract with all deployed addresses (generated by the script)
- `ExampleUsage.s.sol` - Example script showing how to use the DeployedAddresses contract

## Usage

### Running the Script

```bash
# Make the script executable (if not already)
chmod +x script/extract_foundry_addresses.sh

# Run the extraction
./script/extract_foundry_addresses.sh
```

### Generated Output

The script generates three files:

1. **`broadcast/deployed-addresses.md`** - Human-readable markdown file with all deployed addresses
2. **`broadcast/deployed-addresses.json`** - Structured JSON data with all deployed addresses
3. **`broadcast/DeployedAddresses.sol`** - Solidity contract with all addresses as constants and dynamic lookup functions

### Using DeployedAddresses.sol in Your Scripts

The generated `DeployedAddresses.sol` contract contains all deployed contract addresses and provides multiple ways to access them:

#### Method 1: Using Constants (Compile-time)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import { Script } from "forge-std/Script.sol";
import { DeployedAddresses } from "../broadcast/DeployedAddresses.sol";

contract MyDeploymentScript is Script {
  function run() external {
    // Access deployed addresses as constants
    address hubPool = DeployedAddresses.SEPOLIA_DEPLOYHUBPOOL_HUBPOOL;
    address lpTokenFactory = DeployedAddresses.SEPOLIA_DEPLOYHUBPOOL_LPTOKENFACTORY;

    // Use the addresses in your deployment logic
    // ...
  }
}

```

#### Method 2: Using Dynamic Lookup (Runtime)

```solidity
contract MyDeploymentScript is Script {
  function run() external {
    uint256 sepoliaChainId = 11155111;

    // Get addresses dynamically by chain ID and contract name
    address hubPool = DeployedAddresses.getAddress(sepoliaChainId, "HubPool");
    address lpTokenFactory = DeployedAddresses.getAddress(sepoliaChainId, "LpTokenFactory");

    // Check if a contract exists before using it
    if (DeployedAddresses.hasAddress(sepoliaChainId, "HubPool")) {
      // Contract exists, safe to use
      address hubPoolAddress = DeployedAddresses.getAddress(sepoliaChainId, "HubPool");
    }
  }
}

```

### Available Functions

The `DeployedAddresses` contract provides these functions:

#### `getAddress(uint256 chainId, string memory contractName)`

- Returns the contract address for the given chain ID and contract name
- Returns `address(0)` if the contract doesn't exist
- **View function** - no gas cost for reading

#### `hasAddress(uint256 chainId, string memory contractName)`

- Returns `true` if a contract exists for the given chain ID and name
- Returns `false` if the contract doesn't exist
- **View function** - no gas cost for reading

### Constant Naming Convention

The constants in `DeployedAddresses.sol` follow this naming pattern:

```
{CHAIN_NAME}_{SCRIPT_NAME}_{CONTRACT_NAME}
```

Examples:

- `SEPOLIA_DEPLOYHUBPOOL_HUBPOOL` - HubPool contract deployed by DeployHubPool.s.sol on Sepolia
- `MAINNET_DEPLOYPERMISSIONSPLITTERPROXY_PERMISSIONSPLITTERPROXY` - PermissionSplitterProxy on Mainnet

### Contract Name for Dynamic Lookup

For the `getAddress()` and `hasAddress()` functions, use the original contract name as it appears in the deployment:

Examples:

- `"HubPool"` - for the HubPool contract
- `"LpTokenFactory"` - for the LpTokenFactory contract
- `"PermissionSplitterProxy"` - for the PermissionSplitterProxy contract

### Chain Support

The script recognizes these chains:

- Mainnet (Chain ID: 1)
- Sepolia (Chain ID: 11155111)
- Arbitrum One (Chain ID: 42161)
- Arbitrum Sepolia (Chain ID: 421614)
- Polygon (Chain ID: 137)
- Polygon Amoy (Chain ID: 80002)
- Optimism (Chain ID: 10)
- Optimism Sepolia (Chain ID: 11155420)
- Base (Chain ID: 8453)
- Base Sepolia (Chain ID: 84532)
- BSC (Chain ID: 56)
- zkSync Era (Chain ID: 324)
- Linea (Chain ID: 59144)
- Scroll (Chain ID: 534352)
- Scroll Sepolia (Chain ID: 534351)
- Blast (Chain ID: 81457)
- Blast Sepolia (Chain ID: 168587773)

## How It Works

1. The script scans the `broadcast/` directory for `run-latest.json` files
2. It extracts contract addresses from each file's transaction data
3. It organizes the data by chain ID and script name
4. It generates the three output files with the extracted information
5. The Solidity contract includes both constants and a mapping for dynamic lookup
6. All addresses are properly formatted using EIP-55 checksum for Solidity compatibility

## Notes

- The `DeployedAddresses.sol` file is auto-generated and should not be edited manually
- Run the extraction script after each deployment to keep the addresses up to date
- The script only processes the latest deployment for each script/chain combination
- The contract uses a constructor to populate the mapping, making it gas-efficient for lookups
- Both constants and dynamic lookup functions are available for maximum flexibility
- All addresses are properly checksummed using EIP-55 format for Solidity compatibility
