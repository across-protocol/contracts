{
  "address": "0x6f1C9d3bcDF51316E7b515a62C02F601500b084b",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract HubPoolStore",
          "name": "_store",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "_l1Usdc",
          "type": "address"
        },
        {
          "internalType": "contract ITokenMessenger",
          "name": "_cctpTokenMessenger",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_cctpDestinationDomainId",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "_adapterStore",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_oftDstEid",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_oftFeeCap",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "NotImplemented",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OftFeeCapExceeded",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OftIncorrectAmountReceivedLD",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OftIncorrectAmountSentLD",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OftInsufficientBalanceForFee",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OftLzFeeNotZero",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "MessageRelayed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "l1Token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "l2Token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "TokensRelayed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DATA_STORE",
      "outputs": [
        {
          "internalType": "contract HubPoolStore",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "EMPTY_MSG_BYTES",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "OFT_ADAPTER_STORE",
      "outputs": [
        {
          "internalType": "contract AdapterStore",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "OFT_DST_EID",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "OFT_FEE_CAP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cctpTokenMessenger",
      "outputs": [
        {
          "internalType": "contract ITokenMessenger",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cctpV2",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "recipientCircleDomainId",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "relayMessage",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "l1Token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "l2Token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "relayTokens",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "usdcToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x998cf08d47c7d51c049baa1573994021528a944ab67abccfaa208584f8ceb350",
  "receipt": {
    "to": null,
    "from": "0x9A8f92a830A5cB89a3816e3D267CB7791c16b04D",
    "contractAddress": "0x6f1C9d3bcDF51316E7b515a62C02F601500b084b",
    "transactionIndex": 255,
    "gasUsed": "1181368",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa906958a4bb3f89184d149f1742bbc5fdc2a376dcf83fd85b75761e50ffb6f6a",
    "transactionHash": "0x998cf08d47c7d51c049baa1573994021528a944ab67abccfaa208584f8ceb350",
    "logs": [],
    "blockNumber": 23251254,
    "cumulativeGasUsed": "22001141",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1Ace3BbD69b63063F859514Eca29C9BDd8310E61",
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    "0x0000000000000000000000000000000000000000",
    4294967295,
    "0x42df4D71f35ffBD28ae217d52E83C1DA0007D63b",
    30102,
    "1000000000000000000"
  ],
  "numDeployments": 2,
  "solcInputHash": "d10c067446106dff0fadbbfab98548d9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract HubPoolStore\",\"name\":\"_store\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_l1Usdc\",\"type\":\"address\"},{\"internalType\":\"contract ITokenMessenger\",\"name\":\"_cctpTokenMessenger\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_cctpDestinationDomainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_adapterStore\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_oftDstEid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_oftFeeCap\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotImplemented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OftFeeCapExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OftIncorrectAmountReceivedLD\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OftIncorrectAmountSentLD\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OftInsufficientBalanceForFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OftLzFeeNotZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TokensRelayed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DATA_STORE\",\"outputs\":[{\"internalType\":\"contract HubPoolStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMPTY_MSG_BYTES\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OFT_ADAPTER_STORE\",\"outputs\":[{\"internalType\":\"contract AdapterStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OFT_DST_EID\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OFT_FEE_CAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cctpTokenMessenger\",\"outputs\":[{\"internalType\":\"contract ITokenMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cctpV2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipientCircleDomainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"relayMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"relayTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"bugs@across.to\",\"details\":\"This contract should NOT be reused to send messages to SpokePools that have the same address on different L2s.This contract can be redeployed to point to a new HubPoolStore if the data store gets corrupted and new data can't get written to the store for some reason. The corresponding Universal_SpokePool contract will also need to be redeployed to point to the new HubPoolStore.\",\"kind\":\"dev\",\"methods\":{\"relayMessage(address,bytes)\":{\"params\":{\"message\":\"Data to send to target.\",\"target\":\"Contract on the destination that will receive the message. Unused if the message is created by the HubPool admin.\"}},\"relayTokens(address,address,uint256,address)\":{\"details\":\"This function uses CircleCCTPAdapter to relay USDC and OFTTransportAdapterWithStore to relay OFT tokens to L2 chains that support these methods. Relaying other tokens will cause this function to revert.\",\"params\":{\"amount\":\"Amount of tokens to relay.\",\"l1Token\":\"Address of the token on L1.\",\"l2Token\":\"Address of the token on L2. Unused\",\"to\":\"Address to receive the tokens on L2. Should be SpokePool address.\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"OftFeeCapExceeded()\":[{\"notice\":\"Thrown when OFT fee exceeds the configured cap \"}],\"OftIncorrectAmountReceivedLD()\":[{\"notice\":\"Thrown when amount received differs from expected amount \"}],\"OftIncorrectAmountSentLD()\":[{\"notice\":\"Thrown when amount sent differs from expected amount \"}],\"OftInsufficientBalanceForFee()\":[{\"notice\":\"Thrown when contract has insufficient balance to pay OFT fees \"}],\"OftLzFeeNotZero()\":[{\"notice\":\"Thrown when LayerZero token fee is not zero (only native fees supported) \"}]},\"kind\":\"user\",\"methods\":{\"DATA_STORE()\":{\"notice\":\"Contract that stores calldata to be relayed to L2 via storage proofs.\"},\"EMPTY_MSG_BYTES()\":{\"notice\":\"Empty bytes array used for OFT messaging parameters \"},\"OFT_ADAPTER_STORE()\":{\"notice\":\"Helper storage contract to keep track of token => IOFT relationships \"},\"relayMessage(address,bytes)\":{\"notice\":\"Saves calldata in a simple storage contract whose state can be proven and relayed to L2.\"},\"relayTokens(address,address,uint256,address)\":{\"notice\":\"Relays tokens from L1 to L2.\"}},\"notice\":\"Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts on the L2 where the SpokePool is deployed. Designed to be used as a singleton contract that can be used to relay messages to multiple SpokePools on different chains.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/chain-adapters/Universal_Adapter.sol\":\"Universal_Adapter\"},\"debug\":{\"revertStrings\":\"strip\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xa92e4fa126feb6907daa0513ddd816b2eb91f30a808de54f63c17d0e162c3439\",\"license\":\"MIT\"},\"contracts/AdapterStore.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IOFT } from \\\"./interfaces/IOFT.sol\\\";\\n\\n/**\\n * @title MessengerTypes\\n * @notice Library containing messenger type constants\\n * @custom:security-contact bugs@across.to\\n */\\nlibrary MessengerTypes {\\n    /** @notice Identifier for OFT (Omni-chain Fungible Token by LayerZero) messenger type */\\n    bytes32 public constant OFT_MESSENGER = bytes32(\\\"OFT_MESSENGER\\\");\\n}\\n\\n/**\\n * @dev A helper contract for chain adapters on the hub chain that support OFT messaging. Handles\\n * @dev token => messenger mapping storage. Adapters can't store this themselves as they're called\\n * @dev via `delegateCall` and their storage is not part of available context.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract AdapterStore is Ownable {\\n    /** @notice Maps messenger type and destination domain to token-messenger pairs */\\n    mapping(bytes32 messengerType => mapping(uint256 dstDomainId => mapping(address srcChainToken => address messengerAddress)))\\n        public crossChainMessengers;\\n\\n    /**\\n     * @notice Emitted when a messenger is set for a specific token and destination\\n     * @param messengerType Type of messenger being set\\n     * @param dstDomainId Destination domain ID\\n     * @param srcChainToken Source chain token address\\n     * @param srcChainMessenger Source chain messenger address\\n     */\\n    event MessengerSet(\\n        bytes32 indexed messengerType,\\n        uint256 indexed dstDomainId,\\n        address indexed srcChainToken,\\n        address srcChainMessenger\\n    );\\n\\n    /** @notice Thrown when array lengths don't match in batch operations */\\n    error ArrayLengthMismatch();\\n\\n    /** @notice Thrown when IOFT messenger's token doesn't match expected token */\\n    error IOFTTokenMismatch();\\n\\n    /** @notice Thrown when messenger type is not supported */\\n    error NonExistentMessengerType();\\n\\n    /**\\n     * @notice Sets a messenger for a specific token and destination domain\\n     * @param messengerType Type of messenger to set\\n     * @param dstDomainId Destination domain ID\\n     * @param srcChainToken Source chain token address\\n     * @param srcChainMessenger Source chain messenger address\\n     */\\n    function setMessenger(\\n        bytes32 messengerType,\\n        uint256 dstDomainId,\\n        address srcChainToken,\\n        address srcChainMessenger\\n    ) external onlyOwner {\\n        _setMessenger(messengerType, dstDomainId, srcChainToken, srcChainMessenger);\\n    }\\n\\n    /**\\n     * @notice Sets multiple messengers in a single transaction\\n     * @param messengerTypes Array of messenger types\\n     * @param dstDomainIds Array of destination domain IDs\\n     * @param srcChainTokens Array of source chain token addresses\\n     * @param srcChainMessengers Array of source chain messenger addresses\\n     */\\n    function batchSetMessengers(\\n        bytes32[] calldata messengerTypes,\\n        uint256[] calldata dstDomainIds,\\n        address[] calldata srcChainTokens,\\n        address[] calldata srcChainMessengers\\n    ) external onlyOwner {\\n        if (\\n            messengerTypes.length != dstDomainIds.length ||\\n            messengerTypes.length != srcChainTokens.length ||\\n            messengerTypes.length != srcChainMessengers.length\\n        ) {\\n            revert ArrayLengthMismatch();\\n        }\\n\\n        for (uint256 i = 0; i < dstDomainIds.length; i++) {\\n            _setMessenger(messengerTypes[i], dstDomainIds[i], srcChainTokens[i], srcChainMessengers[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to set a messenger with validation\\n     * @param _messengerType Type of messenger to set\\n     * @param _dstDomainId Destination domain ID\\n     * @param _srcChainToken Source chain token address\\n     * @param _srcChainMessenger Source chain messenger address\\n     */\\n    function _setMessenger(\\n        bytes32 _messengerType,\\n        uint256 _dstDomainId,\\n        address _srcChainToken,\\n        address _srcChainMessenger\\n    ) internal {\\n        // @dev Always allow zero-messenger to be set: this can be used to 'remove' a stored token <> messenger relationship\\n        if (_srcChainMessenger != address(0)) {\\n            if (_messengerType == MessengerTypes.OFT_MESSENGER) {\\n                // @dev Protect against human error: check that IOFT messenger's token matches the expected one\\n                if (IOFT(_srcChainMessenger).token() != _srcChainToken) {\\n                    revert IOFTTokenMismatch();\\n                }\\n            } else {\\n                revert NonExistentMessengerType();\\n            }\\n        }\\n        crossChainMessengers[_messengerType][_dstDomainId][_srcChainToken] = _srcChainMessenger;\\n        emit MessengerSet(_messengerType, _dstDomainId, _srcChainToken, _srcChainMessenger);\\n    }\\n}\\n\",\"keccak256\":\"0xd13309eb2b0a3df5d51b1ee1e19fd349347e35307cd420e8e2f637271530e039\",\"license\":\"BUSL-1.1\"},\"contracts/chain-adapters/Universal_Adapter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/AdapterInterface.sol\\\";\\n\\nimport \\\"../libraries/CircleCCTPAdapter.sol\\\";\\nimport { SpokePoolInterface } from \\\"../interfaces/SpokePoolInterface.sol\\\";\\nimport { HubPoolStore } from \\\"./utilities/HubPoolStore.sol\\\";\\nimport { IOFT } from \\\"../interfaces/IOFT.sol\\\";\\nimport { OFTTransportAdapterWithStore } from \\\"../libraries/OFTTransportAdapterWithStore.sol\\\";\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\\n/**\\n * @notice Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts\\n * on the L2 where the SpokePool is deployed. Designed to be used as a singleton contract that can be used to relay\\n * messages to multiple SpokePools on different chains.\\n * @dev This contract should NOT be reused to send messages to SpokePools that have the same address on different L2s.\\n * @dev This contract can be redeployed to point to a new HubPoolStore if the data store gets corrupted and new data\\n * can't get written to the store for some reason. The corresponding Universal_SpokePool contract will\\n * also need to be redeployed to point to the new HubPoolStore.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract Universal_Adapter is AdapterInterface, CircleCCTPAdapter, OFTTransportAdapterWithStore {\\n    /// @notice Contract that stores calldata to be relayed to L2 via storage proofs.\\n    HubPoolStore public immutable DATA_STORE;\\n\\n    error NotImplemented();\\n\\n    constructor(\\n        HubPoolStore _store,\\n        IERC20 _l1Usdc,\\n        ITokenMessenger _cctpTokenMessenger,\\n        uint32 _cctpDestinationDomainId,\\n        address _adapterStore,\\n        uint32 _oftDstEid,\\n        uint256 _oftFeeCap\\n    )\\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, _cctpDestinationDomainId)\\n        OFTTransportAdapterWithStore(_oftDstEid, _oftFeeCap, _adapterStore)\\n    {\\n        DATA_STORE = _store;\\n    }\\n\\n    /**\\n     * @notice Saves calldata in a simple storage contract whose state can be proven and relayed to L2.\\n     * @param target Contract on the destination that will receive the message. Unused if the message is created\\n     * by the HubPool admin.\\n     * @param message Data to send to target.\\n     */\\n    function relayMessage(address target, bytes calldata message) external payable override {\\n        // Admin messages are stored differently in the data store than non-admin messages, because admin\\n        // messages must only be sent to a single target on a specific L2 chain. Non-admin messages are sent\\n        // to any target on any L2 chain because the only type of an non-admin message is the result of a\\n        // HubPool.executeRootBundle() call which attempts to relay a relayRootBundle() call to all SpokePools using\\n        // this adapter. Therefore, non-admin messages are stored optimally in the data store\\n        // by only storing the message once and allowing any SpokePool target to read it via storage proofs.\\n\\n        // We assume that the HubPool is delegatecall-ing into this function, therefore address(this) is the HubPool's\\n        // address. As a result, we can determine whether this message is an admin function based on the msg.sender.\\n        // If an admin sends a message that could have been relayed as a non-admin message (e.g. the admin\\n        // calls executeRootBundle()), then the message won't be stored optimally in the data store, but the\\n        // message can still be delivered to the target.\\n        bool isAdminSender = msg.sender == IOwnable(address(this)).owner();\\n        DATA_STORE.storeRelayMessageCalldata(target, message, isAdminSender);\\n        emit MessageRelayed(target, message);\\n    }\\n\\n    /**\\n     * @notice Relays tokens from L1 to L2.\\n     * @dev This function uses CircleCCTPAdapter to relay USDC and OFTTransportAdapterWithStore to relay\\n     * OFT tokens to L2 chains that support these methods. Relaying other tokens will cause this function\\n     * to revert.\\n     * @param l1Token Address of the token on L1.\\n     * @param l2Token Address of the token on L2. Unused\\n     * @param amount Amount of tokens to relay.\\n     * @param to Address to receive the tokens on L2. Should be SpokePool address.\\n     */\\n    function relayTokens(\\n        address l1Token,\\n        address l2Token,\\n        uint256 amount,\\n        address to\\n    ) external payable override {\\n        address oftMessenger = _getOftMessenger(l1Token);\\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\\n            _transferUsdc(to, amount);\\n        } else if (oftMessenger != address(0)) {\\n            _transferViaOFT(IERC20(l1Token), IOFT(oftMessenger), to, amount);\\n        } else {\\n            revert NotImplemented();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe782b39a2f4093dea462614c5887b5676de7680a969a96854350c719954f4775\",\"license\":\"BUSL-1.1\"},\"contracts/chain-adapters/interfaces/AdapterInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\\n * This interface is implemented by an adapter contract that is deployed on L1.\\n */\\n\\ninterface AdapterInterface {\\n    event MessageRelayed(address target, bytes message);\\n\\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\\n\\n    /**\\n     * @notice Send message to `target` on L2.\\n     * @dev This method is marked payable because relaying the message might require a fee\\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\\n     * to the target contract on L2.\\n     * @param target L2 address to send message to.\\n     * @param message Message to send to `target`.\\n     */\\n    function relayMessage(address target, bytes calldata message) external payable;\\n\\n    /**\\n     * @notice Send `amount` of `l1Token` to `to` on L2. `l2Token` is the L2 address equivalent of `l1Token`.\\n     * @dev This method is marked payable because relaying the message might require a fee\\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\\n     * to the target contract on L2.\\n     * @param l1Token L1 token to bridge.\\n     * @param l2Token L2 token to receive.\\n     * @param amount Amount of `l1Token` to bridge.\\n     * @param to Bridge recipient.\\n     */\\n    function relayTokens(\\n        address l1Token,\\n        address l2Token,\\n        uint256 amount,\\n        address to\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x1d52fcb8b10dc7f260345918c1a90d496a4c9f774402cbd5ebde881b8fed6d50\",\"license\":\"BUSL-1.1\"},\"contracts/chain-adapters/utilities/HubPoolStore.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { HubPoolInterface } from \\\"../../interfaces/HubPoolInterface.sol\\\";\\n\\ninterface IHubPool {\\n    function rootBundleProposal() external view returns (HubPoolInterface.RootBundle memory);\\n}\\n\\n/**\\n * @notice Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts\\n * on the L2 where the SpokePool is deployed. Only the HubPool can store data to this contract. Each data to be\\n * relayed is written to a unique slot key and that slot key's value can never be modified.\\n * @dev Designed to be used with Universal_Adapter and Universal_SpokePool.\\n * @dev This contract DOES NOT prevent replay attacks of storage proofs on the L2 spoke pool if the\\n * UniversalStorageProof_Adapters using this contract are mapped to spokepools with the same address on different\\n * L2 chains. See comment in storeRelayAdminFunctionCalldata() for more details.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract HubPoolStore {\\n    error NotHubPool();\\n\\n    /// @notice Maps nonce to hash of calldata.\\n    mapping(uint256 => bytes32) public relayMessageCallData;\\n\\n    /// @notice Counter to ensure that each relay admin function calldata is unique.\\n    uint256 private dataUuid;\\n\\n    /// @notice Address of the HubPool contract, the only contract that can store data to this contract.\\n    address public immutable hubPool;\\n\\n    /// @notice Event designed to be queried off chain and relayed to Universal SpokePool.\\n    event StoredCallData(address indexed target, bytes data, uint256 indexed nonce);\\n\\n    modifier onlyHubPool() {\\n        if (msg.sender != hubPool) {\\n            revert NotHubPool();\\n        }\\n        _;\\n    }\\n\\n    constructor(address _hubPool) {\\n        hubPool = _hubPool;\\n    }\\n\\n    /**\\n     * @notice To be called by HubPool to store calldata that will be relayed\\n     * to the Universal_SpokePool via storage proofs.\\n     * @dev Only callable by the HubPool contract.\\n     * @param target Address of the contract on the destination that will receive the message. Unused if the\\n     * data is NOT an admin function and can be relayed to any target.\\n     * @param data Data to send to Universal SpokePool.\\n     * @param isAdminSender True if the data is an admin function call, false otherwise.\\n     */\\n    function storeRelayMessageCalldata(\\n        address target,\\n        bytes calldata data,\\n        bool isAdminSender\\n    ) external onlyHubPool {\\n        if (isAdminSender) {\\n            _storeData(target, dataUuid++, data);\\n        } else {\\n            _storeRelayMessageCalldataForAnyTarget(data);\\n        }\\n    }\\n\\n    function _storeRelayMessageCalldataForAnyTarget(bytes calldata data) internal {\\n        // When the data can be sent to any target, we assume that the data contains a relayRootBundleCall as\\n        // constructed by an executeRootBundle() call, therefore this data will be identical for all spoke pools\\n        // in this bundle. We can use the current hub pool's challengePeriodEndTimestamp as the nonce for this data\\n        // so that all relayRootBundle calldata for this bundle gets stored to the same slot and we only write to\\n        // this slot once.\\n        _storeData(address(0), IHubPool(hubPool).rootBundleProposal().challengePeriodEndTimestamp, data);\\n    }\\n\\n    function _storeData(\\n        address target,\\n        uint256 nonce,\\n        bytes calldata data\\n    ) internal {\\n        if (relayMessageCallData[nonce] != bytes32(0)) {\\n            // Data is already stored, do nothing.\\n            return;\\n        }\\n        relayMessageCallData[nonce] = keccak256(abi.encode(target, data));\\n        emit StoredCallData(target, data, nonce);\\n    }\\n}\\n\",\"keccak256\":\"0x4069c9b161df882f990c735fa9076186dac7bf8fd3888ba427057c1631d659c3\",\"license\":\"BUSL-1.1\"},\"contracts/external/interfaces/CCTPInterfaces.sol\":{\"content\":\"/**\\n * Copyright (C) 2015, 2016, 2017 Dapphub\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/**\\n * Imported as-is from commit 139d8d0ce3b5531d3c7ec284f89d946dfb720016 of:\\n *   * https://github.com/walkerq/evm-cctp-contracts/blob/139d8d0ce3b5531d3c7ec284f89d946dfb720016/src/TokenMessenger.sol\\n * Changes applied post-import:\\n *   * Removed a majority of code from this contract and converted the needed function signatures in this interface.\\n */\\ninterface ITokenMessenger {\\n    /**\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\\n     * Emits a `DepositForBurn` event.\\n     * @dev reverts if:\\n     * - given burnToken is not supported\\n     * - given destinationDomain has no TokenMessenger registered\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\n     * to this contract is less than `amount`.\\n     * - burn() reverts. For example, if `amount` is 0.\\n     * - MessageTransmitter returns false or reverts.\\n     * @param amount amount of tokens to burn\\n     * @param destinationDomain destination domain\\n     * @param mintRecipient address of mint recipient on destination domain\\n     * @param burnToken address of contract to burn deposited tokens, on local domain\\n     * @return _nonce unique nonce reserved by message\\n     */\\n    function depositForBurn(\\n        uint256 amount,\\n        uint32 destinationDomain,\\n        bytes32 mintRecipient,\\n        address burnToken\\n    ) external returns (uint64 _nonce);\\n\\n    /**\\n     * @notice Minter responsible for minting and burning tokens on the local domain\\n     * @dev A TokenMessenger stores a TokenMinter contract which extends the TokenController contract.\\n     * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMessenger.sol#L110\\n     * @return minter Token Minter contract.\\n     */\\n    function localMinter() external view returns (ITokenMinter minter);\\n}\\n\\n// Source: https://github.com/circlefin/evm-cctp-contracts/blob/63ab1f0ac06ce0793c0bbfbb8d09816bc211386d/src/v2/TokenMessengerV2.sol#L138C1-L166C15\\ninterface ITokenMessengerV2 {\\n    /**\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\\n     * Emits a `DepositForBurn` event.\\n     * @dev reverts if:\\n     * - given burnToken is not supported\\n     * - given destinationDomain has no TokenMessenger registered\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\n     * to this contract is less than `amount`.\\n     * - burn() reverts. For example, if `amount` is 0.\\n     * - maxFee is greater than or equal to `amount`.\\n     * - MessageTransmitterV2#sendMessage reverts.\\n     * @param amount amount of tokens to burn\\n     * @param destinationDomain destination domain to receive message on\\n     * @param mintRecipient address of mint recipient on destination domain\\n     * @param burnToken token to burn `amount` of, on local domain\\n     * @param destinationCaller authorized caller on the destination domain, as bytes32. If equal to bytes32(0),\\n     * any address can broadcast the message.\\n     * @param maxFee maximum fee to pay on the destination domain, specified in units of burnToken\\n     * @param minFinalityThreshold the minimum finality at which a burn message will be attested to.\\n     */\\n    function depositForBurn(\\n        uint256 amount,\\n        uint32 destinationDomain,\\n        bytes32 mintRecipient,\\n        address burnToken,\\n        bytes32 destinationCaller,\\n        uint256 maxFee,\\n        uint32 minFinalityThreshold\\n    ) external;\\n}\\n\\n/**\\n * A TokenMessenger stores a TokenMinter contract which extends the TokenController contract. The TokenController\\n * contract has a burnLimitsPerMessage public mapping which can be queried to find the per-message burn limit\\n * for a given token:\\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMinter.sol#L33\\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/roles/TokenController.sol#L69C40-L69C60\\n *\\n */\\ninterface ITokenMinter {\\n    /**\\n     * @notice Supported burnable tokens on the local domain\\n     * local token (address) => maximum burn amounts per message\\n     * @param token address of token contract\\n     * @return burnLimit maximum burn amount per message for token\\n     */\\n    function burnLimitsPerMessage(address token) external view returns (uint256);\\n}\\n\\n/**\\n * IMessageTransmitter in CCTP inherits IRelayer and IReceiver, but here we only import sendMessage from IRelayer:\\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IMessageTransmitter.sol#L25\\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IRelayer.sol#L23-L35\\n */\\ninterface IMessageTransmitter {\\n    /**\\n     * @notice Sends an outgoing message from the source domain.\\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\\n     * @param destinationDomain Domain of destination chain\\n     * @param recipient Address of message recipient on destination domain as bytes32\\n     * @param messageBody Raw bytes content of message\\n     * @return nonce reserved by message\\n     */\\n    function sendMessage(\\n        uint32 destinationDomain,\\n        bytes32 recipient,\\n        bytes calldata messageBody\\n    ) external returns (uint64);\\n}\\n\",\"keccak256\":\"0x69059bd91cdb9bea59242c543a167e38a9f3a7788687d4194f68420a956c7608\",\"license\":\"GPL-3.0-or-later\"},\"contracts/interfaces/HubPoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @notice Concise list of functions in HubPool implementation.\\n */\\ninterface HubPoolInterface {\\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\\n    struct PoolRebalanceLeaf {\\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).\\n        uint256 chainId;\\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\\n        uint256[] bundleLpFees;\\n        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative\\n        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This\\n        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does\\n        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous\\n        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's\\n        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.\\n        int256[] netSendAmounts;\\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1\\n        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that\\n        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.\\n        int256[] runningBalances;\\n        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.\\n        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where\\n        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under\\n        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with\\n        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one\\n        // leaf for a specific chainId should have a groupIndex equal to 0.\\n        uint256 groupIndex;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint8 leafId;\\n        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel\\n        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero\\n        // relays on this chain in this bundle in the order of whitelisting.\\n        address[] l1Tokens;\\n    }\\n\\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves\\n    // that can be executed later to:\\n    // - Send funds from this contract to a SpokePool or vice versa\\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \\\"slow\\\" relay\\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\\n    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\\n    struct RootBundle {\\n        // Contains leaves instructing this contract to send funds to SpokePools.\\n        bytes32 poolRebalanceRoot;\\n        // Relayer refund merkle root to be published to a SpokePool.\\n        bytes32 relayerRefundRoot;\\n        // Slow relay merkle root to be published to a SpokePool.\\n        bytes32 slowRelayRoot;\\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\\n        uint256 claimedBitMap;\\n        // Proposer of this root bundle.\\n        address proposer;\\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\\n        // of leaves are executed, a new root bundle can be proposed\\n        uint8 unclaimedPoolRebalanceLeafCount;\\n        // When root bundle challenge period passes and this root bundle becomes executable.\\n        uint32 challengePeriodEndTimestamp;\\n    }\\n\\n    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the\\n    // cumulative LP positions and if this token is enabled for deposits.\\n    struct PooledToken {\\n        // LP token given to LPs of a specific L1 token.\\n        address lpToken;\\n        // True if accepting new LP's.\\n        bool isEnabled;\\n        // Timestamp of last LP fee update.\\n        uint32 lastLpFeeUpdate;\\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\\n        // back later.\\n        int256 utilizedReserves;\\n        // Number of LP funds held in contract less utilized reserves.\\n        uint256 liquidReserves;\\n        // Number of LP funds reserved to pay out to LPs as fees.\\n        uint256 undistributedLpFees;\\n    }\\n\\n    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\\n    struct CrossChainContract {\\n        address adapter;\\n        address spokePool;\\n    }\\n\\n    function setPaused(bool pause) external;\\n\\n    function emergencyDeleteProposal() external;\\n\\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\\n\\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\\n\\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\\n\\n    function setLiveness(uint32 newLiveness) external;\\n\\n    function setIdentifier(bytes32 newIdentifier) external;\\n\\n    function setCrossChainContracts(\\n        uint256 l2ChainId,\\n        address adapter,\\n        address spokePool\\n    ) external;\\n\\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\\n\\n    function removeLiquidity(\\n        address l1Token,\\n        uint256 lpTokenAmount,\\n        bool sendEth\\n    ) external;\\n\\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);\\n\\n    function sync(address l1Token) external;\\n\\n    function proposeRootBundle(\\n        uint256[] memory bundleEvaluationBlockNumbers,\\n        uint8 poolRebalanceLeafCount,\\n        bytes32 poolRebalanceRoot,\\n        bytes32 relayerRefundRoot,\\n        bytes32 slowRelayRoot\\n    ) external;\\n\\n    function executeRootBundle(\\n        uint256 chainId,\\n        uint256 groupIndex,\\n        uint256[] memory bundleLpFees,\\n        int256[] memory netSendAmounts,\\n        int256[] memory runningBalances,\\n        uint8 leafId,\\n        address[] memory l1Tokens,\\n        bytes32[] memory proof\\n    ) external;\\n\\n    function disputeRootBundle() external;\\n\\n    function claimProtocolFeesCaptured(address l1Token) external;\\n\\n    function setPoolRebalanceRoute(\\n        uint256 destinationChainId,\\n        address l1Token,\\n        address destinationToken\\n    ) external;\\n\\n    function setDepositRoute(\\n        uint256 originChainId,\\n        uint256 destinationChainId,\\n        address originToken,\\n        bool depositsEnabled\\n    ) external;\\n\\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\\n        external\\n        view\\n        returns (address destinationToken);\\n\\n    function loadEthForL2Calls() external payable;\\n}\\n\",\"keccak256\":\"0xd8cfdded5db9bf29099e91abd8c8992b4deba1a22d4ffaed94c43ff3d47dcf33\",\"license\":\"MIT\"},\"contracts/interfaces/IOFT.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice This file contains minimal copies of relevant structs / interfaces for OFT bridging. Source code link:\\n * https://github.com/LayerZero-Labs/LayerZero-v2/blob/9a4049ae3a374e1c0ef01ac9fb53dd83f4257a68/packages/layerzero-v2/evm/oapp/contracts/oft/interfaces/IOFT.sol\\n * It's also published as a part of an npm package: @layerzerolabs/oft-evm. The published code is incompatible with\\n * our compiler version requirements, so we copy it here instead\\n */\\n\\nstruct MessagingReceipt {\\n    bytes32 guid;\\n    uint64 nonce;\\n    MessagingFee fee;\\n}\\n\\nstruct MessagingFee {\\n    uint256 nativeFee;\\n    uint256 lzTokenFee;\\n}\\n\\n/**\\n * @dev Struct representing token parameters for the OFT send() operation.\\n */\\nstruct SendParam {\\n    uint32 dstEid; // Destination endpoint ID.\\n    bytes32 to; // Recipient address.\\n    uint256 amountLD; // Amount to send in local decimals.\\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\\n    bytes composeMsg; // The composed message for the send() operation.\\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\\n}\\n\\n/**\\n * @dev Struct representing OFT receipt information.\\n */\\nstruct OFTReceipt {\\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\\n}\\n\\n/**\\n * @title IOFT\\n * @dev Interface for the OftChain (OFT) token.\\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\\n * @dev This specific interface ID is '0x02e49c2c'.\\n */\\ninterface IOFT {\\n    /**\\n     * @notice Retrieves the address of the token associated with the OFT.\\n     * @return token The address of the ERC20 token implementation.\\n     */\\n    function token() external view returns (address);\\n\\n    /**\\n     * @notice Provides a quote for the send() operation.\\n     * @param _sendParam The parameters for the send() operation.\\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\\n     *\\n     * @dev MessagingFee: LayerZero msg fee\\n     *  - nativeFee: The native fee.\\n     *  - lzTokenFee: The lzToken fee.\\n     */\\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\\n\\n    /**\\n     * @notice Executes the send() operation.\\n     * @param _sendParam The parameters for the send operation.\\n     * @param _fee The fee information supplied by the caller.\\n     *      - nativeFee: The native fee.\\n     *      - lzTokenFee: The lzToken fee.\\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\\n     * @return receipt The LayerZero messaging receipt from the send() operation.\\n     * @return oftReceipt The OFT receipt information.\\n     *\\n     * @dev MessagingReceipt: LayerZero msg receipt\\n     *  - guid: The unique identifier for the sent message.\\n     *  - nonce: The nonce of the sent message.\\n     *  - fee: The LayerZero fee incurred for the message.\\n     */\\n    function send(\\n        SendParam calldata _sendParam,\\n        MessagingFee calldata _fee,\\n        address _refundAddress\\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\\n}\\n\",\"keccak256\":\"0x9c32621db83fa983cdc964eec1cd8ee07f98f40aca4d799abe953df620cf1994\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/SpokePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Contains common data structures and functions used by all SpokePool implementations.\\n */\\ninterface SpokePoolInterface {\\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\\n    struct RelayerRefundLeaf {\\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that\\n        // is negative. This is just the negative of this value.\\n        uint256 amountToReturn;\\n        // Used to verify that this is being executed on the correct destination chainId.\\n        uint256 chainId;\\n        // This array designates how much each of those addresses should be refunded.\\n        uint256[] refundAmounts;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint32 leafId;\\n        // The associated L2TokenAddress that these claims apply to.\\n        address l2TokenAddress;\\n        // Must be same length as refundAmounts and designates each address that must be refunded.\\n        address[] refundAddresses;\\n    }\\n\\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\\n    // by \\\"data workers\\\" via inclusion proofs to execute leaves in the roots.\\n    struct RootBundle {\\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\\n        bytes32 slowRelayRoot;\\n        // Merkle root of relayer refunds for successful relays.\\n        bytes32 relayerRefundRoot;\\n        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of\\n        // 256x(2^248) leaves per root.\\n        mapping(uint256 => uint256) claimedBitmap;\\n    }\\n\\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\\n\\n    function setWithdrawalRecipient(address newWithdrawalRecipient) external;\\n\\n    function pauseDeposits(bool pause) external;\\n\\n    function pauseFills(bool pause) external;\\n\\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\\n\\n    function emergencyDeleteRootBundle(uint256 rootBundleId) external;\\n\\n    function depositDeprecated_5947912356(\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external payable;\\n\\n    function depositFor(\\n        address depositor,\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external payable;\\n\\n    function executeRelayerRefundLeaf(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) external payable;\\n\\n    function chainId() external view returns (uint256);\\n\\n    error NotEOA();\\n    error InvalidDepositorSignature();\\n    error InvalidRelayerFeePct();\\n    error MaxTransferSizeExceeded();\\n    error InvalidCrossDomainAdmin();\\n    error InvalidWithdrawalRecipient();\\n    error DepositsArePaused();\\n    error FillsArePaused();\\n}\\n\",\"keccak256\":\"0x67734f330d9b5eb5f7ea7f9f32d2d1cc107879154e9c9424623c6df1709b48e0\",\"license\":\"MIT\"},\"contracts/libraries/AddressConverters.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary Bytes32ToAddress {\\n    /**************************************\\n     *              ERRORS                *\\n     **************************************/\\n    error InvalidBytes32();\\n\\n    function toAddress(bytes32 _bytes32) internal pure returns (address) {\\n        checkAddress(_bytes32);\\n        return address(uint160(uint256(_bytes32)));\\n    }\\n\\n    function toAddressUnchecked(bytes32 _bytes32) internal pure returns (address) {\\n        return address(uint160(uint256(_bytes32)));\\n    }\\n\\n    function checkAddress(bytes32 _bytes32) internal pure {\\n        if (uint256(_bytes32) >> 160 != 0) {\\n            revert InvalidBytes32();\\n        }\\n    }\\n}\\n\\nlibrary AddressToBytes32 {\\n    function toBytes32(address _address) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_address)));\\n    }\\n}\\n\",\"keccak256\":\"0x378f28bb4a17a5c47457cb9341086b2140f7faf6c048f702d3528166f0d74453\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/CircleCCTPAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../external/interfaces/CCTPInterfaces.sol\\\";\\nimport { AddressToBytes32 } from \\\"../libraries/AddressConverters.sol\\\";\\n\\nlibrary CircleDomainIds {\\n    uint32 public constant Ethereum = 0;\\n    uint32 public constant Optimism = 2;\\n    uint32 public constant Arbitrum = 3;\\n    uint32 public constant Solana = 5;\\n    uint32 public constant Base = 6;\\n    uint32 public constant Polygon = 7;\\n    uint32 public constant DoctorWho = 10;\\n    uint32 public constant Linea = 11;\\n    uint32 public constant UNINITIALIZED = type(uint32).max;\\n}\\n\\n/**\\n * @notice Facilitate bridging USDC via Circle's CCTP.\\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\\n * @custom:security-contact bugs@across.to\\n */\\nabstract contract CircleCCTPAdapter {\\n    using SafeERC20 for IERC20;\\n    using AddressToBytes32 for address;\\n    /**\\n     * @notice The domain ID that CCTP will transfer funds to.\\n     * @dev This identifier is assigned by Circle and is not related to a chain ID.\\n     * @dev Official domain list can be found here: https://developers.circle.com/stablecoins/docs/supported-domains\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n\\n    uint32 public immutable recipientCircleDomainId;\\n\\n    /**\\n     * @notice The official USDC contract address on this chain.\\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/usdc-on-main-networks\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    IERC20 public immutable usdcToken;\\n\\n    /**\\n     * @notice The official Circle CCTP token bridge contract endpoint.\\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    ITokenMessenger public immutable cctpTokenMessenger;\\n\\n    /**\\n     * @notice Indicates if the CCTP V2 TokenMessenger is being used.\\n     * @dev This is determined by checking if the feeRecipient() function exists and returns a non-zero address.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    bool public immutable cctpV2;\\n\\n    /**\\n     * @notice intiailizes the CircleCCTPAdapter contract.\\n     * @param _usdcToken USDC address on the current chain.\\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP. If the zero address is passed, CCTP bridging will be disabled.\\n     * @param _recipientCircleDomainId The domain ID that CCTP will transfer funds to.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(\\n        IERC20 _usdcToken,\\n        /// @dev This should ideally be an address but it's kept as an ITokenMessenger to avoid rippling changes to the\\n        /// constructors for every SpokePool/Adapter.\\n        ITokenMessenger _cctpTokenMessenger,\\n        uint32 _recipientCircleDomainId\\n    ) {\\n        usdcToken = _usdcToken;\\n        cctpTokenMessenger = _cctpTokenMessenger;\\n        recipientCircleDomainId = _recipientCircleDomainId;\\n\\n        // Only the CCTP V2 TokenMessenger has a feeRecipient() function, so we use it to\\n        // figure out if we are using CCTP V2 or V1. `success` can be true even if the contract doesn't\\n        // implement feeRecipient but it has a fallback function so to be extra safe, we check the return value\\n        // of feeRecipient() as well.\\n        (bool success, bytes memory feeRecipient) = address(cctpTokenMessenger).staticcall(\\n            abi.encodeWithSignature(\\\"feeRecipient()\\\")\\n        );\\n        // In case of a call to nonexistent contract or a call to a contract with a fallback function which\\n        // doesn't return any data, feeRecipient can be empty so check its length.\\n        // Even with this check, it's possible that the contract has implemented a fallback function that returns\\n        // 32 bytes of data but its not actually the feeRecipient address. This is extremely low risk but worth\\n        // mentioning that the following check is not 100% safe.\\n        cctpV2 = (success &&\\n            feeRecipient.length == 32 &&\\n            address(uint160(uint256(bytes32(feeRecipient)))) != address(0));\\n    }\\n\\n    /**\\n     * @notice Returns whether or not the CCTP bridge is enabled.\\n     * @dev If the CCTPTokenMessenger is the zero address, CCTP bridging is disabled.\\n     */\\n    function _isCCTPEnabled() internal view returns (bool) {\\n        return address(cctpTokenMessenger) != address(0);\\n    }\\n\\n    /**\\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\\n     * @param to Address to receive USDC on the new domain.\\n     * @param amount Amount of USDC to transfer.\\n     */\\n    function _transferUsdc(address to, uint256 amount) internal {\\n        _transferUsdc(to.toBytes32(), amount);\\n    }\\n\\n    /**\\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\\n     * @param to Address to receive USDC on the new domain represented as bytes32.\\n     * @param amount Amount of USDC to transfer.\\n     */\\n    function _transferUsdc(bytes32 to, uint256 amount) internal {\\n        // Only approve the exact amount to be transferred\\n        usdcToken.safeIncreaseAllowance(address(cctpTokenMessenger), amount);\\n        // Submit the amount to be transferred to bridge via the TokenMessenger.\\n        // If the amount to send exceeds the burn limit per message, then split the message into smaller parts.\\n        // @dev We do not care about casting cctpTokenMessenger to ITokenMessengerV2 since both V1 and V2\\n        // expose a localMinter() view function that returns either an ITokenMinterV1 or ITokenMinterV2. Regardless,\\n        // we only care about the burnLimitsPerMessage function which is available in both versions and performs\\n        // the same logic, therefore we purposefully do not re-cast the cctpTokenMessenger and cctpMinter\\n        // to the specific version.\\n        ITokenMinter cctpMinter = cctpTokenMessenger.localMinter();\\n        uint256 burnLimit = cctpMinter.burnLimitsPerMessage(address(usdcToken));\\n        uint256 remainingAmount = amount;\\n        while (remainingAmount > 0) {\\n            uint256 partAmount = remainingAmount > burnLimit ? burnLimit : remainingAmount;\\n            if (cctpV2) {\\n                // Uses the CCTP V2 \\\"standard transfer\\\" speed and\\n                // therefore pays no additional fee for the transfer to be sped up.\\n                ITokenMessengerV2(address(cctpTokenMessenger)).depositForBurn(\\n                    partAmount,\\n                    recipientCircleDomainId,\\n                    to,\\n                    address(usdcToken),\\n                    // The following parameters are new in this function from V2 to V1, can read more here:\\n                    // https://developers.circle.com/stablecoins/evm-smart-contracts\\n                    bytes32(0), // destinationCaller is set to bytes32(0) to indicate that anyone can call\\n                    // receiveMessage on the destination to finalize the transfer\\n                    0, // maxFee can be set to 0 for a \\\"standard transfer\\\"\\n                    2000 // minFinalityThreshold can be set to 2000 for a \\\"standard transfer\\\",\\n                    // https://github.com/circlefin/evm-cctp-contracts/blob/63ab1f0ac06ce0793c0bbfbb8d09816bc211386d/src/v2/FinalityThresholds.sol#L21\\n                );\\n            } else {\\n                cctpTokenMessenger.depositForBurn(partAmount, recipientCircleDomainId, to, address(usdcToken));\\n            }\\n            remainingAmount -= partAmount;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5007254d87c41857f737ddee8b06ef5838182acf6c593f8cc7ced972e03feecb\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/OFTTransportAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { IOFT, SendParam, MessagingFee, OFTReceipt } from \\\"../interfaces/IOFT.sol\\\";\\nimport { AddressToBytes32 } from \\\"../libraries/AddressConverters.sol\\\";\\n\\n/**\\n * @notice Facilitate bridging tokens via LayerZero's OFT.\\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract OFTTransportAdapter {\\n    using SafeERC20 for IERC20;\\n    using AddressToBytes32 for address;\\n\\n    /** @notice Empty bytes array used for OFT messaging parameters */\\n    bytes public constant EMPTY_MSG_BYTES = new bytes(0);\\n\\n    /**\\n     * @notice Fee cap checked before sending messages to OFTMessenger\\n     * @dev Conservative (high) cap to not interfere with operations under normal conditions\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    uint256 public immutable OFT_FEE_CAP;\\n\\n    /**\\n     * @notice The destination endpoint id in the OFT messaging protocol.\\n     * @dev Source https://docs.layerzero.network/v2/developers/evm/technical-reference/deployed-contracts.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    uint32 public immutable OFT_DST_EID;\\n\\n    /** @notice Thrown when OFT fee exceeds the configured cap */\\n    error OftFeeCapExceeded();\\n\\n    /** @notice Thrown when contract has insufficient balance to pay OFT fees */\\n    error OftInsufficientBalanceForFee();\\n\\n    /** @notice Thrown when LayerZero token fee is not zero (only native fees supported) */\\n    error OftLzFeeNotZero();\\n\\n    /** @notice Thrown when amount received differs from expected amount */\\n    error OftIncorrectAmountReceivedLD();\\n\\n    /** @notice Thrown when amount sent differs from expected amount */\\n    error OftIncorrectAmountSentLD();\\n\\n    /**\\n     * @notice intiailizes the OFTTransportAdapter contract.\\n     * @param _oftDstEid the endpoint ID that OFT protocol will transfer funds to.\\n     * @param _feeCap a fee cap we check against before sending a message with value to OFTMessenger as fees.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(uint32 _oftDstEid, uint256 _feeCap) {\\n        OFT_DST_EID = _oftDstEid;\\n        OFT_FEE_CAP = _feeCap;\\n    }\\n\\n    /**\\n     * @notice transfer token to the other dstEid (e.g. chain) via OFT messaging protocol\\n     * @dev the caller has to provide both _token and _messenger. The caller is responsible for knowing the correct _messenger\\n     * @param _token token we're sending on current chain.\\n     * @param _messenger corresponding OFT messenger on current chain.\\n     * @param _to address to receive a transfer on the destination chain.\\n     * @param _amount amount to send.\\n     */\\n    function _transferViaOFT(IERC20 _token, IOFT _messenger, address _to, uint256 _amount) internal {\\n        (SendParam memory sendParam, MessagingFee memory fee) = _buildOftTransfer(_messenger, _to, _amount);\\n        _sendOftTransfer(_token, _messenger, sendParam, fee);\\n    }\\n\\n    /**\\n     * @notice Build OFT send params and quote the native fee.\\n     * @dev Sets `minAmountLD == amountLD` to disallow silent deductions (e.g. dust removal) by OFT.\\n     *      The fee is quoted for payment in native token.\\n     * @param _messenger OFT messenger contract on the current chain for the token being sent.\\n     * @param _to Destination address on the remote chain.\\n     * @param _amount Amount of tokens to transfer.\\n     * @return sendParam The encoded OFT send parameters.\\n     * @return fee The quoted MessagingFee required for the transfer.\\n     */\\n    function _buildOftTransfer(\\n        IOFT _messenger,\\n        address _to,\\n        uint256 _amount\\n    ) internal view returns (SendParam memory, MessagingFee memory) {\\n        bytes32 to = _to.toBytes32();\\n\\n        SendParam memory sendParam = SendParam(\\n            OFT_DST_EID,\\n            to,\\n            /**\\n             * _amount, _amount here specify `amountLD` and `minAmountLD`. Setting `minAmountLD` equal to `amountLD` protects us\\n             * from any changes to the sent amount due to internal OFT contract logic, e.g. `_removeDust`. Meaning that if any\\n             * dust is subtracted, the `.send()` should revert\\n             */\\n            _amount,\\n            _amount,\\n            /**\\n             * EMPTY_MSG_BYTES, EMPTY_MSG_BYTES, EMPTY_MSG_BYTES here specify `extraOptions`, `composeMsg` and `oftCmd`.\\n             * These can be set to empty bytes arrays for the purposes of sending a simple cross-chain transfer.\\n             */\\n            EMPTY_MSG_BYTES,\\n            EMPTY_MSG_BYTES,\\n            EMPTY_MSG_BYTES\\n        );\\n\\n        // `false` in the 2nd param here refers to `bool _payInLzToken`. We will pay in native token, so set to `false`\\n        MessagingFee memory fee = _messenger.quoteSend(sendParam, false);\\n\\n        return (sendParam, fee);\\n    }\\n\\n    /**\\n     * @notice Execute an OFT transfer using pre-built params and fee.\\n     * @dev Verifies fee bounds and equality of sent/received amounts. Pays native fee from this contract.\\n     * @param _token ERC-20 token to transfer.\\n     * @param _messenger OFT messenger contract on the current chain for `_token`.\\n     * @param sendParam Pre-built OFT send parameters.\\n     * @param fee Quoted MessagingFee to pay for this transfer.\\n     */\\n    function _sendOftTransfer(\\n        IERC20 _token,\\n        IOFT _messenger,\\n        SendParam memory sendParam,\\n        MessagingFee memory fee\\n    ) internal {\\n        // Create a stack variable to optimize gas usage on subsequent reads\\n        uint256 nativeFee = fee.nativeFee;\\n        if (nativeFee > OFT_FEE_CAP) revert OftFeeCapExceeded();\\n        if (nativeFee > address(this).balance) revert OftInsufficientBalanceForFee();\\n        if (fee.lzTokenFee != 0) revert OftLzFeeNotZero();\\n\\n        // Approve the exact _amount for `_messenger` to spend. Fee will be paid in native token\\n        uint256 _amount = sendParam.amountLD;\\n        _token.forceApprove(address(_messenger), _amount);\\n\\n        (, OFTReceipt memory oftReceipt) = _messenger.send{ value: nativeFee }(sendParam, fee, address(this));\\n\\n        // The HubPool expects that the amount received by the SpokePool is exactly the sent amount\\n        if (_amount != oftReceipt.amountReceivedLD) revert OftIncorrectAmountReceivedLD();\\n        // Also check the amount sent on origin chain to harden security\\n        if (_amount != oftReceipt.amountSentLD) revert OftIncorrectAmountSentLD();\\n    }\\n}\\n\",\"keccak256\":\"0x373531e2f0d20b27ba5ca8d716c96a6b779b30e2230ae6aad1c3501f1755e5ed\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/OFTTransportAdapterWithStore.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { OFTTransportAdapter } from \\\"./OFTTransportAdapter.sol\\\";\\nimport { AdapterStore, MessengerTypes } from \\\"../AdapterStore.sol\\\";\\n\\n/**\\n * @dev A wrapper of `OFTTransportAdapter` to be used by chain-specific adapters\\n * @custom:security-contact bugs@across.to\\n */\\ncontract OFTTransportAdapterWithStore is OFTTransportAdapter {\\n    /** @notice Helper storage contract to keep track of token => IOFT relationships */\\n    AdapterStore public immutable OFT_ADAPTER_STORE;\\n\\n    /**\\n     * @notice Initializes the OFTTransportAdapterWithStore contract\\n     * @param _oftDstEid The endpoint ID that OFT protocol will transfer funds to\\n     * @param _feeCap Fee cap checked before sending messages to OFTMessenger\\n     * @param _adapterStore Address of the AdapterStore contract\\n     */\\n    constructor(uint32 _oftDstEid, uint256 _feeCap, address _adapterStore) OFTTransportAdapter(_oftDstEid, _feeCap) {\\n        OFT_ADAPTER_STORE = AdapterStore(_adapterStore);\\n    }\\n\\n    /**\\n     * @notice Retrieves the OFT messenger address for a given token\\n     * @param _token Token address to look up messenger for\\n     * @return Address of the OFT messenger for the token\\n     */\\n    function _getOftMessenger(address _token) internal view returns (address) {\\n        return OFT_ADAPTER_STORE.crossChainMessengers(MessengerTypes.OFT_MESSENGER, OFT_DST_EID, _token);\\n    }\\n}\\n\",\"keccak256\":\"0x83bf7ab363b01746fa0d1272f7e01de613e939c6ca55a61d8f913c3ba4665021\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x610180604090808252346200022b5760e081620016c480380380916200002682856200022f565b8339810103126200022b5780516001600160a01b0380821682036200022b57602093848401519482861686036200022b5781850151928084168085036200022b57620000756060880162000253565b6080880151958387168097036200022b5760c06200009660a08b0162000253565b99015160a09a909a5260c052608052835163011a412160e61b848201908152600482526001600160401b039282870191848311848410176200020d575f938493895251915afa923d1562000221573d9182116200020d5784519162000105601f8201601f19168301846200022f565b82523d5f8284013e5b8362000201575b83620001cf575b50505060e052610120938452610100948552610140918252610160928352519261145e9485620002668639608051858181610513015281816108ba015261098f015260a0518581816106e701528181610ffb015261108d015260c0518581816103fd01526106b3015260e051858181610456015261084c01525184818161056c0152610bd20152518381816104b5015261064801525182818161038f015261067f01525181818161015c01526102c90152f35b81519181015192935090818110620001f0575b50501615155f80806200011c565b5f19910360031b1b165f80620001e2565b81518114935062000115565b634e487b7160e01b5f52604160045260245ffd5b606091506200010e565b5f80fd5b601f909101601f19168101906001600160401b038211908210176200020d57604052565b519063ffffffff821682036200022b5756fe6080806040526004361015610012575f80fd5b5f3560e01c90816311eac855146110455750806352c8c75c1461058f57806361a04d30146105375780636e400983146104d95780636fd5c10e1461047b578063775c0d03146104215780639748cf7c146103b3578063a6ec815e14610345578063b4c0d7ab146102ed578063c1d07cc21461027f5763e6eb8ade14610095575f80fd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a576100c76110b1565b6024359067ffffffffffffffff9081831161024a573660238401121561024a57826004013591821161024a576024830192602483369201011161024a57604051927f8da5cb5b000000000000000000000000000000000000000000000000000000008452602084600481305afa93841561023f575f9461024e575b5073ffffffffffffffffffffffffffffffffffffffff91827f00000000000000000000000000000000000000000000000000000000000000001690813b1561024a575f918491836040518099819582947fb6a315780000000000000000000000000000000000000000000000000000000084521698896004840152606060248401526101d2606484018c8b611205565b91163314604483015203925af190811561023f577f9e6c52944e331ba6270e7fe4cea2a4086bae8f7a27e1cdba07f416806f5d0ac49461022b92610230575b506040519384938452604060208501526040840191611205565b0390a1005b6102399061110c565b5f610211565b6040513d5f823e3d90fd5b5f80fd5b61027191945060203d602011610278575b610269818361113c565b8101906111d9565b925f610142565b503d61025f565b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a5761034160405161032a81611120565b5f815260405191829160208352602083019061117d565b0390f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a5760206040517f000000000000000000000000000000000000000000000000000000000000000015158152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b60807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a576105c16110b1565b73ffffffffffffffffffffffffffffffffffffffff6024358181160361024a576044356064359282841680940361024a57604051937f8f7d9bec0000000000000000000000000000000000000000000000000000000085527f4f46545f4d455353454e47455200000000000000000000000000000000000000600486015263ffffffff91827f0000000000000000000000000000000000000000000000000000000000000000168060248801528582166044880152602087606481897f0000000000000000000000000000000000000000000000000000000000000000165afa96871561023f575f97611024575b50857f0000000000000000000000000000000000000000000000000000000000000000169687151580610ff7575b15610abc575050507f000000000000000000000000000000000000000000000000000000000000000092848416936040517fdd62ed3e000000000000000000000000000000000000000000000000000000008152306004820152876024820152602081604481895afa90811561023f575f91610a8a575b50828101809111610924576040517f095ea7b300000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff891660248201526044808201929092529081526107c4916107bf60648361113c565b611365565b6040517fcb75c11c0000000000000000000000000000000000000000000000000000000081526020816004818a5afa801561023f575f90610a4e575b602091506024604051809881937fa56ec632000000000000000000000000000000000000000000000000000000008352896004840152165afa94851561023f575f95610a1a575b5093947f000000000000000000000000000000000000000000000000000000000000000094805b61087457005b86811115610a1457865b861561096057823b1561024a576040517f8e0250ee000000000000000000000000000000000000000000000000000000008152816004820152857f00000000000000000000000000000000000000000000000000000000000000001660248201528460448201528660648201525f60848201525f60a48201526107d060c48201525f8160e48183885af1801561023f57610951575b505b8103908111610924578061086e565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b61095a9061110c565b88610913565b6040517f6fd3504e000000000000000000000000000000000000000000000000000000008152816004820152857f00000000000000000000000000000000000000000000000000000000000000001660248201528460448201528660648201526020816084815f885af1801561023f576109db575b50610915565b6020813d602011610a0c575b816109f46020938361113c565b8101031261024a57610a05906112db565b50886109d5565b3d91506109e7565b8061087e565b9094506020813d602011610a46575b81610a366020938361113c565b8101031261024a57519386610847565b3d9150610a29565b506020813d602011610a82575b81610a686020938361113c565b8101031261024a5751858116810361024a57602090610800565b3d9150610a5b565b90506020813d602011610ab4575b81610aa56020938361113c565b8101031261024a575188610754565b3d9150610a98565b91965094909392509083821615610fcd57606060c0604051610add816110d4565b5f81525f60208201525f60408201525f838201528260808201528260a082015201525f6020604051610b0e816110f0565b8281520152604051610b1f81611120565b5f815260405190610b2f82611120565b5f825260405192610b3f84611120565b5f845260405197610b4f896110d4565b8852602088015260408701948086526060880152608087015260a086015260c0850152604051937f3b6f743b0000000000000000000000000000000000000000000000000000000085526040600486015260408580610bb1604482018561126b565b5f602483015203818588165afa94851561023f575f95610f92575b508451927f00000000000000000000000000000000000000000000000000000000000000008411610f6857478411610f3e576020860151610f145751956040515f80602083017f095ea7b3000000000000000000000000000000000000000000000000000000008152610c9884610c6c8d8a8d16602484016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810186528561113c565b835190828887165af1610ca96112f0565b81610ee5575b5080610ed9575b15610e4e575b505060209260c09492610d0792604051978896879586937fc7c7f5b300000000000000000000000000000000000000000000000000000000855260806004860152608485019061126b565b9180516024850152015160448301523060648301520393165af190811561023f575f91610d97575b5060208101518203610d6d575103610d4357005b60046040517ff1522c00000000000000000000000000000000000000000000000000000000008152fd5b60046040517f37f8796a000000000000000000000000000000000000000000000000000000008152fd5b905060c03d60c011610e47575b610dae818361113c565b810181810360c0811261024a5760801361024a5760405191606083019083821067ffffffffffffffff831117610e1a57610e149360809260405281518152610df8602083016112db565b60208201526040610e0b85828501611243565b91015201611243565b82610d2f565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b503d610da4565b93909492604051927f095ea7b300000000000000000000000000000000000000000000000000000000602085015281851660248501525f60448501526044845283608081011067ffffffffffffffff608086011117610e1a57610ecd6020968360c099610ec7886080610d079a01604052838316611365565b16611365565b92509294819450610cbc565b508382163b1515610cb6565b8051801592508215610efa575b505089610caf565b610f0d925060208091830101910161134d565b8980610ef2565b60046040517f38a0bb24000000000000000000000000000000000000000000000000000000008152fd5b60046040517fa6226f85000000000000000000000000000000000000000000000000000000008152fd5b60046040517f1754d7a9000000000000000000000000000000000000000000000000000000008152fd5b90945060403d604011610fc6575b610faa818361113c565b810160408282031261024a57610fbf91611243565b9386610bcc565b503d610fa0565b60046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b50867f000000000000000000000000000000000000000000000000000000000000000016878416146106dd565b61103e91975060203d60201161027857610269818361113c565b95876106af565b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a5760209073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361024a57565b60e0810190811067ffffffffffffffff821117610e1a57604052565b6040810190811067ffffffffffffffff821117610e1a57604052565b67ffffffffffffffff8111610e1a57604052565b6020810190811067ffffffffffffffff821117610e1a57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610e1a57604052565b91908251928382525f5b8481106111c55750507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f845f6020809697860101520116010190565b602081830181015184830182015201611187565b9081602091031261024a575173ffffffffffffffffffffffffffffffffffffffff8116810361024a5790565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b919082604091031261024a5760405161125b816110f0565b6020808294805184520151910152565b6112d89163ffffffff825116815260208201516020820152604082015160408201526060820151606082015260c06112c76112b5608085015160e0608086015260e085019061117d565b60a085015184820360a086015261117d565b9201519060c081840391015261117d565b90565b519067ffffffffffffffff8216820361024a57565b3d15611348573d9067ffffffffffffffff8211610e1a576040519161133d60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116018461113c565b82523d5f602084013e565b606090565b9081602091031261024a5751801515810361024a5790565b905f8073ffffffffffffffffffffffffffffffffffffffff6113cf9416927f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656460206040516113b2816110f0565b818152015260208151910182855af16113c96112f0565b916113ff565b80519081159182156113e5575b50501561024a57565b6113f8925060208091830101910161134d565b5f806113dc565b901561141957815115611410575090565b3b1561024a5790565b50805190811561024a57602001fdfea26469706673582212205f28cae664a60ee9d75a2cbbfc7becfcf6ed0a9b181846a65404e50a6b47af1e64736f6c63430008170033",
  "deployedBytecode": "0x6080806040526004361015610012575f80fd5b5f3560e01c90816311eac855146110455750806352c8c75c1461058f57806361a04d30146105375780636e400983146104d95780636fd5c10e1461047b578063775c0d03146104215780639748cf7c146103b3578063a6ec815e14610345578063b4c0d7ab146102ed578063c1d07cc21461027f5763e6eb8ade14610095575f80fd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a576100c76110b1565b6024359067ffffffffffffffff9081831161024a573660238401121561024a57826004013591821161024a576024830192602483369201011161024a57604051927f8da5cb5b000000000000000000000000000000000000000000000000000000008452602084600481305afa93841561023f575f9461024e575b5073ffffffffffffffffffffffffffffffffffffffff91827f00000000000000000000000000000000000000000000000000000000000000001690813b1561024a575f918491836040518099819582947fb6a315780000000000000000000000000000000000000000000000000000000084521698896004840152606060248401526101d2606484018c8b611205565b91163314604483015203925af190811561023f577f9e6c52944e331ba6270e7fe4cea2a4086bae8f7a27e1cdba07f416806f5d0ac49461022b92610230575b506040519384938452604060208501526040840191611205565b0390a1005b6102399061110c565b5f610211565b6040513d5f823e3d90fd5b5f80fd5b61027191945060203d602011610278575b610269818361113c565b8101906111d9565b925f610142565b503d61025f565b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a5761034160405161032a81611120565b5f815260405191829160208352602083019061117d565b0390f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a5760206040517f000000000000000000000000000000000000000000000000000000000000000015158152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b60807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a576105c16110b1565b73ffffffffffffffffffffffffffffffffffffffff6024358181160361024a576044356064359282841680940361024a57604051937f8f7d9bec0000000000000000000000000000000000000000000000000000000085527f4f46545f4d455353454e47455200000000000000000000000000000000000000600486015263ffffffff91827f0000000000000000000000000000000000000000000000000000000000000000168060248801528582166044880152602087606481897f0000000000000000000000000000000000000000000000000000000000000000165afa96871561023f575f97611024575b50857f0000000000000000000000000000000000000000000000000000000000000000169687151580610ff7575b15610abc575050507f000000000000000000000000000000000000000000000000000000000000000092848416936040517fdd62ed3e000000000000000000000000000000000000000000000000000000008152306004820152876024820152602081604481895afa90811561023f575f91610a8a575b50828101809111610924576040517f095ea7b300000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff891660248201526044808201929092529081526107c4916107bf60648361113c565b611365565b6040517fcb75c11c0000000000000000000000000000000000000000000000000000000081526020816004818a5afa801561023f575f90610a4e575b602091506024604051809881937fa56ec632000000000000000000000000000000000000000000000000000000008352896004840152165afa94851561023f575f95610a1a575b5093947f000000000000000000000000000000000000000000000000000000000000000094805b61087457005b86811115610a1457865b861561096057823b1561024a576040517f8e0250ee000000000000000000000000000000000000000000000000000000008152816004820152857f00000000000000000000000000000000000000000000000000000000000000001660248201528460448201528660648201525f60848201525f60a48201526107d060c48201525f8160e48183885af1801561023f57610951575b505b8103908111610924578061086e565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b61095a9061110c565b88610913565b6040517f6fd3504e000000000000000000000000000000000000000000000000000000008152816004820152857f00000000000000000000000000000000000000000000000000000000000000001660248201528460448201528660648201526020816084815f885af1801561023f576109db575b50610915565b6020813d602011610a0c575b816109f46020938361113c565b8101031261024a57610a05906112db565b50886109d5565b3d91506109e7565b8061087e565b9094506020813d602011610a46575b81610a366020938361113c565b8101031261024a57519386610847565b3d9150610a29565b506020813d602011610a82575b81610a686020938361113c565b8101031261024a5751858116810361024a57602090610800565b3d9150610a5b565b90506020813d602011610ab4575b81610aa56020938361113c565b8101031261024a575188610754565b3d9150610a98565b91965094909392509083821615610fcd57606060c0604051610add816110d4565b5f81525f60208201525f60408201525f838201528260808201528260a082015201525f6020604051610b0e816110f0565b8281520152604051610b1f81611120565b5f815260405190610b2f82611120565b5f825260405192610b3f84611120565b5f845260405197610b4f896110d4565b8852602088015260408701948086526060880152608087015260a086015260c0850152604051937f3b6f743b0000000000000000000000000000000000000000000000000000000085526040600486015260408580610bb1604482018561126b565b5f602483015203818588165afa94851561023f575f95610f92575b508451927f00000000000000000000000000000000000000000000000000000000000000008411610f6857478411610f3e576020860151610f145751956040515f80602083017f095ea7b3000000000000000000000000000000000000000000000000000000008152610c9884610c6c8d8a8d16602484016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810186528561113c565b835190828887165af1610ca96112f0565b81610ee5575b5080610ed9575b15610e4e575b505060209260c09492610d0792604051978896879586937fc7c7f5b300000000000000000000000000000000000000000000000000000000855260806004860152608485019061126b565b9180516024850152015160448301523060648301520393165af190811561023f575f91610d97575b5060208101518203610d6d575103610d4357005b60046040517ff1522c00000000000000000000000000000000000000000000000000000000008152fd5b60046040517f37f8796a000000000000000000000000000000000000000000000000000000008152fd5b905060c03d60c011610e47575b610dae818361113c565b810181810360c0811261024a5760801361024a5760405191606083019083821067ffffffffffffffff831117610e1a57610e149360809260405281518152610df8602083016112db565b60208201526040610e0b85828501611243565b91015201611243565b82610d2f565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b503d610da4565b93909492604051927f095ea7b300000000000000000000000000000000000000000000000000000000602085015281851660248501525f60448501526044845283608081011067ffffffffffffffff608086011117610e1a57610ecd6020968360c099610ec7886080610d079a01604052838316611365565b16611365565b92509294819450610cbc565b508382163b1515610cb6565b8051801592508215610efa575b505089610caf565b610f0d925060208091830101910161134d565b8980610ef2565b60046040517f38a0bb24000000000000000000000000000000000000000000000000000000008152fd5b60046040517fa6226f85000000000000000000000000000000000000000000000000000000008152fd5b60046040517f1754d7a9000000000000000000000000000000000000000000000000000000008152fd5b90945060403d604011610fc6575b610faa818361113c565b810160408282031261024a57610fbf91611243565b9386610bcc565b503d610fa0565b60046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b50867f000000000000000000000000000000000000000000000000000000000000000016878416146106dd565b61103e91975060203d60201161027857610269818361113c565b95876106af565b3461024a575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024a5760209073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361024a57565b60e0810190811067ffffffffffffffff821117610e1a57604052565b6040810190811067ffffffffffffffff821117610e1a57604052565b67ffffffffffffffff8111610e1a57604052565b6020810190811067ffffffffffffffff821117610e1a57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610e1a57604052565b91908251928382525f5b8481106111c55750507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f845f6020809697860101520116010190565b602081830181015184830182015201611187565b9081602091031261024a575173ffffffffffffffffffffffffffffffffffffffff8116810361024a5790565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b919082604091031261024a5760405161125b816110f0565b6020808294805184520151910152565b6112d89163ffffffff825116815260208201516020820152604082015160408201526060820151606082015260c06112c76112b5608085015160e0608086015260e085019061117d565b60a085015184820360a086015261117d565b9201519060c081840391015261117d565b90565b519067ffffffffffffffff8216820361024a57565b3d15611348573d9067ffffffffffffffff8211610e1a576040519161133d60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116018461113c565b82523d5f602084013e565b606090565b9081602091031261024a5751801515810361024a5790565b905f8073ffffffffffffffffffffffffffffffffffffffff6113cf9416927f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656460206040516113b2816110f0565b818152015260208151910182855af16113c96112f0565b916113ff565b80519081159182156113e5575b50501561024a57565b6113f8925060208091830101910161134d565b5f806113dc565b901561141957815115611410575090565b3b1561024a5790565b50805190811561024a57602001fdfea26469706673582212205f28cae664a60ee9d75a2cbbfc7becfcf6ed0a9b181846a65404e50a6b47af1e64736f6c63430008170033",
  "devdoc": {
    "custom:security-contact": "bugs@across.to",
    "details": "This contract should NOT be reused to send messages to SpokePools that have the same address on different L2s.This contract can be redeployed to point to a new HubPoolStore if the data store gets corrupted and new data can't get written to the store for some reason. The corresponding Universal_SpokePool contract will also need to be redeployed to point to the new HubPoolStore.",
    "kind": "dev",
    "methods": {
      "relayMessage(address,bytes)": {
        "params": {
          "message": "Data to send to target.",
          "target": "Contract on the destination that will receive the message. Unused if the message is created by the HubPool admin."
        }
      },
      "relayTokens(address,address,uint256,address)": {
        "details": "This function uses CircleCCTPAdapter to relay USDC and OFTTransportAdapterWithStore to relay OFT tokens to L2 chains that support these methods. Relaying other tokens will cause this function to revert.",
        "params": {
          "amount": "Amount of tokens to relay.",
          "l1Token": "Address of the token on L1.",
          "l2Token": "Address of the token on L2. Unused",
          "to": "Address to receive the tokens on L2. Should be SpokePool address."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "OftFeeCapExceeded()": [
        {
          "notice": "Thrown when OFT fee exceeds the configured cap "
        }
      ],
      "OftIncorrectAmountReceivedLD()": [
        {
          "notice": "Thrown when amount received differs from expected amount "
        }
      ],
      "OftIncorrectAmountSentLD()": [
        {
          "notice": "Thrown when amount sent differs from expected amount "
        }
      ],
      "OftInsufficientBalanceForFee()": [
        {
          "notice": "Thrown when contract has insufficient balance to pay OFT fees "
        }
      ],
      "OftLzFeeNotZero()": [
        {
          "notice": "Thrown when LayerZero token fee is not zero (only native fees supported) "
        }
      ]
    },
    "kind": "user",
    "methods": {
      "DATA_STORE()": {
        "notice": "Contract that stores calldata to be relayed to L2 via storage proofs."
      },
      "EMPTY_MSG_BYTES()": {
        "notice": "Empty bytes array used for OFT messaging parameters "
      },
      "OFT_ADAPTER_STORE()": {
        "notice": "Helper storage contract to keep track of token => IOFT relationships "
      },
      "relayMessage(address,bytes)": {
        "notice": "Saves calldata in a simple storage contract whose state can be proven and relayed to L2."
      },
      "relayTokens(address,address,uint256,address)": {
        "notice": "Relays tokens from L1 to L2."
      }
    },
    "notice": "Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts on the L2 where the SpokePool is deployed. Designed to be used as a singleton contract that can be used to relay messages to multiple SpokePools on different chains.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
