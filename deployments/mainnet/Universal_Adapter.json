{
  "address": "0x22001f37B586792F25Ef9d19d99537C6446e0833",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract HubPoolStore",
          "name": "_store",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "_l1Usdc",
          "type": "address"
        },
        {
          "internalType": "contract ITokenMessenger",
          "name": "_cctpTokenMessenger",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_cctpDestinationDomainId",
          "type": "uint32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "NotImplemented",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "MessageRelayed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "l1Token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "l2Token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "TokensRelayed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DATA_STORE",
      "outputs": [
        {
          "internalType": "contract HubPoolStore",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cctpTokenMessenger",
      "outputs": [
        {
          "internalType": "contract ITokenMessenger",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cctpV2",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "recipientCircleDomainId",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "relayMessage",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "l1Token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "l2Token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "relayTokens",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "usdcToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe6bb87cfaa6486b70dde9125d449c3ac892a11422ce663ea74a286c54879bc37",
  "receipt": {
    "to": null,
    "from": "0x9A8f92a830A5cB89a3816e3D267CB7791c16b04D",
    "contractAddress": "0x22001f37B586792F25Ef9d19d99537C6446e0833",
    "transactionIndex": 11,
    "gasUsed": "845130",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4fd2708e02fcda50ed3710d23b2d4544d8e917938635b90a46b9f8139792ca83",
    "transactionHash": "0xe6bb87cfaa6486b70dde9125d449c3ac892a11422ce663ea74a286c54879bc37",
    "logs": [],
    "blockNumber": 22368546,
    "cumulativeGasUsed": "1875427",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1Ace3BbD69b63063F859514Eca29C9BDd8310E61",
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    "0x0000000000000000000000000000000000000000",
    4294967295
  ],
  "numDeployments": 1,
  "solcInputHash": "d588ac0bd437ae8849ec6f9277b07547",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract HubPoolStore\",\"name\":\"_store\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_l1Usdc\",\"type\":\"address\"},{\"internalType\":\"contract ITokenMessenger\",\"name\":\"_cctpTokenMessenger\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_cctpDestinationDomainId\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotImplemented\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TokensRelayed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DATA_STORE\",\"outputs\":[{\"internalType\":\"contract HubPoolStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cctpTokenMessenger\",\"outputs\":[{\"internalType\":\"contract ITokenMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cctpV2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipientCircleDomainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"relayMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"relayTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"bugs@across.to\",\"details\":\"This contract should NOT be reused to send messages to SpokePools that have the same address on different L2s.This contract can be redeployed to point to a new HubPoolStore if the data store gets corrupted and new data can't get written to the store for some reason. The corresponding Universal_SpokePool contract will also need to be redeployed to point to the new HubPoolStore.\",\"kind\":\"dev\",\"methods\":{\"relayMessage(address,bytes)\":{\"params\":{\"message\":\"Data to send to target.\",\"target\":\"Contract on the destination that will receive the message. Unused if the message is created by the HubPool admin.\"}},\"relayTokens(address,address,uint256,address)\":{\"details\":\"This function only uses the CircleCCTPAdapter to relay USDC tokens to CCTP enabled L2 chains. Relaying other tokens will cause this function to revert.\",\"params\":{\"amount\":\"Amount of tokens to relay.\",\"l1Token\":\"Address of the token on L1.\",\"l2Token\":\"Address of the token on L2. Unused\",\"to\":\"Address to receive the tokens on L2. Should be SpokePool address.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"DATA_STORE()\":{\"notice\":\"Contract that stores calldata to be relayed to L2 via storage proofs.\"},\"relayMessage(address,bytes)\":{\"notice\":\"Saves calldata in a simple storage contract whose state can be proven and relayed to L2.\"},\"relayTokens(address,address,uint256,address)\":{\"notice\":\"Relays tokens from L1 to L2.\"}},\"notice\":\"Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts on the L2 where the SpokePool is deployed. Designed to be used as a singleton contract that can be used to relay messages to multiple SpokePools on different chains.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/chain-adapters/Universal_Adapter.sol\":\"Universal_Adapter\"},\"debug\":{\"revertStrings\":\"strip\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"contracts/chain-adapters/Universal_Adapter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/AdapterInterface.sol\\\";\\n\\nimport \\\"../libraries/CircleCCTPAdapter.sol\\\";\\nimport { SpokePoolInterface } from \\\"../interfaces/SpokePoolInterface.sol\\\";\\nimport { HubPoolStore } from \\\"./utilities/HubPoolStore.sol\\\";\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\\n/**\\n * @notice Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts\\n * on the L2 where the SpokePool is deployed. Designed to be used as a singleton contract that can be used to relay\\n * messages to multiple SpokePools on different chains.\\n * @dev This contract should NOT be reused to send messages to SpokePools that have the same address on different L2s.\\n * @dev This contract can be redeployed to point to a new HubPoolStore if the data store gets corrupted and new data\\n * can't get written to the store for some reason. The corresponding Universal_SpokePool contract will\\n * also need to be redeployed to point to the new HubPoolStore.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract Universal_Adapter is AdapterInterface, CircleCCTPAdapter {\\n    /// @notice Contract that stores calldata to be relayed to L2 via storage proofs.\\n    HubPoolStore public immutable DATA_STORE;\\n\\n    error NotImplemented();\\n\\n    constructor(\\n        HubPoolStore _store,\\n        IERC20 _l1Usdc,\\n        ITokenMessenger _cctpTokenMessenger,\\n        uint32 _cctpDestinationDomainId\\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, _cctpDestinationDomainId) {\\n        DATA_STORE = _store;\\n    }\\n\\n    /**\\n     * @notice Saves calldata in a simple storage contract whose state can be proven and relayed to L2.\\n     * @param target Contract on the destination that will receive the message. Unused if the message is created\\n     * by the HubPool admin.\\n     * @param message Data to send to target.\\n     */\\n    function relayMessage(address target, bytes calldata message) external payable override {\\n        // Admin messages are stored differently in the data store than non-admin messages, because admin\\n        // messages must only be sent to a single target on a specific L2 chain. Non-admin messages are sent\\n        // to any target on any L2 chain because the only type of an non-admin message is the result of a\\n        // HubPool.executeRootBundle() call which attempts to relay a relayRootBundle() call to all SpokePools using\\n        // this adapter. Therefore, non-admin messages are stored optimally in the data store\\n        // by only storing the message once and allowing any SpokePool target to read it via storage proofs.\\n\\n        // We assume that the HubPool is delegatecall-ing into this function, therefore address(this) is the HubPool's\\n        // address. As a result, we can determine whether this message is an admin function based on the msg.sender.\\n        // If an admin sends a message that could have been relayed as a non-admin message (e.g. the admin\\n        // calls executeRootBundle()), then the message won't be stored optimally in the data store, but the\\n        // message can still be delivered to the target.\\n        bool isAdminSender = msg.sender == IOwnable(address(this)).owner();\\n        DATA_STORE.storeRelayMessageCalldata(target, message, isAdminSender);\\n        emit MessageRelayed(target, message);\\n    }\\n\\n    /**\\n     * @notice Relays tokens from L1 to L2.\\n     * @dev This function only uses the CircleCCTPAdapter to relay USDC tokens to CCTP enabled L2 chains.\\n     * Relaying other tokens will cause this function to revert.\\n     * @param l1Token Address of the token on L1.\\n     * @param l2Token Address of the token on L2. Unused\\n     * @param amount Amount of tokens to relay.\\n     * @param to Address to receive the tokens on L2. Should be SpokePool address.\\n     */\\n    function relayTokens(\\n        address l1Token,\\n        address l2Token,\\n        uint256 amount,\\n        address to\\n    ) external payable override {\\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\\n            _transferUsdc(to, amount);\\n        } else {\\n            revert NotImplemented();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x647f9f45097e858962fda0f6f6ed1715b792fbd51816560ca4c3eff6b83a779a\",\"license\":\"BUSL-1.1\"},\"contracts/chain-adapters/interfaces/AdapterInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\\n * This interface is implemented by an adapter contract that is deployed on L1.\\n */\\n\\ninterface AdapterInterface {\\n    event MessageRelayed(address target, bytes message);\\n\\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\\n\\n    /**\\n     * @notice Send message to `target` on L2.\\n     * @dev This method is marked payable because relaying the message might require a fee\\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\\n     * to the target contract on L2.\\n     * @param target L2 address to send message to.\\n     * @param message Message to send to `target`.\\n     */\\n    function relayMessage(address target, bytes calldata message) external payable;\\n\\n    /**\\n     * @notice Send `amount` of `l1Token` to `to` on L2. `l2Token` is the L2 address equivalent of `l1Token`.\\n     * @dev This method is marked payable because relaying the message might require a fee\\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\\n     * to the target contract on L2.\\n     * @param l1Token L1 token to bridge.\\n     * @param l2Token L2 token to receive.\\n     * @param amount Amount of `l1Token` to bridge.\\n     * @param to Bridge recipient.\\n     */\\n    function relayTokens(\\n        address l1Token,\\n        address l2Token,\\n        uint256 amount,\\n        address to\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x1d52fcb8b10dc7f260345918c1a90d496a4c9f774402cbd5ebde881b8fed6d50\",\"license\":\"BUSL-1.1\"},\"contracts/chain-adapters/utilities/HubPoolStore.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport { HubPoolInterface } from \\\"../../interfaces/HubPoolInterface.sol\\\";\\n\\ninterface IHubPool {\\n    function rootBundleProposal() external view returns (HubPoolInterface.RootBundle memory);\\n}\\n\\n/**\\n * @notice Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts\\n * on the L2 where the SpokePool is deployed. Only the HubPool can store data to this contract. Each data to be\\n * relayed is written to a unique slot key and that slot key's value can never be modified.\\n * @dev Designed to be used with Universal_Adapter and Universal_SpokePool.\\n * @dev This contract DOES NOT prevent replay attacks of storage proofs on the L2 spoke pool if the\\n * UniversalStorageProof_Adapters using this contract are mapped to spokepools with the same address on different\\n * L2 chains. See comment in storeRelayAdminFunctionCalldata() for more details.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract HubPoolStore {\\n    error NotHubPool();\\n\\n    /// @notice Maps nonce to hash of calldata.\\n    mapping(uint256 => bytes32) public relayMessageCallData;\\n\\n    /// @notice Counter to ensure that each relay admin function calldata is unique.\\n    uint256 private dataUuid;\\n\\n    /// @notice Address of the HubPool contract, the only contract that can store data to this contract.\\n    address public immutable hubPool;\\n\\n    /// @notice Event designed to be queried off chain and relayed to Universal SpokePool.\\n    event StoredCallData(address indexed target, bytes data, uint256 indexed nonce);\\n\\n    modifier onlyHubPool() {\\n        if (msg.sender != hubPool) {\\n            revert NotHubPool();\\n        }\\n        _;\\n    }\\n\\n    constructor(address _hubPool) {\\n        hubPool = _hubPool;\\n    }\\n\\n    /**\\n     * @notice To be called by HubPool to store calldata that will be relayed\\n     * to the Universal_SpokePool via storage proofs.\\n     * @dev Only callable by the HubPool contract.\\n     * @param target Address of the contract on the destination that will receive the message. Unused if the\\n     * data is NOT an admin function and can be relayed to any target.\\n     * @param data Data to send to Universal SpokePool.\\n     * @param isAdminSender True if the data is an admin function call, false otherwise.\\n     */\\n    function storeRelayMessageCalldata(\\n        address target,\\n        bytes calldata data,\\n        bool isAdminSender\\n    ) external onlyHubPool {\\n        if (isAdminSender) {\\n            _storeData(target, dataUuid++, data);\\n        } else {\\n            _storeRelayMessageCalldataForAnyTarget(data);\\n        }\\n    }\\n\\n    function _storeRelayMessageCalldataForAnyTarget(bytes calldata data) internal {\\n        // When the data can be sent to any target, we assume that the data contains a relayRootBundleCall as\\n        // constructed by an executeRootBundle() call, therefore this data will be identical for all spoke pools\\n        // in this bundle. We can use the current hub pool's challengePeriodEndTimestamp as the nonce for this data\\n        // so that all relayRootBundle calldata for this bundle gets stored to the same slot and we only write to\\n        // this slot once.\\n        _storeData(address(0), IHubPool(hubPool).rootBundleProposal().challengePeriodEndTimestamp, data);\\n    }\\n\\n    function _storeData(\\n        address target,\\n        uint256 nonce,\\n        bytes calldata data\\n    ) internal {\\n        if (relayMessageCallData[nonce] != bytes32(0)) {\\n            // Data is already stored, do nothing.\\n            return;\\n        }\\n        relayMessageCallData[nonce] = keccak256(abi.encode(target, data));\\n        emit StoredCallData(target, data, nonce);\\n    }\\n}\\n\",\"keccak256\":\"0x4069c9b161df882f990c735fa9076186dac7bf8fd3888ba427057c1631d659c3\",\"license\":\"BUSL-1.1\"},\"contracts/external/interfaces/CCTPInterfaces.sol\":{\"content\":\"/**\\n * Copyright (C) 2015, 2016, 2017 Dapphub\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/**\\n * Imported as-is from commit 139d8d0ce3b5531d3c7ec284f89d946dfb720016 of:\\n *   * https://github.com/walkerq/evm-cctp-contracts/blob/139d8d0ce3b5531d3c7ec284f89d946dfb720016/src/TokenMessenger.sol\\n * Changes applied post-import:\\n *   * Removed a majority of code from this contract and converted the needed function signatures in this interface.\\n */\\ninterface ITokenMessenger {\\n    /**\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\\n     * Emits a `DepositForBurn` event.\\n     * @dev reverts if:\\n     * - given burnToken is not supported\\n     * - given destinationDomain has no TokenMessenger registered\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\n     * to this contract is less than `amount`.\\n     * - burn() reverts. For example, if `amount` is 0.\\n     * - MessageTransmitter returns false or reverts.\\n     * @param amount amount of tokens to burn\\n     * @param destinationDomain destination domain\\n     * @param mintRecipient address of mint recipient on destination domain\\n     * @param burnToken address of contract to burn deposited tokens, on local domain\\n     * @return _nonce unique nonce reserved by message\\n     */\\n    function depositForBurn(\\n        uint256 amount,\\n        uint32 destinationDomain,\\n        bytes32 mintRecipient,\\n        address burnToken\\n    ) external returns (uint64 _nonce);\\n\\n    /**\\n     * @notice Minter responsible for minting and burning tokens on the local domain\\n     * @dev A TokenMessenger stores a TokenMinter contract which extends the TokenController contract.\\n     * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMessenger.sol#L110\\n     * @return minter Token Minter contract.\\n     */\\n    function localMinter() external view returns (ITokenMinter minter);\\n}\\n\\n// Source: https://github.com/circlefin/evm-cctp-contracts/blob/63ab1f0ac06ce0793c0bbfbb8d09816bc211386d/src/v2/TokenMessengerV2.sol#L138C1-L166C15\\ninterface ITokenMessengerV2 {\\n    /**\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\\n     * Emits a `DepositForBurn` event.\\n     * @dev reverts if:\\n     * - given burnToken is not supported\\n     * - given destinationDomain has no TokenMessenger registered\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\n     * to this contract is less than `amount`.\\n     * - burn() reverts. For example, if `amount` is 0.\\n     * - maxFee is greater than or equal to `amount`.\\n     * - MessageTransmitterV2#sendMessage reverts.\\n     * @param amount amount of tokens to burn\\n     * @param destinationDomain destination domain to receive message on\\n     * @param mintRecipient address of mint recipient on destination domain\\n     * @param burnToken token to burn `amount` of, on local domain\\n     * @param destinationCaller authorized caller on the destination domain, as bytes32. If equal to bytes32(0),\\n     * any address can broadcast the message.\\n     * @param maxFee maximum fee to pay on the destination domain, specified in units of burnToken\\n     * @param minFinalityThreshold the minimum finality at which a burn message will be attested to.\\n     */\\n    function depositForBurn(\\n        uint256 amount,\\n        uint32 destinationDomain,\\n        bytes32 mintRecipient,\\n        address burnToken,\\n        bytes32 destinationCaller,\\n        uint256 maxFee,\\n        uint32 minFinalityThreshold\\n    ) external;\\n}\\n\\n/**\\n * A TokenMessenger stores a TokenMinter contract which extends the TokenController contract. The TokenController\\n * contract has a burnLimitsPerMessage public mapping which can be queried to find the per-message burn limit\\n * for a given token:\\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMinter.sol#L33\\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/roles/TokenController.sol#L69C40-L69C60\\n *\\n */\\ninterface ITokenMinter {\\n    /**\\n     * @notice Supported burnable tokens on the local domain\\n     * local token (address) => maximum burn amounts per message\\n     * @param token address of token contract\\n     * @return burnLimit maximum burn amount per message for token\\n     */\\n    function burnLimitsPerMessage(address token) external view returns (uint256);\\n}\\n\\n/**\\n * IMessageTransmitter in CCTP inherits IRelayer and IReceiver, but here we only import sendMessage from IRelayer:\\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IMessageTransmitter.sol#L25\\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IRelayer.sol#L23-L35\\n */\\ninterface IMessageTransmitter {\\n    /**\\n     * @notice Sends an outgoing message from the source domain.\\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\\n     * @param destinationDomain Domain of destination chain\\n     * @param recipient Address of message recipient on destination domain as bytes32\\n     * @param messageBody Raw bytes content of message\\n     * @return nonce reserved by message\\n     */\\n    function sendMessage(\\n        uint32 destinationDomain,\\n        bytes32 recipient,\\n        bytes calldata messageBody\\n    ) external returns (uint64);\\n}\\n\",\"keccak256\":\"0x69059bd91cdb9bea59242c543a167e38a9f3a7788687d4194f68420a956c7608\",\"license\":\"GPL-3.0-or-later\"},\"contracts/interfaces/HubPoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @notice Concise list of functions in HubPool implementation.\\n */\\ninterface HubPoolInterface {\\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\\n    struct PoolRebalanceLeaf {\\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).\\n        uint256 chainId;\\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\\n        uint256[] bundleLpFees;\\n        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative\\n        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This\\n        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does\\n        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous\\n        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's\\n        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.\\n        int256[] netSendAmounts;\\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1\\n        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that\\n        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.\\n        int256[] runningBalances;\\n        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.\\n        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where\\n        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under\\n        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with\\n        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one\\n        // leaf for a specific chainId should have a groupIndex equal to 0.\\n        uint256 groupIndex;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint8 leafId;\\n        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel\\n        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero\\n        // relays on this chain in this bundle in the order of whitelisting.\\n        address[] l1Tokens;\\n    }\\n\\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves\\n    // that can be executed later to:\\n    // - Send funds from this contract to a SpokePool or vice versa\\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \\\"slow\\\" relay\\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\\n    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\\n    struct RootBundle {\\n        // Contains leaves instructing this contract to send funds to SpokePools.\\n        bytes32 poolRebalanceRoot;\\n        // Relayer refund merkle root to be published to a SpokePool.\\n        bytes32 relayerRefundRoot;\\n        // Slow relay merkle root to be published to a SpokePool.\\n        bytes32 slowRelayRoot;\\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\\n        uint256 claimedBitMap;\\n        // Proposer of this root bundle.\\n        address proposer;\\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\\n        // of leaves are executed, a new root bundle can be proposed\\n        uint8 unclaimedPoolRebalanceLeafCount;\\n        // When root bundle challenge period passes and this root bundle becomes executable.\\n        uint32 challengePeriodEndTimestamp;\\n    }\\n\\n    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the\\n    // cumulative LP positions and if this token is enabled for deposits.\\n    struct PooledToken {\\n        // LP token given to LPs of a specific L1 token.\\n        address lpToken;\\n        // True if accepting new LP's.\\n        bool isEnabled;\\n        // Timestamp of last LP fee update.\\n        uint32 lastLpFeeUpdate;\\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\\n        // back later.\\n        int256 utilizedReserves;\\n        // Number of LP funds held in contract less utilized reserves.\\n        uint256 liquidReserves;\\n        // Number of LP funds reserved to pay out to LPs as fees.\\n        uint256 undistributedLpFees;\\n    }\\n\\n    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\\n    struct CrossChainContract {\\n        address adapter;\\n        address spokePool;\\n    }\\n\\n    function setPaused(bool pause) external;\\n\\n    function emergencyDeleteProposal() external;\\n\\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\\n\\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\\n\\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\\n\\n    function setLiveness(uint32 newLiveness) external;\\n\\n    function setIdentifier(bytes32 newIdentifier) external;\\n\\n    function setCrossChainContracts(\\n        uint256 l2ChainId,\\n        address adapter,\\n        address spokePool\\n    ) external;\\n\\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\\n\\n    function removeLiquidity(\\n        address l1Token,\\n        uint256 lpTokenAmount,\\n        bool sendEth\\n    ) external;\\n\\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);\\n\\n    function sync(address l1Token) external;\\n\\n    function proposeRootBundle(\\n        uint256[] memory bundleEvaluationBlockNumbers,\\n        uint8 poolRebalanceLeafCount,\\n        bytes32 poolRebalanceRoot,\\n        bytes32 relayerRefundRoot,\\n        bytes32 slowRelayRoot\\n    ) external;\\n\\n    function executeRootBundle(\\n        uint256 chainId,\\n        uint256 groupIndex,\\n        uint256[] memory bundleLpFees,\\n        int256[] memory netSendAmounts,\\n        int256[] memory runningBalances,\\n        uint8 leafId,\\n        address[] memory l1Tokens,\\n        bytes32[] memory proof\\n    ) external;\\n\\n    function disputeRootBundle() external;\\n\\n    function claimProtocolFeesCaptured(address l1Token) external;\\n\\n    function setPoolRebalanceRoute(\\n        uint256 destinationChainId,\\n        address l1Token,\\n        address destinationToken\\n    ) external;\\n\\n    function setDepositRoute(\\n        uint256 originChainId,\\n        uint256 destinationChainId,\\n        address originToken,\\n        bool depositsEnabled\\n    ) external;\\n\\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\\n        external\\n        view\\n        returns (address destinationToken);\\n\\n    function loadEthForL2Calls() external payable;\\n}\\n\",\"keccak256\":\"0xd8cfdded5db9bf29099e91abd8c8992b4deba1a22d4ffaed94c43ff3d47dcf33\",\"license\":\"MIT\"},\"contracts/interfaces/SpokePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Contains common data structures and functions used by all SpokePool implementations.\\n */\\ninterface SpokePoolInterface {\\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\\n    struct RelayerRefundLeaf {\\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that\\n        // is negative. This is just the negative of this value.\\n        uint256 amountToReturn;\\n        // Used to verify that this is being executed on the correct destination chainId.\\n        uint256 chainId;\\n        // This array designates how much each of those addresses should be refunded.\\n        uint256[] refundAmounts;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint32 leafId;\\n        // The associated L2TokenAddress that these claims apply to.\\n        address l2TokenAddress;\\n        // Must be same length as refundAmounts and designates each address that must be refunded.\\n        address[] refundAddresses;\\n    }\\n\\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\\n    // by \\\"data workers\\\" via inclusion proofs to execute leaves in the roots.\\n    struct RootBundle {\\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\\n        bytes32 slowRelayRoot;\\n        // Merkle root of relayer refunds for successful relays.\\n        bytes32 relayerRefundRoot;\\n        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of\\n        // 256x(2^248) leaves per root.\\n        mapping(uint256 => uint256) claimedBitmap;\\n    }\\n\\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\\n\\n    function setWithdrawalRecipient(address newWithdrawalRecipient) external;\\n\\n    function pauseDeposits(bool pause) external;\\n\\n    function pauseFills(bool pause) external;\\n\\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\\n\\n    function emergencyDeleteRootBundle(uint256 rootBundleId) external;\\n\\n    function depositDeprecated_5947912356(\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external payable;\\n\\n    function depositFor(\\n        address depositor,\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external payable;\\n\\n    function executeRelayerRefundLeaf(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) external payable;\\n\\n    function chainId() external view returns (uint256);\\n\\n    error NotEOA();\\n    error InvalidDepositorSignature();\\n    error InvalidRelayerFeePct();\\n    error MaxTransferSizeExceeded();\\n    error InvalidCrossDomainAdmin();\\n    error InvalidWithdrawalRecipient();\\n    error DepositsArePaused();\\n    error FillsArePaused();\\n}\\n\",\"keccak256\":\"0x67734f330d9b5eb5f7ea7f9f32d2d1cc107879154e9c9424623c6df1709b48e0\",\"license\":\"MIT\"},\"contracts/libraries/AddressConverters.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary Bytes32ToAddress {\\n    /**************************************\\n     *              ERRORS                *\\n     **************************************/\\n    error InvalidBytes32();\\n\\n    function toAddress(bytes32 _bytes32) internal pure returns (address) {\\n        checkAddress(_bytes32);\\n        return address(uint160(uint256(_bytes32)));\\n    }\\n\\n    function toAddressUnchecked(bytes32 _bytes32) internal pure returns (address) {\\n        return address(uint160(uint256(_bytes32)));\\n    }\\n\\n    function checkAddress(bytes32 _bytes32) internal pure {\\n        if (uint256(_bytes32) >> 160 != 0) {\\n            revert InvalidBytes32();\\n        }\\n    }\\n}\\n\\nlibrary AddressToBytes32 {\\n    function toBytes32(address _address) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_address)));\\n    }\\n}\\n\",\"keccak256\":\"0x378f28bb4a17a5c47457cb9341086b2140f7faf6c048f702d3528166f0d74453\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/CircleCCTPAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../external/interfaces/CCTPInterfaces.sol\\\";\\nimport { AddressToBytes32 } from \\\"../libraries/AddressConverters.sol\\\";\\n\\nlibrary CircleDomainIds {\\n    uint32 public constant Ethereum = 0;\\n    uint32 public constant Optimism = 2;\\n    uint32 public constant Arbitrum = 3;\\n    uint32 public constant Solana = 5;\\n    uint32 public constant Base = 6;\\n    uint32 public constant Polygon = 7;\\n    uint32 public constant DoctorWho = 10;\\n    uint32 public constant Linea = 11;\\n    uint32 public constant UNINITIALIZED = type(uint32).max;\\n}\\n\\n/**\\n * @notice Facilitate bridging USDC via Circle's CCTP.\\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\\n * @custom:security-contact bugs@across.to\\n */\\nabstract contract CircleCCTPAdapter {\\n    using SafeERC20 for IERC20;\\n    using AddressToBytes32 for address;\\n    /**\\n     * @notice The domain ID that CCTP will transfer funds to.\\n     * @dev This identifier is assigned by Circle and is not related to a chain ID.\\n     * @dev Official domain list can be found here: https://developers.circle.com/stablecoins/docs/supported-domains\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n\\n    uint32 public immutable recipientCircleDomainId;\\n\\n    /**\\n     * @notice The official USDC contract address on this chain.\\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/usdc-on-main-networks\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    IERC20 public immutable usdcToken;\\n\\n    /**\\n     * @notice The official Circle CCTP token bridge contract endpoint.\\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    ITokenMessenger public immutable cctpTokenMessenger;\\n\\n    /**\\n     * @notice Indicates if the CCTP V2 TokenMessenger is being used.\\n     * @dev This is determined by checking if the feeRecipient() function exists and returns a non-zero address.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    bool public immutable cctpV2;\\n\\n    /**\\n     * @notice intiailizes the CircleCCTPAdapter contract.\\n     * @param _usdcToken USDC address on the current chain.\\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP. If the zero address is passed, CCTP bridging will be disabled.\\n     * @param _recipientCircleDomainId The domain ID that CCTP will transfer funds to.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(\\n        IERC20 _usdcToken,\\n        /// @dev This should ideally be an address but it's kept as an ITokenMessenger to avoid rippling changes to the\\n        /// constructors for every SpokePool/Adapter.\\n        ITokenMessenger _cctpTokenMessenger,\\n        uint32 _recipientCircleDomainId\\n    ) {\\n        usdcToken = _usdcToken;\\n        cctpTokenMessenger = _cctpTokenMessenger;\\n        recipientCircleDomainId = _recipientCircleDomainId;\\n\\n        // Only the CCTP V2 TokenMessenger has a feeRecipient() function, so we use it to\\n        // figure out if we are using CCTP V2 or V1. `success` can be true even if the contract doesn't\\n        // implement feeRecipient but it has a fallback function so to be extra safe, we check the return value\\n        // of feeRecipient() as well.\\n        (bool success, bytes memory feeRecipient) = address(cctpTokenMessenger).staticcall(\\n            abi.encodeWithSignature(\\\"feeRecipient()\\\")\\n        );\\n        // In case of a call to nonexistent contract or a call to a contract with a fallback function which\\n        // doesn't return any data, feeRecipient can be empty so check its length.\\n        // Even with this check, it's possible that the contract has implemented a fallback function that returns\\n        // 32 bytes of data but its not actually the feeRecipient address. This is extremely low risk but worth\\n        // mentioning that the following check is not 100% safe.\\n        cctpV2 = (success &&\\n            feeRecipient.length == 32 &&\\n            address(uint160(uint256(bytes32(feeRecipient)))) != address(0));\\n    }\\n\\n    /**\\n     * @notice Returns whether or not the CCTP bridge is enabled.\\n     * @dev If the CCTPTokenMessenger is the zero address, CCTP bridging is disabled.\\n     */\\n    function _isCCTPEnabled() internal view returns (bool) {\\n        return address(cctpTokenMessenger) != address(0);\\n    }\\n\\n    /**\\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\\n     * @param to Address to receive USDC on the new domain.\\n     * @param amount Amount of USDC to transfer.\\n     */\\n    function _transferUsdc(address to, uint256 amount) internal {\\n        _transferUsdc(to.toBytes32(), amount);\\n    }\\n\\n    /**\\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\\n     * @param to Address to receive USDC on the new domain represented as bytes32.\\n     * @param amount Amount of USDC to transfer.\\n     */\\n    function _transferUsdc(bytes32 to, uint256 amount) internal {\\n        // Only approve the exact amount to be transferred\\n        usdcToken.safeIncreaseAllowance(address(cctpTokenMessenger), amount);\\n        // Submit the amount to be transferred to bridge via the TokenMessenger.\\n        // If the amount to send exceeds the burn limit per message, then split the message into smaller parts.\\n        // @dev We do not care about casting cctpTokenMessenger to ITokenMessengerV2 since both V1 and V2\\n        // expose a localMinter() view function that returns either an ITokenMinterV1 or ITokenMinterV2. Regardless,\\n        // we only care about the burnLimitsPerMessage function which is available in both versions and performs\\n        // the same logic, therefore we purposefully do not re-cast the cctpTokenMessenger and cctpMinter\\n        // to the specific version.\\n        ITokenMinter cctpMinter = cctpTokenMessenger.localMinter();\\n        uint256 burnLimit = cctpMinter.burnLimitsPerMessage(address(usdcToken));\\n        uint256 remainingAmount = amount;\\n        while (remainingAmount > 0) {\\n            uint256 partAmount = remainingAmount > burnLimit ? burnLimit : remainingAmount;\\n            if (cctpV2) {\\n                // Uses the CCTP V2 \\\"standard transfer\\\" speed and\\n                // therefore pays no additional fee for the transfer to be sped up.\\n                ITokenMessengerV2(address(cctpTokenMessenger)).depositForBurn(\\n                    partAmount,\\n                    recipientCircleDomainId,\\n                    to,\\n                    address(usdcToken),\\n                    // The following parameters are new in this function from V2 to V1, can read more here:\\n                    // https://developers.circle.com/stablecoins/evm-smart-contracts\\n                    bytes32(0), // destinationCaller is set to bytes32(0) to indicate that anyone can call\\n                    // receiveMessage on the destination to finalize the transfer\\n                    0, // maxFee can be set to 0 for a \\\"standard transfer\\\"\\n                    2000 // minFinalityThreshold can be set to 2000 for a \\\"standard transfer\\\",\\n                    // https://github.com/circlefin/evm-cctp-contracts/blob/63ab1f0ac06ce0793c0bbfbb8d09816bc211386d/src/v2/FinalityThresholds.sol#L21\\n                );\\n            } else {\\n                cctpTokenMessenger.depositForBurn(partAmount, recipientCircleDomainId, to, address(usdcToken));\\n            }\\n            remainingAmount -= partAmount;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5007254d87c41857f737ddee8b06ef5838182acf6c593f8cc7ced972e03feecb\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x61012060408181523462000218576080826200108b80380380916200002582856200021c565b83398101031262000218578151916001600160a01b0380841684036200021857602091828101518281168103620002185784820151838116928382036200021857606001519163ffffffff83168303620002185760a05260c052608052835163011a412160e61b848201908152600482526001600160401b03928287019184831184841017620001fa575f938493895251915afa923d156200020e573d918211620001fa57845191620000e2601f8201601f19168301846200021c565b82523d5f8284013e5b83620001ee575b83620001bc575b50505060e05261010091825251610e4a91826200024183396080518281816103e3015281816108d90152610a34015260a0518281816105470152818161066e01528181610701015281816107f60152818161093101528181610a8c01528181610ca00152610d11015260c05182818161032b0152818161049301528181610505015281816105c50152818161077d01528181610880015281816109870152610acf015260e051828181610384015261083101525181818161013001526102bd0152f35b81519181015192935090818110620001dd575b50501615155f8080620000f9565b5f19910360031b1b165f80620001cf565b815181149350620000f2565b634e487b7160e01b5f52604160045260245ffd5b60609150620000eb565b5f80fd5b601f909101601f19168101906001600160401b03821190821017620001fa5760405256fe6080806040526004361015610012575f80fd5b5f3560e01c90816311eac85514610cc95750806352c8c75c146104075780636e400983146103a9578063775c0d031461034f5780639748cf7c146102e1578063c1d07cc2146102735763e6eb8ade14610069575f80fd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e5761009b610d35565b6024359067ffffffffffffffff9081831161021e573660238401121561021e57826004013591821161021e576024830192602483369201011161021e57604051927f8da5cb5b000000000000000000000000000000000000000000000000000000008452602084600481305afa938415610213575f94610222575b5073ffffffffffffffffffffffffffffffffffffffff91827f00000000000000000000000000000000000000000000000000000000000000001690813b1561021e575f918491836040518099819582947fb6a315780000000000000000000000000000000000000000000000000000000084521698896004840152606060248401526101a6606484018c8b610dad565b91163314604483015203925af1908115610213577f9e6c52944e331ba6270e7fe4cea2a4086bae8f7a27e1cdba07f416806f5d0ac4946101ff92610204575b506040519384938452604060208501526040840191610dad565b0390a1005b61020d90610d58565b5f6101e5565b6040513d5f823e3d90fd5b5f80fd5b9093506020813d60201161026b575b8161023e60209383610d6c565b8101031261021e575173ffffffffffffffffffffffffffffffffffffffff8116810361021e57925f610116565b3d9150610231565b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e5760206040517f000000000000000000000000000000000000000000000000000000000000000015158152f35b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b60807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e57610439610d35565b60243573ffffffffffffffffffffffffffffffffffffffff81160361021e576044356064359173ffffffffffffffffffffffffffffffffffffffff8316830361021e5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001615159081610c86575b5015610c5c576040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015260208160448173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa908115610213575f91610c2a575b508181018091116109c5576040519060208201907f095ea7b300000000000000000000000000000000000000000000000000000000825273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166024840152604483015260448252608082019082821067ffffffffffffffff831117610bf15760c083019282841067ffffffffffffffff851117610bf15760205f94938594604052527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656460a082015251908273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af13d15610c1e573d67ffffffffffffffff8111610bf15761072691604051916106e060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184610d6c565b82523d5f602084013e5b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016610deb565b8051908115918215610bce575b50501561021e576040517fcb75c11c00000000000000000000000000000000000000000000000000000000815260208160048173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa908115610213575f91610b7c575b5090602073ffffffffffffffffffffffffffffffffffffffff926024604051809581937fa56ec632000000000000000000000000000000000000000000000000000000008352817f0000000000000000000000000000000000000000000000000000000000000000166004840152165afa918215610213575f92610b48575b5090917f000000000000000000000000000000000000000000000000000000000000000091805b61085957005b83811115610b4257835b8315610a015773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b1561021e576040517f8e0250ee00000000000000000000000000000000000000000000000000000000815281600482015263ffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273ffffffffffffffffffffffffffffffffffffffff8416604482015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660648201525f60848201525f60a48201526107d060c48201525f8160e4818373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015610213576109f2575b505b81039081116109c55780610853565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b6109fb90610d58565b856109b4565b6040517f6fd3504e00000000000000000000000000000000000000000000000000000000815281600482015263ffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273ffffffffffffffffffffffffffffffffffffffff8416604482015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660648201526020816084815f73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af1801561021357610b02575b506109b6565b6020813d602011610b3a575b81610b1b60209383610d6c565b8101031261021e575167ffffffffffffffff81160361021e5785610afc565b3d9150610b0e565b80610863565b9091506020813d602011610b74575b81610b6460209383610d6c565b8101031261021e5751908361082c565b3d9150610b57565b90506020813d602011610bc6575b81610b9760209383610d6c565b8101031261021e57519073ffffffffffffffffffffffffffffffffffffffff8216820361021e579060206107ad565b3d9150610b8a565b819250906020918101031261021e5760200151801515810361021e578380610733565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610726906060906106ea565b90506020813d602011610c54575b81610c4560209383610d6c565b8101031261021e575183610577565b3d9150610c38565b60046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b905073ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016911614836104bc565b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e5760209073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361021e57565b67ffffffffffffffff8111610bf157604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610bf157604052565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b9015610e0557815115610dfc575090565b3b1561021e5790565b50805190811561021e57602001fdfea26469706673582212205aafbc5c47553279d4fcb43410b676938f427ada1ab33e9b041ec0c4b309508064736f6c63430008170033",
  "deployedBytecode": "0x6080806040526004361015610012575f80fd5b5f3560e01c90816311eac85514610cc95750806352c8c75c146104075780636e400983146103a9578063775c0d031461034f5780639748cf7c146102e1578063c1d07cc2146102735763e6eb8ade14610069575f80fd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e5761009b610d35565b6024359067ffffffffffffffff9081831161021e573660238401121561021e57826004013591821161021e576024830192602483369201011161021e57604051927f8da5cb5b000000000000000000000000000000000000000000000000000000008452602084600481305afa938415610213575f94610222575b5073ffffffffffffffffffffffffffffffffffffffff91827f00000000000000000000000000000000000000000000000000000000000000001690813b1561021e575f918491836040518099819582947fb6a315780000000000000000000000000000000000000000000000000000000084521698896004840152606060248401526101a6606484018c8b610dad565b91163314604483015203925af1908115610213577f9e6c52944e331ba6270e7fe4cea2a4086bae8f7a27e1cdba07f416806f5d0ac4946101ff92610204575b506040519384938452604060208501526040840191610dad565b0390a1005b61020d90610d58565b5f6101e5565b6040513d5f823e3d90fd5b5f80fd5b9093506020813d60201161026b575b8161023e60209383610d6c565b8101031261021e575173ffffffffffffffffffffffffffffffffffffffff8116810361021e57925f610116565b3d9150610231565b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e5760206040517f000000000000000000000000000000000000000000000000000000000000000015158152f35b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b60807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e57610439610d35565b60243573ffffffffffffffffffffffffffffffffffffffff81160361021e576044356064359173ffffffffffffffffffffffffffffffffffffffff8316830361021e5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001615159081610c86575b5015610c5c576040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015260208160448173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa908115610213575f91610c2a575b508181018091116109c5576040519060208201907f095ea7b300000000000000000000000000000000000000000000000000000000825273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166024840152604483015260448252608082019082821067ffffffffffffffff831117610bf15760c083019282841067ffffffffffffffff851117610bf15760205f94938594604052527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656460a082015251908273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af13d15610c1e573d67ffffffffffffffff8111610bf15761072691604051916106e060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184610d6c565b82523d5f602084013e5b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016610deb565b8051908115918215610bce575b50501561021e576040517fcb75c11c00000000000000000000000000000000000000000000000000000000815260208160048173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165afa908115610213575f91610b7c575b5090602073ffffffffffffffffffffffffffffffffffffffff926024604051809581937fa56ec632000000000000000000000000000000000000000000000000000000008352817f0000000000000000000000000000000000000000000000000000000000000000166004840152165afa918215610213575f92610b48575b5090917f000000000000000000000000000000000000000000000000000000000000000091805b61085957005b83811115610b4257835b8315610a015773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b1561021e576040517f8e0250ee00000000000000000000000000000000000000000000000000000000815281600482015263ffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273ffffffffffffffffffffffffffffffffffffffff8416604482015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660648201525f60848201525f60a48201526107d060c48201525f8160e4818373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015610213576109f2575b505b81039081116109c55780610853565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b6109fb90610d58565b856109b4565b6040517f6fd3504e00000000000000000000000000000000000000000000000000000000815281600482015263ffffffff7f000000000000000000000000000000000000000000000000000000000000000016602482015273ffffffffffffffffffffffffffffffffffffffff8416604482015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660648201526020816084815f73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af1801561021357610b02575b506109b6565b6020813d602011610b3a575b81610b1b60209383610d6c565b8101031261021e575167ffffffffffffffff81160361021e5785610afc565b3d9150610b0e565b80610863565b9091506020813d602011610b74575b81610b6460209383610d6c565b8101031261021e5751908361082c565b3d9150610b57565b90506020813d602011610bc6575b81610b9760209383610d6c565b8101031261021e57519073ffffffffffffffffffffffffffffffffffffffff8216820361021e579060206107ad565b3d9150610b8a565b819250906020918101031261021e5760200151801515810361021e578380610733565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610726906060906106ea565b90506020813d602011610c54575b81610c4560209383610d6c565b8101031261021e575183610577565b3d9150610c38565b60046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b905073ffffffffffffffffffffffffffffffffffffffff807f000000000000000000000000000000000000000000000000000000000000000016911614836104bc565b3461021e575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261021e5760209073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361021e57565b67ffffffffffffffff8111610bf157604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610bf157604052565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b9015610e0557815115610dfc575090565b3b1561021e5790565b50805190811561021e57602001fdfea26469706673582212205aafbc5c47553279d4fcb43410b676938f427ada1ab33e9b041ec0c4b309508064736f6c63430008170033",
  "devdoc": {
    "custom:security-contact": "bugs@across.to",
    "details": "This contract should NOT be reused to send messages to SpokePools that have the same address on different L2s.This contract can be redeployed to point to a new HubPoolStore if the data store gets corrupted and new data can't get written to the store for some reason. The corresponding Universal_SpokePool contract will also need to be redeployed to point to the new HubPoolStore.",
    "kind": "dev",
    "methods": {
      "relayMessage(address,bytes)": {
        "params": {
          "message": "Data to send to target.",
          "target": "Contract on the destination that will receive the message. Unused if the message is created by the HubPool admin."
        }
      },
      "relayTokens(address,address,uint256,address)": {
        "details": "This function only uses the CircleCCTPAdapter to relay USDC tokens to CCTP enabled L2 chains. Relaying other tokens will cause this function to revert.",
        "params": {
          "amount": "Amount of tokens to relay.",
          "l1Token": "Address of the token on L1.",
          "l2Token": "Address of the token on L2. Unused",
          "to": "Address to receive the tokens on L2. Should be SpokePool address."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "DATA_STORE()": {
        "notice": "Contract that stores calldata to be relayed to L2 via storage proofs."
      },
      "relayMessage(address,bytes)": {
        "notice": "Saves calldata in a simple storage contract whose state can be proven and relayed to L2."
      },
      "relayTokens(address,address,uint256,address)": {
        "notice": "Relays tokens from L1 to L2."
      }
    },
    "notice": "Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts on the L2 where the SpokePool is deployed. Designed to be used as a singleton contract that can be used to relay messages to multiple SpokePools on different chains.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
