{
  "language": "Solidity",
  "sources": {
    "contracts/HubPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MerkleLib.sol\";\r\nimport \"./HubPoolInterface.sol\";\r\nimport \"./Lockable.sol\";\r\n\r\nimport \"./interfaces/LpTokenFactoryInterface.sol\";\r\nimport \"./interfaces/WETH9.sol\";\r\n\r\nimport \"@uma/core/contracts/common/implementation/Testable.sol\";\r\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\r\nimport \"@uma/core/contracts/oracle/implementation/Constants.sol\";\r\nimport \"@uma/core/contracts/common/interfaces/AddressWhitelistInterface.sol\";\r\nimport \"@uma/core/contracts/oracle/interfaces/IdentifierWhitelistInterface.sol\";\r\n\r\nimport \"@uma/core/contracts/oracle/interfaces/FinderInterface.sol\";\r\nimport \"@uma/core/contracts/oracle/interfaces/StoreInterface.sol\";\r\nimport \"@uma/core/contracts/oracle/interfaces/SkinnyOptimisticOracleInterface.sol\";\r\nimport \"@uma/core/contracts/common/interfaces/ExpandedIERC20.sol\";\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n/**\r\n * @notice Contract deployed on Ethereum that houses L1 token liquidity for all SpokePools. A dataworker can interact\r\n * with merkle roots stored in this contract via inclusion proofs to instruct this contract to send tokens to L2\r\n * SpokePools via \"pool rebalances\" that can be used to pay out relayers on those networks. This contract is also\r\n * responsible for publishing relayer refund and slow relay merkle roots to SpokePools.\r\n * @notice This contract is meant to act as the cross chain administrator and owner of all L2 spoke pools, so all\r\n * governance actions and pool rebalances originate from here and bridge instructions to L2s.\r\n * @dev This contract should be deprecated by the year 2106, at which point uint32 timestamps will roll over. This is\r\n * an issue for this contract because fee calculations will become bizarre when multiplying by negative time deltas.\r\n * Before this date, this contract should be paused from accepting new root bundles and all LP tokens should be\r\n * disabled by the admin.\r\n */\r\ncontract HubPool is HubPoolInterface, Testable, Lockable, MultiCaller, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    // Only one root bundle can be stored at a time. Once all pool rebalance leaves are executed, a new proposal\r\n    // can be submitted.\r\n    RootBundle public rootBundleProposal;\r\n\r\n    // Mapping of L1 token addresses to the associated pool information.\r\n    mapping(address => PooledToken) public pooledTokens;\r\n\r\n    // Stores paths from L1 token + destination ID to destination token. Since different tokens on L1 might map to\r\n    // to the same address on different destinations, we hash (L1 token address, destination ID) to\r\n    // use as a key that maps to a destination token. This mapping is used to direct pool rebalances from\r\n    // HubPool to SpokePool, and also is designed to be used as a lookup for off-chain data workers to determine\r\n    // which L1 tokens to relay to SpokePools to refund relayers. The admin can set the \"destination token\"\r\n    // to 0x0 to disable a pool rebalance route and block executeRootBundle() from executing.\r\n    mapping(bytes32 => address) private poolRebalanceRoutes;\r\n\r\n    // Mapping of chainId to the associated adapter and spokePool contracts.\r\n    mapping(uint256 => CrossChainContract) public crossChainContracts;\r\n\r\n    mapping(address => uint256) public unclaimedAccumulatedProtocolFees;\r\n\r\n    // Whether the bundle proposal process is paused.\r\n    bool public paused;\r\n\r\n    // WETH contract for Ethereum.\r\n    WETH9 public immutable weth;\r\n\r\n    // Helper factory to deploy new LP tokens for enabled L1 tokens\r\n    LpTokenFactoryInterface public immutable lpTokenFactory;\r\n\r\n    // Finder contract for this network.\r\n    FinderInterface public immutable finder;\r\n\r\n    // Address that captures protocol fees. Accumulated protocol fees can be claimed by this address.\r\n    address public protocolFeeCaptureAddress;\r\n\r\n    // Token used to bond the data worker for proposing relayer refund bundles.\r\n    IERC20 public bondToken;\r\n\r\n    // Each root bundle proposal must stay in liveness for this period of time before it can be considered finalized.\r\n    // It can be disputed only during this period of time. Defaults to 2 hours, like the rest of the UMA ecosystem.\r\n    uint32 public liveness = 7200;\r\n\r\n    // When root bundles are disputed a price request is enqueued with the DVM to resolve the resolution.\r\n    bytes32 public identifier = \"IS_ACROSS_V2_BUNDLE_VALID\";\r\n\r\n    // Interest rate payment that scales the amount of pending fees per second paid to LPs. 0.0000015e18 will pay out\r\n    // the full amount of fees entitled to LPs in ~ 7.72 days assuming no contract interactions. If someone interacts\r\n    // with the contract then the LP rewards are smeared sublinearly over the window (i.e spread over the remaining\r\n    // period for each interaction which approximates a decreasing exponential function).\r\n    uint256 public lpFeeRatePerSecond = 1500000000000;\r\n\r\n    // Percentage of lpFees that are captured by the protocol and claimable by the protocolFeeCaptureAddress.\r\n    uint256 public protocolFeeCapturePct;\r\n\r\n    // The computed bond amount as the UMA Store's final fee multiplied by the bondTokenFinalFeeMultiplier.\r\n    uint256 public bondAmount;\r\n\r\n    event Paused(bool indexed isPaused);\r\n\r\n    event EmergencyRootBundleDeleted(\r\n        bytes32 indexed poolRebalanceRoot,\r\n        bytes32 indexed relayerRefundRoot,\r\n        bytes32 slowRelayRoot,\r\n        address indexed proposer\r\n    );\r\n\r\n    event ProtocolFeeCaptureSet(address indexed newProtocolFeeCaptureAddress, uint256 indexed newProtocolFeeCapturePct);\r\n\r\n    event ProtocolFeesCapturedClaimed(address indexed l1Token, uint256 indexed accumulatedFees);\r\n\r\n    event BondSet(address indexed newBondToken, uint256 newBondAmount);\r\n\r\n    event LivenessSet(uint256 newLiveness);\r\n\r\n    event IdentifierSet(bytes32 newIdentifier);\r\n\r\n    event CrossChainContractsSet(uint256 l2ChainId, address adapter, address spokePool);\r\n\r\n    event L1TokenEnabledForLiquidityProvision(address l1Token, address lpToken);\r\n\r\n    event L2TokenDisabledForLiquidityProvision(address l1Token, address lpToken);\r\n\r\n    event LiquidityAdded(\r\n        address indexed l1Token,\r\n        uint256 amount,\r\n        uint256 lpTokensMinted,\r\n        address indexed liquidityProvider\r\n    );\r\n    event LiquidityRemoved(\r\n        address indexed l1Token,\r\n        uint256 amount,\r\n        uint256 lpTokensBurnt,\r\n        address indexed liquidityProvider\r\n    );\r\n    event SetPoolRebalanceRoute(\r\n        uint256 indexed destinationChainId,\r\n        address indexed l1Token,\r\n        address indexed destinationToken\r\n    );\r\n    event SetEnableDepositRoute(\r\n        uint256 indexed originChainId,\r\n        uint256 indexed destinationChainId,\r\n        address indexed originToken,\r\n        bool depositsEnabled\r\n    );\r\n    event ProposeRootBundle(\r\n        uint32 challengePeriodEndTimestamp,\r\n        uint8 poolRebalanceLeafCount,\r\n        uint256[] bundleEvaluationBlockNumbers,\r\n        bytes32 indexed poolRebalanceRoot,\r\n        bytes32 indexed relayerRefundRoot,\r\n        bytes32 slowRelayRoot,\r\n        address indexed proposer\r\n    );\r\n    event RootBundleExecuted(\r\n        uint256 groupIndex,\r\n        uint256 indexed leafId,\r\n        uint256 indexed chainId,\r\n        address[] l1Tokens,\r\n        uint256[] bundleLpFees,\r\n        int256[] netSendAmounts,\r\n        int256[] runningBalances,\r\n        address indexed caller\r\n    );\r\n    event SpokePoolAdminFunctionTriggered(uint256 indexed chainId, bytes message);\r\n\r\n    event RootBundleDisputed(address indexed disputer, uint256 requestTime);\r\n\r\n    event RootBundleCanceled(address indexed disputer, uint256 requestTime);\r\n\r\n    modifier noActiveRequests() {\r\n        require(!_activeRequest(), \"Proposal has unclaimed leaves\");\r\n        _;\r\n    }\r\n\r\n    modifier unpaused() {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier zeroOptimisticOracleApproval() {\r\n        _;\r\n        bondToken.safeApprove(address(_getOptimisticOracle()), 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Construct HubPool.\r\n     * @param _lpTokenFactory LP Token factory address used to deploy LP tokens for new collateral types.\r\n     * @param _finder Finder address.\r\n     * @param _weth WETH address.\r\n     * @param _timer Timer address.\r\n     */\r\n    constructor(\r\n        LpTokenFactoryInterface _lpTokenFactory,\r\n        FinderInterface _finder,\r\n        WETH9 _weth,\r\n        address _timer\r\n    ) Testable(_timer) {\r\n        lpTokenFactory = _lpTokenFactory;\r\n        finder = _finder;\r\n        weth = _weth;\r\n        protocolFeeCaptureAddress = owner();\r\n    }\r\n\r\n    /*************************************************\r\n     *                ADMIN FUNCTIONS                *\r\n     *************************************************/\r\n\r\n    /**\r\n     * @notice Pauses the bundle proposal and execution process. This is intended to be used during upgrades or when\r\n     * something goes awry.\r\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\r\n     */\r\n    function setPaused(bool pause) public onlyOwner nonReentrant {\r\n        paused = pause;\r\n        emit Paused(pause);\r\n    }\r\n\r\n    /**\r\n     * @notice This allows for the deletion of the active proposal in case of emergency.\r\n     * @dev This is primarily intended to rectify situations where an unexecutable bundle gets through liveness in the\r\n     * case of a non-malicious bug in the proposal/dispute code. Without this function, the contract would be\r\n     * indefinitely blocked, migration would be required, and in-progress transfers would never be repaid.\r\n     */\r\n    function emergencyDeleteProposal() public onlyOwner nonReentrant {\r\n        RootBundle memory _rootBundleProposal = rootBundleProposal;\r\n        delete rootBundleProposal;\r\n        if (_rootBundleProposal.unclaimedPoolRebalanceLeafCount > 0)\r\n            bondToken.safeTransfer(_rootBundleProposal.proposer, bondAmount);\r\n        emit EmergencyRootBundleDeleted(\r\n            _rootBundleProposal.poolRebalanceRoot,\r\n            _rootBundleProposal.relayerRefundRoot,\r\n            _rootBundleProposal.slowRelayRoot,\r\n            _rootBundleProposal.proposer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sends message to SpokePool from this contract. Callable only by owner.\r\n     * @dev This function has permission to call onlyAdmin functions on the SpokePool, so it's imperative that this\r\n     * contract only allows the owner to call this method directly or indirectly.\r\n     * @param chainId Chain with SpokePool to send message to.\r\n     * @param functionData ABI encoded function call to send to SpokePool, but can be any arbitrary data technically.\r\n     */\r\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData)\r\n        public\r\n        override\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        _relaySpokePoolAdminFunction(chainId, functionData);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets protocolFeeCaptureAddress and protocolFeeCapturePct. Callable only by owner.\r\n     * @param newProtocolFeeCaptureAddress New protocol fee capture address.\r\n     * @param newProtocolFeeCapturePct New protocol fee capture %.\r\n     */\r\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct)\r\n        public\r\n        override\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        require(newProtocolFeeCapturePct <= 1e18, \"Bad protocolFeeCapturePct\");\r\n        require(newProtocolFeeCaptureAddress != address(0), \"Bad protocolFeeCaptureAddress\");\r\n        protocolFeeCaptureAddress = newProtocolFeeCaptureAddress;\r\n        protocolFeeCapturePct = newProtocolFeeCapturePct;\r\n        emit ProtocolFeeCaptureSet(newProtocolFeeCaptureAddress, newProtocolFeeCapturePct);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets bond token and amount. Callable only by owner.\r\n     * @param newBondToken New bond currency.\r\n     * @param newBondAmount New bond amount.\r\n     */\r\n    function setBond(IERC20 newBondToken, uint256 newBondAmount)\r\n        public\r\n        override\r\n        onlyOwner\r\n        noActiveRequests\r\n        nonReentrant\r\n    {\r\n        // Bond should not equal final fee otherwise every proposal will get cancelled in a dispute.\r\n        // In practice we expect that bond amounts are set >> final fees so this shouldn't be an inconvenience.\r\n        // The only way for the bond amount to be equal to the final fee is if the newBondAmount == 0.\r\n        require(newBondAmount != 0, \"bond equal to final fee\");\r\n\r\n        // Check that this token is on the whitelist.\r\n        AddressWhitelistInterface addressWhitelist = AddressWhitelistInterface(\r\n            finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist)\r\n        );\r\n        require(addressWhitelist.isOnWhitelist(address(newBondToken)), \"Not on whitelist\");\r\n\r\n        // The bond should be the passed in bondAmount + the final fee.\r\n        bondToken = newBondToken;\r\n        uint256 _bondAmount = newBondAmount + _getBondTokenFinalFee();\r\n        bondAmount = _bondAmount;\r\n        emit BondSet(address(newBondToken), _bondAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets root bundle proposal liveness period. Callable only by owner.\r\n     * @param newLiveness New liveness period.\r\n     */\r\n    function setLiveness(uint32 newLiveness) public override onlyOwner nonReentrant {\r\n        require(newLiveness > 10 minutes, \"Liveness too short\");\r\n        liveness = newLiveness;\r\n        emit LivenessSet(newLiveness);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets identifier for root bundle disputes. Callable only by owner.\r\n     * @param newIdentifier New identifier.\r\n     */\r\n    function setIdentifier(bytes32 newIdentifier) public override onlyOwner noActiveRequests nonReentrant {\r\n        IdentifierWhitelistInterface identifierWhitelist = IdentifierWhitelistInterface(\r\n            finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist)\r\n        );\r\n        require(identifierWhitelist.isIdentifierSupported(newIdentifier), \"Identifier not supported\");\r\n        identifier = newIdentifier;\r\n        emit IdentifierSet(newIdentifier);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets cross chain relay helper contracts for L2 chain ID. Callable only by owner.\r\n     * @dev We do not block setting the adapter or SpokePool to invalid/zero addresses because we want to allow the\r\n     * admin to block relaying roots to the spoke pool for emergency recovery purposes.\r\n     * @param l2ChainId Chain to set contracts for.\r\n     * @param adapter Adapter used to relay messages and tokens to spoke pool. Deployed on current chain.\r\n     * @param spokePool Recipient of relayed messages and tokens on spoke pool. Deployed on l2ChainId.\r\n     */\r\n\r\n    function setCrossChainContracts(\r\n        uint256 l2ChainId,\r\n        address adapter,\r\n        address spokePool\r\n    ) public override onlyOwner nonReentrant {\r\n        crossChainContracts[l2ChainId] = CrossChainContract(adapter, spokePool);\r\n        emit CrossChainContractsSet(l2ChainId, adapter, spokePool);\r\n    }\r\n\r\n    /**\r\n     * @notice Store canonical destination token counterpart for l1 token. Callable only by owner.\r\n     * @dev Admin can set destinationToken to 0x0 to effectively disable executing any root bundles with leaves\r\n     * containing this l1 token + destination chain ID combination.\r\n     * @param destinationChainId Destination chain where destination token resides.\r\n     * @param l1Token Token enabled for liquidity in this pool, and the L1 counterpart to the destination token on the\r\n     * destination chain ID.\r\n     * @param destinationToken Destination chain counterpart of L1 token.\r\n     */\r\n    function setPoolRebalanceRoute(\r\n        uint256 destinationChainId,\r\n        address l1Token,\r\n        address destinationToken\r\n    ) public override onlyOwner nonReentrant {\r\n        poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, destinationChainId)] = destinationToken;\r\n        emit SetPoolRebalanceRoute(destinationChainId, l1Token, destinationToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Sends cross-chain message to SpokePool on originChainId to enable or disable deposit route from that\r\n     * SpokePool to another one. Callable only by owner.\r\n     * @dev Admin is responsible for ensuring that `originToken` is linked to some L1 token on this contract, via\r\n     * poolRebalanceRoutes(), and that this L1 token also has a counterpart on the destination chain. If either\r\n     * condition fails, then the deposit will be unrelayable by off-chain relayers because they will not know which\r\n     * token to relay to recipients on the destination chain, and data workers wouldn't know which L1 token to send\r\n     * to the destination chain to refund the relayer.\r\n     * @param originChainId Chain where token deposit occurs.\r\n     * @param destinationChainId Chain where token depositor wants to receive funds.\r\n     * @param originToken Token sent in deposit.\r\n     * @param depositsEnabled Set to true to whitelist this route for deposits, set to false if caller just wants to\r\n     * map the origin token + destination ID to the destination token address on the origin chain's SpokePool.\r\n     */\r\n    function setDepositRoute(\r\n        uint256 originChainId,\r\n        uint256 destinationChainId,\r\n        address originToken,\r\n        bool depositsEnabled\r\n    ) public override nonReentrant onlyOwner {\r\n        _relaySpokePoolAdminFunction(\r\n            originChainId,\r\n            abi.encodeWithSignature(\r\n                \"setEnableRoute(address,uint256,bool)\",\r\n                originToken,\r\n                destinationChainId,\r\n                depositsEnabled\r\n            )\r\n        );\r\n        emit SetEnableDepositRoute(originChainId, destinationChainId, originToken, depositsEnabled);\r\n    }\r\n\r\n    /**\r\n     * @notice Enables LPs to provide liquidity for L1 token. Deploys new LP token for L1 token if appropriate.\r\n     * Callable only by owner.\r\n     * @param l1Token Token to provide liquidity for.\r\n     */\r\n    function enableL1TokenForLiquidityProvision(address l1Token) public override onlyOwner nonReentrant {\r\n        // If token is being enabled for the first time, create a new LP token and set the timestamp once. We don't\r\n        // want to ever reset this timestamp otherwise fees that have accrued will be lost since the last update. This\r\n        // could happen for example if an L1 token is enabled, disabled, and then enabled again.\r\n        if (pooledTokens[l1Token].lpToken == address(0)) {\r\n            pooledTokens[l1Token].lpToken = lpTokenFactory.createLpToken(l1Token);\r\n            pooledTokens[l1Token].lastLpFeeUpdate = uint32(getCurrentTime());\r\n        }\r\n\r\n        pooledTokens[l1Token].isEnabled = true;\r\n\r\n        emit L1TokenEnabledForLiquidityProvision(l1Token, pooledTokens[l1Token].lpToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Disables LPs from providing liquidity for L1 token. Callable only by owner.\r\n     * @param l1Token Token to disable liquidity provision for.\r\n     */\r\n    function disableL1TokenForLiquidityProvision(address l1Token) public override onlyOwner nonReentrant {\r\n        pooledTokens[l1Token].isEnabled = false;\r\n        emit L2TokenDisabledForLiquidityProvision(l1Token, pooledTokens[l1Token].lpToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Enables the owner of the protocol to haircut reserves in the event of an irrecoverable loss of funds on\r\n     * one of the L2s. Consider funds are leant out onto a L2 that dies irrecoverably. This value will offset the\r\n     * exchangeRateCurrent such that all LPs receive a pro rata loss of the the reserves. Should be used in conjunction\r\n     * with pause logic to prevent LPs from adding/withdrawing liquidity during the haircut process.\r\n     * Callable only by owner.\r\n     * @param l1Token Token to execute the haircut on.\r\n     * @param haircutAmount The amount of reserves to haircut the LPs by.\r\n     */\r\n    function haircutReserves(address l1Token, int256 haircutAmount) public onlyOwner nonReentrant {\r\n        // Note that we do not call sync first in this method. The Owner should call this manually before haircutting.\r\n        // This is done in the event sync is reverting due to too low balanced in the contract relative to bond amount.\r\n        pooledTokens[l1Token].utilizedReserves -= haircutAmount;\r\n    }\r\n\r\n    /*************************************************\r\n     *          LIQUIDITY PROVIDER FUNCTIONS         *\r\n     *************************************************/\r\n\r\n    /**\r\n     * @notice Deposit liquidity into this contract to earn LP fees in exchange for funding relays on SpokePools.\r\n     * Caller is essentially loaning their funds to be sent from this contract to the SpokePool, where it will be used\r\n     * to repay a relayer, and ultimately receives their loan back after the tokens are bridged back to this contract\r\n     * via the canonical token bridge. Then, the caller's loans are used again. This loan cycle repeats continuously\r\n     * and the caller, or \"liquidity provider\" earns a continuous fee for their credit that they are extending relayers.\r\n     * @notice Caller will receive an LP token representing their share of this pool. The LP token's redemption value\r\n     * increments from the time that they enter the pool to reflect their accrued fees.\r\n     * @notice The caller of this function must approve this contract to spend l1TokenAmount of l1Token.\r\n     * @param l1Token Token to deposit into this contract.\r\n     * @param l1TokenAmount Amount of liquidity to provide.\r\n     */\r\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) public payable override nonReentrant unpaused {\r\n        require(pooledTokens[l1Token].isEnabled, \"Token not enabled\");\r\n        // If this is the weth pool and the caller sends msg.value then the msg.value must match the l1TokenAmount.\r\n        // Else, msg.value must be set to 0.\r\n        require(((address(weth) == l1Token) && msg.value == l1TokenAmount) || msg.value == 0, \"Bad msg.value\");\r\n\r\n        // Since _exchangeRateCurrent() reads this contract's balance and updates contract state using it, it must be\r\n        // first before transferring any tokens to this contract to ensure synchronization.\r\n        uint256 lpTokensToMint = (l1TokenAmount * 1e18) / _exchangeRateCurrent(l1Token);\r\n        pooledTokens[l1Token].liquidReserves += l1TokenAmount;\r\n        ExpandedIERC20(pooledTokens[l1Token].lpToken).mint(msg.sender, lpTokensToMint);\r\n\r\n        if (address(weth) == l1Token && msg.value > 0) WETH9(address(l1Token)).deposit{ value: msg.value }();\r\n        else IERC20(l1Token).safeTransferFrom(msg.sender, address(this), l1TokenAmount);\r\n\r\n        emit LiquidityAdded(l1Token, l1TokenAmount, lpTokensToMint, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Burns LP share to redeem for underlying l1Token original deposit amount plus fees.\r\n     * @param l1Token Token to redeem LP share for.\r\n     * @param lpTokenAmount Amount of LP tokens to burn. Exchange rate between L1 token and LP token can be queried\r\n     * via public exchangeRateCurrent method.\r\n     * @param sendEth Set to True if L1 token is WETH and user wants to receive ETH. Note that if caller\r\n     * is a contract, then the contract should have a way to receive ETH if this value is set to True. Similarly,\r\n     * if this value is set to False, then the calling contract should have a way to handle WETH.\r\n     */\r\n    function removeLiquidity(\r\n        address l1Token,\r\n        uint256 lpTokenAmount,\r\n        bool sendEth\r\n    ) public override nonReentrant unpaused {\r\n        require(address(weth) == l1Token || !sendEth, \"Cant send eth\");\r\n        uint256 l1TokensToReturn = (lpTokenAmount * _exchangeRateCurrent(l1Token)) / 1e18;\r\n\r\n        ExpandedIERC20(pooledTokens[l1Token].lpToken).burnFrom(msg.sender, lpTokenAmount);\r\n        // Note this method does not make any liquidity utilization checks before letting the LP redeem their LP tokens.\r\n        // If they try access more funds than available (i.e l1TokensToReturn > liquidReserves) this will underflow.\r\n        pooledTokens[l1Token].liquidReserves -= l1TokensToReturn;\r\n\r\n        if (sendEth) {\r\n            weth.withdraw(l1TokensToReturn);\r\n            Address.sendValue(payable(msg.sender), l1TokensToReturn); // This will revert if the caller is a contract that does not implement a fallback function.\r\n        } else {\r\n            IERC20(address(l1Token)).safeTransfer(msg.sender, l1TokensToReturn);\r\n        }\r\n        emit LiquidityRemoved(l1Token, l1TokensToReturn, lpTokenAmount, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns exchange rate of L1 token to LP token.\r\n     * @param l1Token L1 token redeemable by burning LP token.\r\n     * @return Amount of L1 tokens redeemable for 1 unit LP token.\r\n     */\r\n    function exchangeRateCurrent(address l1Token) public override nonReentrant returns (uint256) {\r\n        return _exchangeRateCurrent(l1Token);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns % of liquid reserves currently being \"used\" and sitting in SpokePools.\r\n     * @param l1Token L1 token to query utilization for.\r\n     * @return % of liquid reserves currently being \"used\" and sitting in SpokePools.\r\n     */\r\n    function liquidityUtilizationCurrent(address l1Token) public override nonReentrant returns (uint256) {\r\n        return _liquidityUtilizationPostRelay(l1Token, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns % of liquid reserves currently being \"used\" and sitting in SpokePools and accounting for\r\n     * relayedAmount of tokens to be withdrawn from the pool.\r\n     * @param l1Token L1 token to query utilization for.\r\n     * @param relayedAmount The higher this amount, the higher the utilization.\r\n     * @return % of liquid reserves currently being \"used\" and sitting in SpokePools plus the relayedAmount.\r\n     */\r\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount)\r\n        public\r\n        nonReentrant\r\n        returns (uint256)\r\n    {\r\n        return _liquidityUtilizationPostRelay(l1Token, relayedAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Synchronize any balance changes in this contract with the utilized & liquid reserves. This should be done\r\n     * at the conclusion of a L2->L1 token transfer via the canonical token bridge, when this contract's reserves do not\r\n     * reflect its true balance due to new tokens being dropped onto the contract at the conclusion of a bridging action.\r\n     */\r\n    function sync(address l1Token) public override nonReentrant {\r\n        _sync(l1Token);\r\n    }\r\n\r\n    /*************************************************\r\n     *             DATA WORKER FUNCTIONS             *\r\n     *************************************************/\r\n\r\n    /**\r\n     * @notice Publish a new root bundle along with all of the block numbers that the merkle roots are relevant for.\r\n     * This is used to aid off-chain validators in evaluating the correctness of this bundle. Caller stakes a bond that\r\n     * can be slashed if the root bundle proposal is invalid, and they will receive it back if accepted.\r\n     * @notice After proposeRootBundle is called, if the any props are wrong then this proposal can be challenged.\r\n     * Once the challenge period passes, then the roots are no longer disputable, and only executeRootBundle can be\r\n     * called; moreover, this method can't be called again until all leaves are executed.\r\n     * @param bundleEvaluationBlockNumbers should contain the latest block number for all chains, even if there are no\r\n     * relays contained on some of them. The usage of this variable should be defined in an off chain UMIP.\r\n     * @notice The caller of this function must approve this contract to spend bondAmount of bondToken.\r\n     * @param poolRebalanceLeafCount Number of leaves contained in pool rebalance root. Max is # of whitelisted chains.\r\n     * @param poolRebalanceRoot Pool rebalance root containing leaves that sends tokens from this contract to SpokePool.\r\n     * @param relayerRefundRoot Relayer refund root to publish to SpokePool where a data worker can execute leaves to\r\n     * refund relayers on their chosen refund chainId.\r\n     * @param slowRelayRoot Slow relay root to publish to Spoke Pool where a data worker can execute leaves to\r\n     * fulfill slow relays.\r\n     */\r\n    function proposeRootBundle(\r\n        uint256[] calldata bundleEvaluationBlockNumbers,\r\n        uint8 poolRebalanceLeafCount,\r\n        bytes32 poolRebalanceRoot,\r\n        bytes32 relayerRefundRoot,\r\n        bytes32 slowRelayRoot\r\n    ) public override nonReentrant noActiveRequests unpaused {\r\n        // Note: this is to prevent \"empty block\" style attacks where someone can make empty proposals that are\r\n        // technically valid but not useful. This could also potentially be enforced at the UMIP-level.\r\n        require(poolRebalanceLeafCount > 0, \"Bundle must have at least 1 leaf\");\r\n\r\n        uint32 challengePeriodEndTimestamp = uint32(getCurrentTime()) + liveness;\r\n\r\n        delete rootBundleProposal; // Only one bundle of roots can be executed at a time. Delete the previous bundle.\r\n\r\n        rootBundleProposal.challengePeriodEndTimestamp = challengePeriodEndTimestamp;\r\n        rootBundleProposal.unclaimedPoolRebalanceLeafCount = poolRebalanceLeafCount;\r\n        rootBundleProposal.poolRebalanceRoot = poolRebalanceRoot;\r\n        rootBundleProposal.relayerRefundRoot = relayerRefundRoot;\r\n        rootBundleProposal.slowRelayRoot = slowRelayRoot;\r\n        rootBundleProposal.proposer = msg.sender;\r\n\r\n        // Pull bondAmount of bondToken from the caller.\r\n        bondToken.safeTransferFrom(msg.sender, address(this), bondAmount);\r\n\r\n        emit ProposeRootBundle(\r\n            challengePeriodEndTimestamp,\r\n            poolRebalanceLeafCount,\r\n            bundleEvaluationBlockNumbers,\r\n            poolRebalanceRoot,\r\n            relayerRefundRoot,\r\n            slowRelayRoot,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Executes a pool rebalance leaf as part of the currently published root bundle. Will bridge any tokens\r\n     * from this contract to the SpokePool designated in the leaf, and will also publish relayer refund and slow\r\n     * relay roots to the SpokePool on the network specified in the leaf.\r\n     * @dev In some cases, will instruct spokePool to send funds back to L1.\r\n     * @param chainId ChainId number of the target spoke pool on which the bundle is executed.\r\n     * @param groupIndex If set to 0, then relay roots to SpokePool via cross chain bridge. Used by off-chain validator\r\n     * to organize leaves with the same chain ID and also set which leaves should result in relayed messages.\r\n     * @param bundleLpFees Array representing the total LP fee amount per token in this bundle for all bundled relays.\r\n     * @param netSendAmounts Array representing the amount of tokens to send to the SpokePool on the target chainId.\r\n     * @param runningBalances Array used to track any unsent tokens that are not included in the netSendAmounts.\r\n     * @param leafId Index of this executed leaf within the poolRebalance tree.\r\n     * @param l1Tokens Array of all the tokens associated with the bundleLpFees, nedSendAmounts and runningBalances.\r\n     * @param proof Inclusion proof for this leaf in pool rebalance root in root bundle.\r\n     */\r\n\r\n    function executeRootBundle(\r\n        uint256 chainId,\r\n        uint256 groupIndex,\r\n        uint256[] memory bundleLpFees,\r\n        int256[] memory netSendAmounts,\r\n        int256[] memory runningBalances,\r\n        uint8 leafId,\r\n        address[] memory l1Tokens,\r\n        bytes32[] calldata proof\r\n    ) public nonReentrant unpaused {\r\n        require(getCurrentTime() > rootBundleProposal.challengePeriodEndTimestamp, \"Not passed liveness\");\r\n\r\n        // Verify the leafId in the poolRebalanceLeaf has not yet been claimed.\r\n        require(!MerkleLib.isClaimed1D(rootBundleProposal.claimedBitMap, leafId), \"Already claimed\");\r\n\r\n        // Verify the props provided generate a leaf that, along with the proof, are included in the merkle root.\r\n        require(\r\n            MerkleLib.verifyPoolRebalance(\r\n                rootBundleProposal.poolRebalanceRoot,\r\n                PoolRebalanceLeaf({\r\n                    chainId: chainId,\r\n                    groupIndex: groupIndex,\r\n                    bundleLpFees: bundleLpFees,\r\n                    netSendAmounts: netSendAmounts,\r\n                    runningBalances: runningBalances,\r\n                    leafId: leafId,\r\n                    l1Tokens: l1Tokens\r\n                }),\r\n                proof\r\n            ),\r\n            \"Bad Proof\"\r\n        );\r\n        // Grouping code that uses adapter and spokepool to avoid stack too deep warning.\r\n        // Get cross chain helpers for leaf's destination chain ID. This internal method will revert if either helper\r\n        // is set improperly.\r\n        (address adapter, address spokePool) = _getInitializedCrossChainContracts(chainId);\r\n\r\n        // Set the leafId in the claimed bitmap.\r\n        rootBundleProposal.claimedBitMap = MerkleLib.setClaimed1D(rootBundleProposal.claimedBitMap, leafId);\r\n\r\n        // Decrement the unclaimedPoolRebalanceLeafCount.\r\n        --rootBundleProposal.unclaimedPoolRebalanceLeafCount;\r\n\r\n        // Relay each L1 token to destination chain.\r\n        // Note: if any of the keccak256(l1Tokens, chainId) combinations are not mapped to a destination token address,\r\n        // then this internal method will revert. In this case the admin will have to associate a destination token\r\n        // with each l1 token. If the destination token mapping was missing at the time of the proposal, we assume\r\n        // that the root bundle would have been disputed because the off-chain data worker would have been unable to\r\n        // determine if the relayers used the correct destination token for a given origin token.\r\n        _sendTokensToChainAndUpdatePooledTokenTrackers(\r\n            adapter,\r\n            spokePool,\r\n            chainId,\r\n            l1Tokens,\r\n            netSendAmounts,\r\n            bundleLpFees\r\n        );\r\n\r\n        // Check bool used by data worker to prevent relaying redundant roots to SpokePool.\r\n        if (groupIndex == 0) {\r\n            // Relay root bundles to spoke pool on destination chain by\r\n            // performing delegatecall to use the adapter's code with this contract's context.\r\n\r\n            // We are ok with this low-level call since the adapter address is set by the admin and we've\r\n            // already checked that its not the zero address.\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success, ) = adapter.delegatecall(\r\n                abi.encodeWithSignature(\r\n                    \"relayMessage(address,bytes)\",\r\n                    spokePool, // target. This should be the spokePool on the L2.\r\n                    abi.encodeWithSignature(\r\n                        \"relayRootBundle(bytes32,bytes32)\",\r\n                        rootBundleProposal.relayerRefundRoot,\r\n                        rootBundleProposal.slowRelayRoot\r\n                    ) // message\r\n                )\r\n            );\r\n            require(success, \"delegatecall failed\");\r\n        }\r\n\r\n        // Transfer the bondAmount back to the proposer, if this the last executed leaf. Only sending this once all\r\n        // leaves have been executed acts to force the data worker to execute all bundles or they won't receive their bond.\r\n        if (rootBundleProposal.unclaimedPoolRebalanceLeafCount == 0)\r\n            bondToken.safeTransfer(rootBundleProposal.proposer, bondAmount);\r\n\r\n        emit RootBundleExecuted(\r\n            groupIndex,\r\n            leafId,\r\n            chainId,\r\n            l1Tokens,\r\n            bundleLpFees,\r\n            netSendAmounts,\r\n            runningBalances,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Caller stakes a bond to dispute the current root bundle proposal assuming it has not passed liveness\r\n     * yet. The proposal is deleted, allowing a follow-up proposal to be submitted, and the dispute is sent to the\r\n     * optimistic oracle to be adjudicated. Can only be called within the liveness period of the current proposal.\r\n     * @notice The caller of this function must approve this contract to spend bondAmount of l1Token.\r\n     */\r\n    function disputeRootBundle() public nonReentrant zeroOptimisticOracleApproval {\r\n        uint32 currentTime = uint32(getCurrentTime());\r\n        require(currentTime <= rootBundleProposal.challengePeriodEndTimestamp, \"Request passed liveness\");\r\n\r\n        // Request price from OO and dispute it.\r\n        uint256 finalFee = _getBondTokenFinalFee();\r\n\r\n        // This method will request a price from the OO and dispute it. Note that we set the ancillary data to\r\n        // the empty string (\"\"). The root bundle that is being disputed was the most recently proposed one with a\r\n        // block number less than or equal to the dispute block time. All of this root bundle data can be found in\r\n        // the ProposeRootBundle event params. Moreover, the optimistic oracle will stamp the requester's address\r\n        // (i.e. this contract address) meaning that ancillary data for a dispute originating from another HubPool\r\n        // will always be distinct from a dispute originating from this HubPool. Moreover, since\r\n        // bundleEvaluationNumbers for a root bundle proposal are not stored in this contract, DVM voters will always\r\n        // have to look up the ProposeRootBundle event to evaluate a dispute, therefore there is no point emitting extra\r\n        // data in this ancillary data that is already included in the ProposeRootBundle event.\r\n\r\n        // If the finalFee is larger than the bond amount, the bond amount needs to be reset before a request can go\r\n        // through. Cancel to avoid a revert. Similarly, if the final fee == bond amount, then the proposer bond\r\n        // set in the optimistic oracle would be 0. The optimistic oracle would then default the bond to be equal\r\n        // to the final fee, which would mean that the allowance set to the bondAmount would be insufficient and the\r\n        // requestAndProposePriceFor() call would revert. Source: https://github.com/UMAprotocol/protocol/blob/5b37ea818a28479c01e458389a83c3e736306b17/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L321\r\n        if (finalFee >= bondAmount) {\r\n            _cancelBundle();\r\n            return;\r\n        }\r\n\r\n        SkinnyOptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\r\n\r\n        // Only approve exact tokens to avoid more tokens than expected being pulled into the OptimisticOracle.\r\n        bondToken.safeIncreaseAllowance(address(optimisticOracle), bondAmount);\r\n        try\r\n            optimisticOracle.requestAndProposePriceFor(\r\n                identifier,\r\n                currentTime,\r\n                \"\",\r\n                bondToken,\r\n                // Set reward to 0, since we'll settle proposer reward payouts directly from this contract after a root\r\n                // proposal has passed the challenge period.\r\n                0,\r\n                // Set the Optimistic oracle proposer bond for the request. We can assume that bondAmount > finalFee.\r\n                bondAmount - finalFee,\r\n                // Set the Optimistic oracle liveness for the price request.\r\n                liveness,\r\n                rootBundleProposal.proposer,\r\n                // Canonical value representing \"True\"; i.e. the proposed relay is valid.\r\n                int256(1e18)\r\n            )\r\n        returns (uint256) {\r\n            // Ensure that approval == 0 after the call so the increaseAllowance call below doesn't allow more tokens\r\n            // to transfer than intended.\r\n            bondToken.safeApprove(address(optimisticOracle), 0);\r\n        } catch {\r\n            // Cancel the bundle since the proposal failed.\r\n            _cancelBundle();\r\n            return;\r\n        }\r\n\r\n        // Dispute the request that we just sent.\r\n        SkinnyOptimisticOracleInterface.Request memory ooPriceRequest = SkinnyOptimisticOracleInterface.Request({\r\n            proposer: rootBundleProposal.proposer,\r\n            disputer: address(0),\r\n            currency: bondToken,\r\n            settled: false,\r\n            proposedPrice: int256(1e18),\r\n            resolvedPrice: 0,\r\n            expirationTime: currentTime + liveness,\r\n            reward: 0,\r\n            finalFee: finalFee,\r\n            bond: bondAmount - finalFee,\r\n            customLiveness: liveness\r\n        });\r\n\r\n        // Finally, delete the state pertaining to the active proposal so that another proposer can submit a new bundle.\r\n        delete rootBundleProposal;\r\n\r\n        bondToken.safeTransferFrom(msg.sender, address(this), bondAmount);\r\n        bondToken.safeIncreaseAllowance(address(optimisticOracle), bondAmount);\r\n        optimisticOracle.disputePriceFor(identifier, currentTime, \"\", ooPriceRequest, msg.sender, address(this));\r\n\r\n        emit RootBundleDisputed(msg.sender, currentTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Send unclaimed accumulated protocol fees to fee capture address.\r\n     * @param l1Token Token whose protocol fees the caller wants to disburse.\r\n     */\r\n    function claimProtocolFeesCaptured(address l1Token) public override nonReentrant {\r\n        uint256 _unclaimedAccumulatedProtocolFees = unclaimedAccumulatedProtocolFees[l1Token];\r\n        unclaimedAccumulatedProtocolFees[l1Token] = 0;\r\n        IERC20(l1Token).safeTransfer(protocolFeeCaptureAddress, _unclaimedAccumulatedProtocolFees);\r\n        emit ProtocolFeesCapturedClaimed(l1Token, _unclaimedAccumulatedProtocolFees);\r\n    }\r\n\r\n    /**\r\n     * @notice Conveniently queries which destination token is mapped to the hash of an l1 token + destination chain ID.\r\n     * @dev Admin must be considerate to the compatibility of originToken and destinationToken within the protocol. Some\r\n     * token implementations will not function correctly within the Across v2 system. For example ERC20s that charge\r\n     * fees will break internal accounting, ERC777 can cause some functions to revert and upgradable tokens can pose\r\n     * risks if the implementation is shifted between whitelisting and usage.\r\n     * @dev If the pool rebalance route is not whitelisted then this will return address(0).\r\n     * @param destinationChainId Where destination token is deployed.\r\n     * @param l1Token Ethereum version token.\r\n     * @return destinationToken address The destination token that is sent to spoke pools after this contract bridges\r\n     * the l1Token to the destination chain.\r\n     */\r\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\r\n        external\r\n        view\r\n        override\r\n        returns (address destinationToken)\r\n    {\r\n        return poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, destinationChainId)];\r\n    }\r\n\r\n    /**\r\n     * @notice This function allows a caller to load the contract with raw ETH to perform L2 calls. This is needed for\r\n     * Arbitrum calls, but may also be needed for others.\r\n     * @dev This function cannot be included in a multicall transaction call because it is payable. A realistic\r\n     * situation where this might be an issue is if the caller is executing a PoolRebalanceLeaf that needs to relay\r\n     * messages to Arbitrum. Relaying messages to Arbitrum requires that this contract has an ETH balance, so in this\r\n     * case the caller would need to pre-load this contract with ETH before multicall-executing the leaf.\r\n     */\r\n    function loadEthForL2Calls() public payable override {\r\n        /* solhint-disable-line no-empty-blocks */\r\n    }\r\n\r\n    /*************************************************\r\n     *              INTERNAL FUNCTIONS               *\r\n     *************************************************/\r\n\r\n    // Called when a dispute fails due to parameter changes. This effectively resets the state and cancels the request\r\n    // with no loss of funds, thereby enabling a new bundle to be added.\r\n    function _cancelBundle() internal {\r\n        bondToken.transfer(rootBundleProposal.proposer, bondAmount);\r\n        delete rootBundleProposal;\r\n        emit RootBundleCanceled(msg.sender, getCurrentTime());\r\n    }\r\n\r\n    function _getOptimisticOracle() internal view returns (SkinnyOptimisticOracleInterface) {\r\n        return\r\n            SkinnyOptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle));\r\n    }\r\n\r\n    function _getBondTokenFinalFee() internal view returns (uint256) {\r\n        return\r\n            StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store))\r\n                .computeFinalFee(address(bondToken))\r\n                .rawValue;\r\n    }\r\n\r\n    // Note this method does a lot and wraps together the sending of tokens and updating the pooled token trackers. This\r\n    // is done as a gas saving so we don't need to iterate over the l1Tokens multiple times.\r\n    function _sendTokensToChainAndUpdatePooledTokenTrackers(\r\n        address adapter,\r\n        address spokePool,\r\n        uint256 chainId,\r\n        address[] memory l1Tokens,\r\n        int256[] memory netSendAmounts,\r\n        uint256[] memory bundleLpFees\r\n    ) internal {\r\n        uint256 length = l1Tokens.length;\r\n        for (uint256 i = 0; i < length; ) {\r\n            address l1Token = l1Tokens[i];\r\n            // Validate the L1 -> L2 token route is stored. If it is not then the output of the bridging action\r\n            // could send tokens to the 0x0 address on the L2.\r\n            address l2Token = poolRebalanceRoutes[_poolRebalanceRouteKey(l1Token, chainId)];\r\n            require(l2Token != address(0), \"Route not whitelisted\");\r\n\r\n            // If the net send amount for this token is positive then: 1) send tokens from L1->L2 to facilitate the L2\r\n            // relayer refund, 2) Update the liquidity trackers for the associated pooled tokens.\r\n            if (netSendAmounts[i] > 0) {\r\n                // Perform delegatecall to use the adapter's code with this contract's context. Opt for delegatecall's\r\n                // complexity in exchange for lower gas costs.\r\n\r\n                // We are ok with this low-level call since the adapter address is set by the admin and we've\r\n                // already checked that its not the zero address.\r\n                // solhint-disable-next-line avoid-low-level-calls\r\n                (bool success, ) = adapter.delegatecall(\r\n                    abi.encodeWithSignature(\r\n                        \"relayTokens(address,address,uint256,address)\",\r\n                        l1Token, // l1Token.\r\n                        l2Token, // l2Token.\r\n                        uint256(netSendAmounts[i]), // amount.\r\n                        spokePool // to. This should be the spokePool.\r\n                    )\r\n                );\r\n                require(success, \"delegatecall failed\");\r\n\r\n                // Liquid reserves is decreased by the amount sent. utilizedReserves is increased by the amount sent.\r\n                pooledTokens[l1Token].utilizedReserves += netSendAmounts[i];\r\n                pooledTokens[l1Token].liquidReserves -= uint256(netSendAmounts[i]);\r\n            }\r\n\r\n            // Allocate LP fees and protocol fees from the bundle to the associated pooled token trackers.\r\n            _allocateLpAndProtocolFees(l1Token, bundleLpFees[i]);\r\n\r\n            // L1 tokens length won't be > types(uint256).length, so use unchecked block to save gas. Based on the\r\n            // stress test results in /test/gas-analytics/HubPool.RootExecution.ts, the UMIP should limit the L1 token\r\n            // count in valid proposals to be ~100 so any PoolRebalanceLeaves with > 100 l1Tokens should not make it\r\n            // to this stage.\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _exchangeRateCurrent(address l1Token) internal returns (uint256) {\r\n        PooledToken storage pooledToken = pooledTokens[l1Token]; // Note this is storage so the state can be modified.\r\n        uint256 lpTokenTotalSupply = IERC20(pooledToken.lpToken).totalSupply();\r\n        if (lpTokenTotalSupply == 0) return 1e18; // initial rate is 1:1 between LP tokens and collateral.\r\n\r\n        // First, update fee counters and local accounting of finalized transfers from L2 -> L1.\r\n        _updateAccumulatedLpFees(pooledToken); // Accumulate all allocated fees from the last time this method was called.\r\n        _sync(l1Token); // Fetch any balance changes due to token bridging finalization and factor them in.\r\n\r\n        // ExchangeRate := (liquidReserves + utilizedReserves - undistributedLpFees) / lpTokenSupply\r\n        // Both utilizedReserves and undistributedLpFees contain assigned LP fees. UndistributedLpFees is gradually\r\n        // decreased over the smear duration using _updateAccumulatedLpFees. This means that the exchange rate will\r\n        // gradually increase over time as undistributedLpFees goes to zero.\r\n        // utilizedReserves can be negative. If this is the case, then liquidReserves is offset by an equal\r\n        // and opposite size. LiquidReserves + utilizedReserves will always be larger than undistributedLpFees so this\r\n        // int will always be positive so there is no risk in underflow in type casting in the return line.\r\n        int256 numerator = int256(pooledToken.liquidReserves) +\r\n            pooledToken.utilizedReserves -\r\n            int256(pooledToken.undistributedLpFees);\r\n        return (uint256(numerator) * 1e18) / lpTokenTotalSupply;\r\n    }\r\n\r\n    // Update internal fee counters by adding in any accumulated fees from the last time this logic was called.\r\n    function _updateAccumulatedLpFees(PooledToken storage pooledToken) internal {\r\n        uint256 accumulatedFees = _getAccumulatedFees(pooledToken.undistributedLpFees, pooledToken.lastLpFeeUpdate);\r\n        pooledToken.undistributedLpFees -= accumulatedFees;\r\n        pooledToken.lastLpFeeUpdate = uint32(getCurrentTime());\r\n    }\r\n\r\n    // Calculate the unallocated accumulatedFees from the last time the contract was called.\r\n    function _getAccumulatedFees(uint256 undistributedLpFees, uint256 lastLpFeeUpdate) internal view returns (uint256) {\r\n        // accumulatedFees := min(undistributedLpFees * lpFeeRatePerSecond * timeFromLastInteraction, undistributedLpFees)\r\n        // The min acts to pay out all fees in the case the equation returns more than the remaining fees.\r\n        uint256 timeFromLastInteraction = getCurrentTime() - lastLpFeeUpdate;\r\n        uint256 maxUndistributedLpFees = (undistributedLpFees * lpFeeRatePerSecond * timeFromLastInteraction) / (1e18);\r\n        return maxUndistributedLpFees < undistributedLpFees ? maxUndistributedLpFees : undistributedLpFees;\r\n    }\r\n\r\n    function _sync(address l1Token) internal {\r\n        // Check if the l1Token balance of the contract is greater than the liquidReserves. If it is then the bridging\r\n        // action from L2 -> L1 has concluded and the local accounting can be updated.\r\n        // Note: this calculation must take into account the bond when it's acting on the bond token and there's an\r\n        // active request.\r\n        uint256 balance = IERC20(l1Token).balanceOf(address(this));\r\n        uint256 balanceSansBond = l1Token == address(bondToken) && _activeRequest() ? balance - bondAmount : balance;\r\n        if (balanceSansBond > pooledTokens[l1Token].liquidReserves) {\r\n            // Note the numerical operation below can send utilizedReserves to negative. This can occur when tokens are\r\n            // dropped onto the contract, exceeding the liquidReserves.\r\n            pooledTokens[l1Token].utilizedReserves -= int256(balanceSansBond - pooledTokens[l1Token].liquidReserves);\r\n            pooledTokens[l1Token].liquidReserves = balanceSansBond;\r\n        }\r\n    }\r\n\r\n    function _liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) internal returns (uint256) {\r\n        _sync(l1Token); // Fetch any balance changes due to token bridging finalization and factor them in.\r\n\r\n        // liquidityUtilizationRatio := (relayedAmount + max(utilizedReserves,0)) / (liquidReserves + max(utilizedReserves,0))\r\n        // UtilizedReserves has a dual meaning: if it's greater than zero then it represents funds pending in the bridge\r\n        // that will flow from L2 to L1. In this case, we can use it normally in the equation. However, if it is\r\n        // negative, then it is already counted in liquidReserves. This occurs if tokens are transferred directly to the\r\n        // contract. In this case, ignore it as it is captured in liquid reserves and has no meaning in the numerator.\r\n        PooledToken memory pooledL1Token = pooledTokens[l1Token];\r\n        uint256 flooredUtilizedReserves = pooledL1Token.utilizedReserves > 0\r\n            ? uint256(pooledL1Token.utilizedReserves) // If positive: take the uint256 cast utilizedReserves.\r\n            : 0; // Else, if negative, then the is already captured in liquidReserves and should be ignored.\r\n        uint256 numerator = relayedAmount + flooredUtilizedReserves;\r\n        uint256 denominator = pooledL1Token.liquidReserves + flooredUtilizedReserves;\r\n\r\n        // If the denominator equals zero, return 1e18 (max utilization).\r\n        if (denominator == 0) return 1e18;\r\n\r\n        // In all other cases, return the utilization ratio.\r\n        return (numerator * 1e18) / denominator;\r\n    }\r\n\r\n    function _allocateLpAndProtocolFees(address l1Token, uint256 bundleLpFees) internal {\r\n        // Calculate the fraction of bundledLpFees that are allocated to the protocol and to the LPs.\r\n        uint256 protocolFeesCaptured = (bundleLpFees * protocolFeeCapturePct) / 1e18;\r\n        uint256 lpFeesCaptured = bundleLpFees - protocolFeesCaptured;\r\n\r\n        // Assign any LP fees included into the bundle to the pooled token. These LP fees are tracked in the\r\n        // undistributedLpFees and within the utilizedReserves. undistributedLpFees is gradually decreased\r\n        // over the smear duration to give the LPs their rewards over a period of time. Adding to utilizedReserves\r\n        // acts to track these rewards after the smear duration. See _exchangeRateCurrent for more details.\r\n        if (lpFeesCaptured > 0) {\r\n            pooledTokens[l1Token].undistributedLpFees += lpFeesCaptured;\r\n            pooledTokens[l1Token].utilizedReserves += int256(lpFeesCaptured);\r\n        }\r\n\r\n        // If there are any protocol fees, allocate them to the unclaimed protocol tracker amount.\r\n        if (protocolFeesCaptured > 0) unclaimedAccumulatedProtocolFees[l1Token] += protocolFeesCaptured;\r\n    }\r\n\r\n    function _relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) internal {\r\n        (address adapter, address spokePool) = _getInitializedCrossChainContracts(chainId);\r\n\r\n        // Perform delegatecall to use the adapter's code with this contract's context.\r\n\r\n        // We are ok with this low-level call since the adapter address is set by the admin and we've\r\n        // already checked that its not the zero address.\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, ) = adapter.delegatecall(\r\n            abi.encodeWithSignature(\r\n                \"relayMessage(address,bytes)\",\r\n                spokePool, // target. This should be the spokePool on the L2.\r\n                functionData\r\n            )\r\n        );\r\n        require(success, \"delegatecall failed\");\r\n        emit SpokePoolAdminFunctionTriggered(chainId, functionData);\r\n    }\r\n\r\n    function _poolRebalanceRouteKey(address l1Token, uint256 destinationChainId) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(l1Token, destinationChainId));\r\n    }\r\n\r\n    function _getInitializedCrossChainContracts(uint256 chainId)\r\n        internal\r\n        view\r\n        returns (address adapter, address spokePool)\r\n    {\r\n        adapter = crossChainContracts[chainId].adapter;\r\n        spokePool = crossChainContracts[chainId].spokePool;\r\n        require(spokePool != address(0), \"SpokePool not initialized\");\r\n        require(adapter.isContract(), \"Adapter not initialized\");\r\n    }\r\n\r\n    function _activeRequest() internal view returns (bool) {\r\n        return rootBundleProposal.unclaimedPoolRebalanceLeafCount != 0;\r\n    }\r\n\r\n    // If functionCallStackOriginatesFromOutsideThisContract is true then this was called by the callback function\r\n    // by dropping ETH onto the contract. In this case, deposit the ETH into WETH. This would happen if ETH was sent\r\n    // over the optimism bridge, for example. If false then this was set as a result of unwinding LP tokens, with the\r\n    // intention of sending ETH to the LP. In this case, do nothing as we intend on sending the ETH to the LP.\r\n    function _depositEthToWeth() internal {\r\n        if (functionCallStackOriginatesFromOutsideThisContract()) weth.deposit{ value: msg.value }();\r\n    }\r\n\r\n    // Added to enable the HubPool to receive ETH. This will occur both when the HubPool unwraps WETH to send to LPs and\r\n    // when ETH is sent over the canonical Optimism bridge, which sends ETH.\r\n    fallback() external payable {\r\n        _depositEthToWeth();\r\n    }\r\n\r\n    receive() external payable {\r\n        _depositEthToWeth();\r\n    }\r\n}\r\n"
    },
    "contracts/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./SpokePoolInterface.sol\";\nimport \"./HubPoolInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @notice Library to help with merkle roots, proofs, and claims.\n */\nlibrary MerkleLib {\n    /**\n     * @notice Verifies that a repayment is contained within a merkle root.\n     * @param root the merkle root.\n     * @param rebalance the rebalance struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the pool rebalance proof correctly shows inclusion of the rebalance within the tree.\n     */\n    function verifyPoolRebalance(\n        bytes32 root,\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));\n    }\n\n    /**\n     * @notice Verifies that a relayer refund is contained within a merkle root.\n     * @param root the merkle root.\n     * @param refund the refund struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the relayer refund proof correctly shows inclusion of the refund within the tree.\n     */\n    function verifyRelayerRefund(\n        bytes32 root,\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(refund)));\n    }\n\n    /**\n     * @notice Verifies that a distribution is contained within a merkle root.\n     * @param root the merkle root.\n     * @param slowRelayFulfillment the relayData fulfillment struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the slow relay's proof correctly shows inclusion of the slow relay within the tree.\n     */\n    function verifySlowRelayFulfillment(\n        bytes32 root,\n        SpokePoolInterface.RelayData memory slowRelayFulfillment,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\n    }\n\n    // The following functions are primarily copied from\n    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.\n\n    /**\n     * @notice Tests whether a claim is contained within a claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to check in the bitmap.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to mark in the bitmap.\n     */\n    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    /**\n     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.\n     * @param index the index to check in the bitmap. Uint8 type enforces that index can't be > 255.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (bool) {\n        uint256 mask = (1 << index);\n        return claimedBitMap & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap. Uint8 type enforces that index\n     * can't be > 255.\n     * @param index the index to mark in the bitmap.\n     * @return uint256 representing the modified input claimedBitMap with the index set to true.\n     */\n    function setClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (uint256) {\n        return claimedBitMap | (1 << index % 256);\n    }\n}\n"
    },
    "contracts/HubPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Concise list of functions in HubPool implementation.\n */\ninterface HubPoolInterface {\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\n    struct PoolRebalanceLeaf {\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).\n        uint256 chainId;\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\n        uint256[] bundleLpFees;\n        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative\n        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This\n        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does\n        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous\n        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's\n        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.\n        int256[] netSendAmounts;\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1\n        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that\n        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.\n        int256[] runningBalances;\n        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.\n        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where\n        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under\n        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with\n        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one\n        // leaf for a specific chainId should have a groupIndex equal to 0.\n        uint256 groupIndex;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint8 leafId;\n        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel\n        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero\n        // relays on this chain in this bundle in the order of whitelisting.\n        address[] l1Tokens;\n    }\n\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves\n    // that can be executed later to:\n    // - Send funds from this contract to a SpokePool or vice versa\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \"slow\" relay\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\n    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\n    struct RootBundle {\n        // Contains leaves instructing this contract to send funds to SpokePools.\n        bytes32 poolRebalanceRoot;\n        // Relayer refund merkle root to be published to a SpokePool.\n        bytes32 relayerRefundRoot;\n        // Slow relay merkle root to be published to a SpokePool.\n        bytes32 slowRelayRoot;\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\n        uint256 claimedBitMap;\n        // Proposer of this root bundle.\n        address proposer;\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\n        // of leaves are executed, a new root bundle can be proposed\n        uint8 unclaimedPoolRebalanceLeafCount;\n        // When root bundle challenge period passes and this root bundle becomes executable.\n        uint32 challengePeriodEndTimestamp;\n    }\n\n    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the\n    // cumulative LP positions and if this token is enabled for deposits.\n    struct PooledToken {\n        // LP token given to LPs of a specific L1 token.\n        address lpToken;\n        // True if accepting new LP's.\n        bool isEnabled;\n        // Timestamp of last LP fee update.\n        uint32 lastLpFeeUpdate;\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\n        // back later.\n        int256 utilizedReserves;\n        // Number of LP funds held in contract less utilized reserves.\n        uint256 liquidReserves;\n        // Number of LP funds reserved to pay out to LPs as fees.\n        uint256 undistributedLpFees;\n    }\n\n    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\n    struct CrossChainContract {\n        address adapter;\n        address spokePool;\n    }\n\n    function setPaused(bool pause) external;\n\n    function emergencyDeleteProposal() external;\n\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\n\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\n\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\n\n    function setLiveness(uint32 newLiveness) external;\n\n    function setIdentifier(bytes32 newIdentifier) external;\n\n    function setCrossChainContracts(\n        uint256 l2ChainId,\n        address adapter,\n        address spokePool\n    ) external;\n\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\n\n    function removeLiquidity(\n        address l1Token,\n        uint256 lpTokenAmount,\n        bool sendEth\n    ) external;\n\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);\n\n    function sync(address l1Token) external;\n\n    function proposeRootBundle(\n        uint256[] memory bundleEvaluationBlockNumbers,\n        uint8 poolRebalanceLeafCount,\n        bytes32 poolRebalanceRoot,\n        bytes32 relayerRefundRoot,\n        bytes32 slowRelayRoot\n    ) external;\n\n    function executeRootBundle(\n        uint256 chainId,\n        uint256 groupIndex,\n        uint256[] memory bundleLpFees,\n        int256[] memory netSendAmounts,\n        int256[] memory runningBalances,\n        uint8 leafId,\n        address[] memory l1Tokens,\n        bytes32[] memory proof\n    ) external;\n\n    function disputeRootBundle() external;\n\n    function claimProtocolFeesCaptured(address l1Token) external;\n\n    function setPoolRebalanceRoute(\n        uint256 destinationChainId,\n        address l1Token,\n        address destinationToken\n    ) external;\n\n    function setDepositRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        bool depositsEnabled\n    ) external;\n\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\n        external\n        view\n        returns (address destinationToken);\n\n    function loadEthForL2Calls() external payable;\n}\n"
    },
    "contracts/Lockable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n * @dev The reason why we use this local contract instead of importing from uma/contracts is because of the addition\n * of the internal method `functionCallStackOriginatesFromOutsideThisContract` which doesn't exist in the one exported\n * by uma/contracts.\n */\ncontract Lockable {\n    bool internal _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a nonReentrant function from another nonReentrant function is not supported. It is possible to\n     * prevent this from happening by making the nonReentrant function external, and making it call a private\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a nonReentrant() state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is currently in a non-entered state, meaning that the origination of the call\n     * came from outside the contract. This is relevant with fallback/receive methods to see if the call came from ETH\n     * being dropped onto the contract externally or due to ETH dropped on the the contract from within a method in this\n     * contract, such as unwrapping WETH to ETH within the contract.\n     */\n    function functionCallStackOriginatesFromOutsideThisContract() internal view returns (bool) {\n        return _notEntered;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every nonReentrant() method.\n    // On entry into a function, _preEntranceCheck() should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call _postEntranceSet(), perform its logic, and\n    // then call _postEntranceReset().\n    // View-only methods can simply call _preEntranceCheck() to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "contracts/interfaces/LpTokenFactoryInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface LpTokenFactoryInterface {\n    function createLpToken(address l1Token) external returns (address);\n}\n"
    },
    "contracts/interfaces/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface WETH9 {\n    function withdraw(uint256 wad) external;\n\n    function deposit() external payable;\n\n    function balanceOf(address guy) external view returns (uint256 wad);\n\n    function transfer(address guy, uint256 wad) external;\n}\n"
    },
    "@uma/core/contracts/common/implementation/Testable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Timer.sol\";\n\n/**\n * @title Base class that provides time overrides, but only if being run in test mode.\n */\nabstract contract Testable {\n    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.\n    // Note: this variable should be set on construction and never modified.\n    address public timerAddress;\n\n    /**\n     * @notice Constructs the Testable contract. Called by child contracts.\n     * @param _timerAddress Contract that stores the current time in a testing environment.\n     * Must be set to 0x0 for production environments that use live time.\n     */\n    constructor(address _timerAddress) {\n        timerAddress = _timerAddress;\n    }\n\n    /**\n     * @notice Reverts if not running in test mode.\n     */\n    modifier onlyIfTest {\n        require(timerAddress != address(0x0));\n        _;\n    }\n\n    /**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set current Testable time to.\n     */\n    function setCurrentTime(uint256 time) external onlyIfTest {\n        Timer(timerAddress).setCurrentTime(time);\n    }\n\n    /**\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n     * Otherwise, it will return the block timestamp.\n     * @return uint for the current Testable timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        if (timerAddress != address(0x0)) {\n            return Timer(timerAddress).getCurrentTime();\n        } else {\n            return block.timestamp; // solhint-disable-line not-rely-on-time\n        }\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiCaller.sol": {
      "content": "// This contract is taken from Uniswaps's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\npragma solidity ^0.8.0;\n\n/// @title MultiCaller\n/// @notice Enables calling multiple methods in a single call to the contract\ncontract MultiCaller {\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {\n        require(msg.value == 0, \"Only multicall with 0 value\");\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
    },
    "@uma/core/contracts/oracle/implementation/Constants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\n */\nlibrary OracleInterfaces {\n    bytes32 public constant Oracle = \"Oracle\";\n    bytes32 public constant IdentifierWhitelist = \"IdentifierWhitelist\";\n    bytes32 public constant Store = \"Store\";\n    bytes32 public constant FinancialContractsAdmin = \"FinancialContractsAdmin\";\n    bytes32 public constant Registry = \"Registry\";\n    bytes32 public constant CollateralWhitelist = \"CollateralWhitelist\";\n    bytes32 public constant OptimisticOracle = \"OptimisticOracle\";\n    bytes32 public constant Bridge = \"Bridge\";\n    bytes32 public constant GenericHandler = \"GenericHandler\";\n    bytes32 public constant SkinnyOptimisticOracle = \"SkinnyOptimisticOracle\";\n    bytes32 public constant ChildMessenger = \"ChildMessenger\";\n    bytes32 public constant OracleHub = \"OracleHub\";\n    bytes32 public constant OracleSpoke = \"OracleSpoke\";\n}\n\n/**\n * @title Commonly re-used values for contracts associated with the OptimisticOracle.\n */\nlibrary OptimisticOracleConstraints {\n    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible\n    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which\n    // refuses to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n}\n"
    },
    "@uma/core/contracts/common/interfaces/AddressWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface AddressWhitelistInterface {\n    function addToWhitelist(address newElement) external;\n\n    function removeFromWhitelist(address newElement) external;\n\n    function isOnWhitelist(address newElement) external view returns (bool);\n\n    function getWhitelist() external view returns (address[] memory);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/IdentifierWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\n */\ninterface IdentifierWhitelistInterface {\n    /**\n     * @notice Adds the provided identifier as a supported identifier.\n     * @dev Price requests using this identifier will succeed after this call.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     */\n    function addSupportedIdentifier(bytes32 identifier) external;\n\n    /**\n     * @notice Removes the identifier from the whitelist.\n     * @dev Price requests using this identifier will no longer succeed after this call.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     */\n    function removeSupportedIdentifier(bytes32 identifier) external;\n\n    /**\n     * @notice Checks whether an identifier is on the whitelist.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     * @return bool if the identifier is supported (or not).\n     */\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/FinderInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Provides addresses of the live contracts implementing certain interfaces.\n * @dev Examples are the Oracle or Store interfaces.\n */\ninterface FinderInterface {\n    /**\n     * @notice Updates the address of the contract that implements `interfaceName`.\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n     * @param implementationAddress address of the deployed contract that implements the interface.\n     */\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n\n    /**\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\n     * @param interfaceName queried interface.\n     * @return implementationAddress address of the deployed contract that implements the interface.\n     */\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/StoreInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\n\n/**\n * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\n */\ninterface StoreInterface {\n    /**\n     * @notice Pays Oracle fees in ETH to the store.\n     * @dev To be used by contracts whose margin currency is ETH.\n     */\n    function payOracleFees() external payable;\n\n    /**\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\n     * @param erc20Address address of the ERC20 token used to pay the fee.\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\n     */\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\n\n    /**\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\n     * @param startTime defines the beginning time from which the fee is paid.\n     * @param endTime end time until which the fee is paid.\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\n     * @return latePenalty for paying the fee after the deadline.\n     */\n    function computeRegularFee(\n        uint256 startTime,\n        uint256 endTime,\n        FixedPoint.Unsigned calldata pfc\n    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\n\n    /**\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\n     * @param currency token used to pay the final fee.\n     * @return finalFee amount due.\n     */\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/SkinnyOptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/OptimisticOracleInterface.sol\";\n\n/**\n * @title Interface for the gas-cost-reduced version of the OptimisticOracle.\n * @notice Differences from normal OptimisticOracle:\n * - refundOnDispute: flag is removed, by default there are no refunds on disputes.\n * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset\n *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be\n *   set in `requestPrice`, which has an expanded input set.\n * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price\n *   can be fetched via the `Settle` event or the return value of `settle`.\n * - general changes to interface: Functions that interact with existing requests all require the parameters of the\n *   request to modify to be passed as input. These parameters must match with the existing request parameters or the\n *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the\n *   full request struct.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract SkinnyOptimisticOracleInterface {\n    // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\n    // in that refundOnDispute is removed.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n    // to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n     * @param customLiveness custom proposal liveness to set for request.\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward,\n        uint256 bond,\n        uint256 customLiveness\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * propose a price for.\n     * @param proposer address to set as the proposer.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        address proposer,\n        int256 proposedPrice\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value where caller is the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * propose a price for.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\n     * @dev The caller is the requester, but the proposer can be customized.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n     * @param customLiveness custom proposal liveness to set for request.\n     * @param proposer address to set as the proposer.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function requestAndProposePriceFor(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward,\n        uint256 bond,\n        uint256 customLiveness,\n        address proposer,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * dispute.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        address disputer,\n        address requester\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * dispute.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * settle.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     * @return resolvedPrice the price that the request settled to.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (uint256 payout, int256 resolvedPrice);\n\n    /**\n     * @notice Computes the current state of a price request. See the State enum for more details.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters.\n     * @return the State.\n     */\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (OptimisticOracleInterface.State);\n\n    /**\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\n     * will revert.\n     * @return boolean indicating true if price exists and false if not.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) public virtual returns (bool);\n\n    /**\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param requester sender of the initial price request.\n     * @return the stamped ancillary bytes.\n     */\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        pure\n        virtual\n        returns (bytes memory);\n}\n"
    },
    "@uma/core/contracts/common/interfaces/ExpandedIERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title ERC20 interface that includes burn and mint methods.\n */\nabstract contract ExpandedIERC20 is IERC20 {\n    /**\n     * @notice Burns a specific amount of the caller's tokens.\n     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\n     */\n    function burn(uint256 value) external virtual;\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     */\n    function burnFrom(address recipient, uint256 value) external virtual returns (bool);\n\n    /**\n     * @notice Mints tokens and adds them to the balance of the `to` address.\n     * @dev This method should be permissioned to only allow designated parties to mint tokens.\n     */\n    function mint(address to, uint256 value) external virtual returns (bool);\n\n    function addMinter(address account) external virtual;\n\n    function addBurner(address account) external virtual;\n\n    function resetOwner(address account) external virtual;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice Contains common data structures and functions used by all SpokePool implementations.\r\n */\r\ninterface SpokePoolInterface {\r\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\r\n    struct RelayerRefundLeaf {\r\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that\r\n        // is negative. This is just the negative of this value.\r\n        uint256 amountToReturn;\r\n        // Used to verify that this is being executed on the correct destination chainId.\r\n        uint256 chainId;\r\n        // This array designates how much each of those addresses should be refunded.\r\n        uint256[] refundAmounts;\r\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\r\n        uint32 leafId;\r\n        // The associated L2TokenAddress that these claims apply to.\r\n        address l2TokenAddress;\r\n        // Must be same length as refundAmounts and designates each address that must be refunded.\r\n        address[] refundAddresses;\r\n    }\r\n\r\n    // This struct represents the data to fully specify a relay. If any portion of this data differs, the relay is\r\n    // considered to be completely distinct. Only one relay for a particular depositId, chainId pair should be\r\n    // considered valid and repaid. This data is hashed and inserted into the slow relay merkle root so that an off\r\n    // chain validator can choose when to refund slow relayers.\r\n    struct RelayData {\r\n        // The address that made the deposit on the origin chain.\r\n        address depositor;\r\n        // The recipient address on the destination chain.\r\n        address recipient;\r\n        // The corresponding token address on the destination chain.\r\n        address destinationToken;\r\n        // The total relay amount before fees are taken out.\r\n        uint256 amount;\r\n        // Origin chain id.\r\n        uint256 originChainId;\r\n        // Destination chain id.\r\n        uint256 destinationChainId;\r\n        // The LP Fee percentage computed by the relayer based on the deposit's quote timestamp\r\n        // and the HubPool's utilization.\r\n        uint64 realizedLpFeePct;\r\n        // The relayer fee percentage specified in the deposit.\r\n        uint64 relayerFeePct;\r\n        // The id uniquely identifying this deposit on the origin chain.\r\n        uint32 depositId;\r\n    }\r\n\r\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\r\n    // by \"data workers\" via inclusion proofs to execute leaves in the roots.\r\n    struct RootBundle {\r\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\r\n        bytes32 slowRelayRoot;\r\n        // Merkle root of relayer refunds for successful relays.\r\n        bytes32 relayerRefundRoot;\r\n        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of\r\n        // 256x(2^248) leaves per root.\r\n        mapping(uint256 => uint256) claimedBitmap;\r\n    }\r\n\r\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\r\n\r\n    function setHubPool(address newHubPool) external;\r\n\r\n    function setEnableRoute(\r\n        address originToken,\r\n        uint256 destinationChainId,\r\n        bool enable\r\n    ) external;\r\n\r\n    function setDepositQuoteTimeBuffer(uint32 buffer) external;\r\n\r\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\r\n\r\n    function emergencyDeleteRootBundle(uint256 rootBundleId) external;\r\n\r\n    function deposit(\r\n        address recipient,\r\n        address originToken,\r\n        uint256 amount,\r\n        uint256 destinationChainId,\r\n        uint64 relayerFeePct,\r\n        uint32 quoteTimestamp\r\n    ) external payable;\r\n\r\n    function speedUpDeposit(\r\n        address depositor,\r\n        uint64 newRelayerFeePct,\r\n        uint32 depositId,\r\n        bytes memory depositorSignature\r\n    ) external;\r\n\r\n    function fillRelay(\r\n        address depositor,\r\n        address recipient,\r\n        address destinationToken,\r\n        uint256 amount,\r\n        uint256 maxTokensToSend,\r\n        uint256 repaymentChainId,\r\n        uint256 originChainId,\r\n        uint64 realizedLpFeePct,\r\n        uint64 relayerFeePct,\r\n        uint32 depositId\r\n    ) external;\r\n\r\n    function fillRelayWithUpdatedFee(\r\n        address depositor,\r\n        address recipient,\r\n        address destinationToken,\r\n        uint256 amount,\r\n        uint256 maxTokensToSend,\r\n        uint256 repaymentChainId,\r\n        uint256 originChainId,\r\n        uint64 realizedLpFeePct,\r\n        uint64 relayerFeePct,\r\n        uint64 newRelayerFeePct,\r\n        uint32 depositId,\r\n        bytes memory depositorSignature\r\n    ) external;\r\n\r\n    function executeSlowRelayLeaf(\r\n        address depositor,\r\n        address recipient,\r\n        address destinationToken,\r\n        uint256 amount,\r\n        uint256 originChainId,\r\n        uint64 realizedLpFeePct,\r\n        uint64 relayerFeePct,\r\n        uint32 depositId,\r\n        uint32 rootBundleId,\r\n        bytes32[] memory proof\r\n    ) external;\r\n\r\n    function executeRelayerRefundLeaf(\r\n        uint32 rootBundleId,\r\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\r\n        bytes32[] memory proof\r\n    ) external;\r\n\r\n    function chainId() external view returns (uint256);\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/interfaces/AdapterInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\n */\n\ninterface AdapterInterface {\n    event MessageRelayed(address target, bytes message);\n\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\n\n    function relayMessage(address target, bytes calldata message) external payable;\n\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable;\n}\n"
    },
    "@uma/core/contracts/common/implementation/Timer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Universal store of current contract time for testing environments.\n */\ncontract Timer {\n    uint256 private currentTime;\n\n    constructor() {\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set `currentTime` to.\n     */\n    function setCurrentTime(uint256 time) external {\n        currentTime = time;\n    }\n\n    /**\n     * @notice Gets the currentTime variable set in the Timer.\n     * @return uint256 for the current Testable timestamp.\n     */\n    function getCurrentTime() public view returns (uint256) {\n        return currentTime;\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/OptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OptimisticOracleInterface {\n    // Struct representing the state of a price request.\n    enum State {\n        Invalid, // Never requested.\n        Requested, // Requested, no other actions taken.\n        Proposed, // Proposed, but not expired or disputed yet.\n        Expired, // Proposed, not disputed, past liveness.\n        Disputed, // Disputed, but no DVM price returned yet.\n        Resolved, // Disputed and DVM price is available.\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\n    }\n\n    // Struct representing a price request.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n    // to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Set the proposal bond associated with a price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param bond custom bond amount to set.\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n     * changed again with a subsequent call to setBond().\n     */\n    function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 bond\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n     * bond, so there is still profit to be made even if the reward is refunded.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function setRefundOnDispute(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual;\n\n    /**\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n     * being auto-resolved.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param customLiveness new custom liveness.\n     */\n    function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external virtual;\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param proposer address to set as the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address proposer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value for an existing price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        address disputer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price value for an existing price request with an active proposal.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n     * hasn't been settled.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return resolved price.\n     */\n    function settleAndGetPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (int256);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 payout);\n\n    /**\n     * @notice Gets the current data structure containing all information about a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the Request data structure.\n     */\n    function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (Request memory);\n\n    /**\n     * @notice Returns the state of a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the State enum value.\n     */\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (State);\n\n    /**\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return true if price has resolved or settled, false otherwise.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (bool);\n\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        view\n        virtual\n        returns (bytes memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
        "": ["ast"]
      }
    }
  }
}
