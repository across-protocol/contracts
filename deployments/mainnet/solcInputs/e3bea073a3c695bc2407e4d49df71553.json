{
  "language": "Solidity",
  "sources": {
    "@eth-optimism/contracts/L1/messaging/IL1ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IL1ERC20Bridge\n */\ninterface IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L2 bridge contract.\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external returns (address);\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _amount Amount of the ERC20 to deposit\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ERC20 token.\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\n     *\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Data provided by the sender on L2. This data is provided\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\n     *   length, these contracts provide no guarantees about its content.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\nimport \"./IL1ERC20Bridge.sol\";\n\n/**\n * @title IL1StandardBridge\n */\ninterface IL1StandardBridge is IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev Deposit an amount of the ETH to the caller's balance on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called\n     * before the withdrawal is finalized.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/crosschain/errorsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/errors.sol)\n\npragma solidity ^0.8.4;\n\nerror NotCrossChainCall();\nerror InvalidCrossChainSender(address actual, address expected);\n"
    },
    "@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/optimism/LibOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport {ICrossDomainMessengerUpgradeable as Optimism_Bridge} from \"../../vendor/optimism/ICrossDomainMessengerUpgradeable.sol\";\nimport \"../errorsUpgradeable.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for https://www.optimism.io/[Optimism].\n * See the https://community.optimism.io/docs/developers/bridge/messaging/#accessing-msg-sender[documentation]\n * for the functionality used here.\n */\nlibrary LibOptimismUpgradeable {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `messenger`.\n     */\n    function isCrossChain(address messenger) internal view returns (bool) {\n        return msg.sender == messenger;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `messenger`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address messenger) internal view returns (address) {\n        if (!isCrossChain(messenger)) revert NotCrossChainCall();\n\n        return Optimism_Bridge(messenger).xDomainMessageSender();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport {Initializable} from \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/vendor/optimism/ICrossDomainMessengerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (vendor/optimism/ICrossDomainMessenger.sol)\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessengerUpgradeable {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiCaller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// This contract is taken from Uniswap's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\n\n/// @title MultiCaller\n/// @notice Enables calling multiple methods in a single call to the contract\ncontract MultiCaller {\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
    },
    "contracts/AlephZero_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Arbitrum only supports v0.8.19\n// See https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/solidity-support#differences-from-solidity-on-ethereum\npragma solidity ^0.8.19;\n\nimport \"./Arbitrum_SpokePool.sol\";\n\n/**\n * @notice AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\n * @custom:security-contact bugs@across.to\n */\ncontract AlephZero_SpokePool is Arbitrum_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        Arbitrum_SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            _l2Usdc,\n            _cctpTokenMessenger\n        )\n    {} // solhint-disable-line no-empty-blocks\n}\n"
    },
    "contracts/Arbitrum_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\nimport { CrossDomainAddressUtils } from \"./libraries/CrossDomainAddressUtils.sol\";\nimport { ArbitrumL2ERC20GatewayLike } from \"./interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\n * @custom:security-contact bugs@across.to\n */\ncontract Arbitrum_SpokePool is SpokePool, CircleCCTPAdapter {\n    // Address of the Arbitrum L2 token gateway to send funds to L1.\n    address public l2GatewayRouter;\n\n    // Admin controlled mapping of arbitrum tokens to L1 counterpart. L1 counterpart addresses\n    // are necessary params used when bridging tokens to L1.\n    mapping(address => address) public whitelistedTokens;\n\n    event SetL2GatewayRouter(address indexed newL2GatewayRouter);\n    event WhitelistedTokens(address indexed l2Token, address indexed l1Token);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the AVM SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _l2GatewayRouter Address of L2 token gateway. Can be reset by admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        address _l2GatewayRouter,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setL2GatewayRouter(_l2GatewayRouter);\n    }\n\n    modifier onlyFromCrossDomainAdmin() {\n        require(msg.sender == CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin), \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /********************************************************\n     *    ARBITRUM-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change L2 gateway router. Callable only by admin.\n     * @param newL2GatewayRouter New L2 gateway router.\n     */\n    function setL2GatewayRouter(address newL2GatewayRouter) public onlyAdmin nonReentrant {\n        _setL2GatewayRouter(newL2GatewayRouter);\n    }\n\n    /**\n     * @notice Add L2 -> L1 token mapping. Callable only by admin.\n     * @param l2Token Arbitrum token.\n     * @param l1Token Ethereum version of l2Token.\n     */\n    function whitelistToken(address l2Token, address l1Token) public onlyAdmin nonReentrant {\n        _whitelistToken(l2Token, l1Token);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // If the l2TokenAddress is UDSC, we need to use the CCTP bridge.\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        } else {\n            // Check that the Ethereum counterpart of the L2 token is stored on this contract.\n            address ethereumTokenToBridge = whitelistedTokens[l2TokenAddress];\n            require(ethereumTokenToBridge != address(0), \"Uninitialized mainnet token\");\n            //slither-disable-next-line unused-return\n            ArbitrumL2ERC20GatewayLike(l2GatewayRouter).outboundTransfer(\n                ethereumTokenToBridge, // _l1Token. Address of the L1 token to bridge over.\n                withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 hub pool contract.\n                amountToReturn, // _amount.\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n    }\n\n    function _setL2GatewayRouter(address _l2GatewayRouter) internal {\n        l2GatewayRouter = _l2GatewayRouter;\n        emit SetL2GatewayRouter(l2GatewayRouter);\n    }\n\n    function _whitelistToken(address _l2Token, address _l1Token) internal {\n        whitelistedTokens[_l2Token] = _l1Token;\n        emit WhitelistedTokens(_l2Token, _l1Token);\n    }\n\n    // Apply AVM-specific transformation to cross domain admin address on L1.\n    function _requireAdminSender() internal override onlyFromCrossDomainAdmin {}\n}\n"
    },
    "contracts/Boba_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Ovm_SpokePool.sol\";\n\n/**\n * @notice Boba Spoke pool. Note that the l2ETH and l2WETH are the opposite as that in Optimism.\n */\ncontract Boba_SpokePool is Ovm_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    )\n        Ovm_SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            IERC20(address(0)),\n            ITokenMessenger(address(0))\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the OVM Boba SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __OvmSpokePool_init(\n            _initialDepositId,\n            _crossDomainAdmin,\n            _withdrawalRecipient,\n            0x4200000000000000000000000000000000000006\n        );\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport { ArbitrumInboxLike as ArbitrumL1InboxLike, ArbitrumL1ERC20GatewayLike } from \"../interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Arbitrum.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    uint256 public constant L2_MAX_SUBMISSION_COST = 0.01e18;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public constant L2_GAS_PRICE = 5e9; // 5 gWei\n\n    // Native token expected to be sent in L2 message. Should be 0 for only use case of this constant, which\n    // includes is sending messages from L1 to L2.\n    uint256 public constant L2_CALL_VALUE = 0;\n\n    // Gas limit for L2 execution of a cross chain token transfer sent via the inbox.\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n    // Gas limit for L2 execution of a message sent via the inbox.\n    uint32 public constant RELAY_MESSAGE_L2_GAS_LIMIT = 2_000_000;\n\n    address public constant L1_DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\n    address public immutable L2_REFUND_L2_ADDRESS;\n\n    // Inbox system contract to send messages to Arbitrum. Token bridges use this to send tokens to L2.\n    // https://github.com/OffchainLabs/nitro-contracts/blob/f7894d3a6d4035ba60f51a7f1334f0f2d4f02dce/src/bridge/Inbox.sol\n    ArbitrumL1InboxLike public immutable L1_INBOX;\n\n    // Router contract to send tokens to Arbitrum. Routes to correct gateway to bridge tokens. Internally this\n    // contract calls the Inbox.\n    // Generic gateway: https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ArbitrumGateway.sol\n    ArbitrumL1ERC20GatewayLike public immutable L1_ERC20_GATEWAY_ROUTER;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        ArbitrumL1InboxLike _l1ArbitrumInbox,\n        ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter,\n        address _l2RefundL2Address,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Arbitrum) {\n        L1_INBOX = _l1ArbitrumInbox;\n        L1_ERC20_GATEWAY_ROUTER = _l1ERC20GatewayRouter;\n        L2_REFUND_L2_ADDRESS = _l2RefundL2Address;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param target Contract on Arbitrum that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance(RELAY_MESSAGE_L2_GAS_LIMIT);\n\n        L1_INBOX.createRetryableTicket{ value: requiredL1CallValue }(\n            target, // destAddr destination L2 contract address\n            L2_CALL_VALUE, // l2CallValue call value for retryable L2 message\n            L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n            message // data ABI encoded data of L2 message\n        );\n\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        }\n        // If not, we can use the Arbitrum gateway\n        else {\n            uint256 requiredL1CallValue = _contractHasSufficientEthBalance(RELAY_TOKENS_L2_GAS_LIMIT);\n\n            // Approve the gateway, not the router, to spend the hub pool's balance. The gateway, which is different\n            // per L1 token, will temporarily escrow the tokens to be bridged and pull them from this contract.\n            address erc20Gateway = L1_ERC20_GATEWAY_ROUTER.getGateway(l1Token);\n            IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n\n            // `outboundTransfer` expects that the caller includes a bytes message as the last param that includes the\n            // maxSubmissionCost to use when creating an L2 retryable ticket: https://github.com/OffchainLabs/arbitrum/blob/e98d14873dd77513b569771f47b5e05b72402c5e/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L232\n            bytes memory data = abi.encode(L2_MAX_SUBMISSION_COST, \"\");\n\n            // Note: Legacy routers don't have the outboundTransferCustomRefund method, so default to using\n            // outboundTransfer(). Legacy routers are used for the following tokens that are currently enabled:\n            // - DAI: the implementation of `outboundTransfer` at the current DAI custom gateway\n            //        (https://etherscan.io/address/0xD3B5b60020504bc3489D6949d545893982BA3011#writeContract) sets the\n            //        sender as the refund address so the aliased HubPool should receive excess funds. Implementation here:\n            //        https://github.com/makerdao/arbitrum-dai-bridge/blob/11a80385e2622968069c34d401b3d54a59060e87/contracts/l1/L1DaiGateway.sol#L109\n            if (l1Token == L1_DAI) {\n                // This means that the excess ETH to pay for the L2 transaction will be sent to the aliased\n                // contract address on L2, which we'd have to retrieve via a custom adapter, the Arbitrum_RescueAdapter.\n                // To do so, in a single transaction: 1) setCrossChainContracts to Arbitrum_RescueAdapter, 2) relayMessage\n                // with function data = abi.encode(amountToRescue), 3) setCrossChainContracts back to this adapter.\n                L1_ERC20_GATEWAY_ROUTER.outboundTransfer{ value: requiredL1CallValue }(\n                    l1Token,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            } else {\n                L1_ERC20_GATEWAY_ROUTER.outboundTransferCustomRefund{ value: requiredL1CallValue }(\n                    l1Token,\n                    L2_REFUND_L2_ADDRESS,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            }\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue(uint32 l2GasLimit) public pure returns (uint256) {\n        return L2_MAX_SUBMISSION_COST + L2_GAS_PRICE * l2GasLimit;\n    }\n\n    function _contractHasSufficientEthBalance(uint32 l2GasLimit) internal view returns (uint256) {\n        uint256 requiredL1CallValue = getL1CallValue(l2GasLimit);\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n        return requiredL1CallValue;\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_CustomGasToken_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ITokenMessenger as ICCTPTokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\nimport { CircleCCTPAdapter, CircleDomainIds } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ArbitrumERC20Bridge as ArbitrumL1ERC20Bridge, ArbitrumCustomGasTokenInbox as ArbitrumL1InboxLike, ArbitrumL1ERC20GatewayLike } from \"../interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice Interface for funder contract that this contract pulls from to pay for relayMessage()/relayTokens()\n * fees using a custom gas token.\n */\ninterface FunderInterface {\n    /**\n     * @notice Withdraws amount of token from funder contract to the caller.\n     * @dev Can only be called by owner of Funder contract, which therefore must be\n     * this contract.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     */\n    function withdraw(IERC20 token, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Arbitrum.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @dev This contract is very similar to Arbitrum_Adapter but it allows the caller to pay for submission\n * fees using a custom gas token. This is required to support certain Arbitrum orbit L2s and L3s.\n * @dev https://docs.arbitrum.io/launch-orbit-chain/how-tos/use-a-custom-gas-token\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_CustomGasToken_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // Amount of gas token allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    // The Arbitrum Inbox requires that this uses 18 decimal precision.\n    uint256 public immutable L2_MAX_SUBMISSION_COST;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    // The Arbitrum Inbox requires that this is specified in gWei (e.g. 1e9 = 1 gWei)\n    uint256 public immutable L2_GAS_PRICE;\n\n    // Native token expected to be sent in L2 message. Should be 0 for most use cases of this constant. This\n    // constant is unused when sending the native gas token over the inbox since the inbox interprets `l2CallValue`\n    // as the amount of the L2 native token to send.\n    uint256 public constant L2_CALL_VALUE = 0;\n\n    // Gas limit for L2 execution of a cross chain token transfer sent via the inbox.\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n    // Gas limit for L2 execution of a message sent via the inbox.\n    uint32 public constant RELAY_MESSAGE_L2_GAS_LIMIT = 2_000_000;\n\n    // The number of decimals of precision for the custom gas token. This is defined in the constructor and not dynamically fetched since decimals are\n    // not part of the standard ERC20 interface.\n    uint8 public immutable NATIVE_TOKEN_DECIMALS;\n\n    // This address on L2 receives extra gas token that is left over after relaying a message via the inbox.\n    address public immutable L2_REFUND_L2_ADDRESS;\n\n    // Inbox system contract to send messages to Arbitrum. Token bridges use this to send tokens to L2.\n    // https://github.com/OffchainLabs/nitro-contracts/blob/f7894d3a6d4035ba60f51a7f1334f0f2d4f02dce/src/bridge/Inbox.sol\n    ArbitrumL1InboxLike public immutable L1_INBOX;\n\n    // Router contract to send tokens to Arbitrum. Routes to correct gateway to bridge tokens. Internally this\n    // contract calls the Inbox.\n    // Generic gateway: https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ArbitrumGateway.sol\n    // Gateway used for communicating with chains that use custom gas tokens:\n    // https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ERC20Gateway.sol\n    ArbitrumL1ERC20GatewayLike public immutable L1_ERC20_GATEWAY_ROUTER;\n\n    // This token is used to pay for l1 to l2 messages if its configured by an Arbitrum orbit chain.\n    IERC20 public immutable CUSTOM_GAS_TOKEN;\n\n    // Contract that funds Inbox cross chain messages with the custom gas token.\n    FunderInterface public immutable CUSTOM_GAS_TOKEN_FUNDER;\n\n    error InvalidCustomGasToken();\n    error InsufficientCustomGasToken();\n    error InvalidNativeTokenDecimals();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     * @param _cctpDomainId Circle CCTP domain identifier for the destination chain.\n     * @param _nativeTokenDecimals Number of decimals corresponding to the L2's gas/fee token.\n     * @param _customGasTokenFunder Contract that funds the custom gas token.\n     * @param _l2MaxSubmissionCost Amount of gas token allocated to pay for the base submission fee. The base\n     * submission fee is a parameter unique to Arbitrum retryable transactions. This value is hardcoded\n     * and used for all messages sent by this adapter.\n     * @param _l2GasPrice Gas price bid for L2 execution. Should be set conservatively high to avoid stuck messages.\n     */\n    constructor(\n        ArbitrumL1InboxLike _l1ArbitrumInbox,\n        ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter,\n        address _l2RefundL2Address,\n        IERC20 _l1Usdc,\n        ICCTPTokenMessenger _cctpTokenMessenger,\n        uint32 _cctpDomainId,\n        uint8 _nativeTokenDecimals,\n        FunderInterface _customGasTokenFunder,\n        uint256 _l2MaxSubmissionCost,\n        uint256 _l2GasPrice\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, _cctpDomainId) {\n        L1_INBOX = _l1ArbitrumInbox;\n        L1_ERC20_GATEWAY_ROUTER = _l1ERC20GatewayRouter;\n        L2_REFUND_L2_ADDRESS = _l2RefundL2Address;\n        CUSTOM_GAS_TOKEN = IERC20(L1_INBOX.bridge().nativeToken());\n        if (address(CUSTOM_GAS_TOKEN) == address(0)) revert InvalidCustomGasToken();\n        L2_MAX_SUBMISSION_COST = _l2MaxSubmissionCost;\n        L2_GAS_PRICE = _l2GasPrice;\n        CUSTOM_GAS_TOKEN_FUNDER = _customGasTokenFunder;\n        if (_nativeTokenDecimals == 0) revert InvalidNativeTokenDecimals();\n        NATIVE_TOKEN_DECIMALS = _nativeTokenDecimals;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of the custom gas token\n     * to send a message via the Inbox successfully, or the message will get stuck.\n     * @param target Contract on Arbitrum that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 requiredL1TokenTotalFeeAmount = _pullCustomGas(RELAY_MESSAGE_L2_GAS_LIMIT);\n        CUSTOM_GAS_TOKEN.safeIncreaseAllowance(address(L1_INBOX), requiredL1TokenTotalFeeAmount);\n        L1_INBOX.createRetryableTicket(\n            target, // destAddr destination L2 contract address\n            L2_CALL_VALUE, // l2CallValue call value for retryable L2 message\n            L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n            requiredL1TokenTotalFeeAmount, // tokenTotalFeeAmount amount of fees to be deposited in native token.\n            // This should be in the precision of the custom gas token.\n            message // data ABI encoded data of L2 message\n        );\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH or custom gas token\n     * to send a message via the Inbox successfully, or the message will get stuck.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        }\n        // If not, we can use the Arbitrum gateway\n        else {\n            address erc20Gateway = L1_ERC20_GATEWAY_ROUTER.getGateway(l1Token);\n\n            // If custom gas token, call special functions that handle paying with custom gas tokens.\n            uint256 requiredL1TokenTotalFeeAmount = _pullCustomGas(RELAY_MESSAGE_L2_GAS_LIMIT);\n\n            // Must use Inbox to bridge custom gas token.\n            // Source: https://github.com/OffchainLabs/token-bridge-contracts/blob/5bdf33259d2d9ae52ddc69bc5a9cbc558c4c40c7/contracts/tokenbridge/ethereum/gateway/L1OrbitERC20Gateway.sol#L33\n            if (l1Token == address(CUSTOM_GAS_TOKEN)) {\n                // amount and requiredL1TokenTotalFeeAmount are in the precision of the custom gas token.\n                uint256 amountToBridge = amount + requiredL1TokenTotalFeeAmount;\n                CUSTOM_GAS_TOKEN.safeIncreaseAllowance(address(L1_INBOX), amountToBridge);\n                // Both `l2CallValue` and `tokenTotalFeeAmount` are rounded in the conversion to/from native/18 decimals. `l2CallValue` is rounded down by the call to _fromNativeTo18Decimals()\n                // in cases where the token's decimals exceeds 18, since we would rather round down and be forced to donate a small amount of the l2 token to the spoke pool to cover the roundoff\n                // error than overshoot a transfer amount. `amountToBridge` is rounded up since we would rather overpay for gas and be refunded on l2 than underpay and risk stuck cross-chain messages.\n                L1_INBOX.createRetryableTicket(\n                    to, // destAddr destination L2 contract address\n                    _fromNativeTo18Decimals(amount), // l2CallValue call value for retryable L2 message\n                    L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n                    L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n                    L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n                    RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n                    L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n                    amountToBridge, // tokenTotalFeeAmount amount of fees to be deposited in native token.\n                    \"0x\" // data ABI encoded data of L2 message\n                );\n            } else {\n                IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n                CUSTOM_GAS_TOKEN.safeIncreaseAllowance(erc20Gateway, requiredL1TokenTotalFeeAmount);\n\n                // To pay for gateway outbound transfer with custom gas token, encode the tokenTotalFeeAmount in the data field:\n                // The data format should be (uint256 maxSubmissionCost, bytes extraData, uint256 tokenTotalFeeAmount).\n                // Source: https://github.com/OffchainLabs/token-bridge-contracts/blob/5bdf33259d2d9ae52ddc69bc5a9cbc558c4c40c7/contracts/tokenbridge/ethereum/gateway/L1OrbitERC20Gateway.sol#L57\n                bytes memory data = abi.encode(L2_MAX_SUBMISSION_COST, \"\", requiredL1TokenTotalFeeAmount);\n                L1_ERC20_GATEWAY_ROUTER.outboundTransferCustomRefund(\n                    l1Token,\n                    L2_REFUND_L2_ADDRESS,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            }\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Returns required amount of gas token to send a message via the Inbox.\n     * @dev Should return a value in the same precision as the gas token's precision.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of gas token that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue(uint32 l2GasLimit) public view returns (uint256) {\n        return _from18ToNativeDecimals(L2_MAX_SUBMISSION_COST + L2_GAS_PRICE * l2GasLimit);\n    }\n\n    function _pullCustomGas(uint32 l2GasLimit) internal returns (uint256) {\n        uint256 requiredL1CallValue = getL1CallValue(l2GasLimit);\n        CUSTOM_GAS_TOKEN_FUNDER.withdraw(CUSTOM_GAS_TOKEN, requiredL1CallValue);\n        if (CUSTOM_GAS_TOKEN.balanceOf(address(this)) < requiredL1CallValue) revert InsufficientCustomGasToken();\n        return requiredL1CallValue;\n    }\n\n    function _from18ToNativeDecimals(uint256 amount) internal view returns (uint256) {\n        if (NATIVE_TOKEN_DECIMALS == 18) {\n            return amount;\n        } else if (NATIVE_TOKEN_DECIMALS < 18) {\n            // Round up the division result so that the L1 call value is always sufficient to cover the submission fee.\n            uint256 reductionFactor = 10**(18 - NATIVE_TOKEN_DECIMALS);\n            uint256 divFloor = amount / reductionFactor;\n            uint256 mod = amount % reductionFactor;\n            if (mod != 0) {\n                return divFloor + 1;\n            } else {\n                return divFloor;\n            }\n        } else {\n            return amount * 10**(NATIVE_TOKEN_DECIMALS - 18);\n        }\n    }\n\n    function _fromNativeTo18Decimals(uint256 amount) internal view returns (uint256) {\n        if (NATIVE_TOKEN_DECIMALS == 18) {\n            return amount;\n        } else if (NATIVE_TOKEN_DECIMALS < 18) {\n            return amount * 10**(18 - NATIVE_TOKEN_DECIMALS);\n        } else {\n            return amount / 10**(NATIVE_TOKEN_DECIMALS - 18);\n        }\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_RescueAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"./Arbitrum_Adapter.sol\"; // Used to import `ArbitrumL1ERC20GatewayLike` and `ArbitrumL1InboxLike`\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Meant to copy the Arbitrum_Adapter exactly in how it sends L1 --> L2 messages but is designed only to be\n * used by the owner of the HubPool to retrieve ETH held by its aliased address on L2. This ETH builds up because\n * `relayTokens` calls `l1ERC20GatewayRouter.outboundTransfer` which does not allow the caller to specify an L2 refund\n * address the same way that `l1Inbox.createRetryableTicket` does. This means that the alias address of the caller, the\n * HubPool in this case, receives ETH on L2. This Adapter can be used to send messages to Arbitrum specifically to send\n * transactions as if called by the aliased HubPool address.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_RescueAdapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    uint256 public immutable l2MaxSubmissionCost = 0.01e18;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public immutable l2GasPrice = 5e9; // 5 gWei\n\n    // Gas limit for immediate L2 execution attempt (can be estimated via NodeInterface.estimateRetryableTicket).\n    // NodeInterface precompile interface exists at L2 address 0x00000000000000000000000000000000000000C8\n    uint32 public immutable l2GasLimit = 2_000_000;\n\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\n    address public immutable l2RefundL2Address;\n\n    // L1 HubPool address aliased on L2: https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md#address-aliasing\n    address public immutable aliasedL2HubPoolAddress = 0xd297fA914353c44B2e33EBE05F21846f1048CFeB;\n\n    ArbitrumL1InboxLike public immutable l1Inbox;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     */\n    constructor(ArbitrumL1InboxLike _l1ArbitrumInbox) {\n        l1Inbox = _l1ArbitrumInbox;\n\n        l2RefundL2Address = msg.sender;\n    }\n\n    /**\n     * @notice Send cross-chain message to aliased hub pool address on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param message Data to send to aliased hub pool.\n     */\n    function relayMessage(address, bytes memory message) external payable override {\n        uint256 valueToReturn = abi.decode(message, (uint256));\n\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance();\n\n        // In the rescue ETH setup, we send the transaction to the refund address, we provide a call value equal to the\n        // amount we want to rescue, and we specify an empty calldata, since it's a simple ETH transfer.\n        // Note: we use the unsafe version of createRetryableTicket because it doesn't require the msg.sender to pass\n        // in arbTxCallValue in addition to maxSubmissionCost + maxGas * gasPriceBid.\n        l1Inbox.unsafeCreateRetryableTicket{ value: requiredL1CallValue }(\n            l2RefundL2Address, // destAddr destination L2 contract address\n            valueToReturn, // l2CallValue call value for retryable L2 message\n            l2MaxSubmissionCost, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            l2RefundL2Address, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            l2RefundL2Address, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            l2GasLimit, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            l2GasPrice, // gasPriceBid price bid for L2 execution\n            \"\" // data ABI encoded data of L2 message\n        );\n\n        emit MessageRelayed(aliasedL2HubPoolAddress, \"\");\n    }\n\n    /**\n     * @notice Should never be called.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        revert(\"useless function\");\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue() public pure returns (uint256) {\n        return l2MaxSubmissionCost + l2GasPrice * l2GasLimit;\n    }\n\n    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_SendTokensAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport { ArbitrumL1ERC20GatewayLike } from \"./Arbitrum_Adapter.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice This adapter is built for emergencies to send funds from the Hub to a Spoke in the event that a spoke pool\n * received a duplicate root bundle relay, due to some replay issue.\n */\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_SendTokensAdapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    uint256 public immutable l2MaxSubmissionCost = 0.01e18;\n    uint256 public immutable l2GasPrice = 5e9;\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n\n    ArbitrumL1ERC20GatewayLike public immutable l1ERC20GatewayRouter;\n    address public immutable l2RefundL2Address;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     */\n    constructor(ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter, address _l2RefundL2Address) {\n        l1ERC20GatewayRouter = _l1ERC20GatewayRouter;\n        l2RefundL2Address = _l2RefundL2Address;\n    }\n\n    /**\n     * @notice Send tokens to SpokePool. Enables HubPool admin to call relaySpokePoolAdminFunction that will trigger\n     * this function.\n     * @dev This performs similar logic to relayTokens in the normal Arbitrum_Adapter by sending tokens\n     * the Arbitrum_SpokePool out of the HubPool.\n     * @param message The encoded address of the ERC20 to send to the rescue address.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        (address l1Token, uint256 amount) = abi.decode(message, (address, uint256));\n\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance();\n\n        // Approve the gateway, not the router, to spend the hub pool's balance. The gateway, which is different\n        // per L1 token, will temporarily escrow the tokens to be bridged and pull them from this contract.\n        address erc20Gateway = l1ERC20GatewayRouter.getGateway(l1Token);\n        IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n\n        // `outboundTransfer` expects that the caller includes a bytes message as the last param that includes the\n        // maxSubmissionCost to use when creating an L2 retryable ticket: https://github.com/OffchainLabs/arbitrum/blob/e98d14873dd77513b569771f47b5e05b72402c5e/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L232\n        bytes memory data = abi.encode(l2MaxSubmissionCost, \"\");\n\n        l1ERC20GatewayRouter.outboundTransferCustomRefund{ value: requiredL1CallValue }(\n            l1Token,\n            l2RefundL2Address,\n            target,\n            amount,\n            RELAY_TOKENS_L2_GAS_LIMIT,\n            l2GasPrice,\n            data\n        );\n\n        // Purposefully not emitting any events so as not to confuse off-chain monitors that track this event.\n        // emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Should never be called.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        revert(\"relayTokens disabled\");\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue() public pure returns (uint256) {\n        return l2MaxSubmissionCost + l2GasPrice * RELAY_TOKENS_L2_GAS_LIMIT;\n    }\n\n    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Base_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Base. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic.\n * @custom:security-contact bugs@across.to\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Base_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Base system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CrossDomainEnabled(_crossDomainMessenger) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Base) {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Base.\n     * @param target Contract on Base that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Base.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Blast_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport { IL1StandardBridge } from \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\ninterface IL1ERC20Bridge {\n    /// @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n    ///         ERC20 token on the other chain does not recognize the local token as the correct\n    ///         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n    ///         this chain.\n    /// @param _localToken  Address of the ERC20 on this chain.\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\n    /// @param _to          Address of the receiver.\n    /// @param _amount      Amount of local tokens to deposit.\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n    ///                     not be triggered with this data, but it will be emitted and can be used\n    ///                     to identify the transaction.\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Blast. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic. It differs from the Base Adapter in that it uses a special\n * Blast contract to bridge WETH and DAI, which are yielding rebasing tokens on L2, WETH and USDB.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Blast_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public immutable L2_GAS_LIMIT; // 200,000 is a reasonable default.\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE; // 0x697402166Fbf2F22E970df8a6486Ef171dbfc524\n\n    // Bridge used to get yielding version of ERC20's on L2.\n    IL1ERC20Bridge public immutable L1_BLAST_BRIDGE; // 0x3a05E5d33d7Ab3864D53aaEc93c8301C1Fa49115 on mainnet.\n    address public immutable L1_DAI; // 0x6B175474E89094C44Da98b954EedeAC495271d0F on mainnet.\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Blast system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        IL1ERC20Bridge l1BlastBridge,\n        address l1Dai,\n        uint32 l2GasLimit\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n        CircleCCTPAdapter(_l1Usdc, ITokenMessenger(address(0)), CircleDomainIds.UNINITIALIZED)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n        L1_BLAST_BRIDGE = l1BlastBridge;\n        L1_DAI = l1Dai;\n        L2_GAS_LIMIT = l2GasLimit;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Blast.\n     * @param target Contract on Blast that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Blast.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If token can be bridged into yield-ing version of ERC20 on L2 side, then use Blast Bridge, otherwise\n        // use standard bridge.\n\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            // @dev: we can use the standard or the blast bridge to deposit ETH here:\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is DAI, then use the L1 Blast Bridge\n        else if (l1Token == L1_DAI) {\n            IERC20(l1Token).safeIncreaseAllowance(address(L1_BLAST_BRIDGE), amount);\n            L1_BLAST_BRIDGE.bridgeERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @custom:security-contact bugs@across.to\n * @dev Helper contract for contracts performing cross-domain communications between L1 and Optimism.\n * @dev This modifies the eth-optimism/CrossDomainEnabled contract only by changing state variables to be\n * immutable for use in contracts like the Optimism_Adapter which use delegateCall().\n */\ncontract CrossDomainEnabled {\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public immutable MESSENGER;\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {\n        MESSENGER = _messenger;\n    }\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\n        return ICrossDomainMessenger(MESSENGER);\n    }\n\n    /**\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  onlyFromCrossDomainAccount())\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes calldata _message\n    ) internal {\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "contracts/chain-adapters/DoctorWho_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Base. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic.\n * @custom:security-contact bugs@across.to\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract DoctorWho_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Base system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.DoctorWho)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Base.\n     * @param target Contract on Base that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Base.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/interfaces/AdapterInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\n * This interface is implemented by an adapter contract that is deployed on L1.\n */\n\ninterface AdapterInterface {\n    event MessageRelayed(address target, bytes message);\n\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\n\n    /**\n     * @notice Send message to `target` on L2.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\n     * to the target contract on L2.\n     * @param target L2 address to send message to.\n     * @param message Message to send to `target`.\n     */\n    function relayMessage(address target, bytes calldata message) external payable;\n\n    /**\n     * @notice Send `amount` of `l1Token` to `to` on L2. `l2Token` is the L2 address equivalent of `l1Token`.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\n     * to the target contract on L2.\n     * @param l1Token L1 token to bridge.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of `l1Token` to bridge.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable;\n}\n"
    },
    "contracts/chain-adapters/l2/Arbitrum_WithdrawalHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ArbitrumL2ERC20GatewayLike } from \"../../interfaces/ArbitrumBridge.sol\";\nimport { WithdrawalHelperBase } from \"./WithdrawalHelperBase.sol\";\nimport { ITokenMessenger } from \"../../external/interfaces/CCTPInterfaces.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { CrossDomainAddressUtils } from \"../../libraries/CrossDomainAddressUtils.sol\";\n\n/**\n * @title Arbitrum_WithdrawalHelper\n * @notice This contract interfaces with L2-L1 token bridges and withdraws tokens to a single address on L1.\n * @dev This contract should be deployed on Arbitrum L2s which only use CCTP or the canonical Arbitrum gateway router to withdraw tokens.\n * @custom:security-contact bugs@across.to\n */\ncontract Arbitrum_WithdrawalHelper is WithdrawalHelperBase {\n    using SafeERC20 for IERC20;\n\n    // Error which triggers when the supplied L1 token does not match the Arbitrum gateway router's expected L2 token.\n    error InvalidTokenMapping();\n\n    /*\n     * @notice Constructs the Arbitrum_WithdrawalHelper.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network. For Ethereum, this is 0.\n     * @param _l2GatewayRouter Address of the Arbitrum l2 gateway router contract.\n     * @param _tokenRecipient L1 Address which will unconditionally receive tokens withdrawn from this contract.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2GatewayRouter,\n        address _tokenRecipient\n    )\n        WithdrawalHelperBase(\n            _l2Usdc,\n            _cctpTokenMessenger,\n            _wrappedNativeToken,\n            _destinationCircleDomainId,\n            _l2GatewayRouter,\n            _tokenRecipient\n        )\n    {}\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which may execute admin functions on this contract.\n     */\n    function initialize(address _crossDomainAdmin) public initializer {\n        __WithdrawalHelper_init(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Calls CCTP or the Arbitrum gateway router to withdraw tokens back to the TOKEN_RECIPIENT L1 address.\n     * @param l1Token Address of the L1 token to receive.\n     * @param l2Token Address of the L2 token to send back.\n     * @param amountToReturn Amount of l2Token to send back.\n     */\n    function withdrawToken(\n        address l1Token,\n        address l2Token,\n        uint256 amountToReturn\n    ) public override {\n        // If the l2TokenAddress is UDSC, we need to use the CCTP bridge.\n        if (l2Token == address(usdcToken) && _isCCTPEnabled()) {\n            _transferUsdc(TOKEN_RECIPIENT, amountToReturn);\n        } else {\n            if (l2Token == address(WRAPPED_NATIVE_TOKEN)) _wrapNativeToken();\n            // Otherwise, we use the Arbitrum ERC20 Gateway router.\n            ArbitrumL2ERC20GatewayLike tokenBridge = ArbitrumL2ERC20GatewayLike(L2_TOKEN_GATEWAY);\n            // If the gateway router's expected L2 token address does not match then revert. This check does not actually\n            // impact whether the bridge will succeed, since the ERC20 gateway router only requires the L1 token address, but\n            // it is added here to potentially catch scenarios where there was a mistake in the calldata.\n            if (tokenBridge.calculateL2TokenAddress(l1Token) != l2Token) revert InvalidTokenMapping();\n            //slither-disable-next-line unused-return\n            tokenBridge.outboundTransfer(\n                l1Token, // _l1Token. Address of the L1 token to bridge over.\n                TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the recipient.\n                amountToReturn, // _amount.\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n    }\n\n    function _requireAdminSender() internal view override {\n        if (msg.sender != CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin)) revert NotCrossDomainAdmin();\n    }\n}\n"
    },
    "contracts/chain-adapters/l2/Ovm_WithdrawalHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WithdrawalHelperBase } from \"./WithdrawalHelperBase.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { ITokenMessenger } from \"../../external/interfaces/CCTPInterfaces.sol\";\nimport { Lib_PredeployAddresses } from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport { LibOptimismUpgradeable } from \"@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol\";\nimport { IL2ERC20Bridge } from \"../../Ovm_SpokePool.sol\";\n\n/**\n * @notice Minimal interface for the Ovm_SpokePool contract. This interface is called to pull state from the network's\n * spoke pool contract to be used by this withdrawal adapter.\n */\ninterface IOvm_SpokePool {\n    // Returns the address of the token bridge for the input l2 token.\n    function tokenBridges(address token) external view returns (address);\n\n    // Returns the address of the l1 token set in the spoke pool for the input l2 token.\n    function remoteL1Tokens(address token) external view returns (address);\n\n    // Returns the address for the representation of ETH on the l2.\n    function l2Eth() external view returns (address);\n\n    // Returns the amount of gas the contract allocates for a token withdrawal.\n    function l1Gas() external view returns (uint32);\n}\n\n/**\n * @title Ovm_WithdrawalAdapter\n * @notice This contract interfaces with L2-L1 token bridges and withdraws tokens to a single address on L1.\n * @dev This contract should be deployed on OpStack L2s which both have a Ovm_SpokePool contract deployed to the L2\n * network AND only use token bridges defined in the Ovm_SpokePool. A notable exception to this requirement is Optimism,\n * which has a special SNX bridge (and thus this adapter will NOT work for Optimism).\n * @custom:security-contact bugs@across.to\n */\ncontract Ovm_WithdrawalHelper is WithdrawalHelperBase {\n    using SafeERC20 for IERC20;\n\n    // Address of the corresponding spoke pool on L2. This is to piggyback off of the spoke pool's supported\n    // token routes/defined token bridges.\n    IOvm_SpokePool public immutable spokePool;\n    // Address of native ETH on the l2. For OpStack chains, this address is used to indicate a native ETH withdrawal.\n    // In general, this address is 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n    address public immutable l2Eth;\n    // Address of the messenger contract on L2. This is by default defined in Lib_PredeployAddresses.\n    address public constant MESSENGER = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n\n    /*\n     * @notice Constructs the Ovm_WithdrawalAdapter.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network. For Ethereum, this\n     * is 0.\n     * @param _l2Gateway Address of the Optimism ERC20 L2 standard bridge contract.\n     * @param _tokenRecipient The L1 address which will unconditionally receive tokens from withdrawals by this contract.\n     * @param _spokePool The contract address of the Ovm_SpokePool which is deployed on this L2 network.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2Gateway,\n        address _tokenRecipient,\n        IOvm_SpokePool _spokePool\n    )\n        WithdrawalHelperBase(\n            _l2Usdc,\n            _cctpTokenMessenger,\n            _wrappedNativeToken,\n            _destinationCircleDomainId,\n            _l2Gateway,\n            _tokenRecipient\n        )\n    {\n        spokePool = _spokePool;\n\n        // This address is immutable in the spoke pool so we query once and save its value locally.\n        l2Eth = spokePool.l2Eth();\n    }\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function initialize(address _crossDomainAdmin) public initializer {\n        __WithdrawalHelper_init(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Calls CCTP or the Optimism token gateway to withdraw tokens back to the recipient.\n     * @param l2Token address of the l2Token to send back.\n     * @param amountToReturn amount of l2Token to send back.\n     * @dev The l1Token parameter is unused since we obtain the l1Token to receive by querying the state of the Ovm_SpokePool deployed\n     * to this network.\n     * @dev This function is a copy of the `_bridgeTokensToHubPool` function found on the Ovm_SpokePool contract here:\n     * https://github.com/across-protocol/contracts/blob/65191dbcded95c8fe050e0f95eb7848e3784e61f/contracts/Ovm_SpokePool.sol#L148.\n     * New lines of code correspond to instances where this contract queries state from the spoke pool, such as determining\n     * the appropriate token bridge for the withdrawal or finding the remoteL1Token to withdraw.\n     */\n    function withdrawToken(\n        address,\n        address l2Token,\n        uint256 amountToReturn\n    ) public override {\n        // Fetch the current l1Gas defined in the Ovm_SpokePool.\n        uint32 l1Gas = spokePool.l1Gas();\n        // If the token being bridged is WETH then we need to first unwrap it to ETH and then send ETH over the\n        // canonical bridge. On Optimism, this is address 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n        if (l2Token == address(WRAPPED_NATIVE_TOKEN)) {\n            // Wrap the contract's balance of the native token if we are withdrawing the L2's native token. We need wrap the contract's balance\n            // and then unwrap the amount to send to account for cases where `amountToReturn` is greater than the contract's native token balance\n            // and wrapped native token balance, but less than their sum.\n            _wrapNativeToken();\n            WETH9Interface(l2Token).withdraw(amountToReturn); // Unwrap into ETH.\n            l2Token = l2Eth; // Set the l2Token to ETH.\n            IL2ERC20Bridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo{ value: amountToReturn }(\n                l2Token, // _l2Token. Address of the L2 token to bridge over.\n                TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                amountToReturn, // _amount.\n                l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n        // If the token is USDC && CCTP bridge is enabled, then bridge USDC via CCTP.\n        else if (l2Token == address(usdcToken) && _isCCTPEnabled()) {\n            _transferUsdc(TOKEN_RECIPIENT, amountToReturn);\n        }\n        // Note we'll default to withdrawTo instead of bridgeERC20To unless the remoteL1Tokens mapping is set for\n        // the l2Token. withdrawTo should be used to bridge back non-native L2 tokens\n        // (i.e. non-native L2 tokens have a canonical L1 token). If we should bridge \"native L2\" tokens then\n        // we'd need to call bridgeERC20To and give allowance to the tokenBridge to spend l2Token from this contract.\n        // Therefore for native tokens we should set ensure that remoteL1Tokens is set for the l2Token.\n        else {\n            IL2ERC20Bridge tokenBridge = IL2ERC20Bridge(\n                spokePool.tokenBridges(l2Token) == address(0)\n                    ? Lib_PredeployAddresses.L2_STANDARD_BRIDGE\n                    : spokePool.tokenBridges(l2Token)\n            );\n            address remoteL1Token = spokePool.remoteL1Tokens(l2Token);\n            if (remoteL1Token != address(0)) {\n                // If there is a mapping for this L2 token to an L1 token, then use the L1 token address and\n                // call bridgeERC20To.\n                IERC20(l2Token).safeIncreaseAllowance(address(tokenBridge), amountToReturn);\n                tokenBridge.bridgeERC20To(\n                    l2Token, // _l2Token. Address of the L2 token to bridge over.\n                    remoteL1Token, // Remote token to be received on L1 side. If the\n                    // remoteL1Token on the other chain does not recognize the local token as the correct\n                    // pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n                    // this chain.\n                    TOKEN_RECIPIENT, // _to\n                    amountToReturn, // _amount\n                    l1Gas, // _l1Gas\n                    \"\" // _data\n                );\n            } else {\n                tokenBridge.withdrawTo(\n                    l2Token, // _l2Token. Address of the L2 token to bridge over.\n                    TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                    amountToReturn, // _amount.\n                    l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                    \"\" // _data. We don't need to send any data for the bridging action.\n                );\n            }\n        }\n    }\n\n    function _requireAdminSender() internal view override {\n        if (LibOptimismUpgradeable.crossChainSender(MESSENGER) != crossDomainAdmin) revert NotCrossDomainAdmin();\n    }\n}\n"
    },
    "contracts/chain-adapters/l2/WithdrawalHelperBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MultiCaller } from \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport { CircleCCTPAdapter, ITokenMessenger, CircleDomainIds } from \"../../libraries/CircleCCTPAdapter.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title WithdrawalHelperBase\n * @notice This contract contains general configurations for bridging tokens from an L2 to a single recipient on L1.\n * @dev This contract should be deployed on L2. It provides an interface to withdraw tokens to some address on L1. The only\n * function which must be implemented in contracts which inherit this contract is `withdrawToken`. It is up to that function\n * to determine which bridges to use for an input L2 token. Importantly, that function must also verify that the L2 to L1\n * token mapping is correct so that the bridge call itself can succeed.\n */\nabstract contract WithdrawalHelperBase is CircleCCTPAdapter, MultiCaller, UUPSUpgradeable {\n    // The L2 address of the wrapped native token for this L2.\n    WETH9Interface public immutable WRAPPED_NATIVE_TOKEN;\n    // The L1 address which will unconditionally receive all withdrawals from this contract.\n    address public immutable TOKEN_RECIPIENT;\n    // The address of the primary or default token gateway/canonical bridge contract on L2.\n    address public immutable L2_TOKEN_GATEWAY;\n    // The address of the admin contract on L1,which will likely be the hub pool. As a last resort, this admin can rescue stuck tokens\n    // on this withdrawal helper contract, similar to how it may send admin functions to spoke pools.\n    address public crossDomainAdmin;\n\n    event SetXDomainAdmin(address indexed _crossDomainAdmin);\n\n    // Error which triggers when the cross domain admin was attempted to be set to the zero address.\n    error InvalidCrossDomainAdmin();\n    // Error which triggers when the caller of a protected function is not the cross domain admin.\n    error NotCrossDomainAdmin();\n\n    // Functions which contain this modifier should only be callable via a cross-chain call where the L1 msg.sender is the hub pool.\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    /*\n     * @notice Constructs a new withdrawal helper.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network.\n     * @param _l2TokenGateway Address of the network's l2 token gateway/bridge contract.\n     * @param _tokenRecipient L1 address which will unconditionally receive all withdrawals originating from this contract.\n     * @dev _disableInitializers() restricts anybody from initializing the implementation contract, which if not done,\n     * may disrupt the proxy if another EOA were to initialize it.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2TokenGateway,\n        address _tokenRecipient\n    ) CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, _destinationCircleDomainId) {\n        L2_TOKEN_GATEWAY = _l2TokenGateway;\n        TOKEN_RECIPIENT = _tokenRecipient;\n        WRAPPED_NATIVE_TOKEN = _wrappedNativeToken;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Receives the native token from bridge contracts.\n     * @dev When bridging from L3 to the L2's native token, OpStack bridges will send the \"unwrapped\"/native token to the recipient on L2\n     * during withdrawals. This means that this contract must be able to accept value transfers.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function __WithdrawalHelper_init(address _crossDomainAdmin) public onlyInitializing {\n        __UUPSUpgradeable_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Sets a new cross domain admin. The admin cannot be the zero address. The cross domain admin is the only address which may call\n     * upgrade this contract.\n     * @param _newCrossDomainAdmin L1 address of the new cross domain admin.\n     */\n    function _setCrossDomainAdmin(address _newCrossDomainAdmin) internal {\n        if (_newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = _newCrossDomainAdmin;\n        emit SetXDomainAdmin(_newCrossDomainAdmin);\n    }\n\n    /*\n     * @notice Withdraws a specified token to L1. This may be implemented uniquely for each L2, since each L2 has various\n     * dependencies to withdraw a token, such as the token bridge to use, mappings for L1 and L2 tokens, and gas configurations.\n     * Notably, withdrawals should always send token back to `TOKEN_RECIPIENT`.\n     * @param l1Token Address of the l1Token to receive.\n     * @param l2Token Address of the l2Token to send back.\n     * @param amountToReturn Amount of l2Token to send back.\n     * @dev Some networks do not require the L1/L2 token argument to withdraw tokens, while others enable contracts to derive the\n     * L1/L2 given knowledge of only one of the addresses. Both arguments are provided to enable a flexible interface; however, due\n     * to this, `withdrawToken` MUST account for situations where the L1/L2 token mapping is incorrect.\n     */\n    function withdrawToken(\n        address l1Token,\n        address l2Token,\n        uint256 amountToReturn\n    ) public virtual;\n\n    /*\n     * @notice Wraps the contract's entire balance of the native token.\n     */\n    function _wrapNativeToken() internal virtual {\n        if (address(this).balance > 0) WRAPPED_NATIVE_TOKEN.deposit{ value: address(this).balance }();\n    }\n\n    /*\n     * @notice Checks that the L1 msg.sender is the `crossDomainAdmin` address.\n     * @dev This implementation must change on a per-chain basis, since each L2 network has their own method of deriving the L1 msg.sender.\n     */\n    function _requireAdminSender() internal virtual;\n\n    /*\n     * @notice Access control check for upgrading this proxy contract\n     * @dev This requires that _requireAdminSender() is properly implemented on all contracts which inherit WithdrawalHelperBase.\n     */\n    function _authorizeUpgrade(address) internal override onlyAdmin {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/chain-adapters/Lisk_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Lisk. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Lisk_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Lisk system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Lisk.\n     * @param target Contract on Lisk that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Lisk.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Mode_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Mode. This is a clone of the Base adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Mode_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Mode system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Mode.\n     * @param target Contract on Mode that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Mode.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/OP_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { CircleCCTPAdapter, CircleDomainIds } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\nimport { IOpUSDCBridgeAdapter } from \"../external/interfaces/IOpUSDCBridgeAdapter.sol\";\nimport { WETH9Interface } from \"../external/interfaces/WETH9Interface.sol\";\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport { CrossDomainEnabled } from \"./CrossDomainEnabled.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to an OP stack chain.\n * @notice This adapter supports the OpUSDCBridgeAdapter interface for bridging into Circle Bridged USDC.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract OP_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n    IOpUSDCBridgeAdapter public immutable L1_OP_USDC_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger World Chain system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        IERC20 _l1Usdc,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IOpUSDCBridgeAdapter _l1USDCBridge\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n        L1_OP_USDC_BRIDGE = _l1USDCBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on World Chain.\n     * @param target Contract on World Chain that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to World Chain.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        } else if (l1Token == address(usdcToken)) {\n            if (_isCCTPEnabled()) {\n                _transferUsdc(to, amount);\n            } else {\n                // Use the relevant OP USDC bridge to received bridged USDC on L2.\n                IERC20(l1Token).safeIncreaseAllowance(address(L1_OP_USDC_BRIDGE), amount);\n                L1_OP_USDC_BRIDGE.sendMessage(to, amount, L2_GAS_LIMIT);\n            }\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(address(L1_STANDARD_BRIDGE), amount);\n            L1_STANDARD_BRIDGE.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Optimism_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Interface for Synthetix custom bridge to Optimism.\n */\ninterface SynthetixBridgeToOptimism is IL1StandardBridge {\n    /**\n     * @notice Send tokens to Optimism.\n     * @param to Address to send tokens to on L2.\n     * @param amount Amount of tokens to send.\n     */\n    function depositTo(address to, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Optimism.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore it's only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Optimism_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    // Optimism has the ability to support \"custom\" bridges. These bridges are not supported by the canonical bridge\n    // and so we need to store the address of the custom token and the associated bridge. In the event we want to\n    // support a new token that is not supported by Optimism, we can add a new custom bridge for it and re-deploy the\n    // adapter. A full list of custom optimism tokens and their associated bridges can be found here:\n    // https://github.com/ethereum-optimism/ethereum-optimism.github.io/blob/master/optimism.tokenlist.json\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant DAI_OPTIMISM_BRIDGE = 0x10E6593CDda8c58a1d0f14C5164B376352a55f2F;\n    address public constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n    address public constant SNX_OPTIMISM_BRIDGE = 0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Optimism system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Optimism)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Optimism.\n     * @param target Contract on Optimism that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Optimism.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // If the l1Token is USDC, then we send it to the CCTP bridge\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            address bridgeToUse = address(L1_STANDARD_BRIDGE);\n\n            // Check if the L1 token requires a custom bridge. If so, use that bridge over the standard bridge.\n            if (l1Token == DAI) bridgeToUse = DAI_OPTIMISM_BRIDGE; // 1. DAI\n            if (l1Token == SNX) bridgeToUse = SNX_OPTIMISM_BRIDGE; // 2. SNX\n\n            IERC20(l1Token).safeIncreaseAllowance(bridgeToUse, amount);\n            if (l1Token == SNX) SynthetixBridgeToOptimism(bridgeToUse).depositTo(to, amount);\n            else IL1StandardBridge(bridgeToUse).depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Polygon_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Send tokens to Polygon.\n */\ninterface IRootChainManager {\n    /**\n     * @notice Send msg.value of ETH to Polygon\n     * @param user Recipient of ETH on Polygon.\n     */\n    function depositEtherFor(address user) external payable;\n\n    /**\n     * @notice Send ERC20 tokens to Polygon.\n     * @param user Recipient of L2 equivalent tokens on Polygon.\n     * @param rootToken L1 Address of token to send.\n     * @param depositData Data to pass to L2 including amount of tokens to send. Should be abi.encode(amount).\n     */\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external;\n}\n\n/**\n * @notice Send arbitrary messages to Polygon.\n */\ninterface IFxStateSender {\n    /**\n     * @notice Send arbitrary message to Polygon.\n     * @param _receiver Address on Polygon to receive message.\n     * @param _data Message to send to `_receiver` on Polygon.\n     */\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\n}\n\n/**\n * @notice Similar to RootChainManager, but for Matic (Plasma) bridge.\n */\ninterface DepositManager {\n    /**\n     * @notice Send tokens to Polygon. Only used to send MATIC in this Polygon_Adapter.\n     * @param token L1 token to send. Should be MATIC.\n     * @param user Recipient of L2 equivalent tokens on Polygon.\n     * @param amount Amount of `token` to send.\n     */\n    function depositERC20ForUser(\n        address token,\n        address user,\n        uint256 amount\n    ) external;\n}\n\n/**\n * @notice Sends cross chain messages Polygon L2 network.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Polygon_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    IRootChainManager public immutable ROOT_CHAIN_MANAGER;\n    IFxStateSender public immutable FX_STATE_SENDER;\n    DepositManager public immutable DEPOSIT_MANAGER;\n    address public immutable ERC20_PREDICATE;\n    address public immutable L1_MATIC;\n    WETH9Interface public immutable L1_WETH;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _rootChainManager RootChainManager Polygon system contract to deposit tokens over the PoS bridge.\n     * @param _fxStateSender FxStateSender Polygon system contract to send arbitrary messages to L2.\n     * @param _depositManager DepositManager Polygon system contract to deposit tokens over the Plasma bridge (Matic).\n     * @param _erc20Predicate ERC20Predicate Polygon system contract to approve when depositing to the PoS bridge.\n     * @param _l1Matic matic address on l1.\n     * @param _l1Weth WETH address on L1.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        IRootChainManager _rootChainManager,\n        IFxStateSender _fxStateSender,\n        DepositManager _depositManager,\n        address _erc20Predicate,\n        address _l1Matic,\n        WETH9Interface _l1Weth,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Polygon) {\n        ROOT_CHAIN_MANAGER = _rootChainManager;\n        FX_STATE_SENDER = _fxStateSender;\n        DEPOSIT_MANAGER = _depositManager;\n        ERC20_PREDICATE = _erc20Predicate;\n        L1_MATIC = _l1Matic;\n        L1_WETH = _l1Weth;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Polygon.\n     * @param target Contract on Polygon that will receive message.\n     * @param message Data to send to target.\n     */\n\n    function relayMessage(address target, bytes calldata message) external payable override {\n        FX_STATE_SENDER.sendMessageToChild(target, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Polygon.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            ROOT_CHAIN_MANAGER.depositEtherFor{ value: amount }(to);\n        }\n        // If the l1Token is USDC, then we send it to the CCTP bridge\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else if (l1Token == L1_MATIC) {\n            IERC20(l1Token).safeIncreaseAllowance(address(DEPOSIT_MANAGER), amount);\n            DEPOSIT_MANAGER.depositERC20ForUser(l1Token, to, amount);\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(ERC20_PREDICATE, amount);\n            ROOT_CHAIN_MANAGER.depositFor(to, l1Token, abi.encode(amount));\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Redstone_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Redstone. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Redstone_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Redstone system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Redstone.\n     * @param target Contract on Redstone that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Redstone.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Zora_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Zora. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Zora_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Zora system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Zora.\n     * @param target Contract on Zora that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Zora.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/erc7683/ERC7683.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/// @title GaslessCrossChainOrder CrossChainOrder type\n/// @notice Standard order struct to be signed by users, disseminated to fillers, and submitted to origin settler contracts\nstruct GaslessCrossChainOrder {\n    /// @dev The contract address that the order is meant to be settled by.\n    /// Fillers send this order to this contract address on the origin chain\n    address originSettler;\n    /// @dev The address of the user who is initiating the swap,\n    /// whose input tokens will be taken and escrowed\n    address user;\n    /// @dev Nonce to be used as replay protection for the order\n    uint256 nonce;\n    /// @dev The chainId of the origin chain\n    uint256 originChainId;\n    /// @dev The timestamp by which the order must be opened\n    uint32 openDeadline;\n    /// @dev The timestamp by which the order must be filled on the destination chain\n    uint32 fillDeadline;\n    /// @dev Type identifier for the order data. This is an EIP-712 typehash.\n    bytes32 orderDataType;\n    /// @dev Arbitrary implementation-specific data\n    /// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,\n    /// or any other order-type specific information\n    bytes orderData;\n}\n\n/// @title OnchainCrossChainOrder CrossChainOrder type\n/// @notice Standard order struct for user-opened orders, where the user is the msg.sender.\nstruct OnchainCrossChainOrder {\n    /// @dev The timestamp by which the order must be filled on the destination chain\n    uint32 fillDeadline;\n    /// @dev Type identifier for the order data. This is an EIP-712 typehash.\n    bytes32 orderDataType;\n    /// @dev Arbitrary implementation-specific data\n    /// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,\n    /// or any other order-type specific information\n    bytes orderData;\n}\n\n/// @title ResolvedCrossChainOrder type\n/// @notice An implementation-generic representation of an order intended for filler consumption\n/// @dev Defines all requirements for filling an order by unbundling the implementation-specific orderData.\n/// @dev Intended to improve integration generalization by allowing fillers to compute the exact input and output information of any order\nstruct ResolvedCrossChainOrder {\n    /// @dev The address of the user who is initiating the transfer\n    address user;\n    /// @dev The chainId of the origin chain\n    uint256 originChainId;\n    /// @dev The timestamp by which the order must be opened\n    uint32 openDeadline;\n    /// @dev The timestamp by which the order must be filled on the destination chain(s)\n    uint32 fillDeadline;\n    /// @dev The unique identifier for this order within this settlement system\n    bytes32 orderId;\n    /// @dev The max outputs that the filler will send. It's possible the actual amount depends on the state of the destination\n    ///      chain (destination dutch auction, for instance), so these outputs should be considered a cap on filler liabilities.\n    Output[] maxSpent;\n    /// @dev The minimum outputs that must to be given to the filler as part of order settlement. Similar to maxSpent, it's possible\n    ///      that special order types may not be able to guarantee the exact amount at open time, so this should be considered\n    ///      a floor on filler receipts.\n    Output[] minReceived;\n    /// @dev Each instruction in this array is parameterizes a single leg of the fill. This provides the filler with the information\n    ///      necessary to perform the fill on the destination(s).\n    FillInstruction[] fillInstructions;\n}\n\n/// @notice Tokens that must be receive for a valid order fulfillment\nstruct Output {\n    /// @dev The address of the ERC20 token on the destination chain\n    /// @dev address(0) used as a sentinel for the native token\n    bytes32 token;\n    /// @dev The amount of the token to be sent\n    uint256 amount;\n    /// @dev The address to receive the output tokens\n    bytes32 recipient;\n    /// @dev The destination chain for this output\n    uint256 chainId;\n}\n\n/// @title FillInstruction type\n/// @notice Instructions to parameterize each leg of the fill\n/// @dev Provides all the origin-generated information required to produce a valid fill leg\nstruct FillInstruction {\n    /// @dev The contract address that the order is meant to be settled by\n    uint64 destinationChainId;\n    /// @dev The contract address that the order is meant to be filled on\n    bytes32 destinationSettler;\n    /// @dev The data generated on the origin chain needed by the destinationSettler to process the fill\n    bytes originData;\n}\n\n/// @title IOriginSettler\n/// @notice Standard interface for settlement contracts on the origin chain\ninterface IOriginSettler {\n    /// @notice Signals that an order has been opened\n    /// @param orderId a unique order identifier within this settlement system\n    /// @param resolvedOrder resolved order that would be returned by resolve if called instead of Open\n    event Open(bytes32 indexed orderId, ResolvedCrossChainOrder resolvedOrder);\n\n    /// @notice Opens a gasless cross-chain order on behalf of a user.\n    /// @dev To be called by the filler.\n    /// @dev This method must emit the Open event\n    /// @param order The GaslessCrossChainOrder definition\n    /// @param signature The user's signature over the order\n    /// @param originFillerData Any filler-defined data required by the settler\n    function openFor(\n        GaslessCrossChainOrder calldata order,\n        bytes calldata signature,\n        bytes calldata originFillerData\n    ) external;\n\n    /// @notice Opens a cross-chain order\n    /// @dev To be called by the user\n    /// @dev This method must emit the Open event\n    /// @param order The OnchainCrossChainOrder definition\n    function open(OnchainCrossChainOrder calldata order) external;\n\n    /// @notice Resolves a specific GaslessCrossChainOrder into a generic ResolvedCrossChainOrder\n    /// @dev Intended to improve standardized integration of various order types and settlement contracts\n    /// @param order The GaslessCrossChainOrder definition\n    /// @param originFillerData Any filler-defined data required by the settler\n    /// @return ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order\n    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData)\n        external\n        view\n        returns (ResolvedCrossChainOrder memory);\n\n    /// @notice Resolves a specific OnchainCrossChainOrder into a generic ResolvedCrossChainOrder\n    /// @dev Intended to improve standardized integration of various order types and settlement contracts\n    /// @param order The OnchainCrossChainOrder definition\n    /// @return ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order\n    function resolve(OnchainCrossChainOrder calldata order) external view returns (ResolvedCrossChainOrder memory);\n}\n\n/// @title IDestinationSettler\n/// @notice Standard interface for settlement contracts on the destination chain\ninterface IDestinationSettler {\n    /// @notice Fills a single leg of a particular order on the destination chain\n    /// @param orderId Unique order identifier for this order\n    /// @param originData Data emitted on the origin to parameterize the fill\n    /// @param fillerData Data provided by the filler to inform the fill or express their preferences\n    function fill(\n        bytes32 orderId,\n        bytes calldata originData,\n        bytes calldata fillerData\n    ) external;\n}\n"
    },
    "contracts/erc7683/ERC7683Permit2Lib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../external/interfaces/IPermit2.sol\";\nimport { GaslessCrossChainOrder } from \"./ERC7683.sol\";\n\n// Data unique to every CrossChainOrder settled on Across\nstruct AcrossOrderData {\n    address inputToken;\n    uint256 inputAmount;\n    address outputToken;\n    uint256 outputAmount;\n    uint256 destinationChainId;\n    bytes32 recipient;\n    address exclusiveRelayer;\n    uint32 exclusivityPeriod;\n    bytes message;\n}\n\nstruct AcrossOriginFillerData {\n    address exclusiveRelayer;\n}\n\nstruct AcrossDestinationFillerData {\n    uint256 repaymentChainId;\n}\n\nbytes constant ACROSS_ORDER_DATA_TYPE = abi.encodePacked(\n    \"AcrossOrderData(\",\n    \"address inputToken,\",\n    \"uint256 inputAmount,\",\n    \"address outputToken,\",\n    \"uint256 outputAmount,\",\n    \"uint256 destinationChainId,\",\n    \"bytes32 recipient,\",\n    \"address exclusiveRelayer,\"\n    \"uint32 exclusivityPeriod,\",\n    \"bytes message)\"\n);\n\nbytes32 constant ACROSS_ORDER_DATA_TYPE_HASH = keccak256(ACROSS_ORDER_DATA_TYPE);\n\n/**\n * @notice ERC7683Permit2Lib knows how to process a particular type of external Permit2Order so that it can be used in Across.\n * @dev This library is responsible for definining the ERC712 type strings/hashes and performing hashes on the types.\n * @custom:security-contact bugs@across.to\n */\nlibrary ERC7683Permit2Lib {\n    bytes internal constant GASLESS_CROSS_CHAIN_ORDER_TYPE =\n        abi.encodePacked(\n            \"GaslessCrossChainOrder(\",\n            \"address originSettler,\",\n            \"address user,\",\n            \"uint256 nonce,\",\n            \"uint256 originChainId,\",\n            \"uint32 openDeadline,\",\n            \"uint32 fillDeadline,\",\n            \"bytes32 orderDataType,\",\n            \"AcrossOrderData orderData)\"\n        );\n\n    bytes internal constant GASLESS_CROSS_CHAIN_ORDER_EIP712_TYPE =\n        abi.encodePacked(GASLESS_CROSS_CHAIN_ORDER_TYPE, ACROSS_ORDER_DATA_TYPE);\n    bytes32 internal constant GASLESS_CROSS_CHAIN_ORDER_TYPE_HASH = keccak256(GASLESS_CROSS_CHAIN_ORDER_EIP712_TYPE);\n\n    string private constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n    string internal constant PERMIT2_ORDER_TYPE =\n        string(\n            abi.encodePacked(\n                \"GaslessCrossChainOrder witness)\",\n                ACROSS_ORDER_DATA_TYPE,\n                GASLESS_CROSS_CHAIN_ORDER_TYPE,\n                TOKEN_PERMISSIONS_TYPE\n            )\n        );\n\n    // Hashes an order to get an order hash. Needed for permit2.\n    function hashOrder(GaslessCrossChainOrder memory order, bytes32 orderDataHash) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    GASLESS_CROSS_CHAIN_ORDER_TYPE_HASH,\n                    order.originSettler,\n                    order.user,\n                    order.nonce,\n                    order.originChainId,\n                    order.openDeadline,\n                    order.fillDeadline,\n                    order.orderDataType,\n                    orderDataHash\n                )\n            );\n    }\n\n    function hashOrderData(AcrossOrderData memory orderData) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    ACROSS_ORDER_DATA_TYPE_HASH,\n                    orderData.inputToken,\n                    orderData.inputAmount,\n                    orderData.outputToken,\n                    orderData.outputAmount,\n                    orderData.destinationChainId,\n                    orderData.recipient,\n                    orderData.exclusiveRelayer,\n                    orderData.exclusivityPeriod,\n                    keccak256(orderData.message)\n                )\n            );\n    }\n}\n"
    },
    "contracts/external/interfaces/CCTPInterfaces.sol": {
      "content": "/**\n * Copyright (C) 2015, 2016, 2017 Dapphub\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/**\n * Imported as-is from commit 139d8d0ce3b5531d3c7ec284f89d946dfb720016 of:\n *   * https://github.com/walkerq/evm-cctp-contracts/blob/139d8d0ce3b5531d3c7ec284f89d946dfb720016/src/TokenMessenger.sol\n * Changes applied post-import:\n *   * Removed a majority of code from this contract and converted the needed function signatures in this interface.\n */\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @return _nonce unique nonce reserved by message\n     */\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64 _nonce);\n\n    /**\n     * @notice Minter responsible for minting and burning tokens on the local domain\n     * @dev A TokenMessenger stores a TokenMinter contract which extends the TokenController contract.\n     * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMessenger.sol#L110\n     * @return minter Token Minter contract.\n     */\n    function localMinter() external view returns (ITokenMinter minter);\n}\n\n/**\n * A TokenMessenger stores a TokenMinter contract which extends the TokenController contract. The TokenController\n * contract has a burnLimitsPerMessage public mapping which can be queried to find the per-message burn limit\n * for a given token:\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMinter.sol#L33\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/roles/TokenController.sol#L69C40-L69C60\n *\n */\ninterface ITokenMinter {\n    /**\n     * @notice Supported burnable tokens on the local domain\n     * local token (address) => maximum burn amounts per message\n     * @param token address of token contract\n     * @return burnLimit maximum burn amount per message for token\n     */\n    function burnLimitsPerMessage(address token) external view returns (uint256);\n}\n"
    },
    "contracts/external/interfaces/IOpUSDCBridgeAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * Imported from https://github.com/defi-wonderland/opUSDC\n * https://github.com/defi-wonderland/opUSDC/blob/ef22e5731f1655bf5249b2160452cce9aa06ff3f/src/interfaces/IOpUSDCBridgeAdapter.sol#L198C1-L204C84\n */\ninterface IOpUSDCBridgeAdapter {\n    /**\n     * @notice Send tokens to another chain through the linked adapter\n     * @param _to The target address on the destination chain\n     * @param _amount The amount of tokens to send\n     * @param _minGasLimit Minimum gas limit that the message can be executed with\n     */\n    function sendMessage(\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit\n    ) external;\n}\n"
    },
    "contracts/external/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPermit2 {\n    struct TokenPermissions {\n        address token;\n        uint256 amount;\n    }\n\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    struct SignatureTransferDetails {\n        address to;\n        uint256 requestedAmount;\n    }\n\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint160 amount,\n        address token\n    ) external;\n}\n"
    },
    "contracts/external/interfaces/WETH9Interface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Interface for the WETH9 contract.\n */\ninterface WETH9Interface {\n    /**\n     * @notice Burn Wrapped Ether and receive native Ether.\n     * @param wad Amount of WETH to unwrap and send to caller.\n     */\n    function withdraw(uint256 wad) external;\n\n    /**\n     * @notice Lock native Ether and mint Wrapped Ether ERC20\n     * @dev msg.value is amount of Wrapped Ether to mint/Ether to lock.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Get balance of WETH held by `guy`.\n     * @param guy Address to get balance of.\n     * @return wad Amount of WETH held by `guy`.\n     */\n    function balanceOf(address guy) external view returns (uint256 wad);\n\n    /**\n     * @notice Transfer `wad` of WETH from caller to `guy`.\n     * @param guy Address to send WETH to.\n     * @param wad Amount of WETH to send.\n     * @return ok True if transfer succeeded.\n     */\n    function transfer(address guy, uint256 wad) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ArbitrumBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Staging ground for incoming and outgoing messages\n * @notice Unlike the standard Eth bridge, native token bridge escrows the custom ERC20 token which is\n * used as native currency on upper layer.\n * @dev Fees are paid in this token. There are certain restrictions on the native token:\n *       - The token can't be rebasing or have a transfer fee\n *       - The token must only be transferrable via a call to the token address itself\n *       - The token must only be able to set allowance via a call to the token address itself\n *       - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\n *       - The token must have a max of 2^256 - 1 wei total supply unscaled\n *       - The token must have a max of 2^256 - 1 wei total supply when scaled to 18 decimals\n */\ninterface ArbitrumERC20Bridge {\n    /**\n     * @notice Returns token that is escrowed in bridge on the lower layer and minted on the upper layer as native currency.\n     * @dev This function doesn't exist on the generic Bridge interface.\n     * @return address of the native token.\n     */\n    function nativeToken() external view returns (address);\n\n    /**\n     * @dev number of decimals used by the native token\n     *      This is set on bridge initialization using nativeToken.decimals()\n     *      If the token does not have decimals() method, we assume it have 0 decimals\n     */\n    function nativeTokenDecimals() external view returns (uint8);\n}\n\n/**\n * @title Inbox for user and contract originated messages\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\n * to await inclusion in the SequencerInbox\n */\ninterface ArbitrumInboxLike {\n    /**\n     * @dev we only use this function to check the native token used by the bridge, so we hardcode the interface\n     * to return an ArbitrumERC20Bridge instead of a more generic Bridge interface.\n     * @return address of the bridge.\n     */\n    function bridge() external view returns (ArbitrumERC20Bridge);\n\n    /**\n     * @notice Put a message in the inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @dev Caller must set msg.value equal to at least `maxSubmissionCost + maxGas * gasPriceBid`.\n     *      all msg.value will deposited to callValueRefundAddress on the upper layer\n     * @dev More details can be found here: https://developer.arbitrum.io/arbos/l1-to-l2-messaging\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's (upper layer) balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on (upper layer) balance\n     * @param callValueRefundAddress callvalue gets credited here on upper layer if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's upper layer balance to cover upper layer execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for upper layer execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the source chain inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed\n     * funds come from the deposit alone, rather than falling back on the user's balance\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\n     * createRetryableTicket method is the recommended standard.\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's source chain balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on source chain balance\n     * @param callValueRefundAddress callvalue gets credited here on source chain if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's balance to cover execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of the message\n     * @return unique message number of the retryable transaction\n     */\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n}\n\n/**\n * @notice Interface which extends ArbitrumInboxLike with functions used to interact with bridges that use a custom gas token.\n */\ninterface ArbitrumCustomGasTokenInbox is ArbitrumInboxLike {\n    /**\n     * @notice Put a message in the inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @notice Overloads the `createRetryableTicket` function but is not payable, and should only be called when paying\n     * for message using a custom gas token.\n     * @dev all tokenTotalFeeAmount will be deposited to callValueRefundAddress on upper layer\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @dev In case of native token having non-18 decimals: tokenTotalFeeAmount is denominated in native token's decimals. All other value params - callValue, maxSubmissionCost and maxFeePerGas are denominated in child chain's native 18 decimals.\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's upper layer balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost. In case this address is a contract, funds will be received in its alias on upper layer.\n     * @param callValueRefundAddress callvalue gets credited here on upper layer if retryable txn times out or gets cancelled. In case this address is a contract, funds will be received in its alias on upper layer.\n     * @param gasLimit Max gas deducted from user's balance to cover execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\n     * @param data ABI encoded data of message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 tokenTotalFeeAmount,\n        bytes calldata data\n    ) external returns (uint256);\n}\n\n/**\n * @notice Generic gateway contract for bridging standard ERC20s to/from Arbitrum-like networks.\n * @notice These function signatures are shared between the L1 and L2 gateway router contracts.\n */\ninterface ArbitrumL1ERC20GatewayLike {\n    /**\n     * @notice Deprecated in favor of outboundTransferCustomRefund but still used in custom bridges\n     * like the DAI bridge.\n     * @dev Refunded to aliased address of sender if sender has code on source chain, otherwise to to sender's EOA on destination chain.\n     * @param _sourceToken address of ERC20\n     * @param _to Account to be credited with the tokens at the destination (can be the user's account or a contract),\n     * not subject to aliasing. This account, or its alias if it has code in the source chain, will also be able to\n     * cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's balance to cover execution\n     * @param _gasPriceBid Gas price for execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransfer(\n        address _sourceToken,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    /**\n     * @notice get ERC20 gateway for token.\n     * @param _token ERC20 address.\n     * @return address of ERC20 gateway.\n     */\n    function getGateway(address _token) external view returns (address);\n\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum-like networks.\n     * @dev Upper layer address alias will not be applied to the following types of addresses on lower layer:\n     *      - an externally-owned account\n     *      - a contract in construction\n     *      - an address where a contract will be created\n     *      - an address where a contract lived, but was destroyed\n     * @param _sourceToken address of ERC20 on source chain.\n     * @param _refundTo Account, or its alias if it has code on the source chain, to be credited with excess gas refund at destination\n     * @param _to Account to be credited with the tokens in the L3 (can be the user's L3 account or a contract),\n     * not subject to aliasing. This account, or its alias if it has code on the source chain, will also be able to\n     * cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's balance to cover execution\n     * @param _gasPriceBid Gas price for execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransferCustomRefund(\n        address _sourceToken,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n\ninterface ArbitrumL2ERC20GatewayLike {\n    /**\n     * @notice Fetches the l2 token address from the gateway router for the input l1 token address\n     * @param _l1Erc20 address of the l1 token.\n     */\n    function calculateL2TokenAddress(address _l1Erc20) external view returns (address);\n\n    /**\n     * @notice Withdraws a specified amount of an l2 token to an l1 token.\n     * @param _l1Token address of the token to withdraw on L1.\n     * @param _to address on L1 which will receive the tokens upon withdrawal.\n     * @param _amount amount of the token to withdraw.\n     * @param _data encoded data to send to the gateway router.\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/HubPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Concise list of functions in HubPool implementation.\n */\ninterface HubPoolInterface {\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\n    struct PoolRebalanceLeaf {\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).\n        uint256 chainId;\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\n        uint256[] bundleLpFees;\n        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative\n        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This\n        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does\n        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous\n        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's\n        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.\n        int256[] netSendAmounts;\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1\n        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that\n        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.\n        int256[] runningBalances;\n        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.\n        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where\n        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under\n        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with\n        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one\n        // leaf for a specific chainId should have a groupIndex equal to 0.\n        uint256 groupIndex;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint8 leafId;\n        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel\n        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero\n        // relays on this chain in this bundle in the order of whitelisting.\n        address[] l1Tokens;\n    }\n\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves\n    // that can be executed later to:\n    // - Send funds from this contract to a SpokePool or vice versa\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \"slow\" relay\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\n    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\n    struct RootBundle {\n        // Contains leaves instructing this contract to send funds to SpokePools.\n        bytes32 poolRebalanceRoot;\n        // Relayer refund merkle root to be published to a SpokePool.\n        bytes32 relayerRefundRoot;\n        // Slow relay merkle root to be published to a SpokePool.\n        bytes32 slowRelayRoot;\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\n        uint256 claimedBitMap;\n        // Proposer of this root bundle.\n        address proposer;\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\n        // of leaves are executed, a new root bundle can be proposed\n        uint8 unclaimedPoolRebalanceLeafCount;\n        // When root bundle challenge period passes and this root bundle becomes executable.\n        uint32 challengePeriodEndTimestamp;\n    }\n\n    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the\n    // cumulative LP positions and if this token is enabled for deposits.\n    struct PooledToken {\n        // LP token given to LPs of a specific L1 token.\n        address lpToken;\n        // True if accepting new LP's.\n        bool isEnabled;\n        // Timestamp of last LP fee update.\n        uint32 lastLpFeeUpdate;\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\n        // back later.\n        int256 utilizedReserves;\n        // Number of LP funds held in contract less utilized reserves.\n        uint256 liquidReserves;\n        // Number of LP funds reserved to pay out to LPs as fees.\n        uint256 undistributedLpFees;\n    }\n\n    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\n    struct CrossChainContract {\n        address adapter;\n        address spokePool;\n    }\n\n    function setPaused(bool pause) external;\n\n    function emergencyDeleteProposal() external;\n\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\n\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\n\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\n\n    function setLiveness(uint32 newLiveness) external;\n\n    function setIdentifier(bytes32 newIdentifier) external;\n\n    function setCrossChainContracts(\n        uint256 l2ChainId,\n        address adapter,\n        address spokePool\n    ) external;\n\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\n\n    function removeLiquidity(\n        address l1Token,\n        uint256 lpTokenAmount,\n        bool sendEth\n    ) external;\n\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);\n\n    function sync(address l1Token) external;\n\n    function proposeRootBundle(\n        uint256[] memory bundleEvaluationBlockNumbers,\n        uint8 poolRebalanceLeafCount,\n        bytes32 poolRebalanceRoot,\n        bytes32 relayerRefundRoot,\n        bytes32 slowRelayRoot\n    ) external;\n\n    function executeRootBundle(\n        uint256 chainId,\n        uint256 groupIndex,\n        uint256[] memory bundleLpFees,\n        int256[] memory netSendAmounts,\n        int256[] memory runningBalances,\n        uint8 leafId,\n        address[] memory l1Tokens,\n        bytes32[] memory proof\n    ) external;\n\n    function disputeRootBundle() external;\n\n    function claimProtocolFeesCaptured(address l1Token) external;\n\n    function setPoolRebalanceRoute(\n        uint256 destinationChainId,\n        address l1Token,\n        address destinationToken\n    ) external;\n\n    function setDepositRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        bool depositsEnabled\n    ) external;\n\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\n        external\n        view\n        returns (address destinationToken);\n\n    function loadEthForL2Calls() external payable;\n}\n"
    },
    "contracts/interfaces/SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Contains common data structures and functions used by all SpokePool implementations.\n */\ninterface SpokePoolInterface {\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\n    struct RelayerRefundLeaf {\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that\n        // is negative. This is just the negative of this value.\n        uint256 amountToReturn;\n        // Used to verify that this is being executed on the correct destination chainId.\n        uint256 chainId;\n        // This array designates how much each of those addresses should be refunded.\n        uint256[] refundAmounts;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint32 leafId;\n        // The associated L2TokenAddress that these claims apply to.\n        address l2TokenAddress;\n        // Must be same length as refundAmounts and designates each address that must be refunded.\n        address[] refundAddresses;\n    }\n\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\n    // by \"data workers\" via inclusion proofs to execute leaves in the roots.\n    struct RootBundle {\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\n        bytes32 slowRelayRoot;\n        // Merkle root of relayer refunds for successful relays.\n        bytes32 relayerRefundRoot;\n        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of\n        // 256x(2^248) leaves per root.\n        mapping(uint256 => uint256) claimedBitmap;\n    }\n\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\n\n    function setWithdrawalRecipient(address newWithdrawalRecipient) external;\n\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enable\n    ) external;\n\n    function pauseDeposits(bool pause) external;\n\n    function pauseFills(bool pause) external;\n\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\n\n    function emergencyDeleteRootBundle(uint256 rootBundleId) external;\n\n    function deposit(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 maxCount\n    ) external payable;\n\n    function depositFor(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 maxCount\n    ) external payable;\n\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) external payable;\n\n    function chainId() external view returns (uint256);\n\n    error NotEOA();\n    error InvalidDepositorSignature();\n    error InvalidRelayerFeePct();\n    error MaxTransferSizeExceeded();\n    error InvalidCrossDomainAdmin();\n    error InvalidWithdrawalRecipient();\n    error DepositsArePaused();\n    error FillsArePaused();\n}\n"
    },
    "contracts/interfaces/SpokePoolMessageHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// This interface is expected to be implemented by any contract that expects to receive messages from the SpokePool.\ninterface AcrossMessageHandler {\n    function handleV3AcrossMessage(\n        address tokenSent,\n        uint256 amount,\n        address relayer,\n        bytes memory message\n    ) external;\n}\n"
    },
    "contracts/interfaces/V3SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// Contains structs and functions used by SpokePool contracts to facilitate universal settlement.\ninterface V3SpokePoolInterface {\n    /**************************************\n     *              ENUMS                 *\n     **************************************/\n\n    // Fill status tracks on-chain state of deposit, uniquely identified by relayHash.\n    enum FillStatus {\n        Unfilled,\n        RequestedSlowFill,\n        Filled\n    }\n    // Fill type is emitted in the FilledRelay event to assist Dataworker with determining which types of\n    // fills to refund (e.g. only fast fills) and whether a fast fill created a sow fill excess.\n    enum FillType {\n        FastFill,\n        // Fast fills are normal fills that do not replace a slow fill request.\n        ReplacedSlowFill,\n        // Replaced slow fills are fast fills that replace a slow fill request. This type is used by the Dataworker\n        // to know when to send excess funds from the SpokePool to the HubPool because they can no longer be used\n        // for a slow fill execution.\n        SlowFill\n        // Slow fills are requested via requestSlowFill and executed by executeSlowRelayLeaf after a bundle containing\n        // the slow fill is validated.\n    }\n\n    /**************************************\n     *              STRUCTS               *\n     **************************************/\n\n    // This struct represents the data to fully specify a **unique** relay submitted on this chain.\n    // This data is hashed with the chainId() and saved by the SpokePool to prevent collisions and protect against\n    // replay attacks on other chains. If any portion of this data differs, the relay is considered to be\n    // completely distinct.\n    struct V3RelayData {\n        // The address that made the deposit on the origin chain.\n        address depositor;\n        // The recipient address on the destination chain.\n        address recipient;\n        // This is the exclusive relayer who can fill the deposit before the exclusivity deadline.\n        address exclusiveRelayer;\n        // Token that is deposited on origin chain by depositor.\n        address inputToken;\n        // Token that is received on destination chain by recipient.\n        address outputToken;\n        // The amount of input token deposited by depositor.\n        uint256 inputAmount;\n        // The amount of output token to be received by recipient.\n        uint256 outputAmount;\n        // Origin chain id.\n        uint256 originChainId;\n        // The id uniquely identifying this deposit on the origin chain.\n        uint32 depositId;\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\n        uint32 fillDeadline;\n        // The timestamp on the destination chain after which any relayer can fill the deposit.\n        uint32 exclusivityDeadline;\n        // Data that is forwarded to the recipient.\n        bytes message;\n    }\n\n    // Contains parameters passed in by someone who wants to execute a slow relay leaf.\n    struct V3SlowFill {\n        V3RelayData relayData;\n        uint256 chainId;\n        uint256 updatedOutputAmount;\n    }\n\n    // Contains information about a relay to be sent along with additional information that is not unique to the\n    // relay itself but is required to know how to process the relay. For example, \"updatedX\" fields can be used\n    // by the relayer to modify fields of the relay with the depositor's permission, and \"repaymentChainId\" is specified\n    // by the relayer to determine where to take a relayer refund, but doesn't affect the uniqueness of the relay.\n    struct V3RelayExecutionParams {\n        V3RelayData relay;\n        bytes32 relayHash;\n        uint256 updatedOutputAmount;\n        address updatedRecipient;\n        bytes updatedMessage;\n        uint256 repaymentChainId;\n    }\n\n    // Packs together parameters emitted in FilledV3Relay because there are too many emitted otherwise.\n    // Similar to V3RelayExecutionParams, these parameters are not used to uniquely identify the deposit being\n    // filled so they don't have to be unpacked by all clients.\n    struct V3RelayExecutionEventInfo {\n        address updatedRecipient;\n        bytes updatedMessage;\n        uint256 updatedOutputAmount;\n        FillType fillType;\n    }\n\n    /**************************************\n     *              EVENTS                *\n     **************************************/\n\n    event V3FundsDeposited(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed destinationChainId,\n        uint32 indexed depositId,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address indexed depositor,\n        address recipient,\n        address exclusiveRelayer,\n        bytes message\n    );\n\n    event RequestedSpeedUpV3Deposit(\n        uint256 updatedOutputAmount,\n        uint32 indexed depositId,\n        address indexed depositor,\n        address updatedRecipient,\n        bytes updatedMessage,\n        bytes depositorSignature\n    );\n\n    event FilledV3Relay(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 repaymentChainId,\n        uint256 indexed originChainId,\n        uint32 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address exclusiveRelayer,\n        address indexed relayer,\n        address depositor,\n        address recipient,\n        bytes message,\n        V3RelayExecutionEventInfo relayExecutionInfo\n    );\n\n    event RequestedV3SlowFill(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed originChainId,\n        uint32 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address exclusiveRelayer,\n        address depositor,\n        address recipient,\n        bytes message\n    );\n\n    /**************************************\n     *              FUNCTIONS             *\n     **************************************/\n\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function speedUpV3Deposit(\n        address depositor,\n        uint32 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function fillV3Relay(V3RelayData calldata relayData, uint256 repaymentChainId) external;\n\n    function fillV3RelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function requestV3SlowFill(V3RelayData calldata relayData) external;\n\n    function executeV3SlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) external;\n\n    /**************************************\n     *              ERRORS                *\n     **************************************/\n\n    error DisabledRoute();\n    error InvalidQuoteTimestamp();\n    error InvalidFillDeadline();\n    error InvalidExclusivityDeadline();\n    error MsgValueDoesNotMatchInputAmount();\n    error NotExclusiveRelayer();\n    error NoSlowFillsInExclusivityWindow();\n    error RelayFilled();\n    error InvalidSlowFillRequest();\n    error ExpiredFillDeadline();\n    error InvalidMerkleProof();\n    error InvalidChainId();\n    error InvalidMerkleLeaf();\n    error ClaimedMerkleLeaf();\n    error InvalidPayoutAdjustmentPct();\n    error WrongERC7683OrderId();\n    error LowLevelCallFailed(bytes data);\n}\n"
    },
    "contracts/libraries/CircleCCTPAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\nlibrary CircleDomainIds {\n    uint32 public constant Ethereum = 0;\n    uint32 public constant Optimism = 2;\n    uint32 public constant Arbitrum = 3;\n    uint32 public constant Base = 6;\n    uint32 public constant Polygon = 7;\n    uint32 public constant DoctorWho = 10;\n    // Use this value for placeholder purposes only for adapters that extend this adapter but haven't yet been\n    // assigned a domain ID by Circle.\n    uint32 public constant UNINITIALIZED = type(uint32).max;\n}\n\n/**\n * @notice Facilitate bridging USDC via Circle's CCTP.\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\n * @custom:security-contact bugs@across.to\n */\nabstract contract CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The domain ID that CCTP will transfer funds to.\n     * @dev This identifier is assigned by Circle and is not related to a chain ID.\n     * @dev Official domain list can be found here: https://developers.circle.com/stablecoins/docs/supported-domains\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable recipientCircleDomainId;\n\n    /**\n     * @notice The official USDC contract address on this chain.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/usdc-on-main-networks\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IERC20 public immutable usdcToken;\n\n    /**\n     * @notice The official Circle CCTP token bridge contract endpoint.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ITokenMessenger public immutable cctpTokenMessenger;\n\n    /**\n     * @notice intiailizes the CircleCCTPAdapter contract.\n     * @param _usdcToken USDC address on the current chain.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP. If the zero address is passed, CCTP bridging will be disabled.\n     * @param _recipientCircleDomainId The domain ID that CCTP will transfer funds to.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        IERC20 _usdcToken,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId\n    ) {\n        usdcToken = _usdcToken;\n        cctpTokenMessenger = _cctpTokenMessenger;\n        recipientCircleDomainId = _recipientCircleDomainId;\n    }\n\n    /**\n     * @notice converts address to bytes32 (alignment preserving cast.)\n     * @param addr the address to convert to bytes32\n     * @dev Sourced from the official CCTP repo: https://github.com/walkerq/evm-cctp-contracts/blob/139d8d0ce3b5531d3c7ec284f89d946dfb720016/src/messages/Message.sol#L142C1-L148C6\n     */\n    function _addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    /**\n     * @notice Returns whether or not the CCTP bridge is enabled.\n     * @dev If the CCTPTokenMessenger is the zero address, CCTP bridging is disabled.\n     */\n    function _isCCTPEnabled() internal view returns (bool) {\n        return address(cctpTokenMessenger) != address(0);\n    }\n\n    /**\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\n     * @param to Address to receive USDC on the new domain.\n     * @param amount Amount of USDC to transfer.\n     */\n    function _transferUsdc(address to, uint256 amount) internal {\n        // Only approve the exact amount to be transferred\n        usdcToken.safeIncreaseAllowance(address(cctpTokenMessenger), amount);\n        // Submit the amount to be transferred to bridged via the TokenMessenger.\n        // If the amount to send exceeds the burn limit per message, then split the message into smaller parts.\n        ITokenMinter cctpMinter = cctpTokenMessenger.localMinter();\n        uint256 burnLimit = cctpMinter.burnLimitsPerMessage(address(usdcToken));\n        uint256 remainingAmount = amount;\n        bytes32 recipient = _addressToBytes32(to);\n        while (remainingAmount > 0) {\n            uint256 partAmount = remainingAmount > burnLimit ? burnLimit : remainingAmount;\n            cctpTokenMessenger.depositForBurn(partAmount, recipientCircleDomainId, recipient, address(usdcToken));\n            remainingAmount -= partAmount;\n        }\n    }\n}\n"
    },
    "contracts/libraries/CrossDomainAddressUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title AddressUtils\n * @notice This library contains internal functions for manipulating addresses.\n */\nlibrary CrossDomainAddressUtils {\n    // L1 addresses are transformed during l1->l2 calls.\n    // This cannot be pulled directly from Arbitrum contracts because their contracts are not 0.8.X compatible and\n    // this operation takes advantage of overflows, whose behavior changed in 0.8.0.\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + uint160(0x1111000000000000000000000000000000001111));\n        }\n    }\n}\n"
    },
    "contracts/Lockable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n * @dev The reason why we use this local contract instead of importing from uma/contracts is because of the addition\n * of the internal method `functionCallStackOriginatesFromOutsideThisContract` which doesn't exist in the one exported\n * by uma/contracts.\n * @custom:security-contact bugs@across.to\n */\ncontract Lockable {\n    bool internal _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a nonReentrant function from another nonReentrant function is not supported. It is possible to\n     * prevent this from happening by making the nonReentrant function external, and making it call a private\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a nonReentrant() state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is currently in a non-entered state, meaning that the origination of the call\n     * came from outside the contract. This is relevant with fallback/receive methods to see if the call came from ETH\n     * being dropped onto the contract externally or due to ETH dropped on the contract from within a method in this\n     * contract, such as unwrapping WETH to ETH within the contract.\n     */\n    function functionCallStackOriginatesFromOutsideThisContract() internal view returns (bool) {\n        return _notEntered;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every nonReentrant() method.\n    // On entry into a function, _preEntranceCheck() should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call _postEntranceSet(), perform its logic, and\n    // then call _postEntranceReset().\n    // View-only methods can simply call _preEntranceCheck() to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "contracts/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"./interfaces/HubPoolInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @notice Library to help with merkle roots, proofs, and claims.\n * @custom:security-contact bugs@across.to\n */\nlibrary MerkleLib {\n    /**\n     * @notice Verifies that a repayment is contained within a merkle root.\n     * @param root the merkle root.\n     * @param rebalance the rebalance struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the pool rebalance proof correctly shows inclusion of the rebalance within the tree.\n     */\n    function verifyPoolRebalance(\n        bytes32 root,\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));\n    }\n\n    /**\n     * @notice Verifies that a relayer refund is contained within a merkle root.\n     * @param root the merkle root.\n     * @param refund the refund struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the relayer refund proof correctly shows inclusion of the refund within the tree.\n     */\n    function verifyRelayerRefund(\n        bytes32 root,\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(refund)));\n    }\n\n    function verifyV3SlowRelayFulfillment(\n        bytes32 root,\n        V3SpokePoolInterface.V3SlowFill memory slowRelayFulfillment,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\n    }\n\n    // The following functions are primarily copied from\n    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.\n\n    /**\n     * @notice Tests whether a claim is contained within a claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to check in the bitmap.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to mark in the bitmap.\n     */\n    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    /**\n     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.\n     * @param index the index to check in the bitmap. Uint8 type enforces that index can't be > 255.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (bool) {\n        uint256 mask = (1 << index);\n        return claimedBitMap & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap. Uint8 type enforces that index\n     * can't be > 255.\n     * @param index the index to mark in the bitmap.\n     * @return uint256 representing the modified input claimedBitMap with the index set to true.\n     */\n    function setClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (uint256) {\n        return claimedBitMap | (1 << index);\n    }\n}\n"
    },
    "contracts/Ovm_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol\";\nimport \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\n\n// https://github.com/ethereum-optimism/optimism/blob/bf51c4935261634120f31827c3910aa631f6bf9c/packages/contracts-bedrock/contracts/L2/L2StandardBridge.sol\ninterface IL2ERC20Bridge {\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable;\n\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external;\n}\n\n/**\n * @notice OVM specific SpokePool. Uses OVM cross-domain-enabled logic to implement admin only access to functions. * Optimism, Base, and Boba each implement this spoke pool and set their chain specific contract addresses for l2Eth and l2Weth.\n * @custom:security-contact bugs@across.to\n */\ncontract Ovm_SpokePool is SpokePool, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    // \"l1Gas\" parameter used in call to bridge tokens from this contract back to L1 via IL2ERC20Bridge. Currently\n    // unused by bridge but included for future compatibility.\n    uint32 public l1Gas;\n\n    // ETH is an ERC20 on OVM.\n    address public l2Eth;\n\n    // Address of the Optimism L2 messenger.\n    address public constant MESSENGER = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n    // @dev This storage slot is reserved to replace the old messenger public variable that has now been\n    // replaced by the above constant.\n    address private __deprecated_messenger;\n\n    // Stores alternative token bridges to use for L2 tokens that don't go over the standard bridge. This is needed\n    // to support non-standard ERC20 tokens on Optimism, such as DAI which uses a custom bridge with the same\n    // interface as the standard bridge.\n    mapping(address => address) public tokenBridges;\n\n    // Stores mapping of L2 tokens to L1 equivalent tokens. If a mapping is defined for a given L2 token, then\n    // the mapped L1 token can be used in _bridgeTokensToHubPool which can then call bridgeERC20To, which\n    // requires specfiying an L1 token.\n    mapping(address => address) public remoteL1Tokens;\n\n    event SetL1Gas(uint32 indexed newL1Gas);\n    event SetL2TokenBridge(address indexed l2Token, address indexed tokenBridge);\n    event SetRemoteL1Token(address indexed l2Token, address indexed l1Token);\n\n    error NotCrossDomainAdmin();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the OVM SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     * @param _l2Eth Address of L2 ETH token. Usually should be Lib_PreeployAddresses.OVM_ETH but sometimes this can\n     * be different, like with Boba which flips the WETH and OVM_ETH addresses.\n     */\n    function __OvmSpokePool_init(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient,\n        address _l2Eth\n    ) public onlyInitializing {\n        l1Gas = 5_000_000;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        //slither-disable-next-line missing-zero-check\n        l2Eth = _l2Eth;\n    }\n\n    /*******************************************\n     *    OPTIMISM-SPECIFIC ADMIN FUNCTIONS    *\n     *******************************************/\n\n    /**\n     * @notice Change L1 gas limit. Callable only by admin.\n     * @param newl1Gas New L1 gas limit to set.\n     */\n    function setL1GasLimit(uint32 newl1Gas) public onlyAdmin nonReentrant {\n        l1Gas = newl1Gas;\n        emit SetL1Gas(newl1Gas);\n    }\n\n    function setRemoteL1Token(address l2Token, address l1Token) public onlyAdmin nonReentrant {\n        remoteL1Tokens[l2Token] = l1Token;\n        emit SetRemoteL1Token(l2Token, l1Token);\n    }\n\n    /**\n     * @notice Set bridge contract for L2 token used to withdraw back to L1.\n     * @dev If this mapping isn't set for an L2 token, then the standard bridge will be used to bridge this token.\n     * @param tokenBridge Address of token bridge\n     */\n    function setTokenBridge(address l2Token, address tokenBridge) public onlyAdmin nonReentrant {\n        tokenBridges[l2Token] = tokenBridge;\n        emit SetL2TokenBridge(l2Token, tokenBridge);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Wraps any ETH into WETH before executing leaves. This is necessary because SpokePool receives\n     * ETH over the canonical token bridge instead of WETH.\n     */\n    function _preExecuteLeafHook(address l2TokenAddress) internal override {\n        if (l2TokenAddress == address(wrappedNativeToken)) _depositEthToWeth();\n    }\n\n    // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is necessary because\n    // this SpokePool will receive ETH from the canonical token bridge instead of WETH. Its not sufficient to execute\n    // this logic inside a fallback method that executes when this contract receives ETH because ETH is an ERC20\n    // on the OVM.\n    function _depositEthToWeth() internal {\n        //slither-disable-next-line arbitrary-send-eth\n        if (address(this).balance > 0) wrappedNativeToken.deposit{ value: address(this).balance }();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual override {\n        // If the token being bridged is WETH then we need to first unwrap it to ETH and then send ETH over the\n        // canonical bridge. On Optimism, this is address 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n        if (l2TokenAddress == address(wrappedNativeToken)) {\n            WETH9Interface(l2TokenAddress).withdraw(amountToReturn); // Unwrap into ETH.\n            l2TokenAddress = l2Eth; // Set the l2TokenAddress to ETH.\n            IL2ERC20Bridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo{ value: amountToReturn }(\n                l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                amountToReturn, // _amount.\n                l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n        // If the token is USDC && CCTP bridge is enabled, then bridge USDC via CCTP.\n        else if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        }\n        // Note we'll default to withdrawTo instead of bridgeERC20To unless the remoteL1Tokens mapping is set for\n        // the l2TokenAddress. withdrawTo should be used to bridge back non-native L2 tokens\n        // (i.e. non-native L2 tokens have a canonical L1 token). If we should bridge \"native L2\" tokens then\n        // we'd need to call bridgeERC20To and give allowance to the tokenBridge to spend l2Token from this contract.\n        // Therefore for native tokens we should set ensure that remoteL1Tokens is set for the l2TokenAddress.\n        else {\n            IL2ERC20Bridge tokenBridge = IL2ERC20Bridge(\n                tokenBridges[l2TokenAddress] == address(0)\n                    ? Lib_PredeployAddresses.L2_STANDARD_BRIDGE\n                    : tokenBridges[l2TokenAddress]\n            );\n            if (remoteL1Tokens[l2TokenAddress] != address(0)) {\n                // If there is a mapping for this L2 token to an L1 token, then use the L1 token address and\n                // call bridgeERC20To.\n                IERC20(l2TokenAddress).safeIncreaseAllowance(address(tokenBridge), amountToReturn);\n                address remoteL1Token = remoteL1Tokens[l2TokenAddress];\n                tokenBridge.bridgeERC20To(\n                    l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                    remoteL1Token, // Remote token to be received on L1 side. If the\n                    // remoteL1Token on the other chain does not recognize the local token as the correct\n                    // pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n                    // this chain.\n                    withdrawalRecipient, // _to\n                    amountToReturn, // _amount\n                    l1Gas, // _l1Gas\n                    \"\" // _data\n                );\n            } else {\n                tokenBridge.withdrawTo(\n                    l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                    withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                    amountToReturn, // _amount.\n                    l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                    \"\" // _data. We don't need to send any data for the bridging action.\n                );\n            }\n        }\n    }\n\n    // Apply OVM-specific transformation to cross domain admin address on L1.\n    function _requireAdminSender() internal view override {\n        if (LibOptimismUpgradeable.crossChainSender(MESSENGER) != crossDomainAdmin) revert NotCrossDomainAdmin();\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure its always at the end of storage.\n    uint256[999] private __gap;\n}\n"
    },
    "contracts/Polygon_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./PolygonTokenBridger.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\n\n/**\n * @notice IFxMessageProcessor represents interface to process messages.\n */\ninterface IFxMessageProcessor {\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @notice Polygon specific SpokePool.\n * @custom:security-contact bugs@across.to\n */\ncontract Polygon_SpokePool is IFxMessageProcessor, SpokePool, CircleCCTPAdapter {\n    using SafeERC20Upgradeable for PolygonIERC20Upgradeable;\n\n    // Address of FxChild which sends and receives messages to and from L1.\n    address public fxChild;\n\n    // Contract deployed on L1 and L2 processes all cross-chain transfers between this contract and the HubPool.\n    // Required because bridging tokens from Polygon to Ethereum has special constraints.\n    PolygonTokenBridger public polygonTokenBridger;\n\n    // Internal variable that only flips temporarily to true upon receiving messages from L1. Used to authenticate that\n    // the caller is the fxChild AND that the fxChild called processMessageFromRoot\n    bool private callValidated;\n\n    error MulticallExecuteLeaf();\n\n    event SetFxChild(address indexed newFxChild);\n    event SetPolygonTokenBridger(address indexed polygonTokenBridger);\n    event ReceivedMessageFromL1(address indexed caller, address indexed rootMessageSender);\n\n    error CallValidatedAlreadySet();\n    error CallValidatedNotSet();\n    error DelegateCallFailed();\n    error NotHubPool();\n    error NotFxChild();\n\n    // Note: validating calls this way ensures that strange calls coming from the fxChild won't be misinterpreted.\n    // Put differently, just checking that msg.sender == fxChild is not sufficient.\n    // All calls that have admin privileges must be fired from within the processMessageFromRoot method that's gone\n    // through validation where the sender is checked and the root (mainnet) sender is also validated.\n    // This modifier sets the callValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure callValidated is set to True only once at beginning of processMessageFromRoot, which prevents\n        // processMessageFromRoot from being re-entered.\n        if (callValidated) revert CallValidatedAlreadySet();\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed. See comment for `_requireAdminSender` for more details.\n        callValidated = true;\n\n        _;\n\n        // Reset callValidated to false to disallow admin calls after this method exits.\n        callValidated = false;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Polygon SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _polygonTokenBridger Token routing contract that sends tokens from here to HubPool. Changeable by Admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     * @param _fxChild FxChild contract, changeable by Admin.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        PolygonTokenBridger _polygonTokenBridger,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient,\n        address _fxChild\n    ) public initializer {\n        callValidated = false;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setPolygonTokenBridger(payable(_polygonTokenBridger));\n        //slither-disable-next-line missing-zero-check\n        _setFxChild(_fxChild);\n    }\n\n    /********************************************************\n     *    POLYGON-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change FxChild address. Callable only by admin via processMessageFromRoot.\n     * @param newFxChild New FxChild.\n     */\n    function setFxChild(address newFxChild) public onlyAdmin nonReentrant {\n        _setFxChild(newFxChild);\n    }\n\n    /**\n     * @notice Change polygonTokenBridger address. Callable only by admin via processMessageFromRoot.\n     * @param newPolygonTokenBridger New Polygon Token Bridger contract.\n     */\n    function setPolygonTokenBridger(address payable newPolygonTokenBridger) public onlyAdmin nonReentrant {\n        _setPolygonTokenBridger(newPolygonTokenBridger);\n    }\n\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(\n        uint256, /*stateId*/\n        address rootMessageSender,\n        bytes calldata data\n    ) public validateInternalCalls {\n        // Validation logic.\n        if (msg.sender != fxChild) revert NotFxChild();\n        if (rootMessageSender != crossDomainAdmin) revert NotHubPool();\n\n        // This uses delegatecall to take the information in the message and process it as a function call on this contract.\n        /// This is a safe delegatecall because its made to address(this) so there is no risk of delegating to a\n        /// selfdestruct().\n        //slither-disable-start low-level-calls\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(data);\n        //slither-disable-end low-level-calls\n        if (!success) revert DelegateCallFailed();\n\n        emit ReceivedMessageFromL1(msg.sender, rootMessageSender);\n    }\n\n    /**\n     * @notice Allows the caller to trigger the wrapping of any unwrapped matic tokens.\n     * @dev Unlike other ERC20 transfers, Matic transfers from L1 -> L2 bridging don't result in an L2 call into\n     * the contract receiving the tokens, so wrapping must be done via a separate transaction. In other words,\n     * we can't rely upon a `fallback()` method being triggered to wrap MATIC upon receiving it.\n     */\n    function wrap() public nonReentrant {\n        _wrap();\n    }\n\n    /**\n     * @notice Override multicall so that it cannot include executeRelayerRefundLeaf\n     * as one of the calls combined with other public function calls.\n     * @dev Multicalling a single transaction will always succeed.\n     * @dev Multicalling execute functions without combining other public function calls will succeed.\n     * @dev Multicalling public function calls without combining execute functions will succeed.\n     */\n    function _validateMulticallData(bytes[] calldata data) internal pure override {\n        bool hasOtherPublicFunctionCall = false;\n        bool hasExecutedLeafCall = false;\n        for (uint256 i = 0; i < data.length; i++) {\n            bytes4 selector = bytes4(data[i][:4]);\n            if (selector == SpokePoolInterface.executeRelayerRefundLeaf.selector) {\n                if (hasOtherPublicFunctionCall) revert MulticallExecuteLeaf();\n                hasExecutedLeafCall = true;\n            } else {\n                if (hasExecutedLeafCall) revert MulticallExecuteLeaf();\n                hasOtherPublicFunctionCall = true;\n            }\n        }\n    }\n\n    /**\n     * @notice This function can send an L2 to L1 message so we are extra cautious about preventing a griefing vector\n     * whereby someone batches this call with a bunch of other calls and produces a very large L2 burn transaction.\n     * This might make the L2 -> L1 message fail due to exceeding the L1 calldata limit.\n     */\n\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable override {\n        // AddressLibUpgradeable.isContract isn't a sufficient check because it checks the contract code size of\n        // msg.sender which is 0 if called from a constructor function on msg.sender. This is why we check if\n        // msg.sender is equal to tx.origin which is fine as long as Polygon supports the tx.origin opcode.\n        // solhint-disable-next-line avoid-tx-origin\n        if (relayerRefundLeaf.amountToReturn > 0 && msg.sender != tx.origin) revert NotEOA();\n        super.executeRelayerRefundLeaf(rootBundleId, relayerRefundLeaf, proof);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _setFxChild(address _fxChild) internal {\n        //slither-disable-next-line missing-zero-check\n        fxChild = _fxChild;\n        emit SetFxChild(_fxChild);\n    }\n\n    function _setPolygonTokenBridger(address payable _polygonTokenBridger) internal {\n        polygonTokenBridger = PolygonTokenBridger(_polygonTokenBridger);\n        emit SetPolygonTokenBridger(address(_polygonTokenBridger));\n    }\n\n    function _preExecuteLeafHook(address) internal override {\n        // Wraps MATIC --> WMATIC before distributing tokens from this contract.\n        _wrap();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // If the token is USDC, we need to use the CCTP bridge to transfer it to the hub pool.\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        } else {\n            PolygonIERC20Upgradeable(l2TokenAddress).safeIncreaseAllowance(\n                address(polygonTokenBridger),\n                amountToReturn\n            );\n            // Note: WrappedNativeToken is WMATIC on matic, so this tells the tokenbridger that this is an unwrappable native token.\n            polygonTokenBridger.send(PolygonIERC20Upgradeable(l2TokenAddress), amountToReturn);\n        }\n    }\n\n    function _wrap() internal {\n        uint256 balance = address(this).balance;\n        //slither-disable-next-line arbitrary-send-eth\n        if (balance > 0) wrappedNativeToken.deposit{ value: balance }();\n    }\n\n    // @dev: This contract will trigger admin functions internally via the `processMessageFromRoot`, which is why\n    // the `callValidated` check is made below  and why we use the `validateInternalCalls` modifier on\n    // `processMessageFromRoot`. This prevents calling the admin functions from any other method besides\n    // `processMessageFromRoot`.\n    function _requireAdminSender() internal view override {\n        if (!callValidated) revert CallValidatedNotSet();\n    }\n}\n"
    },
    "contracts/PolygonTokenBridger.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Lockable.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n// Polygon Registry contract that stores their addresses.\ninterface PolygonRegistry {\n    function erc20Predicate() external returns (address);\n}\n\n// Polygon ERC20Predicate contract that handles Plasma exits (only used for Matic).\ninterface PolygonERC20Predicate {\n    function startExitWithBurntTokens(bytes calldata data) external;\n}\n\n// ERC20s (on polygon) compatible with polygon's bridge have a withdraw method.\ninterface PolygonIERC20Upgradeable is IERC20Upgradeable {\n    function withdraw(uint256 amount) external;\n}\n\ninterface MaticToken {\n    function withdraw(uint256 amount) external payable;\n}\n\n/**\n * @notice Contract deployed on Ethereum and Polygon to facilitate token transfers from Polygon to the HubPool and back.\n * @dev Because Polygon only allows withdrawals from a particular address to go to that same address on mainnet, we need to\n * have some sort of contract that can guarantee identical addresses on Polygon and Ethereum. This contract is intended\n * to be completely immutable, so it's guaranteed that the contract on each side is  configured identically as long as\n * it is created via create2. create2 is an alternative creation method that uses a different address determination\n * mechanism from normal create.\n * Normal create: address = hash(deployer_address, deployer_nonce)\n * create2:       address = hash(0xFF, sender, salt, bytecode)\n *  This ultimately allows create2 to generate deterministic addresses that don't depend on the transaction count of the\n * sender.\n * @custom:security-contact bugs@across.to\n */\ncontract PolygonTokenBridger is Lockable {\n    using SafeERC20Upgradeable for PolygonIERC20Upgradeable;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Gas token for Polygon.\n    MaticToken public constant MATIC = MaticToken(0x0000000000000000000000000000000000001010);\n\n    // Should be set to HubPool on Ethereum, or unused on Polygon.\n    address public immutable destination;\n\n    // Registry that stores L1 polygon addresses.\n    PolygonRegistry public immutable l1PolygonRegistry;\n\n    // WETH contract on Ethereum.\n    WETH9Interface public immutable l1Weth;\n\n    // Wrapped Matic on Polygon\n    address public immutable l2WrappedMatic;\n\n    // Chain id for the L1 that this contract is deployed on or communicates with.\n    // For example: if this contract were meant to facilitate transfers from polygon to mainnet, this value would be\n    // the mainnet chainId 1.\n    uint256 public immutable l1ChainId;\n\n    // Chain id for the L2 that this contract is deployed on or communicates with.\n    // For example: if this contract were meant to facilitate transfers from polygon to mainnet, this value would be\n    // the polygon chainId 137.\n    uint256 public immutable l2ChainId;\n\n    modifier onlyChainId(uint256 chainId) {\n        _requireChainId(chainId);\n        _;\n    }\n\n    /**\n     * @notice Constructs Token Bridger contract.\n     * @param _destination Where to send tokens to for this network.\n     * @param _l1PolygonRegistry L1 registry that stores updated addresses of polygon contracts. This should always be\n     * set to the L1 registry regardless if whether it's deployed on L2 or L1.\n     * @param _l1Weth L1 WETH address.\n     * @param _l2WrappedMatic L2 address of wrapped matic token.\n     * @param _l1ChainId the chain id for the L1 in this environment.\n     * @param _l2ChainId the chain id for the L2 in this environment.\n     */\n    constructor(\n        address _destination,\n        PolygonRegistry _l1PolygonRegistry,\n        WETH9Interface _l1Weth,\n        address _l2WrappedMatic,\n        uint256 _l1ChainId,\n        uint256 _l2ChainId\n    ) {\n        //slither-disable-next-line missing-zero-check\n        destination = _destination;\n        l1PolygonRegistry = _l1PolygonRegistry;\n        l1Weth = _l1Weth;\n        //slither-disable-next-line missing-zero-check\n        l2WrappedMatic = _l2WrappedMatic;\n        l1ChainId = _l1ChainId;\n        l2ChainId = _l2ChainId;\n    }\n\n    /**\n     * @notice Called by Polygon SpokePool to send tokens over bridge to contract with the same address as this.\n     * @notice The caller of this function must approve this contract to spend amount of token.\n     * @param token Token to bridge.\n     * @param amount Amount to bridge.\n     */\n    function send(PolygonIERC20Upgradeable token, uint256 amount) public nonReentrant onlyChainId(l2ChainId) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // In the wMatic case, this unwraps. For other ERC20s, this is the burn/send action.\n        token.withdraw(token.balanceOf(address(this)));\n\n        // This takes the token that was withdrawn and calls withdraw on the \"native\" ERC20.\n        if (address(token) == l2WrappedMatic) MATIC.withdraw{ value: address(this).balance }(address(this).balance);\n    }\n\n    /**\n     * @notice Called by someone to send tokens to the destination, which should be set to the HubPool.\n     * @param token Token to send to destination.\n     */\n    function retrieve(IERC20Upgradeable token) public nonReentrant onlyChainId(l1ChainId) {\n        if (address(token) == address(l1Weth)) {\n            // For WETH, there is a pre-deposit step to ensure any ETH that has been sent to the contract is captured.\n            //slither-disable-next-line arbitrary-send-eth\n            l1Weth.deposit{ value: address(this).balance }();\n        }\n        token.safeTransfer(destination, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Called to initiate an l1 exit (withdrawal) of matic tokens that have been sent over the plasma bridge.\n     * @param data the proof data to trigger the exit. Can be generated using the maticjs-plasma package.\n     */\n    function callExit(bytes memory data) public nonReentrant onlyChainId(l1ChainId) {\n        PolygonERC20Predicate erc20Predicate = PolygonERC20Predicate(l1PolygonRegistry.erc20Predicate());\n        erc20Predicate.startExitWithBurntTokens(data);\n    }\n\n    receive() external payable {\n        // This method is empty to avoid any gas expendatures that might cause transfers to fail.\n        // Note: the fact that there is _no_ code in this function means that matic can be erroneously transferred in\n        // to the contract on the polygon side. These tokens would be locked indefinitely since the receive function\n        // cannot be called on the polygon side. While this does have some downsides, the lack of any functionality\n        // in this function means that it has no chance of running out of gas on transfers, which is a much more\n        // important benefit. This just makes the matic token risk similar to that of ERC20s that are erroneously\n        // sent to the contract.\n    }\n\n    function _requireChainId(uint256 chainId) internal view {\n        require(block.chainid == chainId, \"Cannot run method on this chain\");\n    }\n}\n"
    },
    "contracts/SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MerkleLib.sol\";\nimport \"./erc7683/ERC7683.sol\";\nimport \"./erc7683/ERC7683Permit2Lib.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolMessageHandler.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"./upgradeable/MultiCallerUpgradeable.sol\";\nimport \"./upgradeable/EIP712CrossChainUpgradeable.sol\";\nimport \"./upgradeable/AddressLibUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title SpokePool\n * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.\n * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a \"data worker\",\n * submits a proof that the relayer correctly submitted a relay on this SpokePool.\n * @custom:security-contact bugs@across.to\n */\nabstract contract SpokePool is\n    V3SpokePoolInterface,\n    SpokePoolInterface,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    MultiCallerUpgradeable,\n    EIP712CrossChainUpgradeable,\n    IDestinationSettler\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressLibUpgradeable for address;\n\n    // Address of the L1 contract that acts as the owner of this SpokePool. This should normally be set to the HubPool\n    // address. The crossDomainAdmin address is unused when the SpokePool is deployed to the same chain as the HubPool.\n    address public crossDomainAdmin;\n\n    // Address of the L1 contract that will send tokens to and receive tokens from this contract to fund relayer\n    // refunds and slow relays.\n    address public withdrawalRecipient;\n\n    // Note: The following two storage variables prefixed with DEPRECATED used to be variables that could be set by\n    // the cross-domain admin. Admins ended up not changing these in production, so to reduce\n    // gas in deposit/fill functions, we are converting them to private variables to maintain the contract\n    // storage layout and replacing them with immutable or constant variables, because retrieving a constant\n    // value is cheaper than retrieving a storage variable. Please see out the immutable/constant variable section.\n    WETH9Interface private DEPRECATED_wrappedNativeToken;\n    uint32 private DEPRECATED_depositQuoteTimeBuffer;\n\n    // Count of deposits is used to construct a unique deposit identifier for this spoke pool.\n    uint32 public numberOfDeposits;\n\n    // Whether deposits and fills are disabled.\n    bool public pausedFills;\n    bool public pausedDeposits;\n\n    // This contract can store as many root bundles as the HubPool chooses to publish here.\n    RootBundle[] public rootBundles;\n\n    // Origin token to destination token routings can be turned on or off, which can enable or disable deposits.\n    mapping(address => mapping(uint256 => bool)) public enabledDepositRoutes;\n\n    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay\n    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to\n    // relay, the fees, and the agents are all parameters included in the hash key.\n    mapping(bytes32 => uint256) private DEPRECATED_relayFills;\n\n    // Note: We will likely un-deprecate the fill and deposit counters to implement a better\n    // dynamic LP fee mechanism but for now we'll deprecate it to reduce bytecode\n    // in deposit/fill functions. These counters are designed to implement a fee mechanism that is based on a\n    // canonical history of deposit and fill events and how they update a virtual running balance of liabilities and\n    // assets, which then determines the LP fee charged to relays.\n\n    // This keeps track of the worst-case liabilities due to fills.\n    // It is never reset. Users should only rely on it to determine the worst-case increase in liabilities between\n    // two points. This is used to provide frontrunning protection to ensure the relayer's assumptions about the state\n    // upon which their expected repayments are based will not change before their transaction is mined.\n    mapping(address => uint256) private DEPRECATED_fillCounter;\n\n    // This keeps track of the total running deposits for each token. This allows depositors to protect themselves from\n    // frontrunning that might change their worst-case quote.\n    mapping(address => uint256) private DEPRECATED_depositCounter;\n\n    // This tracks the number of identical refunds that have been requested.\n    // The intention is to allow an off-chain system to know when this could be a duplicate and ensure that the other\n    // requests are known and accounted for.\n    mapping(bytes32 => uint256) private DEPRECATED_refundsRequested;\n\n    // Mapping of V3 relay hashes to fill statuses. Distinguished from relayFills\n    // to eliminate any chance of collision between pre and post V3 relay hashes.\n    mapping(bytes32 => uint256) public fillStatuses;\n\n    /**************************************************************\n     *                CONSTANT/IMMUTABLE VARIABLES                *\n     **************************************************************/\n    // Constant and immutable variables do not take up storage slots and are instead added to the contract bytecode\n    // at compile time. The difference between them is that constant variables must be declared inline, meaning\n    // that they cannot be changed in production without changing the contract code, while immutable variables\n    // can be set in the constructor. Therefore we use the immutable keyword for variables that we might want to be\n    // different for each child contract (one obvious example of this is the wrappedNativeToken) or that we might\n    // want to update in the future like depositQuoteTimeBuffer. Constants are unlikely to ever be changed.\n\n    // Address of wrappedNativeToken contract for this network. If an origin token matches this, then the caller can\n    // optionally instruct this contract to wrap native tokens when depositing (ie ETH->WETH or MATIC->WMATIC).\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    WETH9Interface public immutable wrappedNativeToken;\n\n    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces\n    // caller to use an approximately \"current\" realized fee.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable depositQuoteTimeBuffer;\n\n    // The fill deadline can only be set this far into the future from the timestamp of the deposit on this contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable fillDeadlineBuffer;\n\n    uint256 public constant MAX_TRANSFER_SIZE = 1e36;\n\n    bytes32 public constant UPDATE_V3_DEPOSIT_DETAILS_HASH =\n        keccak256(\n            \"UpdateDepositDetails(uint32 depositId,uint256 originChainId,uint256 updatedOutputAmount,address updatedRecipient,bytes updatedMessage)\"\n        );\n\n    // Default chain Id used to signify that no repayment is requested, for example when executing a slow fill.\n    uint256 public constant EMPTY_REPAYMENT_CHAIN_ID = 0;\n    // Default address used to signify that no relayer should be credited with a refund, for example\n    // when executing a slow fill.\n    address public constant EMPTY_RELAYER = address(0);\n    // This is the magic value that signals to the off-chain validator\n    // that this deposit can never expire. A deposit with this fill deadline should always be eligible for a\n    // slow fill, meaning that its output token and input token must be \"equivalent\". Therefore, this value is only\n    // used as a fillDeadline in deposit(), a soon to be deprecated function that also hardcodes outputToken to\n    // the zero address, which forces the off-chain validator to replace the output token with the equivalent\n    // token for the input token. By using this magic value, off-chain validators do not have to keep\n    // this event in their lookback window when querying for expired deposts.\n    uint32 public constant INFINITE_FILL_DEADLINE = type(uint32).max;\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n    event SetXDomainAdmin(address indexed newAdmin);\n    event SetWithdrawalRecipient(address indexed newWithdrawalRecipient);\n    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);\n    event RelayedRootBundle(\n        uint32 indexed rootBundleId,\n        bytes32 indexed relayerRefundRoot,\n        bytes32 indexed slowRelayRoot\n    );\n    event ExecutedRelayerRefundRoot(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint256[] refundAmounts,\n        uint32 indexed rootBundleId,\n        uint32 indexed leafId,\n        address l2TokenAddress,\n        address[] refundAddresses,\n        address caller\n    );\n    event TokensBridged(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint32 indexed leafId,\n        address indexed l2TokenAddress,\n        address caller\n    );\n    event EmergencyDeleteRootBundle(uint256 indexed rootBundleId);\n    event PausedDeposits(bool isPaused);\n    event PausedFills(bool isPaused);\n\n    /**\n     * @notice Construct the SpokePool. Normally, logic contracts used in upgradeable proxies shouldn't\n     * have constructors since the following code will be executed within the logic contract's state, not the\n     * proxy contract's state. However, if we restrict the constructor to setting only immutable variables, then\n     * we are safe because immutable variables are included in the logic contract's bytecode rather than its storage.\n     * @dev Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be\n     * taken over by an attacker, which may impact the proxy. To prevent the implementation contract from being\n     * used, you should invoke the _disableInitializers function in the constructor to automatically lock it when\n     * it is deployed:\n     * @param _wrappedNativeTokenAddress wrappedNativeToken address for this network to set.\n     * @param _depositQuoteTimeBuffer depositQuoteTimeBuffer to set. Quote timestamps can't be set more than this amount\n     * into the past from the block time of the deposit.\n     * @param _fillDeadlineBuffer fillDeadlineBuffer to set. Fill deadlines can't be set more than this amount\n     * into the future from the block time of the deposit.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    ) {\n        wrappedNativeToken = WETH9Interface(_wrappedNativeTokenAddress);\n        depositQuoteTimeBuffer = _depositQuoteTimeBuffer;\n        fillDeadlineBuffer = _fillDeadlineBuffer;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Construct the base SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function __SpokePool_init(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public onlyInitializing {\n        numberOfDeposits = _initialDepositId;\n        __EIP712_init(\"ACROSS-V2\", \"1.0.0\");\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n        _setWithdrawalRecipient(_withdrawalRecipient);\n    }\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     * @dev This should be set to cross domain admin for specific SpokePool.\n     */\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    modifier unpausedDeposits() {\n        if (pausedDeposits) revert DepositsArePaused();\n        _;\n    }\n\n    modifier unpausedFills() {\n        if (pausedFills) revert FillsArePaused();\n        _;\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    // Allows cross domain admin to upgrade UUPS proxy implementation.\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {}\n\n    /**\n     * @notice Pauses deposit-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects `deposit()` but not `speedUpV3Deposit()`, so that existing deposits can be sped up and still\n     * relayed.\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseDeposits(bool pause) public override onlyAdmin nonReentrant {\n        pausedDeposits = pause;\n        emit PausedDeposits(pause);\n    }\n\n    /**\n     * @notice Pauses fill-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects fillRelayWithUpdatedDeposit() and fillRelay().\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseFills(bool pause) public override onlyAdmin nonReentrant {\n        pausedFills = pause;\n        emit PausedFills(pause);\n    }\n\n    /**\n     * @notice Change cross domain admin address. Callable by admin only.\n     * @param newCrossDomainAdmin New cross domain admin.\n     */\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyAdmin nonReentrant {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    /**\n     * @notice Change L1 withdrawal recipient address. Callable by admin only.\n     * @param newWithdrawalRecipient New withdrawal recipient address.\n     */\n    function setWithdrawalRecipient(address newWithdrawalRecipient) public override onlyAdmin nonReentrant {\n        _setWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    /**\n     * @notice Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only.\n     * @param originToken Token that depositor can deposit to this contract.\n     * @param destinationChainId Chain ID for where depositor wants to receive funds.\n     * @param enabled True to enable deposits, False otherwise.\n     */\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enabled\n    ) public override onlyAdmin nonReentrant {\n        enabledDepositRoutes[originToken][destinationChainId] = enabled;\n        emit EnabledDepositRoute(originToken, destinationChainId, enabled);\n    }\n\n    /**\n     * @notice This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill\n     * slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is\n     * designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\n     * @param relayerRefundRoot Merkle root containing relayer refund leaves that can be individually executed via\n     * executeRelayerRefundLeaf().\n     * @param slowRelayRoot Merkle root containing slow relay fulfillment leaves that can be individually executed via\n     * executeSlowRelayLeaf().\n     */\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) public override onlyAdmin nonReentrant {\n        uint32 rootBundleId = uint32(rootBundles.length);\n        RootBundle storage rootBundle = rootBundles.push();\n        rootBundle.relayerRefundRoot = relayerRefundRoot;\n        rootBundle.slowRelayRoot = slowRelayRoot;\n        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayRoot);\n    }\n\n    /**\n     * @notice This method is intended to only be used in emergencies where a bad root bundle has reached the\n     * SpokePool.\n     * @param rootBundleId Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256\n     * to ensure that a small input range doesn't limit which indices this method is able to reach.\n     */\n    function emergencyDeleteRootBundle(uint256 rootBundleId) public override onlyAdmin nonReentrant {\n        // Deleting a struct containing a mapping does not delete the mapping in Solidity, therefore the bitmap's\n        // data will still remain potentially leading to vulnerabilities down the line. The way around this would\n        // be to iterate through every key in the mapping and resetting the value to 0, but this seems expensive and\n        // would require a new list in storage to keep track of keys.\n        //slither-disable-next-line mapping-deletion\n        delete rootBundles[rootBundleId];\n        emit EmergencyDeleteRootBundle(rootBundleId);\n    }\n\n    /**************************************\n     *    LEGACY DEPOSITOR FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock\n     * tokens in this contract and receive a destination token on the destination chain. The origin => destination\n     * token mapping is stored on the L1 HubPool.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @dev Produces a V3FundsDeposited event with an infinite expiry, meaning that this deposit can never expire.\n     * Moreover, the event's outputToken is set to 0x0 meaning that this deposit can always be slow filled.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function deposit(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable override nonReentrant unpausedDeposits {\n        _deposit(\n            msg.sender,\n            recipient,\n            originToken,\n            amount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message\n        );\n    }\n\n    /**\n     * @notice The only difference between depositFor and deposit is that the depositor address stored\n     * in the relay hash can be overridden by the caller. This means that the passed in depositor\n     * can speed up the deposit, which is useful if the deposit is taken from the end user to a middle layer\n     * contract, like an aggregator or the SpokePoolVerifier, before calling deposit on this contract.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @param depositor Address who is credited for depositing funds on origin chain and can speed up the deposit.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function depositFor(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable nonReentrant unpausedDeposits {\n        _deposit(depositor, recipient, originToken, amount, destinationChainId, relayerFeePct, quoteTimestamp, message);\n    }\n\n    /********************************************\n     *            DEPOSITOR FUNCTIONS           *\n     ********************************************/\n\n    /**\n     * @notice Previously, this function allowed the caller to specify the exclusivityDeadline, otherwise known as the\n     * as exact timestamp on the destination chain before which only the exclusiveRelayer could fill the deposit. Now,\n     * the caller is expected to pass in an exclusivityPeriod which is the number of seconds to be added to the\n     * block.timestamp to produce the exclusivityDeadline. This allows the caller to ignore any latency associated\n     * with this transaction being mined and propagating this transaction to the miner.\n     * @notice Request to bridge input token cross chain to a destination chain and receive a specified amount\n     * of output tokens. The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs,\n     * the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and the system fee that they'll be charged.\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, less a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp. This must be a valid, non-zero address if the exclusivity deadline is\n     * greater than the current block.timestamp. If the exclusivity deadline is < currentTime, then this must be\n     * address(0), and vice versa if this is address(0).\n     * @param quoteTimestamp The HubPool timestamp that is used to determine the system fee paid by the depositor.\n     *  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp,\n     * the fill will revert on the destination chain. Must be set between [currentTime, currentTime + fillDeadlineBuffer]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param exclusivityPeriod Added to the current time to set the exclusive relayer deadline,\n     * which is the deadline for the exclusiveRelayer to fill the deposit. After this destination chain timestamp,\n     * anyone can fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityPeriod,\n        bytes calldata message\n    ) public payable override nonReentrant unpausedDeposits {\n        // Check that deposit route is enabled for the input token. There are no checks required for the output token\n        // which is pulled from the relayer at fill time and passed through this contract atomically to the recipient.\n        if (!enabledDepositRoutes[inputToken][destinationChainId]) revert DisabledRoute();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits/fills if this is undesirable.\n        // This will underflow if quoteTimestamp is more than depositQuoteTimeBuffer;\n        // this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        uint256 currentTime = getCurrentTime();\n        if (currentTime - quoteTimestamp > depositQuoteTimeBuffer) revert InvalidQuoteTimestamp();\n\n        // fillDeadline is relative to the destination chain.\n        // Dont allow fillDeadline to be more than several bundles into the future.\n        // This limits the maximum required lookback for dataworker and relayer instances.\n        // Also, don't allow fillDeadline to be in the past. This poses a potential UX issue if the destination\n        // chain time keeping and this chain's time keeping are out of sync but is not really a practical hurdle\n        // unless they are significantly out of sync or the depositor is setting very short fill deadlines. This latter\n        // situation won't be a problem for honest users.\n        if (fillDeadline < currentTime || fillDeadline > currentTime + fillDeadlineBuffer) revert InvalidFillDeadline();\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending the native token. In this case, the native token should be\n        // wrapped.\n        if (inputToken == address(wrappedNativeToken) && msg.value > 0) {\n            if (msg.value != inputAmount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the caller as per normal.\n            // Note: this includes the case where the L2 caller has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else {\n            // msg.value should be 0 if input token isn't the wrapped native token.\n            if (msg.value != 0) revert MsgValueDoesNotMatchInputAmount();\n            IERC20Upgradeable(inputToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n\n        emit V3FundsDeposited(\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            // Increment count of deposits so that deposit ID for this spoke pool is unique.\n            numberOfDeposits++,\n            quoteTimestamp,\n            fillDeadline,\n            uint32(currentTime) + exclusivityPeriod,\n            depositor,\n            recipient,\n            exclusiveRelayer,\n            message\n        );\n    }\n\n    /**\n     * @notice Submits deposit and sets quoteTimestamp to current Time. Sets fill and exclusivity\n     * deadlines as offsets added to the current time. This function is designed to be called by users\n     * such as Multisig contracts who do not have certainty when their transaction will mine.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline, which is the deadline for the\n     * relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the\n     * destination chain.\n     * @param exclusivityPeriod Added to the current time to set the exclusive relayer deadline,\n     * which is the deadline for the exclusiveRelayer to fill the deposit. After this destination chain timestamp,\n     * anyone can fill the deposit up to the fillDeadline timestamp.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityPeriod,\n        bytes calldata message\n    ) external payable {\n        depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            uint32(getCurrentTime()),\n            uint32(getCurrentTime()) + fillDeadlineOffset,\n            exclusivityPeriod,\n            message\n        );\n    }\n\n    /**\n     * @notice DEPRECATED. Use depositV3() instead.\n     * @notice Submits deposit and sets exclusivityDeadline to current time plus some offset. This function is\n     * designed to be called by users who want to set an exclusive relayer for some amount of time after their deposit\n     * transaction is mined.\n     * @notice If exclusivtyDeadlineOffset > 0, then exclusiveRelayer must be set to a valid address, which is a\n     * requirement imposed by depositV3().\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * @param quoteTimestamp The HubPool timestamp that is used to determine the system fee paid by the depositor.\n     *  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp,\n     * the fill will revert on the destination chain. Must be set between [currentTime, currentTime + fillDeadlineBuffer]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param exclusivityPeriod Added to the current time to set the exclusive reayer deadline,\n     * which is the deadline for the exclusiveRelayer to fill the deposit. After this destination chain timestamp,\n     * anyone can fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositExclusive(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityPeriod,\n        bytes calldata message\n    ) public payable {\n        depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityPeriod,\n            message\n        );\n    }\n\n    /**\n     * @notice Depositor can use this function to signal to relayer to use updated output amount, recipient,\n     * and/or message.\n     * @dev the depositor and depositId must match the params in a V3FundsDeposited event that the depositor\n     * wants to speed up. The relayer has the option but not the obligation to use this updated information\n     * when filling the deposit via fillV3RelayWithUpdatedDeposit().\n     * @param depositor Depositor that must sign the depositorSignature and was the original depositor.\n     * @param depositId Deposit ID to speed up.\n     * @param updatedOutputAmount New output amount to use for this deposit. Should be lower than previous value\n     * otherwise relayer has no incentive to use this updated value.\n     * @param updatedRecipient New recipient to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param updatedMessage New message to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account. If depositor is a contract, then should implement EIP1271 to sign as a contract. See\n     * _verifyUpdateV3DepositMessage() for more details about how this signature should be constructed.\n     */\n    function speedUpV3Deposit(\n        address depositor,\n        uint32 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant {\n        _verifyUpdateV3DepositMessage(\n            depositor,\n            depositId,\n            chainId(),\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\n        // from the following event to submit a fill with updated relay data.\n        emit RequestedSpeedUpV3Deposit(\n            updatedOutputAmount,\n            depositId,\n            depositor,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n    }\n\n    /**************************************\n     *         RELAYER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Fulfill request to bridge cross chain by sending specified output tokens to the recipient.\n     * @dev The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs, the\n     * relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and a system fee charged to relayers.\n     * @dev The hash of the relayData will be used to uniquely identify the deposit to fill, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters passed to depositV3() on the origin chain along with that chain's chainId(). This chain's\n     * chainId() must therefore match the destinationChainId passed into depositV3.\n     * Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the\n     * origin SpokePool therefore the relayer should not modify any params in relayData.\n     * @dev Cannot fill more than once. Partial fills are not supported.\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. Should match\n     * all the same-named parameters emitted in the origin chain V3FundsDeposited event.\n     * - depositor: The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * - recipient The account receiving funds on this chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this\n     * token on the repayment chain will be sent as a refund to the caller.\n     * - outputToken The token that the caller will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund\n     * following an optimistic challenge window in the HubPool.\n     * - outputAmount: The amount of output tokens that the caller will send to the recipient.\n     * - originChainId: The origin chain identifier.\n     * - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * - fillDeadline The deadline for the caller to fill the deposit. After this timestamp,\n     * the fill will revert on the destination chain.\n     * - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this\n     * timestamp, anyone can fill this deposit.\n     * - message The message to send to the recipient if the recipient is a contract that implements a\n     * handleV3AcrossMessage() public function\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain.\n     */\n    function fillV3Relay(V3RelayData calldata relayData, uint256 repaymentChainId)\n        public\n        override\n        nonReentrant\n        unpausedFills\n    {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusiveRelayer, relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: _getV3RelayHash(relayData),\n            updatedOutputAmount: relayData.outputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: repaymentChainId\n        });\n\n        _fillRelayV3(relayExecution, msg.sender, false);\n    }\n\n    /**\n     * @notice Identical to fillV3Relay except that the relayer wants to use a depositor's updated output amount,\n     * recipient, and/or message. The relayer should only use this function if they can supply a message signed\n     * by the depositor that contains the fill's matching deposit ID along with updated relay parameters.\n     * If the signature can be verified, then this function will emit a FilledV3Event that will be used by\n     * the system for refund verification purposes. In otherwords, this function is an alternative way to fill a\n     * a deposit than fillV3Relay.\n     * @dev Subject to same exclusivity deadline rules as fillV3Relay().\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. See fillV3Relay().\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. See fillV3Relay().\n     * @param updatedOutputAmount New output amount to use for this deposit.\n     * @param updatedRecipient New recipient to use for this deposit.\n     * @param updatedMessage New message to use for this deposit.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account.\n     */\n    function fillV3RelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant unpausedFills {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusiveRelayer, relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: _getV3RelayHash(relayData),\n            updatedOutputAmount: updatedOutputAmount,\n            updatedRecipient: updatedRecipient,\n            updatedMessage: updatedMessage,\n            repaymentChainId: repaymentChainId\n        });\n\n        _verifyUpdateV3DepositMessage(\n            relayData.depositor,\n            relayData.depositId,\n            relayData.originChainId,\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n\n        _fillRelayV3(relayExecution, msg.sender, false);\n    }\n\n    /**\n     * @notice Request Across to send LP funds to this contract to fulfill a slow fill relay\n     * for a deposit in the next bundle.\n     * @dev Slow fills are not possible unless the input and output tokens are \"equivalent\", i.e.\n     * they route to the same L1 token via PoolRebalanceRoutes.\n     * @dev Slow fills are created by inserting slow fill objects into a merkle tree that is included\n     * in the next HubPool \"root bundle\". Once the optimistic challenge window has passed, the HubPool\n     * will relay the slow root to this chain via relayRootBundle(). Once the slow root is relayed,\n     * the slow fill can be executed by anyone who calls executeV3SlowRelayLeaf().\n     * @dev Cannot request a slow fill if the fill deadline has passed.\n     * @dev Cannot request a slow fill if the relay has already been filled or a slow fill has already been requested.\n     * @param relayData struct containing all the data needed to identify the deposit that should be\n     * slow filled. If any of the params are missing or different from the origin chain deposit,\n     * then Across will not include a slow fill for the intended deposit.\n     */\n    function requestV3SlowFill(V3RelayData calldata relayData) public override nonReentrant unpausedFills {\n        uint32 currentTime = uint32(getCurrentTime());\n        // If a depositor has set an exclusivity deadline, then only the exclusive relayer should be able to\n        // fast fill within this deadline. Moreover, the depositor should expect to get *fast* filled within\n        // this deadline, not slow filled. As a simplifying assumption, we will not allow slow fills to be requested\n        // during this exclusivity period.\n        if (_fillIsExclusive(relayData.exclusiveRelayer, relayData.exclusivityDeadline, currentTime)) {\n            revert NoSlowFillsInExclusivityWindow();\n        }\n        if (relayData.fillDeadline < currentTime) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = _getV3RelayHash(relayData);\n        if (fillStatuses[relayHash] != uint256(FillStatus.Unfilled)) revert InvalidSlowFillRequest();\n        fillStatuses[relayHash] = uint256(FillStatus.RequestedSlowFill);\n\n        emit RequestedV3SlowFill(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayData.depositor,\n            relayData.recipient,\n            relayData.message\n        );\n    }\n\n    /**\n     * @notice Fills a single leg of a particular order on the destination chain\n     * @dev ERC-7683 fill function.\n     * @param orderId Unique order identifier for this order\n     * @param originData Data emitted on the origin to parameterize the fill\n     * @param fillerData Data provided by the filler to inform the fill or express their preferences\n     */\n    function fill(\n        bytes32 orderId,\n        bytes calldata originData,\n        bytes calldata fillerData\n    ) external {\n        if (keccak256(abi.encode(originData, chainId())) != orderId) {\n            revert WrongERC7683OrderId();\n        }\n\n        // Ensure that the call is not malformed. If the call is malformed, abi.decode will fail.\n        V3SpokePoolInterface.V3RelayData memory relayData = abi.decode(originData, (V3SpokePoolInterface.V3RelayData));\n        AcrossDestinationFillerData memory destinationFillerData = abi.decode(\n            fillerData,\n            (AcrossDestinationFillerData)\n        );\n\n        // Must do a delegatecall because the function requires the inputs to be calldata.\n        (bool success, bytes memory data) = address(this).delegatecall(\n            abi.encodeCall(V3SpokePoolInterface.fillV3Relay, (relayData, destinationFillerData.repaymentChainId))\n        );\n        if (!success) {\n            revert LowLevelCallFailed(data);\n        }\n    }\n\n    /**************************************\n     *         DATA WORKER FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @notice Executes a slow relay leaf stored as part of a root bundle relayed by the HubPool.\n     * @dev Executing a slow fill leaf is equivalent to filling the relayData so this function cannot be used to\n     * double fill a recipient. The relayData that is filled is included in the slowFillLeaf and is hashed\n     * like any other fill sent through fillV3Relay().\n     * @dev There is no relayer credited with filling this relay since funds are sent directly out of this contract.\n     * @param slowFillLeaf Contains all data necessary to uniquely identify a relay for this chain. This struct is\n     * hashed and included in a merkle root that is relayed to all spoke pools.\n     * - relayData: struct containing all the data needed to identify the original deposit to be slow filled.\n     * - chainId: chain identifier where slow fill leaf should be executed. If this doesn't match this chain's\n     * chainId, then this function will revert.\n     * - updatedOutputAmount: Amount to be sent to recipient out of this contract's balance. Can be set differently\n     * from relayData.outputAmount to charge a different fee because this deposit was \"slow\" filled. Usually,\n     * this will be set higher to reimburse the recipient for waiting for the slow fill.\n     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.\n     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.\n     */\n    function executeV3SlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) public override nonReentrant {\n        V3RelayData memory relayData = slowFillLeaf.relayData;\n\n        _preExecuteLeafHook(relayData.outputToken);\n\n        // @TODO In the future consider allowing way for slow fill leaf to be created with updated\n        // deposit params like outputAmount, message and recipient.\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: _getV3RelayHash(relayData),\n            updatedOutputAmount: slowFillLeaf.updatedOutputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: EMPTY_REPAYMENT_CHAIN_ID // Repayment not relevant for slow fills.\n        });\n\n        _verifyV3SlowFill(relayExecution, rootBundleId, proof);\n\n        // - No relayer to refund for slow fill executions.\n        _fillRelayV3(relayExecution, EMPTY_RELAYER, true);\n    }\n\n    /**\n     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they\n     * sent to the recipient plus a relayer fee.\n     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.\n     * @param relayerRefundLeaf Contains all data necessary to reconstruct leaf contained in root bundle and to\n     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.\n     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.\n     */\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable virtual override nonReentrant {\n        _preExecuteLeafHook(relayerRefundLeaf.l2TokenAddress);\n\n        if (relayerRefundLeaf.chainId != chainId()) revert InvalidChainId();\n\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Check that proof proves that relayerRefundLeaf is contained within the relayer refund root.\n        // Note: This should revert if the relayerRefundRoot is uninitialized.\n        if (!MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof))\n            revert InvalidMerkleProof();\n\n        _setClaimedLeaf(rootBundleId, relayerRefundLeaf.leafId);\n\n        _distributeRelayerRefunds(\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.refundAmounts,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses\n        );\n\n        emit ExecutedRelayerRefundRoot(\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.refundAmounts,\n            rootBundleId,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses,\n            msg.sender\n        );\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns chain ID for this network.\n     * @dev Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\n     */\n    function chainId() public view virtual override returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    function _deposit(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message\n    ) internal {\n        // Check that deposit route is enabled.\n        if (!enabledDepositRoutes[originToken][destinationChainId]) revert DisabledRoute();\n\n        // We limit the relay fees to prevent the user spending all their funds on fees.\n        if (SignedMath.abs(relayerFeePct) >= 0.5e18) revert InvalidRelayerFeePct();\n        if (amount > MAX_TRANSFER_SIZE) revert MaxTransferSizeExceeded();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits if this is undesirable. This will underflow if\n        // quoteTimestamp is more than depositQuoteTimeBuffer; this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        if (getCurrentTime() - quoteTimestamp > depositQuoteTimeBuffer) revert InvalidQuoteTimestamp();\n\n        // Increment count of deposits so that deposit ID for this spoke pool is unique.\n        uint32 newDepositId = numberOfDeposits++;\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending ETH. In this case, the ETH should be deposited to wrappedNativeToken.\n        if (originToken == address(wrappedNativeToken) && msg.value > 0) {\n            if (msg.value != amount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the user's wallet as per normal.\n            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else IERC20Upgradeable(originToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit V3FundsDeposited(\n            originToken, // inputToken\n            address(0), // outputToken. Setting this to 0x0 means that the outputToken should be assumed to be the\n            // canonical token for the destination chain matching the inputToken. Therefore, this deposit\n            // can always be slow filled.\n            // - setting token to 0x0 will signal to off-chain validator that the \"equivalent\"\n            // token as the inputToken for the destination chain should be replaced here.\n            amount, // inputAmount\n            _computeAmountPostFees(amount, relayerFeePct), // outputAmount\n            // - output amount will be the deposit amount less relayerFeePct, which should now be set\n            // equal to realizedLpFeePct + gasFeePct + capitalCostFeePct where (gasFeePct + capitalCostFeePct)\n            // is equal to the old usage of `relayerFeePct`.\n            destinationChainId,\n            newDepositId,\n            quoteTimestamp,\n            INFINITE_FILL_DEADLINE, // fillDeadline. Default to infinite expiry because\n            // expired deposits refunds could be a breaking change for existing users of this function.\n            0, // exclusivityDeadline. Setting this to 0 along with the exclusiveRelayer to 0x0 means that there\n            // is no exclusive deadline\n            depositor,\n            recipient,\n            address(0), // exclusiveRelayer. Setting this to 0x0 will signal to off-chain validator that there\n            // is no exclusive relayer.\n            message\n        );\n    }\n\n    function _distributeRelayerRefunds(\n        uint256 _chainId,\n        uint256 amountToReturn,\n        uint256[] memory refundAmounts,\n        uint32 leafId,\n        address l2TokenAddress,\n        address[] memory refundAddresses\n    ) internal {\n        if (refundAddresses.length != refundAmounts.length) revert InvalidMerkleLeaf();\n\n        // Send each relayer refund address the associated refundAmount for the L2 token address.\n        // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.\n        uint256 length = refundAmounts.length;\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 amount = refundAmounts[i];\n            if (amount > 0) IERC20Upgradeable(l2TokenAddress).safeTransfer(refundAddresses[i], amount);\n        }\n\n        // If leaf's amountToReturn is positive, then send L2 --> L1 message to bridge tokens back via\n        // chain-specific bridging method.\n        if (amountToReturn > 0) {\n            _bridgeTokensToHubPool(amountToReturn, l2TokenAddress);\n\n            emit TokensBridged(amountToReturn, _chainId, leafId, l2TokenAddress, msg.sender);\n        }\n    }\n\n    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {\n        if (newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = newCrossDomainAdmin;\n        emit SetXDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function _setWithdrawalRecipient(address newWithdrawalRecipient) internal {\n        if (newWithdrawalRecipient == address(0)) revert InvalidWithdrawalRecipient();\n        withdrawalRecipient = newWithdrawalRecipient;\n        emit SetWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    function _preExecuteLeafHook(address) internal virtual {\n        // This method by default is a no-op. Different child spoke pools might want to execute functionality here\n        // such as wrapping any native tokens owned by the contract into wrapped tokens before proceeding with\n        // executing the leaf.\n    }\n\n    // Should be overriden by implementing contract depending on how L2 handles sending tokens to L1.\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual;\n\n    function _setClaimedLeaf(uint32 rootBundleId, uint32 leafId) internal {\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Verify the leafId in the leaf has not yet been claimed.\n        if (MerkleLib.isClaimed(rootBundle.claimedBitmap, leafId)) revert ClaimedMerkleLeaf();\n\n        // Set leaf as claimed in bitmap. This is passed by reference to the storage rootBundle.\n        MerkleLib.setClaimed(rootBundle.claimedBitmap, leafId);\n    }\n\n    function _verifyUpdateV3DepositMessage(\n        address depositor,\n        uint32 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature\n    ) internal view {\n        // A depositor can request to modify an un-relayed deposit by signing a hash containing the updated\n        // details and information uniquely identifying the deposit to relay. This information ensures\n        // that this signature cannot be re-used for other deposits.\n        // Note: We use the EIP-712 (https://eips.ethereum.org/EIPS/eip-712) standard for hashing and signing typed data.\n        // Specifically, we use the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n        // `eth_signedTypedDataV4` in MetaMask (https://docs.metamask.io/guide/signing-data.html).\n        bytes32 expectedTypedDataV4Hash = _hashTypedDataV4(\n            // EIP-712 compliant hash struct: https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct\n            keccak256(\n                abi.encode(\n                    UPDATE_V3_DEPOSIT_DETAILS_HASH,\n                    depositId,\n                    originChainId,\n                    updatedOutputAmount,\n                    updatedRecipient,\n                    keccak256(updatedMessage)\n                )\n            ),\n            // By passing in the origin chain id, we enable the verification of the signature on a different chain\n            originChainId\n        );\n        _verifyDepositorSignature(depositor, expectedTypedDataV4Hash, depositorSignature);\n    }\n\n    // This function is isolated and made virtual to allow different L2's to implement chain specific recovery of\n    // signers from signatures because some L2s might not support ecrecover. To be safe, consider always reverting\n    // this function for L2s where ecrecover is different from how it works on Ethereum, otherwise there is the\n    // potential to forge a signature from the depositor using a different private key than the original depositor's.\n    function _verifyDepositorSignature(\n        address depositor,\n        bytes32 ethSignedMessageHash,\n        bytes memory depositorSignature\n    ) internal view virtual {\n        // Note:\n        // - We don't need to worry about reentrancy from a contract deployed at the depositor address since the method\n        //   `SignatureChecker.isValidSignatureNow` is a view method. Re-entrancy can happen, but it cannot affect state.\n        // - EIP-1271 signatures are supported. This means that a signature valid now, may not be valid later and vice-versa.\n        // - For an EIP-1271 signature to work, the depositor contract address must map to a deployed contract on the destination\n        //   chain that can validate the signature.\n        // - Regular signatures from an EOA are also supported.\n        bool isValid = SignatureChecker.isValidSignatureNow(depositor, ethSignedMessageHash, depositorSignature);\n        if (!isValid) revert InvalidDepositorSignature();\n    }\n\n    function _verifyV3SlowFill(\n        V3RelayExecutionParams memory relayExecution,\n        uint32 rootBundleId,\n        bytes32[] memory proof\n    ) internal view {\n        V3SlowFill memory slowFill = V3SlowFill({\n            relayData: relayExecution.relay,\n            chainId: chainId(),\n            updatedOutputAmount: relayExecution.updatedOutputAmount\n        });\n\n        if (!MerkleLib.verifyV3SlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, slowFill, proof))\n            revert InvalidMerkleProof();\n    }\n\n    function _computeAmountPostFees(uint256 amount, int256 feesPct) private pure returns (uint256) {\n        return (amount * uint256(int256(1e18) - feesPct)) / 1e18;\n    }\n\n    function _getV3RelayHash(V3RelayData memory relayData) private view returns (bytes32) {\n        return keccak256(abi.encode(relayData, chainId()));\n    }\n\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends wrappedNativeToken.\n    function _unwrapwrappedNativeTokenTo(address payable to, uint256 amount) internal {\n        if (address(to).isContract()) {\n            IERC20Upgradeable(address(wrappedNativeToken)).safeTransfer(to, amount);\n        } else {\n            wrappedNativeToken.withdraw(amount);\n            AddressLibUpgradeable.sendValue(to, amount);\n        }\n    }\n\n    // @param relayer: relayer who is actually credited as filling this deposit. Can be different from\n    // exclusiveRelayer if passed exclusivityDeadline or if slow fill.\n    function _fillRelayV3(\n        V3RelayExecutionParams memory relayExecution,\n        address relayer,\n        bool isSlowFill\n    ) internal {\n        V3RelayData memory relayData = relayExecution.relay;\n\n        if (relayData.fillDeadline < getCurrentTime()) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = relayExecution.relayHash;\n\n        // If a slow fill for this fill was requested then the relayFills value for this hash will be\n        // FillStatus.RequestedSlowFill. Therefore, if this is the status, then this fast fill\n        // will be replacing the slow fill. If this is a slow fill execution, then the following variable\n        // is trivially true. We'll emit this value in the FilledV3Relay\n        // event to assist the Dataworker in knowing when to return funds back to the HubPool that can no longer\n        // be used for a slow fill execution.\n        FillType fillType = isSlowFill\n            ? FillType.SlowFill\n            : (\n                // The following is true if this is a fast fill that was sent after a slow fill request.\n                fillStatuses[relayExecution.relayHash] == uint256(FillStatus.RequestedSlowFill)\n                    ? FillType.ReplacedSlowFill\n                    : FillType.FastFill\n            );\n\n        // @dev This function doesn't support partial fills. Therefore, we associate the relay hash with\n        // an enum tracking its fill status. All filled relays, whether slow or fast fills, are set to the Filled\n        // status. However, we also use this slot to track whether this fill had a slow fill requested. Therefore\n        // we can include a bool in the FilledV3Relay event making it easy for the dataworker to compute if this\n        // fill was a fast fill that replaced a slow fill and therefore this SpokePool has excess funds that it\n        // needs to send back to the HubPool.\n        if (fillStatuses[relayHash] == uint256(FillStatus.Filled)) revert RelayFilled();\n        fillStatuses[relayHash] = uint256(FillStatus.Filled);\n\n        // @dev Before returning early, emit events to assist the dataworker in being able to know which fills were\n        // successful.\n        emit FilledV3Relay(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayExecution.repaymentChainId,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayer,\n            relayData.depositor,\n            relayData.recipient,\n            relayData.message,\n            V3RelayExecutionEventInfo({\n                updatedRecipient: relayExecution.updatedRecipient,\n                updatedMessage: relayExecution.updatedMessage,\n                updatedOutputAmount: relayExecution.updatedOutputAmount,\n                fillType: fillType\n            })\n        );\n\n        // If relay token is wrappedNativeToken then unwrap and send native token.\n        address outputToken = relayData.outputToken;\n        uint256 amountToSend = relayExecution.updatedOutputAmount;\n        address recipientToSend = relayExecution.updatedRecipient;\n        if (outputToken == address(wrappedNativeToken)) {\n            // Note: useContractFunds is True if we want to send funds to the recipient directly out of this contract,\n            // otherwise we expect the caller to send funds to the recipient. If useContractFunds is True and the\n            // recipient wants wrappedNativeToken, then we can assume that wrappedNativeToken is already in the\n            // contract, otherwise we'll need the user to send wrappedNativeToken to this contract. Regardless, we'll\n            // need to unwrap it to native token before sending to the user.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, address(this), amountToSend);\n            _unwrapwrappedNativeTokenTo(payable(recipientToSend), amountToSend);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else {\n            // Note: Similar to note above, send token directly from the contract to the user in the slow relay case.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, recipientToSend, amountToSend);\n            else IERC20Upgradeable(outputToken).safeTransfer(recipientToSend, amountToSend);\n        }\n\n        bytes memory updatedMessage = relayExecution.updatedMessage;\n        if (updatedMessage.length > 0 && recipientToSend.isContract()) {\n            AcrossMessageHandler(recipientToSend).handleV3AcrossMessage(\n                outputToken,\n                amountToSend,\n                msg.sender,\n                updatedMessage\n            );\n        }\n    }\n\n    // Determine whether the combination of exlcusiveRelayer and exclusivityDeadline implies active exclusivity.\n    function _fillIsExclusive(\n        address exclusiveRelayer,\n        uint32 exclusivityDeadline,\n        uint32 currentTime\n    ) internal pure returns (bool) {\n        return exclusivityDeadline >= currentTime && exclusiveRelayer != address(0);\n    }\n\n    // Implementing contract needs to override this to ensure that only the appropriate cross chain admin can execute\n    // certain admin functions. For L2 contracts, the cross chain admin refers to some L1 address or contract, and for\n    // L1, this would just be the same admin of the HubPool.\n    function _requireAdminSender() internal virtual;\n\n    // Added to enable the this contract to receive native token (ETH). Used when unwrapping wrappedNativeToken.\n    receive() external payable {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[999] private __gap;\n}\n"
    },
    "contracts/test/MockBedrockStandardBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../Ovm_SpokePool.sol\";\n\n// Provides payable withdrawTo interface introduced on Bedrock\ncontract MockBedrockL2StandardBridge is IL2ERC20Bridge {\n    event ERC20WithdrawalInitiated(address indexed l2Token, address indexed to, uint256 amount);\n\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32,\n        bytes calldata\n    ) external payable {\n        emit ERC20WithdrawalInitiated(_l2Token, _to, _amount);\n    }\n\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32,\n        bytes calldata\n    ) external {\n        // Check that caller has approved this contract to pull funds, mirroring mainnet's behavior\n        IERC20(_localToken).transferFrom(msg.sender, address(this), _amount);\n        IERC20(_remoteToken).transfer(_to, _amount);\n    }\n}\n\ncontract MockBedrockL1StandardBridge {\n    event ETHDepositInitiated(address indexed to, uint256 amount);\n    event ERC20DepositInitiated(address indexed to, address l1Token, address l2Token, uint256 amount);\n\n    function depositERC20To(\n        address l1Token,\n        address l2Token,\n        address to,\n        uint256 amount,\n        uint32,\n        bytes calldata\n    ) external {\n        IERC20(l1Token).transferFrom(msg.sender, address(this), amount);\n        emit ERC20DepositInitiated(to, l1Token, l2Token, amount);\n    }\n\n    function depositETHTo(\n        address to,\n        uint32,\n        bytes calldata\n    ) external payable {\n        emit ETHDepositInitiated(to, msg.value);\n    }\n}\n\ncontract MockBedrockCrossDomainMessenger {\n    event MessageSent(address indexed target);\n\n    address private msgSender;\n\n    function sendMessage(\n        address target,\n        bytes calldata,\n        uint32\n    ) external {\n        emit MessageSent(target);\n    }\n\n    // Impersonates making a call on L2 from L1.\n    function impersonateCall(address target, bytes memory data) external payable returns (bytes memory) {\n        msgSender = msg.sender;\n        (bool success, bytes memory returnData) = target.call{ value: msg.value }(data);\n\n        // Revert if call reverted.\n        if (!success) {\n            assembly {\n                revert(add(32, returnData), mload(returnData))\n            }\n        }\n        return returnData;\n    }\n\n    function xDomainMessageSender() external view returns (address) {\n        return msgSender;\n    }\n}\n"
    },
    "contracts/test/MockOptimism_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../Ovm_SpokePool.sol\";\n\n/**\n * @notice Mock Optimism Spoke pool allowing deployer to override constructor params.\n */\ncontract MockOptimism_SpokePool is Ovm_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wrappedNativeTokenAddress)\n        Ovm_SpokePool(_wrappedNativeTokenAddress, 1 hours, 9 hours, IERC20(address(0)), ITokenMessenger(address(0)))\n    {} // solhint-disable-line no-empty-blocks\n\n    function initialize(\n        address l2Eth,\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _hubPool\n    ) public initializer {\n        __OvmSpokePool_init(_initialDepositId, _crossDomainAdmin, _hubPool, l2Eth);\n    }\n}\n"
    },
    "contracts/upgradeable/AddressLibUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title AddressUpgradeable\n * @dev Collection of functions related to the address type\n * @notice Logic is 100% copied from \"@openzeppelin/contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\" but one\n * comment is added to clarify why we allow delegatecall() in this contract, which is typically unsafe for use in\n * upgradeable implementation contracts.\n * @dev See https://docs.openzeppelin.com/upgrades-plugins/1.x/faq#delegatecall-selfdestruct for more details.\n * @custom:security-contact bugs@across.to\n */\nlibrary AddressLibUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/upgradeable/EIP712CrossChainUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * This contract is based on OpenZeppelin's implementation:\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/cryptography/EIP712Upgradeable.sol\n *\n * NOTE: Modified version that allows to build a domain separator that relies on a different chain id than the chain this\n * contract is deployed to. An example use case we want to support is:\n * - User A signs a message on chain with id = 1\n * - User B executes a method by verifying user A's EIP-712 compliant signature on a chain with id != 1\n * @custom:security-contact bugs@across.to\n */\nabstract contract EIP712CrossChainUpgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator depending on the `originChainId`.\n     * @param originChainId Chain id of network where message originates from.\n     * @return bytes32 EIP-712-compliant domain separator.\n     */\n    function _domainSeparatorV4(uint256 originChainId) internal view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, originChainId));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 structHash = keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * ));\n     * bytes32 digest = _hashTypedDataV4(structHash, originChainId);\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     * @param structHash Hashed struct as defined in https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n     * @param originChainId Chain id of network where message originates from.\n     * @return bytes32 Hash digest that is recoverable via `EDCSA.recover`.\n     */\n    function _hashTypedDataV4(bytes32 structHash, uint256 originChainId) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(originChainId), structHash);\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/upgradeable/MultiCallerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title MultiCallerUpgradeable\n * @notice Logic is 100% copied from \"@uma/core/contracts/common/implementation/MultiCaller.sol\" but one\n * comment is added to clarify why we allow delegatecall() in this contract, which is typically unsafe for use in\n * upgradeable implementation contracts.\n * @dev See https://docs.openzeppelin.com/upgrades-plugins/1.x/faq#delegatecall-selfdestruct for more details.\n * @custom:security-contact bugs@across.to\n */\ncontract MultiCallerUpgradeable {\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function _validateMulticallData(bytes[] calldata data) internal virtual {\n        // no-op\n    }\n\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        _validateMulticallData(data);\n\n        uint256 dataLength = data.length;\n        results = new bytes[](dataLength);\n\n        //slither-disable-start calls-loop\n        for (uint256 i = 0; i < dataLength; ++i) {\n            // Typically, implementation contracts used in the upgradeable proxy pattern shouldn't call `delegatecall`\n            // because it could allow a malicious actor to call this implementation contract directly (rather than\n            // through a proxy contract) and then selfdestruct() the contract, thereby freezing the upgradeable\n            // proxy. However, since we're only delegatecall-ing into this contract, then we can consider this\n            // use of delegatecall() safe.\n\n            //slither-disable-start low-level-calls\n            /// @custom:oz-upgrades-unsafe-allow delegatecall\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n            //slither-disable-end low-level-calls\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                //slither-disable-next-line assembly\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n        //slither-disable-end calls-loop\n    }\n\n    function tryMulticall(bytes[] calldata data) external returns (Result[] memory results) {\n        _validateMulticallData(data);\n\n        uint256 dataLength = data.length;\n        results = new Result[](dataLength);\n\n        //slither-disable-start calls-loop\n        for (uint256 i = 0; i < dataLength; ++i) {\n            // The delegatecall here is safe for the same reasons outlined in the first multicall function.\n            Result memory result = results[i];\n            //slither-disable-start low-level-calls\n            /// @custom:oz-upgrades-unsafe-allow delegatecall\n            (result.success, result.returnData) = address(this).delegatecall(data[i]);\n            //slither-disable-end low-level-calls\n        }\n        //slither-disable-end calls-loop\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure its always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "viaIR": true,
    "debug": {
      "revertStrings": "strip"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
