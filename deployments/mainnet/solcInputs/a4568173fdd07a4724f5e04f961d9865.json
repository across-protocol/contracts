{
  "language": "Solidity",
  "sources": {
    "@eth-optimism/contracts/L1/messaging/IL1ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IL1ERC20Bridge\n */\ninterface IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L2 bridge contract.\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external returns (address);\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _amount Amount of the ERC20 to deposit\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ERC20 token.\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\n     *\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Data provided by the sender on L2. This data is provided\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\n     *   length, these contracts provide no guarantees about its content.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\nimport \"./IL1ERC20Bridge.sol\";\n\n/**\n * @title IL1StandardBridge\n */\ninterface IL1StandardBridge is IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev Deposit an amount of the ETH to the caller's balance on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called\n     * before the withdrawal is finalized.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/crosschain/errorsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/errors.sol)\n\npragma solidity ^0.8.4;\n\nerror NotCrossChainCall();\nerror InvalidCrossChainSender(address actual, address expected);\n"
    },
    "@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/optimism/LibOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport {ICrossDomainMessengerUpgradeable as Optimism_Bridge} from \"../../vendor/optimism/ICrossDomainMessengerUpgradeable.sol\";\nimport \"../errorsUpgradeable.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for https://www.optimism.io/[Optimism].\n * See the https://community.optimism.io/docs/developers/bridge/messaging/#accessing-msg-sender[documentation]\n * for the functionality used here.\n */\nlibrary LibOptimismUpgradeable {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `messenger`.\n     */\n    function isCrossChain(address messenger) internal view returns (bool) {\n        return msg.sender == messenger;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `messenger`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address messenger) internal view returns (address) {\n        if (!isCrossChain(messenger)) revert NotCrossChainCall();\n\n        return Optimism_Bridge(messenger).xDomainMessageSender();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport {Initializable} from \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/vendor/optimism/ICrossDomainMessengerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (vendor/optimism/ICrossDomainMessenger.sol)\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessengerUpgradeable {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual override returns (uint256[] memory) {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@scroll-tech/contracts/L1/gateways/IL1ERC20Gateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IL1ERC20Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone deposit ERC20 token from L1 to L2.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when some ERC20 token is refunded.\n    /// @param token The address of the token in L1.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of token refunded to receiver.\n    event RefundERC20(address indexed token, address indexed recipient, uint256 amount);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param _l1Token The address of l1 token.\n    function getL2ERC20Address(address _l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit some token to a caller's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Deposit some token to a recipient's account on L2 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param _token The address of token in L1.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable;\n\n    /// @notice Complete ERC20 withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L1ScrollMessenger.\n    ///      The function should also only be called by L2ERC20Gateway in L2.\n    /// @param _l1Token The address of corresponding L1 token.\n    /// @param _l2Token The address of corresponding L2 token.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}\n"
    },
    "@scroll-tech/contracts/L1/gateways/IL1ETHGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IL1ETHGateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ETH is withdrawn from L2 to L1 and transfer to recipient.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH withdrawn from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event FinalizeWithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when someone deposit ETH from L1 to L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH will be deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event DepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when some ETH is refunded.\n    /// @param recipient The address of receiver in L1.\n    /// @param amount The amount of ETH refunded to receiver.\n    event RefundETH(address indexed recipient, uint256 amount);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Deposit ETH to caller's account in L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Deposit ETH to some recipient's account in L2 and call the target contract.\n    /// @param to The address of recipient's account on L2.\n    /// @param amount The amount of ETH to be deposited.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Gas limit required to complete the deposit on L2.\n    function depositETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH withdraw from L2 to L1 and send fund to recipient's account in L1.\n    /// @dev This function should only be called by L1ScrollMessenger.\n    ///      This function should also only be called by L1ETHGateway in L2.\n    /// @param from The address of account who withdraw ETH in L2.\n    /// @param to The address of recipient in L1 to receive ETH.\n    /// @param amount The amount of ETH to withdraw.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeWithdrawETH(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}\n"
    },
    "@scroll-tech/contracts/L1/gateways/IL1GatewayRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {IL1ETHGateway} from \"./IL1ETHGateway.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\n\ninterface IL1GatewayRouter is IL1ETHGateway, IL1ERC20Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param ethGateway The address of new ETH Gateway.\n    event SetETHGateway(address indexed ethGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param defaultERC20Gateway The address of new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed defaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param gateway The corresponding address of gateway updated.\n    event SetERC20Gateway(address indexed token, address indexed gateway);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding gateway address for given token address.\n    /// @param _token The address of token to query.\n    function getERC20Gateway(address _token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request ERC20 token transfer from users to gateways.\n    /// @param sender The address of sender to request fund.\n    /// @param token The address of token to request.\n    /// @param amount The amount of token to request.\n    function requestERC20(\n        address sender,\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of ETH gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _ethGateway The address to update.\n    function setETHGateway(address _ethGateway) external;\n\n    /// @notice Update the address of default ERC20 gateway contract.\n    /// @dev This function should only be called by contract owner.\n    /// @param _defaultERC20Gateway The address to update.\n    function setDefaultERC20Gateway(address _defaultERC20Gateway) external;\n\n    /// @notice Update the mapping from token address to gateway address.\n    /// @dev This function should only be called by contract owner.\n    /// @param _tokens The list of addresses of tokens to update.\n    /// @param _gateways The list of addresses of gateways to update.\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external;\n}\n"
    },
    "@scroll-tech/contracts/L1/IL1ScrollMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\n\ninterface IL1ScrollMessenger is IScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can be replayed is updated.\n    /// @param maxReplayTimes The new maximum number of times each message can be replayed.\n    event UpdateMaxReplayTimes(uint256 maxReplayTimes);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct L2MessageProof {\n        // The index of the batch where the message belongs to.\n        uint256 batchIndex;\n        // Concatenation of merkle proof for withdraw merkle trie.\n        bytes merkleProof;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Relay a L2 => L1 message with message proof.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    /// @param proof The proof used to verify the correctness of the transaction.\n    function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;\n\n    /// @notice Replay an existing message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to replay.\n    /// @param message The content of the message.\n    /// @param newGasLimit New gas limit to be used for this message.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;\n\n    /// @notice Drop a skipped message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to drop.\n    /// @param message The content of the message.\n    function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;\n}\n"
    },
    "@scroll-tech/contracts/L1/rollup/IL2GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IL2GasPriceOracle {\n    /// @notice Estimate fee for cross chain message call.\n    /// @param _gasLimit Gas limit required to complete the message relay on L2.\n    function estimateCrossDomainMessageFee(uint256 _gasLimit) external view returns (uint256);\n\n    /// @notice Estimate intrinsic gas fee for cross chain message call.\n    /// @param _message The message to be relayed on L2.\n    function calculateIntrinsicGasFee(bytes memory _message) external view returns (uint256);\n}\n"
    },
    "@scroll-tech/contracts/L2/gateways/IL2ERC20Gateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IL2ERC20Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when ERC20 token is deposited from L1 to L2 and transfer to recipient.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of token withdrawn from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event FinalizeDepositERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /// @notice Emitted when someone withdraw ERC20 token from L2 to L1.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of token will be deposited from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event WithdrawERC20(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the corresponding l1 token address given l2 token address.\n    /// @param l2Token The address of l2 token.\n    function getL1ERC20Address(address l2Token) external view returns (address);\n\n    /// @notice Return the corresponding l2 token address given l1 token address.\n    /// @param l1Token The address of l1 token.\n    function getL2ERC20Address(address l1Token) external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Withdraw of some token to a caller's account on L1.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param token The address of token in L2.\n    /// @param amount The amount of token to transfer.\n    /// @param gasLimit Unused, but included for potential forward compatibility considerations.\n    function withdrawERC20(\n        address token,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Withdraw of some token to a recipient's account on L1.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param token The address of token in L2.\n    /// @param to The address of recipient's account on L1.\n    /// @param amount The amount of token to transfer.\n    /// @param gasLimit Unused, but included for potential forward compatibility considerations.\n    function withdrawERC20(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Withdraw of some token to a recipient's account on L1 and call.\n    /// @dev Make this function payable to send relayer fee in Ether.\n    /// @param token The address of token in L2.\n    /// @param to The address of recipient's account on L1.\n    /// @param amount The amount of token to transfer.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Unused, but included for potential forward compatibility considerations.\n    function withdrawERC20AndCall(\n        address token,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete a deposit from L1 to L2 and send fund to recipient's account in L2.\n    /// @dev Make this function payable to handle WETH deposit/withdraw.\n    ///      The function should only be called by L2ScrollMessenger.\n    ///      The function should also only be called by L1ERC20Gateway in L1.\n    /// @param l1Token The address of corresponding L1 token.\n    /// @param l2Token The address of corresponding L2 token.\n    /// @param from The address of account who deposits the token in L1.\n    /// @param to The address of recipient in L2 to receive the token.\n    /// @param amount The amount of the token to deposit.\n    /// @param data Optional data to forward to recipient's account.\n    function finalizeDepositERC20(\n        address l1Token,\n        address l2Token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external payable;\n}\n"
    },
    "@scroll-tech/contracts/L2/gateways/IL2ETHGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IL2ETHGateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when someone withdraw ETH from L2 to L1.\n    /// @param from The address of sender in L2.\n    /// @param to The address of recipient in L1.\n    /// @param amount The amount of ETH will be deposited from L2 to L1.\n    /// @param data The optional calldata passed to recipient in L1.\n    event WithdrawETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /// @notice Emitted when ETH is deposited from L1 to L2 and transfer to recipient.\n    /// @param from The address of sender in L1.\n    /// @param to The address of recipient in L2.\n    /// @param amount The amount of ETH deposited from L1 to L2.\n    /// @param data The optional calldata passed to recipient in L2.\n    event FinalizeDepositETH(address indexed from, address indexed to, uint256 amount, bytes data);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Withdraw ETH to caller's account in L1.\n    /// @param amount The amount of ETH to be withdrawn.\n    /// @param gasLimit Optional, gas limit used to complete the withdraw on L1.\n    function withdrawETH(uint256 amount, uint256 gasLimit) external payable;\n\n    /// @notice Withdraw ETH to caller's account in L1.\n    /// @param to The address of recipient's account on L1.\n    /// @param amount The amount of ETH to be withdrawn.\n    /// @param gasLimit Optional, gas limit used to complete the withdraw on L1.\n    function withdrawETH(\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Withdraw ETH to caller's account in L1.\n    /// @param to The address of recipient's account on L1.\n    /// @param amount The amount of ETH to be withdrawn.\n    /// @param data Optional data to forward to recipient's account.\n    /// @param gasLimit Optional, gas limit used to complete the withdraw on L1.\n    function withdrawETHAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Complete ETH deposit from L1 to L2 and send fund to recipient's account in L2.\n    /// @dev This function should only be called by L2ScrollMessenger.\n    ///      This function should also only be called by L1GatewayRouter in L1.\n    /// @param _from The address of account who deposit ETH in L1.\n    /// @param _to The address of recipient in L2 to receive ETH.\n    /// @param _amount The amount of ETH to deposit.\n    /// @param _data Optional data to forward to recipient's account.\n    function finalizeDepositETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n}\n"
    },
    "@scroll-tech/contracts/L2/gateways/IL2GatewayRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {IL2ETHGateway} from \"./IL2ETHGateway.sol\";\nimport {IL2ERC20Gateway} from \"./IL2ERC20Gateway.sol\";\n\ninterface IL2GatewayRouter is IL2ETHGateway, IL2ERC20Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of ETH Gateway is updated.\n    /// @param ethGateway The address of new ETH Gateway.\n    event SetETHGateway(address indexed ethGateway);\n\n    /// @notice Emitted when the address of default ERC20 Gateway is updated.\n    /// @param defaultERC20Gateway The address of new default ERC20 Gateway.\n    event SetDefaultERC20Gateway(address indexed defaultERC20Gateway);\n\n    /// @notice Emitted when the `gateway` for `token` is updated.\n    /// @param token The address of token updated.\n    /// @param gateway The corresponding address of gateway updated.\n    event SetERC20Gateway(address indexed token, address indexed gateway);\n}\n"
    },
    "@scroll-tech/contracts/libraries/IScrollMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a cross domain message is sent.\n    /// @param sender The address of the sender who initiates the message.\n    /// @param target The address of target contract to call.\n    /// @param value The amount of value passed to the target contract.\n    /// @param messageNonce The nonce of the message.\n    /// @param gasLimit The optional gas limit passed to L1 or L2.\n    /// @param message The calldata passed to the target contract.\n    event SentMessage(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 messageNonce,\n        uint256 gasLimit,\n        bytes message\n    );\n\n    /// @notice Emitted when a cross domain message is relayed successfully.\n    /// @param messageHash The hash of the message.\n    event RelayedMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted when a cross domain message is failed to relay.\n    /// @param messageHash The hash of the message.\n    event FailedRelayedMessage(bytes32 indexed messageHash);\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the sender of a cross domain message.\n    function xDomainMessageSender() external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;\n}\n"
    },
    "@uma/core/contracts/common/implementation/ExpandedERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./MultiRole.sol\";\nimport \"../interfaces/ExpandedIERC20.sol\";\n\n/**\n * @title An ERC20 with permissioned burning and minting. The contract deployer will initially\n * be the owner who is capable of adding new roles.\n */\ncontract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\n    enum Roles {\n        // Can set the minter and burner.\n        Owner,\n        // Addresses that can mint new tokens.\n        Minter,\n        // Addresses that can burn tokens that address owns.\n        Burner\n    }\n\n    uint8 _decimals;\n\n    /**\n     * @notice Constructs the ExpandedERC20.\n     * @param _tokenName The name which describes the new token.\n     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\n     * @param _tokenDecimals The number of decimals to define token precision.\n     */\n    constructor(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _tokenDecimals\n    ) ERC20(_tokenName, _tokenSymbol) {\n        _decimals = _tokenDecimals;\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));\n        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\n     * @param recipient address to mint to.\n     * @param value amount of tokens to mint.\n     * @return True if the mint succeeded, or False.\n     */\n    function mint(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Minter))\n        returns (bool)\n    {\n        _mint(recipient, value);\n        return true;\n    }\n\n    /**\n     * @dev Burns `value` tokens owned by `msg.sender`.\n     * @param value amount of tokens to burn.\n     */\n    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     * @return True if the burn succeeded, or False.\n     */\n    function burnFrom(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Burner))\n        returns (bool)\n    {\n        _burn(recipient, value);\n        return true;\n    }\n\n    /**\n     * @notice Add Minter role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Minter role is added.\n     */\n    function addMinter(address account) external virtual override {\n        addMember(uint256(Roles.Minter), account);\n    }\n\n    /**\n     * @notice Add Burner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Burner role is added.\n     */\n    function addBurner(address account) external virtual override {\n        addMember(uint256(Roles.Burner), account);\n    }\n\n    /**\n     * @notice Reset Owner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The new holder of the Owner role.\n     */\n    function resetOwner(address account) external virtual override {\n        resetMember(uint256(Roles.Owner), account);\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiCaller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// This contract is taken from Uniswap's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\n\n/// @title MultiCaller\n/// @notice Enables calling multiple methods in a single call to the contract\ncontract MultiCaller {\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiRole.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nlibrary Exclusive {\n    struct RoleMembership {\n        address member;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.member == memberToCheck;\n    }\n\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\n        roleMembership.member = newMember;\n    }\n\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\n        return roleMembership.member;\n    }\n\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\n        resetMember(roleMembership, initialMember);\n    }\n}\n\nlibrary Shared {\n    struct RoleMembership {\n        mapping(address => bool) members;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.members[memberToCheck];\n    }\n\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\n        require(memberToAdd != address(0x0), \"Cannot add 0x0 to a shared role\");\n        roleMembership.members[memberToAdd] = true;\n    }\n\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\n        roleMembership.members[memberToRemove] = false;\n    }\n\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\n        for (uint256 i = 0; i < initialMembers.length; i++) {\n            addMember(roleMembership, initialMembers[i]);\n        }\n    }\n}\n\n/**\n * @title Base class to manage permissions for the derived class.\n */\nabstract contract MultiRole {\n    using Exclusive for Exclusive.RoleMembership;\n    using Shared for Shared.RoleMembership;\n\n    enum RoleType { Invalid, Exclusive, Shared }\n\n    struct Role {\n        uint256 managingRole;\n        RoleType roleType;\n        Exclusive.RoleMembership exclusiveRoleMembership;\n        Shared.RoleMembership sharedRoleMembership;\n    }\n\n    mapping(uint256 => Role) private roles;\n\n    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\n\n    /**\n     * @notice Reverts unless the caller is a member of the specified roleId.\n     */\n    modifier onlyRoleHolder(uint256 roleId) {\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\n     */\n    modifier onlyRoleManager(uint256 roleId) {\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\n     */\n    modifier onlyExclusive(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\n     */\n    modifier onlyShared(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\n        _;\n    }\n\n    /**\n     * @notice Whether `memberToCheck` is a member of roleId.\n     * @dev Reverts if roleId does not correspond to an initialized role.\n     * @param roleId the Role to check.\n     * @param memberToCheck the address to check.\n     * @return True if `memberToCheck` is a member of `roleId`.\n     */\n    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        revert(\"Invalid roleId\");\n    }\n\n    /**\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n     * initialized, ExclusiveRole.\n     * @param roleId the ExclusiveRole membership to modify.\n     * @param newMember the new ExclusiveRole member.\n     */\n    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Gets the current holder of the exclusive role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n     * @param roleId the ExclusiveRole membership to check.\n     * @return the address of the current ExclusiveRole member.\n     */\n    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n        return roles[roleId].exclusiveRoleMembership.getMember();\n    }\n\n    /**\n     * @notice Adds `newMember` to the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param newMember the new SharedRole member.\n     */\n    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n        emit AddedSharedMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param memberToRemove the current SharedRole member to remove.\n     */\n    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n    }\n\n    /**\n     * @notice Removes caller from the role, `roleId`.\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n     * initialized, SharedRole.\n     * @param roleId the SharedRole membership to modify.\n     */\n    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Reverts if `roleId` is not initialized.\n     */\n    modifier onlyValidRole(uint256 roleId) {\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if `roleId` is initialized.\n     */\n    modifier onlyInvalidRole(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\n        _;\n    }\n\n    /**\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMembers` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createSharedRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address[] memory initialMembers\n    ) internal onlyInvalidRole(roleId) {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Shared;\n        role.managingRole = managingRoleId;\n        role.sharedRoleMembership.init(initialMembers);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage a shared role\"\n        );\n    }\n\n    /**\n     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMember` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createExclusiveRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address initialMember\n    ) internal onlyInvalidRole(roleId) {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Exclusive;\n        role.managingRole = managingRoleId;\n        role.exclusiveRoleMembership.init(initialMember);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage an exclusive role\"\n        );\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/Testable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Timer.sol\";\n\n/**\n * @title Base class that provides time overrides, but only if being run in test mode.\n */\nabstract contract Testable {\n    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.\n    // Note: this variable should be set on construction and never modified.\n    address public timerAddress;\n\n    /**\n     * @notice Constructs the Testable contract. Called by child contracts.\n     * @param _timerAddress Contract that stores the current time in a testing environment.\n     * Must be set to 0x0 for production environments that use live time.\n     */\n    constructor(address _timerAddress) {\n        timerAddress = _timerAddress;\n    }\n\n    /**\n     * @notice Reverts if not running in test mode.\n     */\n    modifier onlyIfTest {\n        require(timerAddress != address(0x0));\n        _;\n    }\n\n    /**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set current Testable time to.\n     */\n    function setCurrentTime(uint256 time) external onlyIfTest {\n        Timer(timerAddress).setCurrentTime(time);\n    }\n\n    /**\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n     * Otherwise, it will return the block timestamp.\n     * @return uint for the current Testable timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        if (timerAddress != address(0x0)) {\n            return Timer(timerAddress).getCurrentTime();\n        } else {\n            return block.timestamp; // solhint-disable-line not-rely-on-time\n        }\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/Timer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Universal store of current contract time for testing environments.\n */\ncontract Timer {\n    uint256 private currentTime;\n\n    constructor() {\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set `currentTime` to.\n     */\n    function setCurrentTime(uint256 time) external {\n        currentTime = time;\n    }\n\n    /**\n     * @notice Gets the currentTime variable set in the Timer.\n     * @return uint256 for the current Testable timestamp.\n     */\n    function getCurrentTime() public view returns (uint256) {\n        return currentTime;\n    }\n}\n"
    },
    "@uma/core/contracts/common/interfaces/AddressWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface AddressWhitelistInterface {\n    function addToWhitelist(address newElement) external;\n\n    function removeFromWhitelist(address newElement) external;\n\n    function isOnWhitelist(address newElement) external view returns (bool);\n\n    function getWhitelist() external view returns (address[] memory);\n}\n"
    },
    "@uma/core/contracts/common/interfaces/ExpandedIERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title ERC20 interface that includes burn and mint methods.\n */\nabstract contract ExpandedIERC20 is IERC20 {\n    /**\n     * @notice Burns a specific amount of the caller's tokens.\n     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\n     */\n    function burn(uint256 value) external virtual;\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     */\n    function burnFrom(address recipient, uint256 value) external virtual returns (bool);\n\n    /**\n     * @notice Mints tokens and adds them to the balance of the `to` address.\n     * @dev This method should be permissioned to only allow designated parties to mint tokens.\n     */\n    function mint(address to, uint256 value) external virtual returns (bool);\n\n    function addMinter(address account) external virtual;\n\n    function addBurner(address account) external virtual;\n\n    function resetOwner(address account) external virtual;\n}\n"
    },
    "@uma/core/contracts/data-verification-mechanism/implementation/Constants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\n */\nlibrary OracleInterfaces {\n    bytes32 public constant Oracle = \"Oracle\";\n    bytes32 public constant IdentifierWhitelist = \"IdentifierWhitelist\";\n    bytes32 public constant Store = \"Store\";\n    bytes32 public constant FinancialContractsAdmin = \"FinancialContractsAdmin\";\n    bytes32 public constant Registry = \"Registry\";\n    bytes32 public constant CollateralWhitelist = \"CollateralWhitelist\";\n    bytes32 public constant OptimisticOracle = \"OptimisticOracle\";\n    bytes32 public constant OptimisticOracleV2 = \"OptimisticOracleV2\";\n    bytes32 public constant OptimisticOracleV3 = \"OptimisticOracleV3\";\n    bytes32 public constant Bridge = \"Bridge\";\n    bytes32 public constant GenericHandler = \"GenericHandler\";\n    bytes32 public constant SkinnyOptimisticOracle = \"SkinnyOptimisticOracle\";\n    bytes32 public constant ChildMessenger = \"ChildMessenger\";\n    bytes32 public constant OracleHub = \"OracleHub\";\n    bytes32 public constant OracleSpoke = \"OracleSpoke\";\n}\n\n/**\n * @title Commonly re-used values for contracts associated with the OptimisticOracle.\n */\nlibrary OptimisticOracleConstraints {\n    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible\n    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which\n    // refuses to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n}\n"
    },
    "@uma/core/contracts/data-verification-mechanism/interfaces/FinderInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Provides addresses of the live contracts implementing certain interfaces.\n * @dev Examples are the Oracle or Store interfaces.\n */\ninterface FinderInterface {\n    /**\n     * @notice Updates the address of the contract that implements `interfaceName`.\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n     * @param implementationAddress address of the deployed contract that implements the interface.\n     */\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n\n    /**\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\n     * @param interfaceName queried interface.\n     * @return implementationAddress address of the deployed contract that implements the interface.\n     */\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n}\n"
    },
    "@uma/core/contracts/data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\n */\ninterface IdentifierWhitelistInterface {\n    /**\n     * @notice Adds the provided identifier as a supported identifier.\n     * @dev Price requests using this identifier will succeed after this call.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     */\n    function addSupportedIdentifier(bytes32 identifier) external;\n\n    /**\n     * @notice Removes the identifier from the whitelist.\n     * @dev Price requests using this identifier will no longer succeed after this call.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     */\n    function removeSupportedIdentifier(bytes32 identifier) external;\n\n    /**\n     * @notice Checks whether an identifier is on the whitelist.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     * @return bool if the identifier is supported (or not).\n     */\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\n}\n"
    },
    "@uma/core/contracts/data-verification-mechanism/interfaces/StoreInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\n\n/**\n * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\n */\ninterface StoreInterface {\n    /**\n     * @notice Pays Oracle fees in ETH to the store.\n     * @dev To be used by contracts whose margin currency is ETH.\n     */\n    function payOracleFees() external payable;\n\n    /**\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\n     * @param erc20Address address of the ERC20 token used to pay the fee.\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\n     */\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\n\n    /**\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\n     * @param startTime defines the beginning time from which the fee is paid.\n     * @param endTime end time until which the fee is paid.\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\n     * @return latePenalty for paying the fee after the deadline.\n     */\n    function computeRegularFee(\n        uint256 startTime,\n        uint256 endTime,\n        FixedPoint.Unsigned calldata pfc\n    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\n\n    /**\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\n     * @param currency token used to pay the final fee.\n     * @return finalFee amount due.\n     */\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\n}\n"
    },
    "@uma/core/contracts/merkle-distributor/implementation/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MerkleDistributorInterface.sol\";\n\n/**\n * Inspired by:\n * - https://github.com/pie-dao/vested-token-migration-app\n * - https://github.com/Uniswap/merkle-distributor\n * - https://github.com/balancer-labs/erc20-redeemable\n *\n * @title  MerkleDistributor contract.\n * @notice Allows an owner to distribute any reward ERC20 to claimants according to Merkle roots. The owner can specify\n *         multiple Merkle roots distributions with customized reward currencies.\n * @dev    The Merkle trees are not validated in any way, so the system assumes the contract owner behaves honestly.\n */\ncontract MerkleDistributor is MerkleDistributorInterface, Ownable {\n    using SafeERC20 for IERC20;\n\n    // Windows are mapped to arbitrary indices.\n    mapping(uint256 => Window) public merkleWindows;\n\n    // Index of next created Merkle root.\n    uint256 public nextCreatedIndex;\n\n    // Track which accounts have claimed for each window index.\n    // Note: uses a packed array of bools for gas optimization on tracking certain claims. Copied from Uniswap's contract.\n    mapping(uint256 => mapping(uint256 => uint256)) private claimedBitMap;\n\n    /****************************************\n     *                EVENTS\n     ****************************************/\n    event Claimed(\n        address indexed caller,\n        uint256 windowIndex,\n        address indexed account,\n        uint256 accountIndex,\n        uint256 amount,\n        address indexed rewardToken\n    );\n    event CreatedWindow(\n        uint256 indexed windowIndex,\n        uint256 rewardsDeposited,\n        address indexed rewardToken,\n        address owner\n    );\n    event WithdrawRewards(address indexed owner, uint256 amount, address indexed currency);\n    event DeleteWindow(uint256 indexed windowIndex, address owner);\n\n    /****************************\n     *      ADMIN FUNCTIONS\n     ****************************/\n\n    /**\n     * @notice Set merkle root for the next available window index and seed allocations.\n     * @notice Callable only by owner of this contract. Caller must have approved this contract to transfer\n     *      `rewardsToDeposit` amount of `rewardToken` or this call will fail. Importantly, we assume that the\n     *      owner of this contract correctly chooses an amount `rewardsToDeposit` that is sufficient to cover all\n     *      claims within the `merkleRoot`.\n     * @param rewardsToDeposit amount of rewards to deposit to seed this allocation.\n     * @param rewardToken ERC20 reward token.\n     * @param merkleRoot merkle root describing allocation.\n     * @param ipfsHash hash of IPFS object, conveniently stored for clients\n     */\n    function setWindow(\n        uint256 rewardsToDeposit,\n        address rewardToken,\n        bytes32 merkleRoot,\n        string calldata ipfsHash\n    ) external onlyOwner {\n        uint256 indexToSet = nextCreatedIndex;\n        nextCreatedIndex = indexToSet + 1;\n\n        _setWindow(indexToSet, rewardsToDeposit, rewardToken, merkleRoot, ipfsHash);\n    }\n\n    /**\n     * @notice Delete merkle root at window index.\n     * @dev Callable only by owner. Likely to be followed by a withdrawRewards call to clear contract state.\n     * @param windowIndex merkle root index to delete.\n     */\n    function deleteWindow(uint256 windowIndex) external onlyOwner {\n        delete merkleWindows[windowIndex];\n        emit DeleteWindow(windowIndex, msg.sender);\n    }\n\n    /**\n     * @notice Emergency method that transfers rewards out of the contract if the contract was configured improperly.\n     * @dev Callable only by owner.\n     * @param rewardCurrency rewards to withdraw from contract.\n     * @param amount amount of rewards to withdraw.\n     */\n    function withdrawRewards(IERC20 rewardCurrency, uint256 amount) external onlyOwner {\n        rewardCurrency.safeTransfer(msg.sender, amount);\n        emit WithdrawRewards(msg.sender, amount, address(rewardCurrency));\n    }\n\n    /****************************\n     *    NON-ADMIN FUNCTIONS\n     ****************************/\n\n    /**\n     * @notice Batch claims to reduce gas versus individual submitting all claims. Method will fail\n     *         if any individual claims within the batch would fail.\n     * @dev    Optimistically tries to batch together consecutive claims for the same account and same\n     *         reward token to reduce gas. Therefore, the most gas-cost-optimal way to use this method\n     *         is to pass in an array of claims sorted by account and reward currency. It also reverts\n     *         when any of individual `_claim`'s `amount` exceeds `remainingAmount` for its window.\n     * @param claims array of claims to claim.\n     */\n    function claimMulti(Claim[] memory claims) public virtual override {\n        uint256 batchedAmount;\n        uint256 claimCount = claims.length;\n        for (uint256 i = 0; i < claimCount; i++) {\n            Claim memory _claim = claims[i];\n            _verifyAndMarkClaimed(_claim);\n            batchedAmount += _claim.amount;\n\n            // If the next claim is NOT the same account or the same token (or this claim is the last one),\n            // then disburse the `batchedAmount` to the current claim's account for the current claim's reward token.\n            uint256 nextI = i + 1;\n            IERC20 currentRewardToken = merkleWindows[_claim.windowIndex].rewardToken;\n            if (\n                nextI == claimCount ||\n                // This claim is last claim.\n                claims[nextI].account != _claim.account ||\n                // Next claim account is different than current one.\n                merkleWindows[claims[nextI].windowIndex].rewardToken != currentRewardToken\n                // Next claim reward token is different than current one.\n            ) {\n                currentRewardToken.safeTransfer(_claim.account, batchedAmount);\n                batchedAmount = 0;\n            }\n        }\n    }\n\n    /**\n     * @notice Claim amount of reward tokens for account, as described by Claim input object.\n     * @dev    If the `_claim`'s `amount`, `accountIndex`, and `account` do not exactly match the\n     *         values stored in the merkle root for the `_claim`'s `windowIndex` this method\n     *         will revert. It also reverts when `_claim`'s `amount` exceeds `remainingAmount` for the window.\n     * @param _claim claim object describing amount, accountIndex, account, window index, and merkle proof.\n     */\n    function claim(Claim memory _claim) public virtual override {\n        _verifyAndMarkClaimed(_claim);\n        merkleWindows[_claim.windowIndex].rewardToken.safeTransfer(_claim.account, _claim.amount);\n    }\n\n    /**\n     * @notice Returns True if the claim for `accountIndex` has already been completed for the Merkle root at\n     *         `windowIndex`.\n     * @dev    This method will only work as intended if all `accountIndex`'s are unique for a given `windowIndex`.\n     *         The onus is on the Owner of this contract to submit only valid Merkle roots.\n     * @param windowIndex merkle root to check.\n     * @param accountIndex account index to check within window index.\n     * @return True if claim has been executed already, False otherwise.\n     */\n    function isClaimed(uint256 windowIndex, uint256 accountIndex) public view returns (bool) {\n        uint256 claimedWordIndex = accountIndex / 256;\n        uint256 claimedBitIndex = accountIndex % 256;\n        uint256 claimedWord = claimedBitMap[windowIndex][claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    /**\n     * @notice Returns rewardToken set by admin for windowIndex.\n     * @param windowIndex merkle root to check.\n     * @return address Reward token address\n     */\n    function getRewardTokenForWindow(uint256 windowIndex) public view override returns (address) {\n        return address(merkleWindows[windowIndex].rewardToken);\n    }\n\n    /**\n     * @notice Returns True if leaf described by {account, amount, accountIndex} is stored in Merkle root at given\n     *         window index.\n     * @param _claim claim object describing amount, accountIndex, account, window index, and merkle proof.\n     * @return valid True if leaf exists.\n     */\n    function verifyClaim(Claim memory _claim) public view returns (bool valid) {\n        bytes32 leaf = keccak256(abi.encodePacked(_claim.account, _claim.amount, _claim.accountIndex));\n        return MerkleProof.verify(_claim.merkleProof, merkleWindows[_claim.windowIndex].merkleRoot, leaf);\n    }\n\n    /****************************\n     *     PRIVATE FUNCTIONS\n     ****************************/\n\n    // Mark claim as completed for `accountIndex` for Merkle root at `windowIndex`.\n    function _setClaimed(uint256 windowIndex, uint256 accountIndex) private {\n        uint256 claimedWordIndex = accountIndex / 256;\n        uint256 claimedBitIndex = accountIndex % 256;\n        claimedBitMap[windowIndex][claimedWordIndex] =\n            claimedBitMap[windowIndex][claimedWordIndex] |\n            (1 << claimedBitIndex);\n    }\n\n    // Store new Merkle root at `windowindex`. Pull `rewardsDeposited` from caller to seed distribution for this root.\n    function _setWindow(\n        uint256 windowIndex,\n        uint256 rewardsDeposited,\n        address rewardToken,\n        bytes32 merkleRoot,\n        string memory ipfsHash\n    ) private {\n        Window storage window = merkleWindows[windowIndex];\n        window.merkleRoot = merkleRoot;\n        window.remainingAmount = rewardsDeposited;\n        window.rewardToken = IERC20(rewardToken);\n        window.ipfsHash = ipfsHash;\n\n        emit CreatedWindow(windowIndex, rewardsDeposited, rewardToken, msg.sender);\n\n        window.rewardToken.safeTransferFrom(msg.sender, address(this), rewardsDeposited);\n    }\n\n    // Verify claim is valid and mark it as completed in this contract.\n    function _verifyAndMarkClaimed(Claim memory _claim) internal {\n        // Check claimed proof against merkle window at given index.\n        require(verifyClaim(_claim), \"Incorrect merkle proof\");\n        // Check the account has not yet claimed for this window.\n        require(!isClaimed(_claim.windowIndex, _claim.accountIndex), \"Account has already claimed for this window\");\n\n        // Proof is correct and claim has not occurred yet, mark claimed complete.\n        _setClaimed(_claim.windowIndex, _claim.accountIndex);\n        merkleWindows[_claim.windowIndex].remainingAmount -= _claim.amount;\n        emit Claimed(\n            msg.sender,\n            _claim.windowIndex,\n            _claim.account,\n            _claim.accountIndex,\n            _claim.amount,\n            address(merkleWindows[_claim.windowIndex].rewardToken)\n        );\n    }\n}\n"
    },
    "@uma/core/contracts/merkle-distributor/implementation/MerkleDistributorInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Concise list of functions in MerkleDistributor implementation that would be called by\n * a consuming external contract (such as the Across Protocol's AcceleratingDistributor).\n */\ninterface MerkleDistributorInterface {\n    // A Window maps a Merkle root to a reward token address.\n    struct Window {\n        // Merkle root describing the distribution.\n        bytes32 merkleRoot;\n        // Remaining amount of deposited rewards that have not yet been claimed.\n        uint256 remainingAmount;\n        // Currency in which reward is processed.\n        IERC20 rewardToken;\n        // IPFS hash of the merkle tree. Can be used to independently fetch recipient proofs and tree. Note that the canonical\n        // data type for storing an IPFS hash is a multihash which is the concatenation of  <varint hash function code>\n        // <varint digest size in bytes><hash function output>. We opted to store this in a string type to make it easier\n        // for users to query the ipfs data without needing to reconstruct the multihash. to view the IPFS data simply\n        // go to https://cloudflare-ipfs.com/ipfs/<IPFS-HASH>.\n        string ipfsHash;\n    }\n\n    // Represents an account's claim for `amount` within the Merkle root located at the `windowIndex`.\n    struct Claim {\n        uint256 windowIndex;\n        uint256 amount;\n        uint256 accountIndex; // Used only for bitmap. Assumed to be unique for each claim.\n        address account;\n        bytes32[] merkleProof;\n    }\n\n    function claim(Claim memory _claim) external;\n\n    function claimMulti(Claim[] memory claims) external;\n\n    function getRewardTokenForWindow(uint256 windowIndex) external view returns (address);\n}\n"
    },
    "@uma/core/contracts/optimistic-oracle-v2/interfaces/OptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OptimisticOracleInterface {\n    event RequestPrice(\n        address indexed requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes ancillaryData,\n        address currency,\n        uint256 reward,\n        uint256 finalFee\n    );\n    event ProposePrice(\n        address indexed requester,\n        address indexed proposer,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes ancillaryData,\n        int256 proposedPrice,\n        uint256 expirationTimestamp,\n        address currency\n    );\n    event DisputePrice(\n        address indexed requester,\n        address indexed proposer,\n        address indexed disputer,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes ancillaryData,\n        int256 proposedPrice\n    );\n    event Settle(\n        address indexed requester,\n        address indexed proposer,\n        address indexed disputer,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes ancillaryData,\n        int256 price,\n        uint256 payout\n    );\n\n    // Struct representing the state of a price request.\n    enum State {\n        Invalid, // Never requested.\n        Requested, // Requested, no other actions taken.\n        Proposed, // Proposed, but not expired or disputed yet.\n        Expired, // Proposed, not disputed, past liveness.\n        Disputed, // Disputed, but no DVM price returned yet.\n        Resolved, // Disputed and DVM price is available.\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\n    }\n\n    // Struct representing a price request.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n    // to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    function defaultLiveness() external view virtual returns (uint256);\n\n    function finder() external view virtual returns (FinderInterface);\n\n    function getCurrentTime() external view virtual returns (uint256);\n\n    // Note: this is required so that typechain generates a return value with named fields.\n    mapping(bytes32 => Request) public requests;\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Set the proposal bond associated with a price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param bond custom bond amount to set.\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n     * changed again with a subsequent call to setBond().\n     */\n    function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 bond\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n     * bond, so there is still profit to be made even if the reward is refunded.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function setRefundOnDispute(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual;\n\n    /**\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n     * being auto-resolved.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param customLiveness new custom liveness.\n     */\n    function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external virtual;\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param proposer address to set as the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address proposer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value for an existing price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        address disputer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price value for an existing price request with an active proposal.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n     * hasn't been settled.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return resolved price.\n     */\n    function settleAndGetPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (int256);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 payout);\n\n    /**\n     * @notice Gets the current data structure containing all information about a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the Request data structure.\n     */\n    function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (Request memory);\n\n    /**\n     * @notice Returns the state of a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the State enum value.\n     */\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (State);\n\n    /**\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return true if price has resolved or settled, false otherwise.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (bool);\n\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        view\n        virtual\n        returns (bytes memory);\n}\n"
    },
    "@uma/core/contracts/optimistic-oracle-v2/interfaces/SkinnyOptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/OptimisticOracleInterface.sol\";\n\n/**\n * @title Interface for the gas-cost-reduced version of the OptimisticOracle.\n * @notice Differences from normal OptimisticOracle:\n * - refundOnDispute: flag is removed, by default there are no refunds on disputes.\n * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset\n *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be\n *   set in `requestPrice`, which has an expanded input set.\n * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price\n *   can be fetched via the `Settle` event or the return value of `settle`.\n * - general changes to interface: Functions that interact with existing requests all require the parameters of the\n *   request to modify to be passed as input. These parameters must match with the existing request parameters or the\n *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the\n *   full request struct.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract SkinnyOptimisticOracleInterface {\n    // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\n    // in that refundOnDispute is removed.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n    // to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n     * @param customLiveness custom proposal liveness to set for request.\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward,\n        uint256 bond,\n        uint256 customLiveness\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * propose a price for.\n     * @param proposer address to set as the proposer.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        address proposer,\n        int256 proposedPrice\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value where caller is the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * propose a price for.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\n     * @dev The caller is the requester, but the proposer can be customized.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n     * @param customLiveness custom proposal liveness to set for request.\n     * @param proposer address to set as the proposer.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function requestAndProposePriceFor(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward,\n        uint256 bond,\n        uint256 customLiveness,\n        address proposer,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * dispute.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        address disputer,\n        address requester\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * dispute.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * settle.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     * @return resolvedPrice the price that the request settled to.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (uint256 payout, int256 resolvedPrice);\n\n    /**\n     * @notice Computes the current state of a price request. See the State enum for more details.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters.\n     * @return the State.\n     */\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (OptimisticOracleInterface.State);\n\n    /**\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\n     * will revert.\n     * @return boolean indicating true if price exists and false if not.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) public virtual returns (bool);\n\n    /**\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param requester sender of the initial price request.\n     * @return the stamped ancillary bytes.\n     */\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        pure\n        virtual\n        returns (bytes memory);\n}\n"
    },
    "contracts/AcrossConfigStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Allows admin to set and update configuration settings for full contract system. These settings are designed\n * to be consumed by off-chain bots, rather than by other contracts.\n * @dev This contract should not perform any validation on the setting values and should be owned by the governance\n * system of the full contract suite.\n * @custom:security-contact bugs@across.to\n */\ncontract AcrossConfigStore is Ownable, MultiCaller {\n    // General dictionary where admin can associate variables with specific L1 tokens, like the Rate Model and Token\n    // Transfer Thresholds.\n    mapping(address => string) public l1TokenConfig;\n\n    // General dictionary where admin can store global variables like `MAX_POOL_REBALANCE_LEAF_SIZE` and\n    // `MAX_RELAYER_REPAYMENT_LEAF_SIZE` that off-chain agents can query.\n    mapping(bytes32 => string) public globalConfig;\n\n    event UpdatedTokenConfig(address indexed key, string value);\n    event UpdatedGlobalConfig(bytes32 indexed key, string value);\n\n    /**\n     * @notice Updates token config.\n     * @param l1Token the l1 token address to update value for.\n     * @param value Value to update.\n     */\n    function updateTokenConfig(address l1Token, string memory value) external onlyOwner {\n        l1TokenConfig[l1Token] = value;\n        emit UpdatedTokenConfig(l1Token, value);\n    }\n\n    /**\n     * @notice Updates global config.\n     * @param key Key to update.\n     * @param value Value to update.\n     */\n    function updateGlobalConfig(bytes32 key, string calldata value) external onlyOwner {\n        globalConfig[key] = value;\n        emit UpdatedGlobalConfig(key, value);\n    }\n}\n"
    },
    "contracts/AdapterStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOFT } from \"./interfaces/IOFT.sol\";\n\n/**\n * @title MessengerTypes\n * @notice Library containing messenger type constants\n * @custom:security-contact bugs@across.to\n */\nlibrary MessengerTypes {\n    /** @notice Identifier for OFT (Omni-chain Fungible Token by LayerZero) messenger type */\n    bytes32 public constant OFT_MESSENGER = bytes32(\"OFT_MESSENGER\");\n}\n\n/**\n * @dev A helper contract for chain adapters on the hub chain that support OFT messaging. Handles\n * @dev token => messenger mapping storage. Adapters can't store this themselves as they're called\n * @dev via `delegateCall` and their storage is not part of available context.\n * @custom:security-contact bugs@across.to\n */\ncontract AdapterStore is Ownable {\n    /** @notice Maps messenger type and destination domain to token-messenger pairs */\n    mapping(bytes32 messengerType => mapping(uint256 dstDomainId => mapping(address srcChainToken => address messengerAddress)))\n        public crossChainMessengers;\n\n    /**\n     * @notice Emitted when a messenger is set for a specific token and destination\n     * @param messengerType Type of messenger being set\n     * @param dstDomainId Destination domain ID\n     * @param srcChainToken Source chain token address\n     * @param srcChainMessenger Source chain messenger address\n     */\n    event MessengerSet(\n        bytes32 indexed messengerType,\n        uint256 indexed dstDomainId,\n        address indexed srcChainToken,\n        address srcChainMessenger\n    );\n\n    /** @notice Thrown when array lengths don't match in batch operations */\n    error ArrayLengthMismatch();\n\n    /** @notice Thrown when IOFT messenger's token doesn't match expected token */\n    error IOFTTokenMismatch();\n\n    /** @notice Thrown when messenger type is not supported */\n    error NonExistentMessengerType();\n\n    /**\n     * @notice Sets a messenger for a specific token and destination domain\n     * @param messengerType Type of messenger to set\n     * @param dstDomainId Destination domain ID\n     * @param srcChainToken Source chain token address\n     * @param srcChainMessenger Source chain messenger address\n     */\n    function setMessenger(\n        bytes32 messengerType,\n        uint256 dstDomainId,\n        address srcChainToken,\n        address srcChainMessenger\n    ) external onlyOwner {\n        _setMessenger(messengerType, dstDomainId, srcChainToken, srcChainMessenger);\n    }\n\n    /**\n     * @notice Sets multiple messengers in a single transaction\n     * @param messengerTypes Array of messenger types\n     * @param dstDomainIds Array of destination domain IDs\n     * @param srcChainTokens Array of source chain token addresses\n     * @param srcChainMessengers Array of source chain messenger addresses\n     */\n    function batchSetMessengers(\n        bytes32[] calldata messengerTypes,\n        uint256[] calldata dstDomainIds,\n        address[] calldata srcChainTokens,\n        address[] calldata srcChainMessengers\n    ) external onlyOwner {\n        if (\n            messengerTypes.length != dstDomainIds.length ||\n            messengerTypes.length != srcChainTokens.length ||\n            messengerTypes.length != srcChainMessengers.length\n        ) {\n            revert ArrayLengthMismatch();\n        }\n\n        for (uint256 i = 0; i < dstDomainIds.length; i++) {\n            _setMessenger(messengerTypes[i], dstDomainIds[i], srcChainTokens[i], srcChainMessengers[i]);\n        }\n    }\n\n    /**\n     * @notice Internal function to set a messenger with validation\n     * @param _messengerType Type of messenger to set\n     * @param _dstDomainId Destination domain ID\n     * @param _srcChainToken Source chain token address\n     * @param _srcChainMessenger Source chain messenger address\n     */\n    function _setMessenger(\n        bytes32 _messengerType,\n        uint256 _dstDomainId,\n        address _srcChainToken,\n        address _srcChainMessenger\n    ) internal {\n        // @dev Always allow zero-messenger to be set: this can be used to 'remove' a stored token <> messenger relationship\n        if (_srcChainMessenger != address(0)) {\n            if (_messengerType == MessengerTypes.OFT_MESSENGER) {\n                // @dev Protect against human error: check that IOFT messenger's token matches the expected one\n                if (IOFT(_srcChainMessenger).token() != _srcChainToken) {\n                    revert IOFTTokenMismatch();\n                }\n            } else {\n                revert NonExistentMessengerType();\n            }\n        }\n        crossChainMessengers[_messengerType][_dstDomainId][_srcChainToken] = _srcChainMessenger;\n        emit MessengerSet(_messengerType, _dstDomainId, _srcChainToken, _srcChainMessenger);\n    }\n}\n"
    },
    "contracts/AlephZero_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Arbitrum only supports v0.8.19\n// See https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/solidity-support#differences-from-solidity-on-ethereum\npragma solidity ^0.8.19;\n\nimport \"./Arbitrum_SpokePool.sol\";\n\n/**\n * @notice AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\n * @custom:security-contact bugs@across.to\n */\ncontract AlephZero_SpokePool is Arbitrum_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _oftDstEid,\n        uint256 _oftFeeCap\n    )\n        Arbitrum_SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            _l2Usdc,\n            _cctpTokenMessenger,\n            _oftDstEid,\n            _oftFeeCap\n        )\n    {} // solhint-disable-line no-empty-blocks\n}\n"
    },
    "contracts/Arbitrum_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\nimport { CrossDomainAddressUtils } from \"./libraries/CrossDomainAddressUtils.sol\";\nimport { ArbitrumL2ERC20GatewayLike } from \"./interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\n * @custom:security-contact bugs@across.to\n */\ncontract Arbitrum_SpokePool is SpokePool, CircleCCTPAdapter {\n    // Address of the Arbitrum L2 token gateway to send funds to L1.\n    address public l2GatewayRouter;\n\n    // Admin controlled mapping of arbitrum tokens to L1 counterpart. L1 counterpart addresses\n    // are necessary params used when bridging tokens to L1.\n    mapping(address => address) public whitelistedTokens;\n\n    event SetL2GatewayRouter(address indexed newL2GatewayRouter);\n    event WhitelistedTokens(address indexed l2Token, address indexed l1Token);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _oftDstEid,\n        uint256 _oftFeeCap\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer, _oftDstEid, _oftFeeCap)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the AVM SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _l2GatewayRouter Address of L2 token gateway. Can be reset by admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        address _l2GatewayRouter,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setL2GatewayRouter(_l2GatewayRouter);\n    }\n\n    modifier onlyFromCrossDomainAdmin() {\n        require(msg.sender == CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin), \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /********************************************************\n     *    ARBITRUM-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change L2 gateway router. Callable only by admin.\n     * @param newL2GatewayRouter New L2 gateway router.\n     */\n    function setL2GatewayRouter(address newL2GatewayRouter) public onlyAdmin nonReentrant {\n        _setL2GatewayRouter(newL2GatewayRouter);\n    }\n\n    /**\n     * @notice Add L2 -> L1 token mapping. Callable only by admin.\n     * @param l2Token Arbitrum token.\n     * @param l1Token Ethereum version of l2Token.\n     */\n    function whitelistToken(address l2Token, address l1Token) public onlyAdmin nonReentrant {\n        _whitelistToken(l2Token, l1Token);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        address oftMessenger = _getOftMessenger(l2TokenAddress);\n\n        // If the l2TokenAddress is UDSC, we need to use the CCTP bridge.\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        } else if (oftMessenger != address(0)) {\n            _transferViaOFT(IERC20(l2TokenAddress), IOFT(oftMessenger), withdrawalRecipient, amountToReturn);\n        } else {\n            // Check that the Ethereum counterpart of the L2 token is stored on this contract.\n            address ethereumTokenToBridge = whitelistedTokens[l2TokenAddress];\n            require(ethereumTokenToBridge != address(0), \"Uninitialized mainnet token\");\n            //slither-disable-next-line unused-return\n            ArbitrumL2ERC20GatewayLike(l2GatewayRouter).outboundTransfer(\n                ethereumTokenToBridge, // _l1Token. Address of the L1 token to bridge over.\n                withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 hub pool contract.\n                amountToReturn, // _amount.\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n    }\n\n    function _setL2GatewayRouter(address _l2GatewayRouter) internal {\n        l2GatewayRouter = _l2GatewayRouter;\n        emit SetL2GatewayRouter(l2GatewayRouter);\n    }\n\n    function _whitelistToken(address _l2Token, address _l1Token) internal {\n        whitelistedTokens[_l2Token] = _l1Token;\n        emit WhitelistedTokens(_l2Token, _l1Token);\n    }\n\n    // Apply AVM-specific transformation to cross domain admin address on L1.\n    function _requireAdminSender() internal override onlyFromCrossDomainAdmin {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added, so that the total number of slots taken by this contract remains constant. Per-contract\n    // storage layout information  can be found in storage-layouts/\n    // This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/Blast_DaiRetriever.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Lockable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\n\ninterface USDYieldManager {\n    function claimWithdrawal(uint256 _requestId, uint256 _hintId) external returns (bool success);\n}\n\n/**\n * @notice Contract deployed on Ethereum to facilitate DAI transfers from Blast to the HubPool.\n * @dev Blast USDB withdrawals are a two step process where the L2 to L1 withdrawal must first be finalized via\n * the typical OP Stack mechanism, and then a claim from the withdrawal's *recipient* must be made against a\n * USDBYieldManager contract. This means that the Blast_SpokePool must set its recipient to this contract's address\n * and then an EOA can call this contract to retrieve the DAI.\n */\ncontract Blast_DaiRetriever is Lockable, MultiCaller {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Should be set to HubPool on Ethereum\n    address public immutable hubPool;\n\n    // USDCYieldManager contract on Ethereum which releases DAI to the hubPool.\n    USDYieldManager public immutable usdYieldManager;\n\n    // Token to be retrieved.\n    IERC20Upgradeable public immutable dai;\n\n    /**\n     * @notice Constructs USDB Retriever\n     * @param _hubPool Where to send DAI to.\n     * @param _usdYieldManager USDCYieldManager contract on Ethereum.\n     * @param _dai DAI token to be retrieved.\n     */\n    constructor(\n        address _hubPool,\n        USDYieldManager _usdYieldManager,\n        IERC20Upgradeable _dai\n    ) {\n        //slither-disable-next-line missing-zero-check\n        hubPool = _hubPool;\n        usdYieldManager = _usdYieldManager;\n        dai = _dai;\n    }\n\n    /**\n     * @notice Calls USDCYieldManager contract to release DAI and send to the hubPool. Required to use this function\n     * to retrieve DAI since only the L2 withdrawal recipient can make this call.\n     * @notice This can revert if the claim is not ready yet. It takes ~12 hours for a Blast admin to make the DAI\n     * available for retrieval following withdrawal finalization.\n     * @param _requestId L2 withdrawal request ID. Emitted in L1 WithdrawalRequested event when the L2 to L1\n     * withdrawal is first \"finalized\" but still awaiting the recipient to claim the DAI.\n     * @param _hintId Checkpoint hint ID. Can be found by querying USDYieldManager.findCheckpointHint.\n     */\n    function retrieve(uint256 _requestId, uint256 _hintId) public nonReentrant {\n        require(usdYieldManager.claimWithdrawal(_requestId, _hintId), \"claim failed\");\n        dai.safeTransfer(hubPool, dai.balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/Boba_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Ovm_SpokePool.sol\";\n\n/**\n * @notice Boba Spoke pool. Note that the l2ETH and l2WETH are the opposite as that in Optimism.\n */\ncontract Boba_SpokePool is Ovm_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    )\n        Ovm_SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            IERC20(address(0)),\n            ITokenMessenger(address(0))\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the OVM Boba SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __OvmSpokePool_init(\n            _initialDepositId,\n            _crossDomainAdmin,\n            _withdrawalRecipient,\n            0x4200000000000000000000000000000000000006\n        );\n    }\n}\n"
    },
    "contracts/BondToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./interfaces/HubPoolInterface.sol\";\nimport \"./external/WETH9.sol\";\n\ninterface ExtendedHubPoolInterface is HubPoolInterface {\n    // Specify the automatically-implemented rootBundleProposal() getter.\n    function rootBundleProposal() external pure returns (HubPoolInterface.RootBundle memory);\n}\n\n/**\n * @notice Across Bond Token (ABT).\n * ABT is a simple deposit contract based on WETH9. ABT is issued proportionally to any address that deposits Ether. It\n * imposes address-based permissioning on the WETH9 transferFrom() function in order to constrain the movement of ABT\n * into the Across v2 HubPool contract. When configured as the required HubPool bond token, ABT can dramatically reduce\n * the attack surface of the HubPool by requiring that addresses are explicitly approved before they can successfully\n * submit a root bundle proposal. The address-based permissioning does not constrain transfers that are needed to dispute\n * a root bundle proposal, so the ability of decentralised/unknown actors to dispute is unaffected.\n * @custom:security-contact bugs@across.to\n */\ncontract BondToken is WETH9, Ownable {\n    using Address for address;\n\n    ExtendedHubPoolInterface public immutable HUB_POOL;\n\n    /**\n     * @notice Addresses that are permitted to make HubPool root bundle proposals.\n     */\n    mapping(address => bool) public proposers;\n\n    /**\n     * @notice Emitted on proposer permissions update.\n     */\n    event ProposerModified(address proposer, bool enabled);\n\n    /**\n     * @notice BondToken constructor.\n     * @param _hubPool Address of the target HubPool contract.\n     */\n    constructor(ExtendedHubPoolInterface _hubPool) {\n        name = \"Across Bond Token\";\n        symbol = \"ABT\";\n        HUB_POOL = _hubPool;\n    }\n\n    /**\n     * @notice Enable or disable an address as an allowed proposer. Emits a \"ProposerModified\" event on completion.\n     * @param proposer Proposer address to modify.\n     * @param enabled Boolean controlling whether the address is permitted to propose.\n     */\n    function setProposer(address proposer, bool enabled) external onlyOwner {\n        proposers[proposer] = enabled;\n        emit ProposerModified(proposer, enabled);\n    }\n\n    /**\n     * @notice Transfer amt from src to dst. Prevents unauthorised root bundle proposals by blocking transfers to the\n     * HubPool under the following conditions:\n     * - The src address is not a pre-approved proposer, *and*\n     * - The src address is the current proposer of a HubPool root bundle.\n     * Falls back to the base implementation after verifying that the transfer is permitted.\n     * @dev The require(..., \"Transfer not permitted\") statement is dependent on the internal ordering of HubPool\n     * proposedRootBundle state variable updates, relative to calling bondToken.safeTransferFrom(). Changing the order\n     * of HubPool actions may invalidate this verification. BondToken tests are implemented to detect this.\n     * @param src Source address.\n     * @param dst Destination address.\n     * @param amt Amount to transfer.\n     * @return True on success.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) public override returns (bool) {\n        if (dst == address(HUB_POOL)) {\n            require(proposers[src] || HUB_POOL.rootBundleProposal().proposer != src, \"Transfer not permitted\");\n        }\n        return super.transferFrom(src, dst, amt);\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IOFT } from \"../interfaces/IOFT.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport { OFTTransportAdapterWithStore } from \"../libraries/OFTTransportAdapterWithStore.sol\";\nimport { ArbitrumInboxLike as ArbitrumL1InboxLike, ArbitrumL1ERC20GatewayLike } from \"../interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Arbitrum.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_Adapter is AdapterInterface, CircleCCTPAdapter, OFTTransportAdapterWithStore {\n    using SafeERC20 for IERC20;\n\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    uint256 public constant L2_MAX_SUBMISSION_COST = 0.01e18;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public constant L2_GAS_PRICE = 5e9; // 5 gWei\n\n    // Native token expected to be sent in L2 message. Should be 0 for only use case of this constant, which\n    // includes is sending messages from L1 to L2.\n    uint256 public constant L2_CALL_VALUE = 0;\n\n    // Gas limit for L2 execution of a cross chain token transfer sent via the inbox.\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n    // Gas limit for L2 execution of a message sent via the inbox.\n    uint32 public constant RELAY_MESSAGE_L2_GAS_LIMIT = 2_000_000;\n\n    address public constant L1_DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\n    address public immutable L2_REFUND_L2_ADDRESS;\n\n    // Inbox system contract to send messages to Arbitrum. Token bridges use this to send tokens to L2.\n    // https://github.com/OffchainLabs/nitro-contracts/blob/f7894d3a6d4035ba60f51a7f1334f0f2d4f02dce/src/bridge/Inbox.sol\n    ArbitrumL1InboxLike public immutable L1_INBOX;\n\n    // Router contract to send tokens to Arbitrum. Routes to correct gateway to bridge tokens. Internally this\n    // contract calls the Inbox.\n    // Generic gateway: https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ArbitrumGateway.sol\n    ArbitrumL1ERC20GatewayLike public immutable L1_ERC20_GATEWAY_ROUTER;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     * @param _adapterStore Helper storage contract to support bridging via OFT\n     * @param _oftDstEid destination endpoint id for OFT messaging\n     * @param _oftFeeCap A fee cap we apply to OFT bridge native payment. A good default is 1 ether\n     */\n    constructor(\n        ArbitrumL1InboxLike _l1ArbitrumInbox,\n        ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter,\n        address _l2RefundL2Address,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        address _adapterStore,\n        uint32 _oftDstEid,\n        uint256 _oftFeeCap\n    )\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Arbitrum)\n        OFTTransportAdapterWithStore(_oftDstEid, _oftFeeCap, _adapterStore)\n    {\n        L1_INBOX = _l1ArbitrumInbox;\n        L1_ERC20_GATEWAY_ROUTER = _l1ERC20GatewayRouter;\n        L2_REFUND_L2_ADDRESS = _l2RefundL2Address;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param target Contract on Arbitrum that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance(RELAY_MESSAGE_L2_GAS_LIMIT);\n\n        L1_INBOX.createRetryableTicket{ value: requiredL1CallValue }(\n            target, // destAddr destination L2 contract address\n            L2_CALL_VALUE, // l2CallValue call value for retryable L2 message\n            L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n            message // data ABI encoded data of L2 message\n        );\n\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override {\n        address oftMessenger = _getOftMessenger(l1Token);\n\n        // Check if the token needs to use any of the custom bridge solutions first\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else if (oftMessenger != address(0)) {\n            _transferViaOFT(IERC20(l1Token), IOFT(oftMessenger), to, amount);\n        }\n        // If not, we can use the Arbitrum gateway\n        else {\n            uint256 requiredL1CallValue = _contractHasSufficientEthBalance(RELAY_TOKENS_L2_GAS_LIMIT);\n\n            // Approve the gateway, not the router, to spend the hub pool's balance. The gateway, which is different\n            // per L1 token, will temporarily escrow the tokens to be bridged and pull them from this contract.\n            address erc20Gateway = L1_ERC20_GATEWAY_ROUTER.getGateway(l1Token);\n            IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n\n            // `outboundTransfer` expects that the caller includes a bytes message as the last param that includes the\n            // maxSubmissionCost to use when creating an L2 retryable ticket: https://github.com/OffchainLabs/arbitrum/blob/e98d14873dd77513b569771f47b5e05b72402c5e/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L232\n            bytes memory data = abi.encode(L2_MAX_SUBMISSION_COST, \"\");\n\n            // Note: Legacy routers don't have the outboundTransferCustomRefund method, so default to using\n            // outboundTransfer(). Legacy routers are used for the following tokens that are currently enabled:\n            // - DAI: the implementation of `outboundTransfer` at the current DAI custom gateway\n            //        (https://etherscan.io/address/0xD3B5b60020504bc3489D6949d545893982BA3011#writeContract) sets the\n            //        sender as the refund address so the aliased HubPool should receive excess funds. Implementation here:\n            //        https://github.com/makerdao/arbitrum-dai-bridge/blob/11a80385e2622968069c34d401b3d54a59060e87/contracts/l1/L1DaiGateway.sol#L109\n            if (l1Token == L1_DAI) {\n                // This means that the excess ETH to pay for the L2 transaction will be sent to the aliased\n                // contract address on L2, which we'd have to retrieve via a custom adapter, the Arbitrum_RescueAdapter.\n                // To do so, in a single transaction: 1) setCrossChainContracts to Arbitrum_RescueAdapter, 2) relayMessage\n                // with function data = abi.encode(amountToRescue), 3) setCrossChainContracts back to this adapter.\n                L1_ERC20_GATEWAY_ROUTER.outboundTransfer{ value: requiredL1CallValue }(\n                    l1Token,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            } else {\n                L1_ERC20_GATEWAY_ROUTER.outboundTransferCustomRefund{ value: requiredL1CallValue }(\n                    l1Token,\n                    L2_REFUND_L2_ADDRESS,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            }\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue(uint32 l2GasLimit) public pure returns (uint256) {\n        return L2_MAX_SUBMISSION_COST + L2_GAS_PRICE * l2GasLimit;\n    }\n\n    function _contractHasSufficientEthBalance(uint32 l2GasLimit) internal view returns (uint256) {\n        uint256 requiredL1CallValue = getL1CallValue(l2GasLimit);\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n        return requiredL1CallValue;\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_CustomGasToken_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ITokenMessenger as ICCTPTokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\nimport { CircleCCTPAdapter, CircleDomainIds } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ArbitrumERC20Bridge as ArbitrumL1ERC20Bridge, ArbitrumCustomGasTokenInbox as ArbitrumL1InboxLike, ArbitrumL1ERC20GatewayLike } from \"../interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice Interface for funder contract that this contract pulls from to pay for relayMessage()/relayTokens()\n * fees using a custom gas token.\n */\ninterface FunderInterface {\n    /**\n     * @notice Withdraws amount of token from funder contract to the caller.\n     * @dev Can only be called by owner of Funder contract, which therefore must be\n     * this contract.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     */\n    function withdraw(IERC20 token, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Arbitrum.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @dev This contract is very similar to Arbitrum_Adapter but it allows the caller to pay for submission\n * fees using a custom gas token. This is required to support certain Arbitrum orbit L2s and L3s.\n * @dev https://docs.arbitrum.io/launch-orbit-chain/how-tos/use-a-custom-gas-token\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_CustomGasToken_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // Amount of gas token allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    // The Arbitrum Inbox requires that this uses 18 decimal precision.\n    uint256 public immutable L2_MAX_SUBMISSION_COST;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    // The Arbitrum Inbox requires that this is specified in gWei (e.g. 1e9 = 1 gWei)\n    uint256 public immutable L2_GAS_PRICE;\n\n    // Native token expected to be sent in L2 message. Should be 0 for most use cases of this constant. This\n    // constant is unused when sending the native gas token over the inbox since the inbox interprets `l2CallValue`\n    // as the amount of the L2 native token to send.\n    uint256 public constant L2_CALL_VALUE = 0;\n\n    // Gas limit for L2 execution of a cross chain token transfer sent via the inbox.\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n    // Gas limit for L2 execution of a message sent via the inbox.\n    uint32 public constant RELAY_MESSAGE_L2_GAS_LIMIT = 2_000_000;\n\n    // The number of decimals of precision for the custom gas token. This is defined in the constructor and not dynamically fetched since decimals are\n    // not part of the standard ERC20 interface.\n    uint8 public immutable NATIVE_TOKEN_DECIMALS;\n\n    // This address on L2 receives extra gas token that is left over after relaying a message via the inbox.\n    address public immutable L2_REFUND_L2_ADDRESS;\n\n    // Inbox system contract to send messages to Arbitrum. Token bridges use this to send tokens to L2.\n    // https://github.com/OffchainLabs/nitro-contracts/blob/f7894d3a6d4035ba60f51a7f1334f0f2d4f02dce/src/bridge/Inbox.sol\n    ArbitrumL1InboxLike public immutable L1_INBOX;\n\n    // Router contract to send tokens to Arbitrum. Routes to correct gateway to bridge tokens. Internally this\n    // contract calls the Inbox.\n    // Generic gateway: https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ArbitrumGateway.sol\n    // Gateway used for communicating with chains that use custom gas tokens:\n    // https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ERC20Gateway.sol\n    ArbitrumL1ERC20GatewayLike public immutable L1_ERC20_GATEWAY_ROUTER;\n\n    // This token is used to pay for l1 to l2 messages if its configured by an Arbitrum orbit chain.\n    IERC20 public immutable CUSTOM_GAS_TOKEN;\n\n    // Contract that funds Inbox cross chain messages with the custom gas token.\n    FunderInterface public immutable CUSTOM_GAS_TOKEN_FUNDER;\n\n    error InvalidCustomGasToken();\n    error InsufficientCustomGasToken();\n    error InvalidNativeTokenDecimals();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     * @param _cctpDomainId Circle CCTP domain identifier for the destination chain.\n     * @param _nativeTokenDecimals Number of decimals corresponding to the L2's gas/fee token.\n     * @param _customGasTokenFunder Contract that funds the custom gas token.\n     * @param _l2MaxSubmissionCost Amount of gas token allocated to pay for the base submission fee. The base\n     * submission fee is a parameter unique to Arbitrum retryable transactions. This value is hardcoded\n     * and used for all messages sent by this adapter.\n     * @param _l2GasPrice Gas price bid for L2 execution. Should be set conservatively high to avoid stuck messages.\n     */\n    constructor(\n        ArbitrumL1InboxLike _l1ArbitrumInbox,\n        ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter,\n        address _l2RefundL2Address,\n        IERC20 _l1Usdc,\n        ICCTPTokenMessenger _cctpTokenMessenger,\n        uint32 _cctpDomainId,\n        uint8 _nativeTokenDecimals,\n        FunderInterface _customGasTokenFunder,\n        uint256 _l2MaxSubmissionCost,\n        uint256 _l2GasPrice\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, _cctpDomainId) {\n        L1_INBOX = _l1ArbitrumInbox;\n        L1_ERC20_GATEWAY_ROUTER = _l1ERC20GatewayRouter;\n        L2_REFUND_L2_ADDRESS = _l2RefundL2Address;\n        CUSTOM_GAS_TOKEN = IERC20(L1_INBOX.bridge().nativeToken());\n        if (address(CUSTOM_GAS_TOKEN) == address(0)) revert InvalidCustomGasToken();\n        L2_MAX_SUBMISSION_COST = _l2MaxSubmissionCost;\n        L2_GAS_PRICE = _l2GasPrice;\n        CUSTOM_GAS_TOKEN_FUNDER = _customGasTokenFunder;\n        if (_nativeTokenDecimals == 0) revert InvalidNativeTokenDecimals();\n        NATIVE_TOKEN_DECIMALS = _nativeTokenDecimals;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of the custom gas token\n     * to send a message via the Inbox successfully, or the message will get stuck.\n     * @param target Contract on Arbitrum that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 requiredL1TokenTotalFeeAmount = _pullCustomGas(RELAY_MESSAGE_L2_GAS_LIMIT);\n        CUSTOM_GAS_TOKEN.safeIncreaseAllowance(address(L1_INBOX), requiredL1TokenTotalFeeAmount);\n        L1_INBOX.createRetryableTicket(\n            target, // destAddr destination L2 contract address\n            L2_CALL_VALUE, // l2CallValue call value for retryable L2 message\n            L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n            requiredL1TokenTotalFeeAmount, // tokenTotalFeeAmount amount of fees to be deposited in native token.\n            // This should be in the precision of the custom gas token.\n            message // data ABI encoded data of L2 message\n        );\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH or custom gas token\n     * to send a message via the Inbox successfully, or the message will get stuck.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        }\n        // If not, we can use the Arbitrum gateway\n        else {\n            address erc20Gateway = L1_ERC20_GATEWAY_ROUTER.getGateway(l1Token);\n\n            // If custom gas token, call special functions that handle paying with custom gas tokens.\n            uint256 requiredL1TokenTotalFeeAmount = _pullCustomGas(RELAY_MESSAGE_L2_GAS_LIMIT);\n\n            // Must use Inbox to bridge custom gas token.\n            // Source: https://github.com/OffchainLabs/token-bridge-contracts/blob/5bdf33259d2d9ae52ddc69bc5a9cbc558c4c40c7/contracts/tokenbridge/ethereum/gateway/L1OrbitERC20Gateway.sol#L33\n            if (l1Token == address(CUSTOM_GAS_TOKEN)) {\n                // amount and requiredL1TokenTotalFeeAmount are in the precision of the custom gas token.\n                uint256 amountToBridge = amount + requiredL1TokenTotalFeeAmount;\n                CUSTOM_GAS_TOKEN.safeIncreaseAllowance(address(L1_INBOX), amountToBridge);\n                // Both `l2CallValue` and `tokenTotalFeeAmount` are rounded in the conversion to/from native/18 decimals. `l2CallValue` is rounded down by the call to _fromNativeTo18Decimals()\n                // in cases where the token's decimals exceeds 18, since we would rather round down and be forced to donate a small amount of the l2 token to the spoke pool to cover the roundoff\n                // error than overshoot a transfer amount. `amountToBridge` is rounded up since we would rather overpay for gas and be refunded on l2 than underpay and risk stuck cross-chain messages.\n                L1_INBOX.createRetryableTicket(\n                    to, // destAddr destination L2 contract address\n                    _fromNativeTo18Decimals(amount), // l2CallValue call value for retryable L2 message\n                    L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n                    L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n                    L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n                    RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n                    L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n                    amountToBridge, // tokenTotalFeeAmount amount of fees to be deposited in native token.\n                    \"0x\" // data ABI encoded data of L2 message\n                );\n            } else {\n                IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n                CUSTOM_GAS_TOKEN.safeIncreaseAllowance(erc20Gateway, requiredL1TokenTotalFeeAmount);\n\n                // To pay for gateway outbound transfer with custom gas token, encode the tokenTotalFeeAmount in the data field:\n                // The data format should be (uint256 maxSubmissionCost, bytes extraData, uint256 tokenTotalFeeAmount).\n                // Source: https://github.com/OffchainLabs/token-bridge-contracts/blob/5bdf33259d2d9ae52ddc69bc5a9cbc558c4c40c7/contracts/tokenbridge/ethereum/gateway/L1OrbitERC20Gateway.sol#L57\n                bytes memory data = abi.encode(L2_MAX_SUBMISSION_COST, \"\", requiredL1TokenTotalFeeAmount);\n                L1_ERC20_GATEWAY_ROUTER.outboundTransferCustomRefund(\n                    l1Token,\n                    L2_REFUND_L2_ADDRESS,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            }\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Returns required amount of gas token to send a message via the Inbox.\n     * @dev Should return a value in the same precision as the gas token's precision.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of gas token that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue(uint32 l2GasLimit) public view returns (uint256) {\n        return _from18ToNativeDecimals(L2_MAX_SUBMISSION_COST + L2_GAS_PRICE * l2GasLimit);\n    }\n\n    function _pullCustomGas(uint32 l2GasLimit) internal returns (uint256) {\n        uint256 requiredL1CallValue = getL1CallValue(l2GasLimit);\n        CUSTOM_GAS_TOKEN_FUNDER.withdraw(CUSTOM_GAS_TOKEN, requiredL1CallValue);\n        if (CUSTOM_GAS_TOKEN.balanceOf(address(this)) < requiredL1CallValue) revert InsufficientCustomGasToken();\n        return requiredL1CallValue;\n    }\n\n    function _from18ToNativeDecimals(uint256 amount) internal view returns (uint256) {\n        if (NATIVE_TOKEN_DECIMALS == 18) {\n            return amount;\n        } else if (NATIVE_TOKEN_DECIMALS < 18) {\n            // Round up the division result so that the L1 call value is always sufficient to cover the submission fee.\n            uint256 reductionFactor = 10**(18 - NATIVE_TOKEN_DECIMALS);\n            uint256 divFloor = amount / reductionFactor;\n            uint256 mod = amount % reductionFactor;\n            if (mod != 0) {\n                return divFloor + 1;\n            } else {\n                return divFloor;\n            }\n        } else {\n            return amount * 10**(NATIVE_TOKEN_DECIMALS - 18);\n        }\n    }\n\n    function _fromNativeTo18Decimals(uint256 amount) internal view returns (uint256) {\n        if (NATIVE_TOKEN_DECIMALS == 18) {\n            return amount;\n        } else if (NATIVE_TOKEN_DECIMALS < 18) {\n            return amount * 10**(18 - NATIVE_TOKEN_DECIMALS);\n        } else {\n            return amount / 10**(NATIVE_TOKEN_DECIMALS - 18);\n        }\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_Forwarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ForwarderBase } from \"./ForwarderBase.sol\";\nimport { CrossDomainAddressUtils } from \"../libraries/CrossDomainAddressUtils.sol\";\nimport { WETH9Interface } from \"../external/interfaces/WETH9Interface.sol\";\n\n/**\n * @title Arbitrum_Forwarder\n * @notice This contract expects to receive messages and tokens from the hub pool on L1 and forwards messages to a spoke pool on L3.\n * It rejects messages which do not originate from a cross domain admin, which is set as the hub pool.\n * @custom:security-contact bugs@across.to\n */\ncontract Arbitrum_Forwarder is ForwarderBase {\n    // On Arbitrum, L1 msg.senders are derived by aliasing a L1 address.\n    modifier onlyFromCrossDomainAdmin() {\n        require(msg.sender == CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin), \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /**\n     * @notice Constructs an Arbitrum-specific forwarder contract.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on the L2.\n     */\n    constructor(WETH9Interface _wrappedNativeToken) ForwarderBase(_wrappedNativeToken) {}\n\n    /**\n     * @notice Initializes the forwarder contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function initialize(address _crossDomainAdmin) public initializer {\n        __Forwarder_init(_crossDomainAdmin);\n    }\n\n    function _requireAdminSender() internal override onlyFromCrossDomainAdmin {}\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_RescueAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"./Arbitrum_Adapter.sol\"; // Used to import `ArbitrumL1ERC20GatewayLike` and `ArbitrumL1InboxLike`\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Meant to copy the Arbitrum_Adapter exactly in how it sends L1 --> L2 messages but is designed only to be\n * used by the owner of the HubPool to retrieve ETH held by its aliased address on L2. This ETH builds up because\n * `relayTokens` calls `l1ERC20GatewayRouter.outboundTransfer` which does not allow the caller to specify an L2 refund\n * address the same way that `l1Inbox.createRetryableTicket` does. This means that the alias address of the caller, the\n * HubPool in this case, receives ETH on L2. This Adapter can be used to send messages to Arbitrum specifically to send\n * transactions as if called by the aliased HubPool address.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_RescueAdapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    uint256 public immutable l2MaxSubmissionCost = 0.01e18;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public immutable l2GasPrice = 5e9; // 5 gWei\n\n    // Gas limit for immediate L2 execution attempt (can be estimated via NodeInterface.estimateRetryableTicket).\n    // NodeInterface precompile interface exists at L2 address 0x00000000000000000000000000000000000000C8\n    uint32 public immutable l2GasLimit = 2_000_000;\n\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\n    address public immutable l2RefundL2Address;\n\n    // L1 HubPool address aliased on L2: https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md#address-aliasing\n    address public immutable aliasedL2HubPoolAddress = 0xd297fA914353c44B2e33EBE05F21846f1048CFeB;\n\n    ArbitrumL1InboxLike public immutable l1Inbox;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     */\n    constructor(ArbitrumL1InboxLike _l1ArbitrumInbox) {\n        l1Inbox = _l1ArbitrumInbox;\n\n        l2RefundL2Address = msg.sender;\n    }\n\n    /**\n     * @notice Send cross-chain message to aliased hub pool address on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param message Data to send to aliased hub pool.\n     */\n    function relayMessage(address, bytes memory message) external payable override {\n        uint256 valueToReturn = abi.decode(message, (uint256));\n\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance();\n\n        // In the rescue ETH setup, we send the transaction to the refund address, we provide a call value equal to the\n        // amount we want to rescue, and we specify an empty calldata, since it's a simple ETH transfer.\n        // Note: we use the unsafe version of createRetryableTicket because it doesn't require the msg.sender to pass\n        // in arbTxCallValue in addition to maxSubmissionCost + maxGas * gasPriceBid.\n        l1Inbox.unsafeCreateRetryableTicket{ value: requiredL1CallValue }(\n            l2RefundL2Address, // destAddr destination L2 contract address\n            valueToReturn, // l2CallValue call value for retryable L2 message\n            l2MaxSubmissionCost, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            l2RefundL2Address, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            l2RefundL2Address, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            l2GasLimit, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            l2GasPrice, // gasPriceBid price bid for L2 execution\n            \"\" // data ABI encoded data of L2 message\n        );\n\n        emit MessageRelayed(aliasedL2HubPoolAddress, \"\");\n    }\n\n    /**\n     * @notice Should never be called.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        revert(\"useless function\");\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue() public pure returns (uint256) {\n        return l2MaxSubmissionCost + l2GasPrice * l2GasLimit;\n    }\n\n    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_SendTokensAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport { ArbitrumL1ERC20GatewayLike } from \"./Arbitrum_Adapter.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice This adapter is built for emergencies to send funds from the Hub to a Spoke in the event that a spoke pool\n * received a duplicate root bundle relay, due to some replay issue.\n */\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_SendTokensAdapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    uint256 public immutable l2MaxSubmissionCost = 0.01e18;\n    uint256 public immutable l2GasPrice = 5e9;\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n\n    ArbitrumL1ERC20GatewayLike public immutable l1ERC20GatewayRouter;\n    address public immutable l2RefundL2Address;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     */\n    constructor(ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter, address _l2RefundL2Address) {\n        l1ERC20GatewayRouter = _l1ERC20GatewayRouter;\n        l2RefundL2Address = _l2RefundL2Address;\n    }\n\n    /**\n     * @notice Send tokens to SpokePool. Enables HubPool admin to call relaySpokePoolAdminFunction that will trigger\n     * this function.\n     * @dev This performs similar logic to relayTokens in the normal Arbitrum_Adapter by sending tokens\n     * the Arbitrum_SpokePool out of the HubPool.\n     * @param message The encoded address of the ERC20 to send to the rescue address.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        (address l1Token, uint256 amount) = abi.decode(message, (address, uint256));\n\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance();\n\n        // Approve the gateway, not the router, to spend the hub pool's balance. The gateway, which is different\n        // per L1 token, will temporarily escrow the tokens to be bridged and pull them from this contract.\n        address erc20Gateway = l1ERC20GatewayRouter.getGateway(l1Token);\n        IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n\n        // `outboundTransfer` expects that the caller includes a bytes message as the last param that includes the\n        // maxSubmissionCost to use when creating an L2 retryable ticket: https://github.com/OffchainLabs/arbitrum/blob/e98d14873dd77513b569771f47b5e05b72402c5e/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L232\n        bytes memory data = abi.encode(l2MaxSubmissionCost, \"\");\n\n        l1ERC20GatewayRouter.outboundTransferCustomRefund{ value: requiredL1CallValue }(\n            l1Token,\n            l2RefundL2Address,\n            target,\n            amount,\n            RELAY_TOKENS_L2_GAS_LIMIT,\n            l2GasPrice,\n            data\n        );\n\n        // Purposefully not emitting any events so as not to confuse off-chain monitors that track this event.\n        // emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Should never be called.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        revert(\"relayTokens disabled\");\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue() public pure returns (uint256) {\n        return l2MaxSubmissionCost + l2GasPrice * RELAY_TOKENS_L2_GAS_LIMIT;\n    }\n\n    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Base_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Base. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic.\n * @custom:security-contact bugs@across.to\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Base_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Base system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CrossDomainEnabled(_crossDomainMessenger) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Base) {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Base.\n     * @param target Contract on Base that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Base.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Blast_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport { IL1StandardBridge } from \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\ninterface IL1ERC20Bridge {\n    /// @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n    ///         ERC20 token on the other chain does not recognize the local token as the correct\n    ///         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n    ///         this chain.\n    /// @param _localToken  Address of the ERC20 on this chain.\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\n    /// @param _to          Address of the receiver.\n    /// @param _amount      Amount of local tokens to deposit.\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n    ///                     not be triggered with this data, but it will be emitted and can be used\n    ///                     to identify the transaction.\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Blast. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic. It differs from the Base Adapter in that it uses a special\n * Blast contract to bridge WETH and DAI, which are yielding rebasing tokens on L2, WETH and USDB.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Blast_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public immutable L2_GAS_LIMIT; // 200,000 is a reasonable default.\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE; // 0x697402166Fbf2F22E970df8a6486Ef171dbfc524\n\n    // Bridge used to get yielding version of ERC20's on L2.\n    IL1ERC20Bridge public immutable L1_BLAST_BRIDGE; // 0x3a05E5d33d7Ab3864D53aaEc93c8301C1Fa49115 on mainnet.\n    address public immutable L1_DAI; // 0x6B175474E89094C44Da98b954EedeAC495271d0F on mainnet.\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Blast system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        IL1ERC20Bridge l1BlastBridge,\n        address l1Dai,\n        uint32 l2GasLimit\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n        CircleCCTPAdapter(_l1Usdc, ITokenMessenger(address(0)), CircleDomainIds.UNINITIALIZED)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n        L1_BLAST_BRIDGE = l1BlastBridge;\n        L1_DAI = l1Dai;\n        L2_GAS_LIMIT = l2GasLimit;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Blast.\n     * @param target Contract on Blast that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Blast.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If token can be bridged into yield-ing version of ERC20 on L2 side, then use Blast Bridge, otherwise\n        // use standard bridge.\n\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            // @dev: we can use the standard or the blast bridge to deposit ETH here:\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is DAI, then use the L1 Blast Bridge\n        else if (l1Token == L1_DAI) {\n            IERC20(l1Token).safeIncreaseAllowance(address(L1_BLAST_BRIDGE), amount);\n            L1_BLAST_BRIDGE.bridgeERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Blast_RescueAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport { USDYieldManager } from \"../Blast_DaiRetriever.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice This adapter is built to to retrieve Blast USDB from the USDBYieldManager contract on Ethereum that was\n * sent to the HubPool as the `recipient`. These funds should ideally be sent to the BlastRetriever address on\n * Ethereum. This contract can be used to retrieve these funds.\n */\n// solhint-disable-next-line contract-name-camelcase\ncontract Blast_RescueAdapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    address public immutable rescueAddress;\n\n    USDYieldManager public immutable usdYieldManager;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _rescueAddress Rescue address to send funds to.\n     */\n    constructor(address _rescueAddress, USDYieldManager _usdYieldManager) {\n        rescueAddress = _rescueAddress;\n        usdYieldManager = _usdYieldManager;\n    }\n\n    /**\n     * @notice Rescues the tokens from the calling contract.\n     * @param message The encoded address of the ERC20 to send to the rescue addres.\n     */\n    function relayMessage(address, bytes memory message) external payable override {\n        (uint256 requestId, uint256 hintId) = abi.decode(message, (uint256, uint256));\n        require(usdYieldManager.claimWithdrawal(requestId, hintId), \"claim failed\");\n    }\n\n    /**\n     * @notice Should never be called.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        revert(\"relayTokens disabled\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Boba_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Boba. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Boba_Adapter is CrossDomainEnabled, AdapterInterface {\n    using SafeERC20 for IERC20;\n    uint32 public immutable L2_GAS_LIMIT = 2_000_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Boba system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge\n    ) CrossDomainEnabled(_crossDomainMessenger) {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Boba.\n     * @param target Contract on Boba that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, uint32(L2_GAS_LIMIT), message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Boba.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @custom:security-contact bugs@across.to\n * @dev Helper contract for contracts performing cross-domain communications between L1 and Optimism.\n * @dev This modifies the eth-optimism/CrossDomainEnabled contract only by changing state variables to be\n * immutable for use in contracts like the Optimism_Adapter which use delegateCall().\n */\ncontract CrossDomainEnabled {\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public immutable MESSENGER;\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {\n        MESSENGER = _messenger;\n    }\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\n        return ICrossDomainMessenger(MESSENGER);\n    }\n\n    /**\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  onlyFromCrossDomainAccount())\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes calldata _message\n    ) internal {\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "contracts/chain-adapters/DoctorWho_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Doctor Who. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic.\n * @custom:security-contact bugs@across.to\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract DoctorWho_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Doctor Who system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.DoctorWho)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Doctor Who.\n     * @param target Contract on Doctor Who that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Doctor Who.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/DonationBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Users can donate tokens to this contract that only the owner can withdraw.\n * @dev This contract is designed to be used as a convenience for the owner to store funds to pay for\n * future transactions, such as donating custom gas tokens to pay for future retryable ticket messages\n * to be sent via the Arbitrum_Adapter.\n * @custom:security-contact bugs@across.to\n */\ncontract DonationBox is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Withdraw tokens from the contract.\n     * @dev Only callable by owner, which should be set to the HubPool\n     * so that it can use these funds to pay for relaying messages to\n     * an Arbitrum L2 that uses custom gas tokens as the L1 payment currency,\n     * via the Arbitrum_CustomGasToken_Adapter.\n     * @param token Token to withdraw.\n     * @param amount Amount of tokens to withdraw.\n     */\n    function withdraw(IERC20 token, uint256 amount) external onlyOwner {\n        token.safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/chain-adapters/Ethereum_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @custom:security-contact bugs@across.to\n * @notice Contract containing logic to send messages from L1 to Ethereum SpokePool.\n * @notice This contract should always be deployed on the same chain as the HubPool, as it acts as a pass-through\n * contract between HubPool and SpokePool on the same chain. Its named \"Ethereum_Adapter\" because a core assumption\n * is that the HubPool will be deployed on Ethereum, so this adapter will be used to communicate between HubPool\n * and the Ethereum_SpokePool.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Ethereum_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Send message to target on Ethereum.\n     * @notice This function, and contract overall, is not useful in practice except that the HubPool\n     * expects to interact with the SpokePool via an Adapter, so when communicating to the Ethereum_SpokePool, it must\n     * send messages via this pass-through contract.\n     * @param target Contract that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        _executeCall(target, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Send tokens to target.\n     * @param l1Token L1 token to send.\n     * @param l2Token Unused parameter in this contract.\n     * @param amount Amount of L1 tokens to send.\n     * @param to recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for ethereum since we are assuming that the HubPool is only deployed\n        // on this network.\n        uint256 amount,\n        address to\n    ) external payable override {\n        IERC20(l1Token).safeTransfer(to, amount);\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    // Note: this snippet of code is copied from Governor.sol. Source: https://github.com/UMAprotocol/protocol/blob/5b37ea818a28479c01e458389a83c3e736306b17/packages/core/contracts/oracle/implementation/Governor.sol#L190-L207\n    function _executeCall(address to, bytes memory data) private {\n        // Note: this snippet of code is copied from Governor.sol and modified to not include any \"value\" field.\n\n        bool success;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let inputData := add(data, 0x20)\n            let inputDataSize := mload(data)\n            // Hardcode value to be 0 for relayed governance calls in order to avoid addressing complexity of bridging\n            // value cross-chain.\n            success := call(gas(), to, 0, inputData, inputDataSize, 0, 0)\n        }\n        require(success, \"execute call failed\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Ethereum_RescueAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice This adapter is built for emergencies to rescue funds from a Hub in the event of a misconfiguration or\n * security issue.\n */\n// solhint-disable-next-line contract-name-camelcase\ncontract Ethereum_RescueAdapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    address public immutable rescueAddress;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _rescueAddress Rescue address to send funds to.\n     */\n    constructor(address _rescueAddress) {\n        rescueAddress = _rescueAddress;\n    }\n\n    /**\n     * @notice Rescues the tokens from the calling contract.\n     * @param message The encoded address of the ERC20 to send to the rescue addres.\n     */\n    function relayMessage(address, bytes memory message) external payable override {\n        IERC20 tokenAddress = IERC20(abi.decode(message, (address)));\n\n        // Transfer full balance of tokens to the rescue address.\n        tokenAddress.safeTransfer(rescueAddress, tokenAddress.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Should never be called.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        revert(\"relayTokens disabled\");\n    }\n}\n"
    },
    "contracts/chain-adapters/ForwarderBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { ForwarderInterface } from \"./interfaces/ForwarderInterface.sol\";\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\nimport { MultiCaller } from \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport { WETH9Interface } from \"../external/interfaces/WETH9Interface.sol\";\n\n/**\n * @title ForwarderBase\n * @notice This contract expects to receive messages and tokens from an authorized sender on L1 and forwards messages and tokens to spoke pool contracts on\n * L3. Messages are intended to originate from the hub pool. The motivating use case for this contract is to aid with sending messages from L1 to an L3, which\n * by definition is a network which does not have a direct connection with L1 but instead must communicate with that L1 via an L2. Each contract that extends\n * the ForwarderBase maintains a mapping of chain IDs to a bridge adapter addresses. For example, if this contract is deployed on Arbitrum, then this mapping\n * would send L3 chain IDs which roll up to Arbitrum to an adapter contract address deployed on Arbitrum which directly interfaces with the L3 token/message\n * bridge. In other words, this contract maintains a mapping of important contracts which helps transmit messages to the \"next layer\".\n * @custom:security-contact bugs@across.to\n */\nabstract contract ForwarderBase is UUPSUpgradeable, ForwarderInterface, MultiCaller, ReentrancyGuardUpgradeable {\n    // Address of the wrapped native token contract on this L2.\n    WETH9Interface public immutable WRAPPED_NATIVE_TOKEN;\n    // Address that can relay messages using this contract and also upgrade this contract.\n    address public crossDomainAdmin;\n\n    // Map from a destination chain ID to the address of an adapter contract which interfaces with the L2-L3 bridge. The destination chain ID corresponds to\n    // the network ID of an L3. These chain IDs are used as the key in this mapping because network IDs are enforced to be unique. Since we require the chain\n    // ID to be sent along with a message or token relay, ForwarderInterface's relay functions include an extra field, `destinationChainId`, when compared to the\n    // relay functions of `AdapterInterface`.\n    mapping(uint256 => address) public chainAdapters;\n\n    // An array of which contains all token relays sent to this forwarder. A token relay is only stored here if it is received from the L1 cross domain admin.\n    // Each TokenRelay element contains a yes/no value describing whether or not the token relay has been executed. TokenRelays can only ever be executed once,\n    // but anybody can execute a stored TokenRelay in the array.\n    TokenRelay[] public tokenRelays;\n\n    event ChainAdaptersUpdated(uint256 indexed destinationChainId, address l2Adapter);\n    event SetXDomainAdmin(address indexed crossDomainAdmin);\n\n    error InvalidCrossDomainAdmin();\n    error InvalidTokenRelayId();\n    // Error which is triggered when there is no adapter set in the `chainAdapters` mapping.\n    error UninitializedChainAdapter();\n    // Error which is triggered when the contract attempts to wrap a native token for an amount greater than\n    // its balance.\n    error InsufficientNativeTokenBalance();\n\n    /*\n     * @dev Cross domain admin permissioning is implemented specifically for each L2 that this contract is deployed on, so this base contract\n     * simply prescribes this modifier to protect external functions using that L2's specific admin permissioning logic.\n     */\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    /**\n     * @notice Constructs the Forwarder contract.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on the L2.\n     * @dev _disableInitializers() restricts anybody from initializing the implementation contract, which if not done,\n     * may disrupt the proxy if another EOA were to initialize it.\n     */\n    constructor(WETH9Interface _wrappedNativeToken) {\n        WRAPPED_NATIVE_TOKEN = _wrappedNativeToken;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Receives the native token from external sources.\n     * @dev Forwarders need a receive function so that it may accept the native token incoming from L1-L2 bridges.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Initializes the forwarder contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function __Forwarder_init(address _crossDomainAdmin) public onlyInitializing {\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n    }\n\n    /**\n     * @notice Sets a new cross domain admin for this contract.\n     * @param _newCrossDomainAdmin L1 address of the new cross domain admin.\n     * @dev Before calling this function, you must ensure that there are no message or token relays currently being sent over the L1-L2\n     * bridge. This is to prevent these messages from getting permanently stuck, since otherwise receipt of these messages will always revert,\n     * as the L1 sender is the old cross-domain admin.\n     */\n    function setCrossDomainAdmin(address _newCrossDomainAdmin) external onlyAdmin {\n        _setCrossDomainAdmin(_newCrossDomainAdmin);\n    }\n\n    /**\n     * @notice Maps a new destination chain ID to an adapter contract which facilitates bridging to that chain.\n     * @param _destinationChainId The chain ID of the target network.\n     * @param _l2Adapter Contract address of the adapter which interfaces with the L2-L3 bridge.\n     * @dev Actual bridging logic is delegated to the adapter contract so that the forwarder can function irrespective of the \"flavor\" of\n     * L3 (e.g. ArbitrumOrbit, OpStack, etc.).\n     */\n    function updateAdapter(uint256 _destinationChainId, address _l2Adapter) external onlyAdmin {\n        chainAdapters[_destinationChainId] = _l2Adapter;\n        emit ChainAdaptersUpdated(_destinationChainId, _l2Adapter);\n    }\n\n    /**\n     * @notice Relays a specified message to a contract on L3. This contract assumes that `target` exists on the L3 and can properly\n     * receive the function being called.\n     * @param target The address of the spoke pool contract that will receive the input message.\n     * @param destinationChainId The chain ID of the network which contains `target`.\n     * @param message The data to execute on the target contract.\n     */\n    function relayMessage(\n        address target,\n        uint256 destinationChainId,\n        bytes memory message\n    ) external payable override onlyAdmin {\n        address adapter = chainAdapters[destinationChainId];\n        if (adapter == address(0)) revert UninitializedChainAdapter();\n\n        // The forwarder assumes that `target` exists on the following network.\n        (bool success, ) = adapter.delegatecall(abi.encodeCall(AdapterInterface.relayMessage, (target, message)));\n        if (!success) revert RelayMessageFailed();\n        emit MessageForwarded(target, destinationChainId, message);\n    }\n\n    /**\n     * @notice Stores information about sending `amount` of a token to a target on L3. Importantly, this contract assumes that `target` exists on L3.\n     * @param l2Token This layer's address of the token to send.\n     * @param l3Token The next layer's address of the token to send.\n     * @param amount The amount of the token to send.\n     * @param destinationChainId The chain ID of the network which contains `target`.\n     * @param to The address of the contract that which will *ultimately* receive the tokens. For most cases, this is the spoke pool contract on L3.\n     * @dev While `relayMessage` also assumes that `target` is correct, this function has the potential of deleting funds if `target` is incorrectly set.\n     * This should be guarded by the logic of the Hub Pool on L1, since the Hub Pool will always set `target` to the L3 spoke pool per UMIP-157.\n     * @dev This function does not perform the bridging action. Instead, it receives information from the hub pool on L1 and saves it to state, so that it\n     * may be executed in the future by any EOA.\n     */\n    function relayTokens(\n        address l2Token,\n        address l3Token,\n        uint256 amount,\n        uint256 destinationChainId,\n        address to\n    ) external payable override onlyAdmin {\n        uint32 tokenRelayId = uint32(tokenRelays.length);\n        // Create a TokenRelay struct with all the information provided.\n        TokenRelay memory tokenRelay = TokenRelay({\n            l2Token: l2Token,\n            l3Token: l3Token,\n            to: to,\n            amount: amount,\n            destinationChainId: destinationChainId,\n            executed: false\n        });\n        // Save the token relay to state.\n        tokenRelays.push(tokenRelay);\n        emit ReceivedTokenRelay(tokenRelayId, tokenRelay);\n    }\n\n    /**\n     * @notice Sends a stored TokenRelay to L3.\n     * @param tokenRelayId Index of the relay to send in the `tokenRelays` array.\n     */\n    function executeRelayTokens(uint32 tokenRelayId) external payable nonReentrant {\n        if (tokenRelayId >= tokenRelays.length) revert InvalidTokenRelayId();\n        TokenRelay storage tokenRelay = tokenRelays[tokenRelayId];\n        if (tokenRelay.executed) revert TokenRelayExecuted();\n\n        address adapter = chainAdapters[tokenRelay.destinationChainId];\n        if (adapter == address(0)) revert UninitializedChainAdapter();\n        if (tokenRelay.l2Token == address(WRAPPED_NATIVE_TOKEN)) {\n            // Only wrap the minimum required amount of the native token.\n            uint256 wrappedNativeTokenBalance = WRAPPED_NATIVE_TOKEN.balanceOf(address(this));\n            if (wrappedNativeTokenBalance < tokenRelay.amount)\n                _wrapNativeToken(tokenRelay.amount - wrappedNativeTokenBalance);\n        }\n\n        tokenRelay.executed = true;\n        (bool success, ) = adapter.delegatecall(\n            abi.encodeCall(\n                AdapterInterface.relayTokens,\n                (tokenRelay.l2Token, tokenRelay.l3Token, tokenRelay.amount, tokenRelay.to)\n            )\n        );\n        if (!success) revert RelayTokensFailed(tokenRelay.l2Token);\n\n        emit ExecutedTokenRelay(tokenRelayId);\n    }\n\n    // Function to be overridden in order to authenticate that messages sent to this contract originated\n    // from the expected account.\n    function _requireAdminSender() internal virtual;\n\n    // We also want to restrict who can upgrade this contract. The same admin that can relay messages through this\n    // contract can upgrade this contract.\n    function _authorizeUpgrade(address) internal virtual override onlyAdmin {}\n\n    function _setCrossDomainAdmin(address _newCrossDomainAdmin) internal {\n        if (_newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = _newCrossDomainAdmin;\n        emit SetXDomainAdmin(_newCrossDomainAdmin);\n    }\n\n    /*\n     * @notice Wraps the specified amount of the network's native token.\n     */\n    function _wrapNativeToken(uint256 wrapAmount) internal {\n        if (address(this).balance < wrapAmount) revert InsufficientNativeTokenBalance();\n        WRAPPED_NATIVE_TOKEN.deposit{ value: wrapAmount }();\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added, so that the total number of slots taken by this contract remains constant. Per-contract\n    // storage layout information  can be found in storage-layouts/\n    // This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/chain-adapters/interfaces/AdapterInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\n * This interface is implemented by an adapter contract that is deployed on L1.\n */\n\ninterface AdapterInterface {\n    event MessageRelayed(address target, bytes message);\n\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\n\n    /**\n     * @notice Send message to `target` on L2.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\n     * to the target contract on L2.\n     * @param target L2 address to send message to.\n     * @param message Message to send to `target`.\n     */\n    function relayMessage(address target, bytes calldata message) external payable;\n\n    /**\n     * @notice Send `amount` of `l1Token` to `to` on L2. `l2Token` is the L2 address equivalent of `l1Token`.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\n     * to the target contract on L2.\n     * @param l1Token L1 token to bridge.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of `l1Token` to bridge.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable;\n}\n"
    },
    "contracts/chain-adapters/interfaces/ForwarderInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Sends cross chain messages and tokens to contracts on a specific L3 network.\n * This interface is implemented by forwarder contracts deployed to L2s.\n */\n\ninterface ForwarderInterface {\n    // A TokenRelay defines all the information a forwarder needs to send tokens to an L3.\n    struct TokenRelay {\n        // The address of the token on L2 to send to L3.\n        address l2Token;\n        // The address of the token on L3 to receive.\n        address l3Token;\n        // The L3 address of the recipient.\n        address to;\n        // The amount of the L2 token to send over the L2-L3 bridge.\n        uint256 amount;\n        // The chain ID of the L3 to send tokens to.\n        uint256 destinationChainId;\n        // A yes/no value for determining whether the token relay which was stored has been executed.\n        bool executed;\n    }\n\n    event MessageForwarded(address indexed target, uint256 indexed chainId, bytes message);\n    event ReceivedTokenRelay(uint32 indexed tokenRelayId, TokenRelay tokenRelay);\n    event ExecutedTokenRelay(uint32 indexed tokenRelayId);\n\n    /**\n     * @notice Send message to `target` on L3.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L3. However, it will not send msg.value\n     * to the target contract on L3.\n     * @param target L3 address to send message to.\n     * @param destinationChainId Chain ID of the L3 network.\n     * @param message Message to send to `target`.\n     */\n    function relayMessage(\n        address target,\n        uint256 destinationChainId,\n        bytes calldata message\n    ) external payable;\n\n    /**\n     * @notice Send `amount` of `l2Token` to `to` on L3. `l3oken` is the L3 address equivalent of `l2Token`.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\n     * to the target contract on L2.\n     * @param l2Token L2 token to bridge.\n     * @param l3Token L3 token to receive.\n     * @param amount Amount of `l2Token` to bridge.\n     * @param destinationChainId Chain ID of the L3 network.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l2Token,\n        address l3Token,\n        uint256 amount,\n        uint256 destinationChainId,\n        address to\n    ) external payable;\n\n    error RelayMessageFailed();\n    error RelayTokensFailed(address l2Token);\n    error TokenRelayExecuted();\n}\n"
    },
    "contracts/chain-adapters/l2/Arbitrum_WithdrawalHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ArbitrumL2ERC20GatewayLike } from \"../../interfaces/ArbitrumBridge.sol\";\nimport { WithdrawalHelperBase } from \"./WithdrawalHelperBase.sol\";\nimport { ITokenMessenger } from \"../../external/interfaces/CCTPInterfaces.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { CrossDomainAddressUtils } from \"../../libraries/CrossDomainAddressUtils.sol\";\n\n/**\n * @title Arbitrum_WithdrawalHelper\n * @notice This contract interfaces with L2-L1 token bridges and withdraws tokens to a single address on L1.\n * @dev This contract should be deployed on Arbitrum L2s which only use CCTP or the canonical Arbitrum gateway router to withdraw tokens.\n * @custom:security-contact bugs@across.to\n */\ncontract Arbitrum_WithdrawalHelper is WithdrawalHelperBase {\n    using SafeERC20 for IERC20;\n\n    // Error which triggers when the supplied L1 token does not match the Arbitrum gateway router's expected L2 token.\n    error InvalidTokenMapping();\n\n    /*\n     * @notice Constructs the Arbitrum_WithdrawalHelper.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network. For Ethereum, this is 0.\n     * @param _l2GatewayRouter Address of the Arbitrum l2 gateway router contract.\n     * @param _tokenRecipient L1 Address which will unconditionally receive tokens withdrawn from this contract.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2GatewayRouter,\n        address _tokenRecipient\n    )\n        WithdrawalHelperBase(\n            _l2Usdc,\n            _cctpTokenMessenger,\n            _wrappedNativeToken,\n            _destinationCircleDomainId,\n            _l2GatewayRouter,\n            _tokenRecipient\n        )\n    {}\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which may execute admin functions on this contract.\n     */\n    function initialize(address _crossDomainAdmin) public initializer {\n        __WithdrawalHelper_init(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Calls CCTP or the Arbitrum gateway router to withdraw tokens back to the TOKEN_RECIPIENT L1 address.\n     * @param l1Token Address of the L1 token to receive.\n     * @param l2Token Address of the L2 token to send back.\n     * @param amountToReturn Amount of l2Token to send back.\n     */\n    function withdrawToken(\n        address l1Token,\n        address l2Token,\n        uint256 amountToReturn\n    ) public override {\n        // If the l2TokenAddress is UDSC, we need to use the CCTP bridge.\n        if (l2Token == address(usdcToken) && _isCCTPEnabled()) {\n            _transferUsdc(TOKEN_RECIPIENT, amountToReturn);\n        } else {\n            if (l2Token == address(WRAPPED_NATIVE_TOKEN)) _wrapNativeToken();\n            // Otherwise, we use the Arbitrum ERC20 Gateway router.\n            ArbitrumL2ERC20GatewayLike tokenBridge = ArbitrumL2ERC20GatewayLike(L2_TOKEN_GATEWAY);\n            // If the gateway router's expected L2 token address does not match then revert. This check does not actually\n            // impact whether the bridge will succeed, since the ERC20 gateway router only requires the L1 token address, but\n            // it is added here to potentially catch scenarios where there was a mistake in the calldata.\n            if (tokenBridge.calculateL2TokenAddress(l1Token) != l2Token) revert InvalidTokenMapping();\n            //slither-disable-next-line unused-return\n            tokenBridge.outboundTransfer(\n                l1Token, // _l1Token. Address of the L1 token to bridge over.\n                TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the recipient.\n                amountToReturn, // _amount.\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n    }\n\n    function _requireAdminSender() internal view override {\n        if (msg.sender != CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin)) revert NotCrossDomainAdmin();\n    }\n}\n"
    },
    "contracts/chain-adapters/l2/Ovm_WithdrawalHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WithdrawalHelperBase } from \"./WithdrawalHelperBase.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { ITokenMessenger } from \"../../external/interfaces/CCTPInterfaces.sol\";\nimport { Lib_PredeployAddresses } from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport { LibOptimismUpgradeable } from \"@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol\";\nimport { IL2ERC20Bridge } from \"../../Ovm_SpokePool.sol\";\n\n/**\n * @notice Minimal interface for the Ovm_SpokePool contract. This interface is called to pull state from the network's\n * spoke pool contract to be used by this withdrawal adapter.\n */\ninterface IOvm_SpokePool {\n    // Returns the address of the token bridge for the input l2 token.\n    function tokenBridges(address token) external view returns (address);\n\n    // Returns the address of the l1 token set in the spoke pool for the input l2 token.\n    function remoteL1Tokens(address token) external view returns (address);\n\n    // Returns the address for the representation of ETH on the l2.\n    function l2Eth() external view returns (address);\n\n    // Returns the amount of gas the contract allocates for a token withdrawal.\n    function l1Gas() external view returns (uint32);\n}\n\n/**\n * @title Ovm_WithdrawalAdapter\n * @notice This contract interfaces with L2-L1 token bridges and withdraws tokens to a single address on L1.\n * @dev This contract should be deployed on OpStack L2s which both have a Ovm_SpokePool contract deployed to the L2\n * network AND only use token bridges defined in the Ovm_SpokePool. A notable exception to this requirement is Optimism,\n * which has a special SNX bridge (and thus this adapter will NOT work for Optimism).\n * @custom:security-contact bugs@across.to\n */\ncontract Ovm_WithdrawalHelper is WithdrawalHelperBase {\n    using SafeERC20 for IERC20;\n\n    // Address of the corresponding spoke pool on L2. This is to piggyback off of the spoke pool's supported\n    // token routes/defined token bridges.\n    IOvm_SpokePool public immutable spokePool;\n    // Address of native ETH on the l2. For OpStack chains, this address is used to indicate a native ETH withdrawal.\n    // In general, this address is 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n    address public immutable l2Eth;\n    // Address of the messenger contract on L2. This is by default defined in Lib_PredeployAddresses.\n    address public constant MESSENGER = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n\n    /*\n     * @notice Constructs the Ovm_WithdrawalAdapter.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network. For Ethereum, this\n     * is 0.\n     * @param _l2Gateway Address of the Optimism ERC20 L2 standard bridge contract.\n     * @param _tokenRecipient The L1 address which will unconditionally receive tokens from withdrawals by this contract.\n     * @param _spokePool The contract address of the Ovm_SpokePool which is deployed on this L2 network.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2Gateway,\n        address _tokenRecipient,\n        IOvm_SpokePool _spokePool\n    )\n        WithdrawalHelperBase(\n            _l2Usdc,\n            _cctpTokenMessenger,\n            _wrappedNativeToken,\n            _destinationCircleDomainId,\n            _l2Gateway,\n            _tokenRecipient\n        )\n    {\n        spokePool = _spokePool;\n\n        // This address is immutable in the spoke pool so we query once and save its value locally.\n        l2Eth = spokePool.l2Eth();\n    }\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function initialize(address _crossDomainAdmin) public initializer {\n        __WithdrawalHelper_init(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Calls CCTP or the Optimism token gateway to withdraw tokens back to the recipient.\n     * @param l2Token address of the l2Token to send back.\n     * @param amountToReturn amount of l2Token to send back.\n     * @dev The l1Token parameter is unused since we obtain the l1Token to receive by querying the state of the Ovm_SpokePool deployed\n     * to this network.\n     * @dev This function is a copy of the `_bridgeTokensToHubPool` function found on the Ovm_SpokePool contract here:\n     * https://github.com/across-protocol/contracts/blob/65191dbcded95c8fe050e0f95eb7848e3784e61f/contracts/Ovm_SpokePool.sol#L148.\n     * New lines of code correspond to instances where this contract queries state from the spoke pool, such as determining\n     * the appropriate token bridge for the withdrawal or finding the remoteL1Token to withdraw.\n     */\n    function withdrawToken(\n        address,\n        address l2Token,\n        uint256 amountToReturn\n    ) public override {\n        // Fetch the current l1Gas defined in the Ovm_SpokePool.\n        uint32 l1Gas = spokePool.l1Gas();\n        // If the token being bridged is WETH then we need to first unwrap it to ETH and then send ETH over the\n        // canonical bridge. On Optimism, this is address 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n        if (l2Token == address(WRAPPED_NATIVE_TOKEN)) {\n            // Wrap the contract's balance of the native token if we are withdrawing the L2's native token. We need wrap the contract's balance\n            // and then unwrap the amount to send to account for cases where `amountToReturn` is greater than the contract's native token balance\n            // and wrapped native token balance, but less than their sum.\n            _wrapNativeToken();\n            WETH9Interface(l2Token).withdraw(amountToReturn); // Unwrap into ETH.\n            l2Token = l2Eth; // Set the l2Token to ETH.\n            IL2ERC20Bridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo{ value: amountToReturn }(\n                l2Token, // _l2Token. Address of the L2 token to bridge over.\n                TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                amountToReturn, // _amount.\n                l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n        // If the token is USDC && CCTP bridge is enabled, then bridge USDC via CCTP.\n        else if (l2Token == address(usdcToken) && _isCCTPEnabled()) {\n            _transferUsdc(TOKEN_RECIPIENT, amountToReturn);\n        }\n        // Note we'll default to withdrawTo instead of bridgeERC20To unless the remoteL1Tokens mapping is set for\n        // the l2Token. withdrawTo should be used to bridge back non-native L2 tokens\n        // (i.e. non-native L2 tokens have a canonical L1 token). If we should bridge \"native L2\" tokens then\n        // we'd need to call bridgeERC20To and give allowance to the tokenBridge to spend l2Token from this contract.\n        // Therefore for native tokens we should set ensure that remoteL1Tokens is set for the l2Token.\n        else {\n            IL2ERC20Bridge tokenBridge = IL2ERC20Bridge(\n                spokePool.tokenBridges(l2Token) == address(0)\n                    ? Lib_PredeployAddresses.L2_STANDARD_BRIDGE\n                    : spokePool.tokenBridges(l2Token)\n            );\n            address remoteL1Token = spokePool.remoteL1Tokens(l2Token);\n            if (remoteL1Token != address(0)) {\n                // If there is a mapping for this L2 token to an L1 token, then use the L1 token address and\n                // call bridgeERC20To.\n                IERC20(l2Token).safeIncreaseAllowance(address(tokenBridge), amountToReturn);\n                tokenBridge.bridgeERC20To(\n                    l2Token, // _l2Token. Address of the L2 token to bridge over.\n                    remoteL1Token, // Remote token to be received on L1 side. If the\n                    // remoteL1Token on the other chain does not recognize the local token as the correct\n                    // pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n                    // this chain.\n                    TOKEN_RECIPIENT, // _to\n                    amountToReturn, // _amount\n                    l1Gas, // _l1Gas\n                    \"\" // _data\n                );\n            } else {\n                tokenBridge.withdrawTo(\n                    l2Token, // _l2Token. Address of the L2 token to bridge over.\n                    TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                    amountToReturn, // _amount.\n                    l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                    \"\" // _data. We don't need to send any data for the bridging action.\n                );\n            }\n        }\n    }\n\n    function _requireAdminSender() internal view override {\n        if (LibOptimismUpgradeable.crossChainSender(MESSENGER) != crossDomainAdmin) revert NotCrossDomainAdmin();\n    }\n}\n"
    },
    "contracts/chain-adapters/l2/WithdrawalHelperBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MultiCaller } from \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport { CircleCCTPAdapter, ITokenMessenger, CircleDomainIds } from \"../../libraries/CircleCCTPAdapter.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title WithdrawalHelperBase\n * @notice This contract contains general configurations for bridging tokens from an L2 to a single recipient on L1.\n * @dev This contract should be deployed on L2. It provides an interface to withdraw tokens to some address on L1. The only\n * function which must be implemented in contracts which inherit this contract is `withdrawToken`. It is up to that function\n * to determine which bridges to use for an input L2 token. Importantly, that function must also verify that the L2 to L1\n * token mapping is correct so that the bridge call itself can succeed.\n */\nabstract contract WithdrawalHelperBase is CircleCCTPAdapter, MultiCaller, UUPSUpgradeable {\n    // The L2 address of the wrapped native token for this L2.\n    WETH9Interface public immutable WRAPPED_NATIVE_TOKEN;\n    // The L1 address which will unconditionally receive all withdrawals from this contract.\n    address public immutable TOKEN_RECIPIENT;\n    // The address of the primary or default token gateway/canonical bridge contract on L2.\n    address public immutable L2_TOKEN_GATEWAY;\n    // The address of the admin contract on L1,which will likely be the hub pool. As a last resort, this admin can rescue stuck tokens\n    // on this withdrawal helper contract, similar to how it may send admin functions to spoke pools.\n    address public crossDomainAdmin;\n\n    event SetXDomainAdmin(address indexed _crossDomainAdmin);\n\n    // Error which triggers when the cross domain admin was attempted to be set to the zero address.\n    error InvalidCrossDomainAdmin();\n    // Error which triggers when the caller of a protected function is not the cross domain admin.\n    error NotCrossDomainAdmin();\n\n    // Functions which contain this modifier should only be callable via a cross-chain call where the L1 msg.sender is the hub pool.\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    /*\n     * @notice Constructs a new withdrawal helper.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network.\n     * @param _l2TokenGateway Address of the network's l2 token gateway/bridge contract.\n     * @param _tokenRecipient L1 address which will unconditionally receive all withdrawals originating from this contract.\n     * @dev _disableInitializers() restricts anybody from initializing the implementation contract, which if not done,\n     * may disrupt the proxy if another EOA were to initialize it.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2TokenGateway,\n        address _tokenRecipient\n    ) CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, _destinationCircleDomainId) {\n        L2_TOKEN_GATEWAY = _l2TokenGateway;\n        TOKEN_RECIPIENT = _tokenRecipient;\n        WRAPPED_NATIVE_TOKEN = _wrappedNativeToken;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Receives the native token from bridge contracts.\n     * @dev When bridging from L3 to the L2's native token, OpStack bridges will send the \"unwrapped\"/native token to the recipient on L2\n     * during withdrawals. This means that this contract must be able to accept value transfers.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function __WithdrawalHelper_init(address _crossDomainAdmin) public onlyInitializing {\n        __UUPSUpgradeable_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Sets a new cross domain admin. The admin cannot be the zero address. The cross domain admin is the only address which may call\n     * upgrade this contract.\n     * @param _newCrossDomainAdmin L1 address of the new cross domain admin.\n     */\n    function _setCrossDomainAdmin(address _newCrossDomainAdmin) internal {\n        if (_newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = _newCrossDomainAdmin;\n        emit SetXDomainAdmin(_newCrossDomainAdmin);\n    }\n\n    /*\n     * @notice Withdraws a specified token to L1. This may be implemented uniquely for each L2, since each L2 has various\n     * dependencies to withdraw a token, such as the token bridge to use, mappings for L1 and L2 tokens, and gas configurations.\n     * Notably, withdrawals should always send token back to `TOKEN_RECIPIENT`.\n     * @param l1Token Address of the l1Token to receive.\n     * @param l2Token Address of the l2Token to send back.\n     * @param amountToReturn Amount of l2Token to send back.\n     * @dev Some networks do not require the L1/L2 token argument to withdraw tokens, while others enable contracts to derive the\n     * L1/L2 given knowledge of only one of the addresses. Both arguments are provided to enable a flexible interface; however, due\n     * to this, `withdrawToken` MUST account for situations where the L1/L2 token mapping is incorrect.\n     */\n    function withdrawToken(\n        address l1Token,\n        address l2Token,\n        uint256 amountToReturn\n    ) public virtual;\n\n    /*\n     * @notice Wraps the contract's entire balance of the native token.\n     */\n    function _wrapNativeToken() internal virtual {\n        if (address(this).balance > 0) WRAPPED_NATIVE_TOKEN.deposit{ value: address(this).balance }();\n    }\n\n    /*\n     * @notice Checks that the L1 msg.sender is the `crossDomainAdmin` address.\n     * @dev This implementation must change on a per-chain basis, since each L2 network has their own method of deriving the L1 msg.sender.\n     */\n    function _requireAdminSender() internal virtual;\n\n    /*\n     * @notice Access control check for upgrading this proxy contract\n     * @dev This requires that _requireAdminSender() is properly implemented on all contracts which inherit WithdrawalHelperBase.\n     */\n    function _authorizeUpgrade(address) internal override onlyAdmin {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added, so that the total number of slots taken by this contract remains constant. Per-contract\n    // storage layout information  can be found in storage-layouts/\n    // This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/chain-adapters/Linea_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\nimport \"../libraries/CircleCCTPAdapter.sol\";\n\nimport { IMessageService, ITokenBridge, IUSDCBridge } from \"../external/interfaces/LineaInterfaces.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Supports sending messages and tokens from L1 to Linea.\n * @custom:security-contact bugs@across.to\n */\n// solhint-disable-next-line contract-name-camelcase\ncontract Linea_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    WETH9Interface public immutable L1_WETH;\n    IMessageService public immutable L1_MESSAGE_SERVICE;\n    ITokenBridge public immutable L1_TOKEN_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _l1MessageService Canonical message service contract on L1.\n     * @param _l1TokenBridge Canonical token bridge contract on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        IMessageService _l1MessageService,\n        ITokenBridge _l1TokenBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Linea) {\n        L1_WETH = _l1Weth;\n        L1_MESSAGE_SERVICE = _l1MessageService;\n        L1_TOKEN_BRIDGE = _l1TokenBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Linea.\n     * @param target Contract on Linea that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        // Linea currently does not support auto-claiming of cross-chain messages that have\n        // non-empty calldata. As we need to manually claim these messages, we can set the\n        // message fees to 0.\n        L1_MESSAGE_SERVICE.sendMessage(target, 0, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Linea.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        if (l1Token == address(usdcToken) && _isCCTPEnabled()) {\n            _transferUsdc(to, amount);\n        }\n        // If the l1Token is WETH then unwrap it to ETH then send the ETH directly\n        // via the Canoncial Message Service.\n        else if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_MESSAGE_SERVICE.sendMessage{ value: amount }(to, 0, \"\");\n        }\n        // For other tokens, we can use the Canonical Token Bridge.\n        else {\n            IERC20(l1Token).safeIncreaseAllowance(address(L1_TOKEN_BRIDGE), amount);\n            L1_TOKEN_BRIDGE.bridgeToken(l1Token, amount, to);\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Lisk_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Lisk. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Lisk_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Lisk system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Lisk.\n     * @param target Contract on Lisk that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Lisk.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Mock_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Contract used for testing communication between HubPool and Adapter.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Mock_Adapter is AdapterInterface {\n    event RelayMessageCalled(address target, bytes message, address caller);\n\n    event RelayTokensCalled(address l1Token, address l2Token, uint256 amount, address to, address caller);\n\n    Mock_Bridge public immutable bridge;\n\n    constructor() {\n        bridge = new Mock_Bridge();\n    }\n\n    function relayMessage(address target, bytes calldata message) external payable override {\n        bridge.bridgeMessage(target, message);\n        emit RelayMessageCalled(target, message, msg.sender);\n    }\n\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        IERC20(l1Token).approve(address(bridge), amount);\n        bridge.bridgeTokens(l1Token, amount);\n        emit RelayTokensCalled(l1Token, l2Token, amount, to, msg.sender);\n    }\n}\n\n// This contract is intended to \"act like\" a simple version of an L2 bridge.\n// It's primarily meant to better reflect how a true L2 bridge interaction might work to give better gas estimates.\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Mock_Bridge {\n    event BridgedTokens(address token, uint256 amount);\n    event BridgedMessage(address target, bytes message);\n\n    mapping(address => uint256) public deposits;\n\n    function bridgeTokens(address token, uint256 amount) public {\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        deposits[token] += amount;\n        emit BridgedTokens(token, amount);\n    }\n\n    function bridgeMessage(address target, bytes calldata message) public {\n        emit BridgedMessage(target, message);\n    }\n}\n"
    },
    "contracts/chain-adapters/Mode_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Mode. This is a clone of the Base adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Mode_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Mode system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Mode.\n     * @param target Contract on Mode that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Mode.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/OP_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { CircleCCTPAdapter, CircleDomainIds } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\nimport { IOpUSDCBridgeAdapter } from \"../external/interfaces/IOpUSDCBridgeAdapter.sol\";\nimport { WETH9Interface } from \"../external/interfaces/WETH9Interface.sol\";\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport { CrossDomainEnabled } from \"./CrossDomainEnabled.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to an OP stack chain.\n * @notice This adapter supports the OpUSDCBridgeAdapter interface for bridging into Circle Bridged USDC.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract OP_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n    IOpUSDCBridgeAdapter public immutable L1_OP_USDC_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Destination chain system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        IERC20 _l1Usdc,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IOpUSDCBridgeAdapter _l1USDCBridge\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n        L1_OP_USDC_BRIDGE = _l1USDCBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on destination chain.\n     * @param target Contract on destination chain that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to destination chain.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        } else if (l1Token == address(usdcToken)) {\n            if (_isCCTPEnabled()) {\n                _transferUsdc(to, amount);\n            } else {\n                // Use the relevant OP USDC bridge to received bridged USDC on L2.\n                IERC20(l1Token).safeIncreaseAllowance(address(L1_OP_USDC_BRIDGE), amount);\n                L1_OP_USDC_BRIDGE.sendMessage(to, amount, L2_GAS_LIMIT);\n            }\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(address(L1_STANDARD_BRIDGE), amount);\n            L1_STANDARD_BRIDGE.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Optimism_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Interface for Synthetix custom bridge to Optimism.\n */\ninterface SynthetixBridgeToOptimism is IL1StandardBridge {\n    /**\n     * @notice Send tokens to Optimism.\n     * @param to Address to send tokens to on L2.\n     * @param amount Amount of tokens to send.\n     */\n    function depositTo(address to, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Optimism.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore it's only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Optimism_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    // Optimism has the ability to support \"custom\" bridges. These bridges are not supported by the canonical bridge\n    // and so we need to store the address of the custom token and the associated bridge. In the event we want to\n    // support a new token that is not supported by Optimism, we can add a new custom bridge for it and re-deploy the\n    // adapter. A full list of custom optimism tokens and their associated bridges can be found here:\n    // https://github.com/ethereum-optimism/ethereum-optimism.github.io/blob/master/optimism.tokenlist.json\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant DAI_OPTIMISM_BRIDGE = 0x10E6593CDda8c58a1d0f14C5164B376352a55f2F;\n    address public constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n    address public constant SNX_OPTIMISM_BRIDGE = 0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Optimism system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Optimism)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Optimism.\n     * @param target Contract on Optimism that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Optimism.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // If the l1Token is USDC, then we send it to the CCTP bridge\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            address bridgeToUse = address(L1_STANDARD_BRIDGE);\n\n            // Check if the L1 token requires a custom bridge. If so, use that bridge over the standard bridge.\n            if (l1Token == DAI) bridgeToUse = DAI_OPTIMISM_BRIDGE; // 1. DAI\n            if (l1Token == SNX) bridgeToUse = SNX_OPTIMISM_BRIDGE; // 2. SNX\n\n            IERC20(l1Token).safeIncreaseAllowance(bridgeToUse, amount);\n            if (l1Token == SNX) SynthetixBridgeToOptimism(bridgeToUse).depositTo(to, amount);\n            else IL1StandardBridge(bridgeToUse).depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Ovm_Forwarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { ForwarderBase } from \"./ForwarderBase.sol\";\nimport { LibOptimismUpgradeable } from \"@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol\";\nimport { Lib_PredeployAddresses } from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport { WETH9Interface } from \"../external/interfaces/WETH9Interface.sol\";\n\n/**\n * @title Ovm_Forwarder\n * @notice This contract expects to receive messages and tokens from the hub pool on L1 and forwards messages to a spoke pool on L3.\n * It rejects messages which do not originate from a cross domain admin, which is set as the hub pool.\n * @dev This forwarder assumes that the cross domain messenger predeploy contract is set to the same contract as the standard OpStack predeploy.\n * (0x4200000000000000000000000000000000000007). This is because in order to determine the L1 msg.sender of a cross-chain message, we must\n * query information from that contract.\n * @custom:security-contact bugs@across.to\n */\ncontract Ovm_Forwarder is ForwarderBase {\n    // Address of the cross domain messenger contract.\n    address public constant MESSENGER = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n\n    error NotCrossDomainAdmin();\n\n    /**\n     * @notice Constructs an Ovm specific forwarder contract.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on the L2.\n     */\n    constructor(WETH9Interface _wrappedNativeToken) ForwarderBase(_wrappedNativeToken) {}\n\n    /**\n     * @notice Initializes the forwarder contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function initialize(address _crossDomainAdmin) public initializer {\n        __Forwarder_init(_crossDomainAdmin);\n    }\n\n    function _requireAdminSender() internal view override {\n        if (LibOptimismUpgradeable.crossChainSender(MESSENGER) != crossDomainAdmin) revert NotCrossDomainAdmin();\n    }\n}\n"
    },
    "contracts/chain-adapters/Polygon_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Send tokens to Polygon.\n */\ninterface IRootChainManager {\n    /**\n     * @notice Send msg.value of ETH to Polygon\n     * @param user Recipient of ETH on Polygon.\n     */\n    function depositEtherFor(address user) external payable;\n\n    /**\n     * @notice Send ERC20 tokens to Polygon.\n     * @param user Recipient of L2 equivalent tokens on Polygon.\n     * @param rootToken L1 Address of token to send.\n     * @param depositData Data to pass to L2 including amount of tokens to send. Should be abi.encode(amount).\n     */\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external;\n}\n\n/**\n * @notice Send arbitrary messages to Polygon.\n */\ninterface IFxStateSender {\n    /**\n     * @notice Send arbitrary message to Polygon.\n     * @param _receiver Address on Polygon to receive message.\n     * @param _data Message to send to `_receiver` on Polygon.\n     */\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\n}\n\n/**\n * @notice Similar to RootChainManager, but for Matic (Plasma) bridge.\n */\ninterface DepositManager {\n    /**\n     * @notice Send tokens to Polygon. Only used to send MATIC in this Polygon_Adapter.\n     * @param token L1 token to send. Should be MATIC.\n     * @param user Recipient of L2 equivalent tokens on Polygon.\n     * @param amount Amount of `token` to send.\n     */\n    function depositERC20ForUser(\n        address token,\n        address user,\n        uint256 amount\n    ) external;\n}\n\n/**\n * @notice Sends cross chain messages Polygon L2 network.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Polygon_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    IRootChainManager public immutable ROOT_CHAIN_MANAGER;\n    IFxStateSender public immutable FX_STATE_SENDER;\n    DepositManager public immutable DEPOSIT_MANAGER;\n    address public immutable ERC20_PREDICATE;\n    address public immutable L1_MATIC;\n    WETH9Interface public immutable L1_WETH;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _rootChainManager RootChainManager Polygon system contract to deposit tokens over the PoS bridge.\n     * @param _fxStateSender FxStateSender Polygon system contract to send arbitrary messages to L2.\n     * @param _depositManager DepositManager Polygon system contract to deposit tokens over the Plasma bridge (Matic).\n     * @param _erc20Predicate ERC20Predicate Polygon system contract to approve when depositing to the PoS bridge.\n     * @param _l1Matic matic address on l1.\n     * @param _l1Weth WETH address on L1.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        IRootChainManager _rootChainManager,\n        IFxStateSender _fxStateSender,\n        DepositManager _depositManager,\n        address _erc20Predicate,\n        address _l1Matic,\n        WETH9Interface _l1Weth,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Polygon) {\n        ROOT_CHAIN_MANAGER = _rootChainManager;\n        FX_STATE_SENDER = _fxStateSender;\n        DEPOSIT_MANAGER = _depositManager;\n        ERC20_PREDICATE = _erc20Predicate;\n        L1_MATIC = _l1Matic;\n        L1_WETH = _l1Weth;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Polygon.\n     * @param target Contract on Polygon that will receive message.\n     * @param message Data to send to target.\n     */\n\n    function relayMessage(address target, bytes calldata message) external payable override {\n        FX_STATE_SENDER.sendMessageToChild(target, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Polygon.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            ROOT_CHAIN_MANAGER.depositEtherFor{ value: amount }(to);\n        }\n        // If the l1Token is USDC, then we send it to the CCTP bridge\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else if (l1Token == L1_MATIC) {\n            IERC20(l1Token).safeIncreaseAllowance(address(DEPOSIT_MANAGER), amount);\n            DEPOSIT_MANAGER.depositERC20ForUser(l1Token, to, amount);\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(ERC20_PREDICATE, amount);\n            ROOT_CHAIN_MANAGER.depositFor(to, l1Token, abi.encode(amount));\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/PolygonZkEVM_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\nimport \"../external/interfaces/IPolygonZkEVMBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Supports sending messages and tokens from L1 to PolygonZkEVM.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract PolygonZkEVM_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    WETH9Interface public immutable L1_WETH;\n    // Address of Polygon zkEVM's Canonical Bridge on L1.\n    IPolygonZkEVMBridge public immutable L1_POLYGON_ZKEVM_BRIDGE;\n\n    // Polygon's internal network id for zkEVM.\n    uint32 public constant POLYGON_ZKEVM_L2_NETWORK_ID = 1;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _l1PolygonZkEVMBridge Canonical token bridge contract on L1.\n     */\n    constructor(WETH9Interface _l1Weth, IPolygonZkEVMBridge _l1PolygonZkEVMBridge) {\n        L1_WETH = _l1Weth;\n        L1_POLYGON_ZKEVM_BRIDGE = _l1PolygonZkEVMBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Polygon zkEVM.\n     * @param target Contract on Polygon zkEVM that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        L1_POLYGON_ZKEVM_BRIDGE.bridgeMessage(POLYGON_ZKEVM_L2_NETWORK_ID, target, true, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Polygon zkEVM.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // The mapped WETH address in the native Polygon zkEVM bridge contract does not match\n        // the official WETH address. Therefore, if the l1Token is WETH then unwrap it to ETH\n        // and send the ETH directly via as msg.value.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_POLYGON_ZKEVM_BRIDGE.bridgeAsset{ value: amount }(\n                POLYGON_ZKEVM_L2_NETWORK_ID,\n                to,\n                amount,\n                address(0),\n                true,\n                \"\"\n            );\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(address(L1_POLYGON_ZKEVM_BRIDGE), amount);\n            L1_POLYGON_ZKEVM_BRIDGE.bridgeAsset(POLYGON_ZKEVM_L2_NETWORK_ID, to, amount, l1Token, true, \"\");\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Redstone_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Redstone. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Redstone_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Redstone system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Redstone.\n     * @param target Contract on Redstone that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Redstone.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Router_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\nimport { ForwarderInterface } from \"./interfaces/ForwarderInterface.sol\";\nimport { HubPoolInterface } from \"../interfaces/HubPoolInterface.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to \"L3\" networks that do not have direct connections\n * with L1. L3's are defined as networks that connect to L1 indirectly via L2, and this contract sends\n * messages to those L3's by rerouting them via those L2's. This contract is called a \"Router\" because it uses\n * (i.e. delegatecall's) existing L2 adapter logic to send a message first from L1 to L2 and then from L2 to L3.\n * @dev Due to the constraints of the `SetCrossChainContracts` event as outlined in UMIP-157 and how the HubPool\n * delegatecalls adapters like this one, all messages relayed through this\n * adapter have target addresses on the L3's. However, these target addresses do not exist on L2 where all messages are\n * rerouted through. Therefore, this contract is designed to be used in tandem with \"L2 Forwarder Adapters\" which help\n * get the messages from L1 to L3 via L2's.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Router_Adapter is AdapterInterface {\n    // Adapter designed to relay messages from L1 to L2 addresses and delegatecalled by this contract to reroute\n    // messages to L3 via the L2_TARGET.\n    address public immutable L1_ADAPTER;\n    // L2_TARGET is a \"Forwarder\" contract that will help relay messages from L1 to L3. Messages are \"rerouted\" through\n    // the L2_TARGET.\n    address public immutable L2_TARGET;\n    // L2_CHAIN_ID is the chain ID of the network which is \"in between\" the L1 and L3. This network will contain the forwarder.\n    uint256 public immutable L2_CHAIN_ID;\n    // L3_CHAIN_ID is the chain ID of the network which contains the target spoke pool. This chain id is passed to the\n    // forwarder contract so that it may determine the correct L2-L3 bridge to use to arrive at L3.\n    uint256 public immutable L3_CHAIN_ID;\n    // Interface of the Hub Pool. Used to query state related to L1-L2 token mappings.\n    HubPoolInterface public immutable HUB_POOL;\n\n    error RelayMessageFailed();\n    error RelayTokensFailed(address l1Token);\n    error L2RouteNotWhitelisted(address l1Token);\n\n    /**\n     * @notice Constructs new Adapter. This contract will re-route messages destined for an L3 to L2_TARGET via the L1_ADAPTER contract.\n     * @param _l1Adapter Address of the adapter contract on mainnet which implements message transfers\n     * and token relays to the L2 where _l2Target is deployed.\n     * @param _l2Target Address of the L2 contract which receives the token and message relays in order to forward them to an L3.\n     * @param _l2ChainId Chain ID of the network which contains the forwarder. It is the network which is intermediate in message\n     * transmission from L1 to L3.\n     * @param _l3ChainId Chain ID of the network which contains the spoke pool which corresponds to this adapter instance.\n     * @param _hubPool Address of the hub pool deployed on L1.\n     */\n    constructor(\n        address _l1Adapter,\n        address _l2Target,\n        uint256 _l2ChainId,\n        uint256 _l3ChainId,\n        HubPoolInterface _hubPool\n    ) {\n        L1_ADAPTER = _l1Adapter;\n        L2_TARGET = _l2Target;\n        L2_CHAIN_ID = _l2ChainId;\n        L3_CHAIN_ID = _l3ChainId;\n        HUB_POOL = _hubPool;\n    }\n\n    /**\n     * @notice Send cross-chain message to a target on L2 which will forward messages to the intended remote target on an L3.\n     * @param target Address of the remote contract which receives `message` after it has been forwarded by all intermediate\n     * contracts.\n     * @param message Data to send to `target`.\n     * @dev The message passed into this function is wrapped into a `relayMessage` function call, which is then passed\n     * to L2. The `L2_TARGET` contract implements ForwarderInterface, so upon arrival on L2, the arguments to the L2 contract's\n     * `relayMessage` call will be these `target` and `message` values. From there, the forwarder derives the next appropriate\n     * method to send `message` to the following layers and ultimately to the target on L3.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        bytes memory wrappedMessage = abi.encodeCall(ForwarderInterface.relayMessage, (target, L3_CHAIN_ID, message));\n        (bool success, ) = L1_ADAPTER.delegatecall(\n            abi.encodeCall(AdapterInterface.relayMessage, (L2_TARGET, wrappedMessage))\n        );\n        if (!success) revert RelayMessageFailed();\n    }\n\n    /**\n     * @notice Bridge tokens to a target on L2 and follow up the token bridge with a call to continue bridging the sent tokens.\n     * @param l1Token L1 token to deposit.\n     * @param l3Token L3 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L3 tokens to receive.\n     * @param target The address of the contract which should ultimately receive `amount` of `l3Token`.\n     * @dev When sending tokens, we follow-up with a message describing the amount of tokens we wish to continue bridging.\n     * This allows forwarders to know how much of some token to allocate to a certain target.\n     */\n    function relayTokens(\n        address l1Token,\n        address l3Token,\n        uint256 amount,\n        address target\n    ) external payable override {\n        // Fetch the address of the L2 token, as defined in the Hub Pool. This is to complete a proper token bridge from L1 to L2.\n        address l2Token = HUB_POOL.poolRebalanceRoute(L2_CHAIN_ID, l1Token);\n        // If l2Token is the zero address, then this means that the L2 token is not enabled as a pool rebalance route. This is similar\n        // to the check in the hub pool contract found here: https://github.com/across-protocol/contracts/blob/a2afefecba57177a62be35be092516d0c106097e/contracts/HubPool.sol#L890\n        if (l2Token == address(0)) revert L2RouteNotWhitelisted(l1Token);\n\n        // Relay tokens to the forwarder.\n        (bool success, ) = L1_ADAPTER.delegatecall(\n            abi.encodeCall(AdapterInterface.relayTokens, (l1Token, l2Token, amount, L2_TARGET))\n        );\n        if (!success) revert RelayTokensFailed(l1Token);\n\n        // Follow-up token relay with a message to continue the token relay on L2.\n        bytes memory message = abi.encodeCall(\n            ForwarderInterface.relayTokens,\n            (l2Token, l3Token, amount, L3_CHAIN_ID, target)\n        );\n        (success, ) = L1_ADAPTER.delegatecall(abi.encodeCall(AdapterInterface.relayMessage, (L2_TARGET, message)));\n        if (!success) revert RelayMessageFailed();\n    }\n}\n"
    },
    "contracts/chain-adapters/Scroll_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@scroll-tech/contracts/L1/gateways/IL1GatewayRouter.sol\";\nimport \"@scroll-tech/contracts/L1/rollup/IL2GasPriceOracle.sol\";\nimport \"@scroll-tech/contracts/L1/IL1ScrollMessenger.sol\";\nimport \"./interfaces/AdapterInterface.sol\";\n\n/**\n * @title Scroll_Adapter\n * @notice Adapter contract deployed on L1 alongside the HubPool to facilitate token transfers\n * and arbitrary message relaying from L1 to L2.\n * @custom:security-contact bugs@across.to\n */\ncontract Scroll_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Used as the gas limit for relaying messages to L2.\n     */\n    uint32 public immutable L2_MESSAGE_RELAY_GAS_LIMIT;\n\n    /**\n     * @notice Use as the gas limit for relaying tokens to L2.\n     */\n    uint32 public immutable L2_TOKEN_RELAY_GAS_LIMIT;\n\n    /**\n     * @notice The address of the official l1GatewayRouter contract for Scroll for bridging tokens from L1 -> L2\n     * @dev We can find these (main/test)net deployments here: https://docs.scroll.io/en/developers/scroll-contracts/#scroll-contracts\n     */\n    IL1GatewayRouter public immutable L1_GATEWAY_ROUTER;\n\n    /**\n     * @notice The address of the official messenger contract for Scroll from L1 -> L2\n     * @dev We can find these (main/test)net deployments here: https://docs.scroll.io/en/developers/scroll-contracts/#scroll-contracts\n     */\n    IL1ScrollMessenger public immutable L1_SCROLL_MESSENGER;\n\n    /**\n     * @notice The address of the official gas price oracle contract for Scroll for estimating the relayer fee\n     * @dev We can find these (main/test)net deployments here: https://docs.scroll.io/en/developers/scroll-contracts/#scroll-contracts\n     */\n    IL2GasPriceOracle public immutable L2_GAS_PRICE_ORACLE;\n\n    /**************************************\n     *          PUBLIC FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1GatewayRouter Standard bridge contract.\n     * @param _l1ScrollMessenger Scroll Messenger contract.\n     * @param _l2GasPriceOracle Gas price oracle contract.\n     * @param _l2MessageRelayGasLimit Gas limit for relaying messages to L2.\n     * @param _l2TokenRelayGasLimit Gas limit for relaying tokens to L2.\n     */\n    constructor(\n        IL1GatewayRouter _l1GatewayRouter,\n        IL1ScrollMessenger _l1ScrollMessenger,\n        IL2GasPriceOracle _l2GasPriceOracle,\n        uint32 _l2MessageRelayGasLimit,\n        uint32 _l2TokenRelayGasLimit\n    ) {\n        L1_GATEWAY_ROUTER = _l1GatewayRouter;\n        L1_SCROLL_MESSENGER = _l1ScrollMessenger;\n        L2_GAS_PRICE_ORACLE = _l2GasPriceOracle;\n        L2_MESSAGE_RELAY_GAS_LIMIT = _l2MessageRelayGasLimit;\n        L2_TOKEN_RELAY_GAS_LIMIT = _l2TokenRelayGasLimit;\n    }\n\n    /**\n     * @notice Send message to `target` on Scroll.\n     * @dev This message is marked payable because relaying the message will require\n     * a fee that needs to be propagated to the Scroll Bridge. It will not send msg.value\n     * to the target contract on L2.\n     * @param target L2 address to send message to.\n     * @param message Message to send to `target`.\n     */\n    function relayMessage(address target, bytes calldata message) external payable {\n        // We can specifically send a message with 0 value to the Scroll Bridge\n        // and it will not forward any ETH to the target contract on L2. However,\n        // we need to set the payable value to msg.value to ensure that the Scroll\n        // Bridge has enough gas to forward the message to L2.\n        L1_SCROLL_MESSENGER.sendMessage{ value: _generateRelayerFee(L2_MESSAGE_RELAY_GAS_LIMIT) }(\n            target,\n            0,\n            message,\n            L2_MESSAGE_RELAY_GAS_LIMIT\n        );\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Send `amount` of `l1Token` to `to` on Scroll. `l2Token` is the Scroll address equivalent of `l1Token`.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\n     * to the target contract on L2.\n     * @param l1Token L1 token to bridge.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of `l1Token` to bridge.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable {\n        IL1GatewayRouter _l1GatewayRouter = L1_GATEWAY_ROUTER;\n\n        // Confirm that the l2Token that we're trying to send is the correct counterpart\n        // address\n        address _l2Token = _l1GatewayRouter.getL2ERC20Address(l1Token);\n        require(_l2Token == l2Token, \"l2Token Mismatch\");\n\n        IERC20(l1Token).safeIncreaseAllowance(address(_l1GatewayRouter), amount);\n\n        // The scroll bridge handles arbitrary ERC20 tokens and is mindful of\n        // the official WETH address on-chain. We don't need to do anything specific\n        // to differentiate between WETH and a separate ERC20.\n        // Note: This happens due to the L1GatewayRouter.getERC20Gateway() call\n        // Note: dev docs: https://docs.scroll.io/en/developers/l1-and-l2-bridging/eth-and-erc20-token-bridge/\n        _l1GatewayRouter.depositERC20{ value: _generateRelayerFee(L2_TOKEN_RELAY_GAS_LIMIT) }(\n            l1Token,\n            to,\n            amount,\n            L2_TOKEN_RELAY_GAS_LIMIT\n        );\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    /**\n     * @notice Generates the relayer fee for a message to be sent to L2.\n     * @dev Function will revert if the contract does not have enough ETH to pay the fee.\n     * @param _l2GasLimit Gas limit for relaying message to L2.\n     * @return l2Fee The relayer fee for the message.\n     */\n    function _generateRelayerFee(uint32 _l2GasLimit) internal view returns (uint256 l2Fee) {\n        l2Fee = L2_GAS_PRICE_ORACLE.estimateCrossDomainMessageFee(_l2GasLimit);\n        require(address(this).balance >= l2Fee, \"Insufficient ETH balance\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Solana_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IMessageTransmitter, ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\nimport { SpokePoolInterface } from \"../interfaces/SpokePoolInterface.sol\";\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\nimport { CircleCCTPAdapter, CircleDomainIds } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { Bytes32ToAddress } from \"../libraries/AddressConverters.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Solana via CCTP.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore it's only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Solana_Adapter is AdapterInterface, CircleCCTPAdapter {\n    /**\n     * @notice We use Bytes32ToAddress library to map a Solana address to an Ethereum address representation.\n     * @dev The Ethereum address is derived from the Solana address by truncating it to its lowest 20 bytes. This same\n     * conversion must be done by the HubPool owner when adding Solana spoke pool and setting the corresponding pool\n     * rebalance and deposit routes.\n     */\n    using Bytes32ToAddress for bytes32;\n\n    /**\n     * @notice The official Circle CCTP MessageTransmitter contract endpoint.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\n     */\n    // solhint-disable-next-line immutable-vars-naming\n    IMessageTransmitter public immutable cctpMessageTransmitter;\n\n    // Solana spoke pool address, decoded from Base58 to bytes32.\n    bytes32 public immutable SOLANA_SPOKE_POOL_BYTES32;\n\n    // Solana spoke pool address, mapped to its EVM address representation.\n    address public immutable SOLANA_SPOKE_POOL_ADDRESS;\n\n    // USDC mint address on Solana, mapped to its EVM address representation.\n    address public immutable SOLANA_USDC_ADDRESS;\n\n    // USDC token address on Solana for the spoke pool (vault ATA), decoded from Base58 to bytes32.\n    bytes32 public immutable SOLANA_SPOKE_POOL_USDC_VAULT;\n\n    // Custom errors for constructor argument validation.\n    error InvalidCctpTokenMessenger(address tokenMessenger);\n    error InvalidCctpMessageTransmitter(address messageTransmitter);\n\n    // Custom errors for relayMessage validation.\n    error InvalidRelayMessageTarget(address target);\n\n    // Custom errors for relayTokens validation.\n    error InvalidL1Token(address l1Token);\n    error InvalidL2Token(address l2Token);\n    error InvalidAmount(uint256 amount);\n    error InvalidTokenRecipient(address to);\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge tokens via CCTP.\n     * @param _cctpMessageTransmitter MessageTransmitter contract to bridge messages via CCTP.\n     * @param solanaSpokePool Solana spoke pool address, decoded from Base58 to bytes32.\n     * @param solanaUsdc USDC mint address on Solana, decoded from Base58 to bytes32.\n     * @param solanaSpokePoolUsdcVault USDC token address on Solana for the spoke pool, decoded from Base58 to bytes32.\n     */\n    constructor(\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        IMessageTransmitter _cctpMessageTransmitter,\n        bytes32 solanaSpokePool,\n        bytes32 solanaUsdc,\n        bytes32 solanaSpokePoolUsdcVault\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Solana) {\n        // Solana adapter requires CCTP TokenMessenger and MessageTransmitter contracts to be set.\n        if (address(_cctpTokenMessenger) == address(0)) {\n            revert InvalidCctpTokenMessenger(address(_cctpTokenMessenger));\n        }\n        if (address(_cctpMessageTransmitter) == address(0)) {\n            revert InvalidCctpMessageTransmitter(address(_cctpMessageTransmitter));\n        }\n\n        cctpMessageTransmitter = _cctpMessageTransmitter;\n\n        SOLANA_SPOKE_POOL_BYTES32 = solanaSpokePool;\n        SOLANA_SPOKE_POOL_ADDRESS = solanaSpokePool.toAddressUnchecked();\n\n        SOLANA_USDC_ADDRESS = solanaUsdc.toAddressUnchecked();\n\n        SOLANA_SPOKE_POOL_USDC_VAULT = solanaSpokePoolUsdcVault;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Solana.\n     * @dev Only allows sending messages to the Solana spoke pool.\n     * @param target Program on Solana (translated as EVM address) that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        if (target != SOLANA_SPOKE_POOL_ADDRESS) {\n            revert InvalidRelayMessageTarget(target);\n        }\n        cctpMessageTransmitter.sendMessage(CircleDomainIds.Solana, SOLANA_SPOKE_POOL_BYTES32, message);\n\n        // TODO: consider if we need also to emit the translated message.\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Solana.\n     * @dev Only allows bridging USDC to Solana spoke pool.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        if (l1Token != address(usdcToken)) {\n            revert InvalidL1Token(l1Token);\n        }\n        if (l2Token != SOLANA_USDC_ADDRESS) {\n            revert InvalidL2Token(l2Token);\n        }\n        if (amount > type(uint64).max) {\n            revert InvalidAmount(amount);\n        }\n        if (to != SOLANA_SPOKE_POOL_ADDRESS) {\n            revert InvalidTokenRecipient(to);\n        }\n\n        _transferUsdc(SOLANA_SPOKE_POOL_USDC_VAULT, amount);\n\n        // TODO: consider if we need also to emit the translated addresses.\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Succinct_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/SuccinctInterfaces.sol\";\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Succinct_Adapter is AdapterInterface {\n    ITelepathyBroadcaster public immutable succinctSourceAmb;\n    uint16 public immutable destinationChainId;\n\n    // Special Succinct event for additional tracking information.\n    event SuccinctMessageRelayed(bytes32 messageRoot, uint16 destinationChainId, address target, bytes message);\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _succinctSourceAmb address of the SourceAmb succinct contract for sending messages.\n     * @param _destinationChainId chainId of the destination.\n     */\n    constructor(ITelepathyBroadcaster _succinctSourceAmb, uint16 _destinationChainId) {\n        succinctSourceAmb = _succinctSourceAmb;\n        destinationChainId = _destinationChainId;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on the destination.\n     * @param target Contract on the destination that will receive the message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        bytes32 messageRoot = succinctSourceAmb.send(destinationChainId, target, message);\n\n        // Note: this emits two events. MessageRelayed for the sake of compatibility with other adapters.\n        // It emits SuccinctMessageRelayed to encode additional tracking information that is Succinct-specific.\n        emit MessageRelayed(target, message);\n        emit SuccinctMessageRelayed(messageRoot, destinationChainId, target, message);\n    }\n\n    /**\n     * @notice No-op relay tokens method.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        // This method is intentionally left as a no-op.\n        // If the adapter is intended to be able to relay tokens, this method should be overriden.\n    }\n}\n"
    },
    "contracts/chain-adapters/Universal_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport { SpokePoolInterface } from \"../interfaces/SpokePoolInterface.sol\";\nimport { HubPoolStore } from \"./utilities/HubPoolStore.sol\";\nimport { IOFT } from \"../interfaces/IOFT.sol\";\nimport { OFTTransportAdapterWithStore } from \"../libraries/OFTTransportAdapterWithStore.sol\";\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n\n/**\n * @notice Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts\n * on the L2 where the SpokePool is deployed. Designed to be used as a singleton contract that can be used to relay\n * messages to multiple SpokePools on different chains.\n * @dev This contract should NOT be reused to send messages to SpokePools that have the same address on different L2s.\n * @dev This contract can be redeployed to point to a new HubPoolStore if the data store gets corrupted and new data\n * can't get written to the store for some reason. The corresponding Universal_SpokePool contract will\n * also need to be redeployed to point to the new HubPoolStore.\n * @custom:security-contact bugs@across.to\n */\ncontract Universal_Adapter is AdapterInterface, CircleCCTPAdapter, OFTTransportAdapterWithStore {\n    /// @notice Contract that stores calldata to be relayed to L2 via storage proofs.\n    HubPoolStore public immutable DATA_STORE;\n\n    error NotImplemented();\n\n    constructor(\n        HubPoolStore _store,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _cctpDestinationDomainId,\n        address _adapterStore,\n        uint32 _oftDstEid,\n        uint256 _oftFeeCap\n    )\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, _cctpDestinationDomainId)\n        OFTTransportAdapterWithStore(_oftDstEid, _oftFeeCap, _adapterStore)\n    {\n        DATA_STORE = _store;\n    }\n\n    /**\n     * @notice Saves calldata in a simple storage contract whose state can be proven and relayed to L2.\n     * @param target Contract on the destination that will receive the message. Unused if the message is created\n     * by the HubPool admin.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        // Admin messages are stored differently in the data store than non-admin messages, because admin\n        // messages must only be sent to a single target on a specific L2 chain. Non-admin messages are sent\n        // to any target on any L2 chain because the only type of an non-admin message is the result of a\n        // HubPool.executeRootBundle() call which attempts to relay a relayRootBundle() call to all SpokePools using\n        // this adapter. Therefore, non-admin messages are stored optimally in the data store\n        // by only storing the message once and allowing any SpokePool target to read it via storage proofs.\n\n        // We assume that the HubPool is delegatecall-ing into this function, therefore address(this) is the HubPool's\n        // address. As a result, we can determine whether this message is an admin function based on the msg.sender.\n        // If an admin sends a message that could have been relayed as a non-admin message (e.g. the admin\n        // calls executeRootBundle()), then the message won't be stored optimally in the data store, but the\n        // message can still be delivered to the target.\n        bool isAdminSender = msg.sender == IOwnable(address(this)).owner();\n        DATA_STORE.storeRelayMessageCalldata(target, message, isAdminSender);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Relays tokens from L1 to L2.\n     * @dev This function uses CircleCCTPAdapter to relay USDC and OFTTransportAdapterWithStore to relay\n     * OFT tokens to L2 chains that support these methods. Relaying other tokens will cause this function\n     * to revert.\n     * @param l1Token Address of the token on L1.\n     * @param l2Token Address of the token on L2. Unused\n     * @param amount Amount of tokens to relay.\n     * @param to Address to receive the tokens on L2. Should be SpokePool address.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        address oftMessenger = _getOftMessenger(l1Token);\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else if (oftMessenger != address(0)) {\n            _transferViaOFT(IERC20(l1Token), IOFT(oftMessenger), to, amount);\n        } else {\n            revert NotImplemented();\n        }\n    }\n}\n"
    },
    "contracts/chain-adapters/utilities/HubPoolStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { HubPoolInterface } from \"../../interfaces/HubPoolInterface.sol\";\n\ninterface IHubPool {\n    function rootBundleProposal() external view returns (HubPoolInterface.RootBundle memory);\n}\n\n/**\n * @notice Stores data that can be relayed to L2 SpokePool using storage proof verification and light client contracts\n * on the L2 where the SpokePool is deployed. Only the HubPool can store data to this contract. Each data to be\n * relayed is written to a unique slot key and that slot key's value can never be modified.\n * @dev Designed to be used with Universal_Adapter and Universal_SpokePool.\n * @dev This contract DOES NOT prevent replay attacks of storage proofs on the L2 spoke pool if the\n * UniversalStorageProof_Adapters using this contract are mapped to spokepools with the same address on different\n * L2 chains. See comment in storeRelayAdminFunctionCalldata() for more details.\n * @custom:security-contact bugs@across.to\n */\ncontract HubPoolStore {\n    error NotHubPool();\n\n    /// @notice Maps nonce to hash of calldata.\n    mapping(uint256 => bytes32) public relayMessageCallData;\n\n    /// @notice Counter to ensure that each relay admin function calldata is unique.\n    uint256 private dataUuid;\n\n    /// @notice Address of the HubPool contract, the only contract that can store data to this contract.\n    address public immutable hubPool;\n\n    /// @notice Event designed to be queried off chain and relayed to Universal SpokePool.\n    event StoredCallData(address indexed target, bytes data, uint256 indexed nonce);\n\n    modifier onlyHubPool() {\n        if (msg.sender != hubPool) {\n            revert NotHubPool();\n        }\n        _;\n    }\n\n    constructor(address _hubPool) {\n        hubPool = _hubPool;\n    }\n\n    /**\n     * @notice To be called by HubPool to store calldata that will be relayed\n     * to the Universal_SpokePool via storage proofs.\n     * @dev Only callable by the HubPool contract.\n     * @param target Address of the contract on the destination that will receive the message. Unused if the\n     * data is NOT an admin function and can be relayed to any target.\n     * @param data Data to send to Universal SpokePool.\n     * @param isAdminSender True if the data is an admin function call, false otherwise.\n     */\n    function storeRelayMessageCalldata(\n        address target,\n        bytes calldata data,\n        bool isAdminSender\n    ) external onlyHubPool {\n        if (isAdminSender) {\n            _storeData(target, dataUuid++, data);\n        } else {\n            _storeRelayMessageCalldataForAnyTarget(data);\n        }\n    }\n\n    function _storeRelayMessageCalldataForAnyTarget(bytes calldata data) internal {\n        // When the data can be sent to any target, we assume that the data contains a relayRootBundleCall as\n        // constructed by an executeRootBundle() call, therefore this data will be identical for all spoke pools\n        // in this bundle. We can use the current hub pool's challengePeriodEndTimestamp as the nonce for this data\n        // so that all relayRootBundle calldata for this bundle gets stored to the same slot and we only write to\n        // this slot once.\n        _storeData(address(0), IHubPool(hubPool).rootBundleProposal().challengePeriodEndTimestamp, data);\n    }\n\n    function _storeData(\n        address target,\n        uint256 nonce,\n        bytes calldata data\n    ) internal {\n        if (relayMessageCallData[nonce] != bytes32(0)) {\n            // Data is already stored, do nothing.\n            return;\n        }\n        relayMessageCallData[nonce] = keccak256(abi.encode(target, data));\n        emit StoredCallData(target, data, nonce);\n    }\n}\n"
    },
    "contracts/chain-adapters/ZkStack_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\nimport { CircleCCTPAdapter } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkStack with ETH as the gas token.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkStack_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // The ZkSync bridgehub contract treats address(1) to represent ETH.\n    address private constant ETH_TOKEN_ADDRESS = address(1);\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://docs.zksync.io/build/developer-reference/l1-l2-interoperability#l1-to-l2-gas-estimation-for-transactions\n\n    // Limit on L2 gas to spend.\n    uint256 public immutable L2_GAS_LIMIT; // typically 2_000_000\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public immutable L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT; // Typically 800\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable L2_REFUND_ADDRESS;\n\n    // L2 chain id\n    uint256 public immutable CHAIN_ID;\n\n    // BridgeHub address\n    BridgeHubInterface public immutable BRIDGE_HUB;\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable L1_WETH;\n\n    // USDC SharedBridge address, which is passed in on construction and used as the second bridge contract for USDC transfers.\n    address public immutable USDC_SHARED_BRIDGE;\n\n    // The maximum gas price a transaction sent to this adapter may have. This is set to prevent a block producer from setting an artificially high priority fee\n    // when calling a hub pool message relay, which would otherwise cause a large amount of ETH to be sent to L2.\n    uint256 private immutable MAX_TX_GASPRICE;\n\n    error ETHGasTokenRequired();\n    error TransactionFeeTooHigh();\n    error InvalidBridgeConfig();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @notice Circle bridged & native USDC are optionally supported via configuration, but are mutually exclusive.\n     * @param _chainId The target ZkStack network's chain ID.\n     * @param _bridgeHub The bridge hub contract address for the ZkStack network.\n     * @param _circleUSDC Circle USDC address on L1. If not set to address(0), then either the USDCSharedBridge\n     * or CCTP token messenger must be set and will be used to bridge this token.\n     * @param _usdcSharedBridge Address of the second bridge contract for USDC corresponding to the configured ZkStack network.\n     * @param _cctpTokenMessenger address of the CCTP token messenger contract for the configured network.\n     * @param _recipientCircleDomainId Circle domain ID for the destination network.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     * @param _l2GasLimit The maximum amount of gas this contract is willing to pay to execute a transaction on L2.\n     * @param _l1GasToL2GasPerPubDataLimit The exchange rate of l1 gas to l2 gas.\n     * @param _maxTxGasprice The maximum effective gas price any transaction sent to this adapter may have.\n     */\n    constructor(\n        uint256 _chainId,\n        BridgeHubInterface _bridgeHub,\n        IERC20 _circleUSDC,\n        address _usdcSharedBridge,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId,\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        uint256 _l2GasLimit,\n        uint256 _l1GasToL2GasPerPubDataLimit,\n        uint256 _maxTxGasprice\n    ) CircleCCTPAdapter(_circleUSDC, _cctpTokenMessenger, _recipientCircleDomainId) {\n        CHAIN_ID = _chainId;\n        BRIDGE_HUB = _bridgeHub;\n        L1_WETH = _l1Weth;\n        L2_REFUND_ADDRESS = _l2RefundAddress;\n        L2_GAS_LIMIT = _l2GasLimit;\n        MAX_TX_GASPRICE = _maxTxGasprice;\n        L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = _l1GasToL2GasPerPubDataLimit;\n        address zero = address(0);\n        if (address(_circleUSDC) != zero) {\n            bool zkUSDCBridgeDisabled = _usdcSharedBridge == zero;\n            bool cctpUSDCBridgeDisabled = address(_cctpTokenMessenger) == zero;\n            // Bridged and Native USDC are mutually exclusive.\n            if (zkUSDCBridgeDisabled == cctpUSDCBridgeDisabled) {\n                revert InvalidBridgeConfig();\n            }\n        }\n        USDC_SHARED_BRIDGE = _usdcSharedBridge;\n        address gasToken = BRIDGE_HUB.baseToken(CHAIN_ID);\n        if (gasToken != ETH_TOKEN_ADDRESS) {\n            revert ETHGasTokenRequired();\n        }\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkStack.\n     * @dev The HubPool must hold enough ETH to pay for the L2 txn.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _computeETHTxCost(L2_GAS_LIMIT);\n\n        BRIDGE_HUB.requestL2TransactionDirect{ value: txBaseCost }(\n            BridgeHubInterface.L2TransactionRequestDirect({\n                chainId: CHAIN_ID,\n                mintValue: txBaseCost,\n                l2Contract: target,\n                l2Value: 0,\n                l2Calldata: message,\n                l2GasLimit: L2_GAS_LIMIT,\n                l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                factoryDeps: new bytes[](0),\n                refundRecipient: L2_REFUND_ADDRESS\n            })\n        );\n\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkStack.\n     * @dev The HubPool must hold enough ETH to pay for the L2 txn.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // A bypass proxy seems to no longer be needed to avoid deposit limits. The tracking of these limits seems to be deprecated.\n        // See: https://github.com/matter-labs/era-contracts/blob/bce4b2d0f34bd87f1aaadd291772935afb1c3bd6/l1-contracts/contracts/bridge/L1ERC20Bridge.sol#L54-L55\n        uint256 txBaseCost = _computeETHTxCost(L2_GAS_LIMIT);\n\n        bytes32 txHash;\n        if (l1Token == address(L1_WETH)) {\n            // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n            // cost.\n            L1_WETH.withdraw(amount);\n            txHash = BRIDGE_HUB.requestL2TransactionDirect{ value: amount + txBaseCost }(\n                BridgeHubInterface.L2TransactionRequestDirect({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost + amount,\n                    l2Contract: to,\n                    l2Value: amount,\n                    l2Calldata: \"\",\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    factoryDeps: new bytes[](0),\n                    refundRecipient: L2_REFUND_ADDRESS\n                })\n            );\n        } else if (l1Token == address(usdcToken)) {\n            // Either use CCTP or the custom shared bridge when bridging USDC.\n            if (_isCCTPEnabled()) {\n                _transferUsdc(to, amount);\n            } else {\n                IERC20(l1Token).forceApprove(USDC_SHARED_BRIDGE, amount);\n                txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                    BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                        chainId: CHAIN_ID,\n                        mintValue: txBaseCost,\n                        l2Value: 0,\n                        l2GasLimit: L2_GAS_LIMIT,\n                        l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                        refundRecipient: L2_REFUND_ADDRESS,\n                        secondBridgeAddress: USDC_SHARED_BRIDGE,\n                        secondBridgeValue: 0,\n                        secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                    })\n                );\n            }\n        } else {\n            // An standard bridged ERC20, separate from WETH and Circle Bridged/Native USDC.\n            address sharedBridge = BRIDGE_HUB.sharedBridge();\n            IERC20(l1Token).forceApprove(sharedBridge, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges{ value: txBaseCost }(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: sharedBridge,\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Computes the calldata for the \"second bridge\", which handles sending non native tokens.\n     * @param l2Recipient recipient of the tokens.\n     * @param l1Token the l1 address of the token. Note: ETH is encoded as address(1).\n     * @param amount number of tokens to send.\n     * @return abi encoded bytes.\n     */\n    function _secondBridgeCalldata(\n        address l2Recipient,\n        address l1Token,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        return abi.encode(l1Token, amount, l2Recipient);\n    }\n\n    /**\n     * @notice For a given l2 gas limit, this computes the amount of ETH needed and\n     * returns the amount.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of ETH that this contract needs to provide in order for the l2 transaction to succeed.\n     */\n    function _computeETHTxCost(uint256 l2GasLimit) internal view returns (uint256) {\n        if (tx.gasprice > MAX_TX_GASPRICE) revert TransactionFeeTooHigh();\n        return BRIDGE_HUB.l2TransactionBaseCost(CHAIN_ID, tx.gasprice, l2GasLimit, L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT);\n    }\n}\n"
    },
    "contracts/chain-adapters/ZkStack_CustomGasToken_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\nimport { CircleCCTPAdapter } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Interface for funder contract that this contract pulls from to pay for relayMessage()/relayTokens()\n * fees using a custom gas token.\n */\ninterface FunderInterface {\n    /**\n     * @notice Withdraws amount of token from funder contract to the caller.\n     * @dev Can only be called by owner of Funder contract, which therefore must be\n     * this contract.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     */\n    function withdraw(IERC20 token, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkStack with a custom gas token.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkStack_CustomGasToken_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // The ZkSync bridgehub contract treats address(1) to represent ETH.\n    address private constant ETH_TOKEN_ADDRESS = address(1);\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://docs.zksync.io/build/developer-reference/l1-l2-interoperability#l1-to-l2-gas-estimation-for-transactions\n\n    // Limit on L2 gas to spend.\n    uint256 public immutable L2_GAS_LIMIT; // typically 2_000_000\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public immutable L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT; // Typically 800\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable L2_REFUND_ADDRESS;\n\n    // L2 chain id\n    uint256 public immutable CHAIN_ID;\n\n    // BridgeHub address\n    BridgeHubInterface public immutable BRIDGE_HUB;\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable L1_WETH;\n\n    // USDC SharedBridge address, which is passed in on construction and used as the second bridge contract for USDC transfers.\n    address public immutable USDC_SHARED_BRIDGE;\n\n    // Custom gas token address, which is read from the BridgeHub at construction.\n    address public immutable CUSTOM_GAS_TOKEN;\n\n    // Custom gas token funder\n    FunderInterface public immutable CUSTOM_GAS_TOKEN_FUNDER;\n\n    // The maximum gas price a transaction sent to this adapter may have. This is set to prevent a block producer from setting an artificially high priority fee\n    // when calling a hub pool message relay, which would otherwise cause a large amount of the custom gas token to be sent to L2.\n    uint256 private immutable MAX_TX_GASPRICE;\n\n    error ETHGasTokenNotAllowed();\n    error TransactionFeeTooHigh();\n    error InvalidBridgeConfig();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @notice Circle bridged & native USDC are optionally supported via configuration, but are mutually exclusive.\n     * @param _chainId The target ZkStack network's chain ID.\n     * @param _bridgeHub The bridge hub contract address for the ZkStack network.\n     * @param _circleUSDC Circle USDC address on L1. If not set to address(0), then either the USDCSharedBridge\n     * or CCTP token messenger must be set and will be used to bridge this token.\n     * @param _usdcSharedBridge Address of the second bridge contract for USDC corresponding to the configured ZkStack network.\n     * @param _cctpTokenMessenger address of the CCTP token messenger contract for the configured network.\n     * @param _recipientCircleDomainId Circle domain ID for the destination network.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     * @param _customGasTokenFunder Contract on L1 which funds bridge fees with amounts in the custom gas token.\n     * @param _l2GasLimit The maximum amount of gas this contract is willing to pay to execute a transaction on L2.\n     * @param _l1GasToL2GasPerPubDataLimit The exchange rate of l1 gas to l2 gas.\n     * @param _maxTxGasprice The maximum effective gas price any transaction sent to this adapter may have.\n     */\n    constructor(\n        uint256 _chainId,\n        BridgeHubInterface _bridgeHub,\n        IERC20 _circleUSDC,\n        address _usdcSharedBridge,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId,\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        FunderInterface _customGasTokenFunder,\n        uint256 _l2GasLimit,\n        uint256 _l1GasToL2GasPerPubDataLimit,\n        uint256 _maxTxGasprice\n    ) CircleCCTPAdapter(_circleUSDC, _cctpTokenMessenger, _recipientCircleDomainId) {\n        CHAIN_ID = _chainId;\n        BRIDGE_HUB = _bridgeHub;\n        L1_WETH = _l1Weth;\n        L2_REFUND_ADDRESS = _l2RefundAddress;\n        CUSTOM_GAS_TOKEN_FUNDER = _customGasTokenFunder;\n        L2_GAS_LIMIT = _l2GasLimit;\n        MAX_TX_GASPRICE = _maxTxGasprice;\n        L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = _l1GasToL2GasPerPubDataLimit;\n        address zero = address(0);\n        if (address(_circleUSDC) != zero) {\n            bool zkUSDCBridgeDisabled = _usdcSharedBridge == zero;\n            bool cctpUSDCBridgeDisabled = address(_cctpTokenMessenger) == zero;\n            // Bridged and Native USDC are mutually exclusive.\n            if (zkUSDCBridgeDisabled == cctpUSDCBridgeDisabled) {\n                revert InvalidBridgeConfig();\n            }\n        }\n        USDC_SHARED_BRIDGE = _usdcSharedBridge;\n        CUSTOM_GAS_TOKEN = BRIDGE_HUB.baseToken(CHAIN_ID);\n        if (CUSTOM_GAS_TOKEN == ETH_TOKEN_ADDRESS) {\n            revert ETHGasTokenNotAllowed();\n        }\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkStack.\n     * @dev The CUSTOM_GAS_TOKEN_FUNDER must hold enough of the gas token to pay for the L2 txn.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _pullCustomGas(L2_GAS_LIMIT);\n        IERC20(CUSTOM_GAS_TOKEN).forceApprove(BRIDGE_HUB.sharedBridge(), txBaseCost);\n\n        BRIDGE_HUB.requestL2TransactionDirect(\n            BridgeHubInterface.L2TransactionRequestDirect({\n                chainId: CHAIN_ID,\n                mintValue: txBaseCost,\n                l2Contract: target,\n                l2Value: 0,\n                l2Calldata: message,\n                l2GasLimit: L2_GAS_LIMIT,\n                l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                factoryDeps: new bytes[](0),\n                refundRecipient: L2_REFUND_ADDRESS\n            })\n        );\n\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkStack.\n     * @dev The CUSTOM_GAS_TOKEN_FUNDER must hold enough of the gas token to pay for the L2 txn.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // The Hub Pool will always bridge via CCTP to a ZkStack network if CCTP is enabled for that network. Therefore, we can short-circuit ZkStack-specific logic\n        // like pulling custom gas or getting the shared bridge address if CCTP is enabled and we are bridging USDC.\n        if (l1Token == address(usdcToken) && _isCCTPEnabled()) {\n            _transferUsdc(to, amount);\n            emit TokensRelayed(l1Token, l2Token, amount, to);\n            return;\n        }\n        // A bypass proxy seems to no longer be needed to avoid deposit limits. The tracking of these limits seems to be deprecated.\n        // See: https://github.com/matter-labs/era-contracts/blob/bce4b2d0f34bd87f1aaadd291772935afb1c3bd6/l1-contracts/contracts/bridge/L1ERC20Bridge.sol#L54-L55\n        uint256 txBaseCost = _pullCustomGas(L2_GAS_LIMIT);\n        address sharedBridge = BRIDGE_HUB.sharedBridge();\n\n        bytes32 txHash;\n        if (l1Token == address(L1_WETH)) {\n            // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n            // cost of custom gas tokens.\n            L1_WETH.withdraw(amount);\n            IERC20(CUSTOM_GAS_TOKEN).forceApprove(sharedBridge, txBaseCost);\n            // Note: When bridging ETH with `L2TransactionRequestTwoBridgesOuter`, the second bridge must be 0 for the shared bridge call to not revert.\n            // https://github.com/matter-labs/era-contracts/blob/aafee035db892689df3f7afe4b89fd6467a39313/l1-contracts/contracts/bridge/L1SharedBridge.sol#L328\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges{ value: amount }(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: sharedBridge,\n                    secondBridgeValue: amount,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, ETH_TOKEN_ADDRESS, 0)\n                })\n            );\n        } else if (l1Token == CUSTOM_GAS_TOKEN) {\n            // The chain's custom gas token.\n            IERC20(l1Token).forceApprove(sharedBridge, txBaseCost + amount);\n            txHash = BRIDGE_HUB.requestL2TransactionDirect(\n                BridgeHubInterface.L2TransactionRequestDirect({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost + amount,\n                    l2Contract: to,\n                    l2Value: amount,\n                    l2Calldata: \"\",\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    factoryDeps: new bytes[](0),\n                    refundRecipient: L2_REFUND_ADDRESS\n                })\n            );\n        } else if (l1Token == address(usdcToken)) {\n            // Since we already checked if we are bridging USDC via CCTP, if this conditional is hit, then we must be bridging USDC via the `USDC_SHARED_BRIDGE`.\n            IERC20(CUSTOM_GAS_TOKEN).forceApprove(sharedBridge, txBaseCost);\n            IERC20(l1Token).forceApprove(USDC_SHARED_BRIDGE, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: USDC_SHARED_BRIDGE,\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        } else {\n            // An standard bridged ERC20, separate from WETH and Circle Bridged/Native USDC.\n            IERC20(CUSTOM_GAS_TOKEN).forceApprove(sharedBridge, txBaseCost);\n            IERC20(l1Token).forceApprove(sharedBridge, amount);\n            txHash = BRIDGE_HUB.requestL2TransactionTwoBridges(\n                BridgeHubInterface.L2TransactionRequestTwoBridgesOuter({\n                    chainId: CHAIN_ID,\n                    mintValue: txBaseCost,\n                    l2Value: 0,\n                    l2GasLimit: L2_GAS_LIMIT,\n                    l2GasPerPubdataByteLimit: L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                    refundRecipient: L2_REFUND_ADDRESS,\n                    secondBridgeAddress: sharedBridge,\n                    secondBridgeValue: 0,\n                    secondBridgeCalldata: _secondBridgeCalldata(to, l1Token, amount)\n                })\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Computes the calldata for the \"second bridge\", which handles sending non native tokens.\n     * @param l2Recipient recipient of the tokens.\n     * @param l1Token the l1 address of the token. Note: ETH is encoded as address(1).\n     * @param amount number of tokens to send.\n     * @return abi encoded bytes.\n     */\n    function _secondBridgeCalldata(\n        address l2Recipient,\n        address l1Token,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        return abi.encode(l1Token, amount, l2Recipient);\n    }\n\n    /**\n     * @notice For a given l2 gas limit, this computes the amount of tokens needed, pulls them from the funder, and\n     * returns the amount.\n     * @dev Should return a value in the same precision as the gas token's precision.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of gas token that this contract needs to provide in order for the l2 transaction to succeed.\n     */\n    function _pullCustomGas(uint256 l2GasLimit) internal returns (uint256) {\n        if (tx.gasprice > MAX_TX_GASPRICE) revert TransactionFeeTooHigh();\n        uint256 cost = BRIDGE_HUB.l2TransactionBaseCost(\n            CHAIN_ID,\n            tx.gasprice,\n            l2GasLimit,\n            L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT\n        );\n        CUSTOM_GAS_TOKEN_FUNDER.withdraw(IERC20(CUSTOM_GAS_TOKEN), cost);\n\n        return cost;\n    }\n}\n"
    },
    "contracts/chain-adapters/ZkSync_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface ZkSyncInterface {\n    // _contractL2: L2 address of the contract to be called.\n    // _l2Value: Amount of ETH to pass with the call to L2; used as msg.value for the transaction.\n    // _calldata: Calldata of the transaction call; encoded the same way as in Ethereum.\n    // _l2GasLimit: Gas limit of the L2 transaction call.\n    // _l2GasPerPubdataByteLimit: A constant representing how much gas is required to publish a byte of data from\n    //  L1 to L2. https://era.zksync.io/docs/api/js/utils.html#gas\n    // _factoryDeps: Bytecodes array containing the bytecode of the contract being deployed.\n    //  If the contract is a factory contract, the array contains the bytecodes of the contracts it can deploy.\n    // _refundRecipient: Address that receives the rest of the fee after the transaction execution.\n    //  If refundRecipient == 0, L2 msg.sender is used. Note: If the _refundRecipient is a smart contract,\n    //  then during the L1 to L2 transaction its address is aliased.\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    // @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    // @param _l1GasPrice Effective gas price on L1 (priority fee + base fee)\n    // @param _l2GasLimit Gas limit for the L2 transaction\n    // @param _l2GasPerPubdataByteLimit Gas limit for the L2 transaction per byte of pubdata\n    // @return The estimated L2 gas for the transaction to be paid\n    function l2TransactionBaseCost(\n        uint256 _l1GasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n}\n\ninterface ZkBridgeLike {\n    // @dev: Use ZkSyncInterface.requestL2Transaction to bridge WETH as ETH to L2.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n}\n\n// Note: this contract just forwards the calls from the HubPool to ZkSync to avoid limits.\n// A modified ZKSync_Adapter should be deployed with this address swapped in for all zkSync addresses.\ncontract LimitBypassProxy is ZkSyncInterface, ZkBridgeLike {\n    using SafeERC20 for IERC20;\n    ZkSyncInterface public constant zkSync = ZkSyncInterface(0x32400084C286CF3E17e7B677ea9583e60a000324);\n    ZkBridgeLike public constant zkErc20Bridge = ZkBridgeLike(0x57891966931Eb4Bb6FB81430E6cE0A03AAbDe063);\n\n    function l2TransactionBaseCost(\n        uint256 _l1GasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256) {\n        return zkSync.l2TransactionBaseCost(_l1GasPrice, _l2GasLimit, _l2GasPerPubdataByteLimit);\n    }\n\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        return\n            zkSync.requestL2Transaction{ value: msg.value }(\n                _contractL2,\n                _l2Value,\n                _calldata,\n                _l2GasLimit,\n                _l2GasPerPubdataByteLimit,\n                _factoryDeps,\n                _refundRecipient\n            );\n    }\n\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash) {\n        IERC20(_l1Token).safeIncreaseAllowance(address(zkErc20Bridge), _amount);\n        return\n            zkErc20Bridge.deposit{ value: msg.value }(\n                _l2Receiver,\n                _l1Token,\n                _amount,\n                _l2TxGasLimit,\n                _l2TxGasPerPubdataByte,\n                _refundRecipient\n            );\n    }\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkSync.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkSync_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://era.zksync.io/docs/dev/developer-guides/bridging/l1-l2.html#getting-the-base-cost\n\n    // Generally, the following params are a bit hard to set and may change in the future once ZkSync\n    // goes live. For now, we'll hardcode these and use aggressive values to ensure inclusion.\n\n    // Limit on L2 gas to spend.\n    uint256 public constant L2_GAS_LIMIT = 2_000_000;\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public constant L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT = 800;\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unless msg.sender is a contract then its address\n    // gets aliased.\n    address public immutable l2RefundAddress;\n\n    // Hardcode the following ZkSync system contract addresses to save gas on construction. This adapter can be\n    // redeployed in the event that the following addresses change.\n\n    // Main contract used to send L1 --> L2 messages. Fetchable via `zks_getMainContract` method on JSON RPC.\n    ZkSyncInterface public constant zkSyncMessageBridge = ZkSyncInterface(0x32400084C286CF3E17e7B677ea9583e60a000324);\n\n    // Contract used to send ETH to L2. Note: this is the same address as the main contract, but separated to allow\n    // only this contract to be swapped (leaving the main zkSync contract to be used for messaging).\n    ZkSyncInterface public constant zkSyncEthBridge = ZkSyncInterface(0x32400084C286CF3E17e7B677ea9583e60a000324);\n\n    // Bridges to send ERC20 and ETH to L2. Fetchable via `zks_getBridgeContracts` method on JSON RPC.\n    ZkBridgeLike public constant zkErc20Bridge = ZkBridgeLike(0x57891966931Eb4Bb6FB81430E6cE0A03AAbDe063);\n\n    // Set l1Weth at construction time to make testing easier.\n    WETH9Interface public immutable l1Weth;\n\n    // The maximum gas price a transaction sent to this adapter may have. This is set to prevent a block producer from setting an artificially high priority fee\n    // when calling a hub pool message relay, which would otherwise cause a large amount of ETH to be sent to L2.\n    uint256 private immutable MAX_TX_GASPRICE;\n\n    event ZkSyncMessageRelayed(bytes32 canonicalTxHash);\n    error TransactionFeeTooHigh();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _l2RefundAddress address that recieves excess gas refunds on L2.\n     * @param _maxTxGasPrice The maximum effective gas price any transaction sent to this adapter may have.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _l2RefundAddress,\n        uint256 _maxTxGasPrice\n    ) {\n        l1Weth = _l1Weth;\n        l2RefundAddress = _l2RefundAddress;\n        MAX_TX_GASPRICE = _maxTxGasPrice;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkSync.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message, or the message\n     * will revert.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _contractHasSufficientEthBalance();\n\n        // Returns the hash of the requested L2 transaction. This hash can be used to follow the transaction status.\n        bytes32 canonicalTxHash = zkSyncMessageBridge.requestL2Transaction{ value: txBaseCost }(\n            target,\n            // We pass no ETH with the call, otherwise we'd need to add to the txBaseCost this value.\n            0,\n            message,\n            L2_GAS_LIMIT,\n            L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n            new bytes[](0),\n            l2RefundAddress\n        );\n\n        emit MessageRelayed(target, message);\n        emit ZkSyncMessageRelayed(canonicalTxHash);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkSync.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message\n     * or the message will revert.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // This could revert if the relay amount is over the ZkSync deposit\n        // limit: https://github.com/matter-labs/era-contracts/blob/main/ethereum/contracts/common/AllowList.sol#L150\n        // We should make sure that the limit is either set very high or we need to do logic\n        // that splits the amount to deposit into multiple chunks. We can't have\n        // this function revert or the HubPool will not be able to proceed to the\n        // next bundle. See more here:\n        // https://github.com/matter-labs/era-contracts/blob/main/docs/Overview.md#deposit-limitation\n        // https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L230\n        uint256 txBaseCost = _contractHasSufficientEthBalance();\n\n        // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n        // cost. I've tried sending WETH over the erc20Bridge directly but we receive the wrong WETH\n        // on the L2 side. So, we need to unwrap the WETH into ETH and then send.\n        bytes32 txHash;\n        if (l1Token == address(l1Weth)) {\n            l1Weth.withdraw(amount);\n            // We cannot call the standard ERC20 bridge because it disallows ETH deposits.\n            txHash = zkSyncEthBridge.requestL2Transaction{ value: txBaseCost + amount }(\n                to,\n                amount,\n                \"\",\n                L2_GAS_LIMIT,\n                L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                new bytes[](0),\n                l2RefundAddress\n            );\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(address(zkErc20Bridge), amount);\n            txHash = zkErc20Bridge.deposit{ value: txBaseCost }(\n                to,\n                l1Token,\n                amount,\n                L2_GAS_LIMIT,\n                L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT,\n                l2RefundAddress\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n        emit ZkSyncMessageRelayed(txHash);\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue() public view returns (uint256) {\n        // - tx.gasprice returns effective_gas_price. It's also used by Mailbox contract to estimate L2GasPrice\n        // so using tx.gasprice should always pass this check that msg.value >= baseCost + _l2Value\n        // https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L273\n        // - priority_fee_per_gas = min(transaction.max_priority_fee_per_gas, transaction.max_fee_per_gas - block.base_fee_per_gas)\n        // - effective_gas_price = priority_fee_per_gas + block.base_fee_per_gas\n        if (tx.gasprice > MAX_TX_GASPRICE) revert TransactionFeeTooHigh();\n        return\n            zkSyncMessageBridge.l2TransactionBaseCost(tx.gasprice, L2_GAS_LIMIT, L1_GAS_TO_L2_GAS_PER_PUB_DATA_LIMIT);\n    }\n\n    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Zora_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Zora. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Zora_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Zora system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Zora.\n     * @param target Contract on Zora that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Zora.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/erc1155/MintableERC1155.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\n/**\n * @title MintableERC1155\n * @notice Ownable contract enabling owner to airdrop many recipients the same token ID at once\n */\ncontract MintableERC1155 is ERC1155, Ownable {\n    // Maps `tokenId` to metadata URI `tokenURI`\n    mapping(uint256 => string) public _tokenURIs;\n\n    event Airdrop(address caller, uint256 tokenId, address[] recipients, uint256 amount);\n\n    // We are passing an empty string as the `baseURI` because we use `_tokenURIs` instead\n    // to allow for IPFS URIs.\n    // solhint-disable-next-line\n    constructor() ERC1155(\"\") {}\n\n    /**\n     * @notice Creates `amount` new tokens for `recipients` of token type `tokenId`.\n     * @dev Call might run out of gas if `recipients` arg too long. Might need to chunk up the list.\n     * @param recipients List of airdrop recipients.\n     * @param tokenId Token type to airdrop.\n     * @param amount Amount of token types to airdrop.\n     */\n    function airdrop(\n        uint256 tokenId,\n        address[] memory recipients,\n        uint256 amount\n    ) public onlyOwner {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            _mint(recipients[i], tokenId, amount, \"\");\n        }\n        emit Airdrop(_msgSender(), tokenId, recipients, amount);\n    }\n\n    /**\n     * @notice Sets the URI for token of type `tokenId` to `tokenURI`.\n     * @param tokenId Token type to set `tokenURI` for.\n     * @param tokenURI URI of token metadata.\n     */\n    function setTokenURI(uint256 tokenId, string memory tokenURI) external onlyOwner {\n        require(bytes(_tokenURIs[tokenId]).length == 0, \"uri already set\");\n\n        _tokenURIs[tokenId] = tokenURI;\n        emit URI(tokenURI, tokenId);\n    }\n\n    /**\n     * @notice Returns metadata URI of token type `tokenId`.\n     * @dev Instead of returning the same URI for *all* token types, we return the uri set by\n     * `setTokenURI` to allow IPFS URIs for all token types.\n     * @param tokenId Token type to retrieve metadata URI for.\n     */\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return _tokenURIs[tokenId];\n    }\n}\n"
    },
    "contracts/erc7683/AcrossOriginSettler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC7683OrderDepositor } from \"./ERC7683OrderDepositor.sol\";\nimport \"../SpokePool.sol\";\nimport \"../external/interfaces/IPermit2.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\n\n/**\n * @notice AcrossOriginSettler processes an external order type and translates it into an AcrossV3Deposit\n * that it sends to the SpokePool contract.\n * @custom:security-contact bugs@across.to\n */\ncontract AcrossOriginSettler is ERC7683OrderDepositor, Ownable, MultiCaller {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n\n    event SetDestinationSettler(\n        uint256 indexed chainId,\n        address indexed prevDestinationSettler,\n        address indexed destinationSettler\n    );\n\n    SpokePool public immutable SPOKE_POOL;\n\n    // Mapping of chainIds to destination settler addresses.\n    mapping(uint256 => address) public destinationSettlers;\n\n    constructor(\n        SpokePool _spokePool,\n        IPermit2 _permit2,\n        uint256 _quoteBeforeDeadline\n    ) ERC7683OrderDepositor(_permit2, _quoteBeforeDeadline) {\n        SPOKE_POOL = _spokePool;\n    }\n\n    function setDestinationSettler(uint256 chainId, address destinationSettler) external onlyOwner {\n        address prevDestinationSettler = destinationSettlers[chainId];\n        destinationSettlers[chainId] = destinationSettler;\n        emit SetDestinationSettler(chainId, prevDestinationSettler, destinationSettler);\n    }\n\n    function _callDeposit(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes memory message\n    ) internal override {\n        IERC20(inputToken).forceApprove(address(SPOKE_POOL), inputAmount);\n\n        if (depositNonce == 0) {\n            SPOKE_POOL.depositV3(\n                depositor,\n                recipient,\n                inputToken,\n                outputToken,\n                inputAmount,\n                outputAmount,\n                destinationChainId,\n                exclusiveRelayer,\n                quoteTimestamp,\n                fillDeadline,\n                exclusivityDeadline,\n                message\n            );\n        } else {\n            SPOKE_POOL.unsafeDeposit(\n                depositor.toBytes32(),\n                recipient.toBytes32(),\n                inputToken.toBytes32(),\n                outputToken.toBytes32(),\n                inputAmount,\n                outputAmount,\n                destinationChainId,\n                exclusiveRelayer.toBytes32(),\n                depositNonce,\n                quoteTimestamp,\n                fillDeadline,\n                exclusivityDeadline,\n                message\n            );\n        }\n    }\n\n    function computeDepositId(uint256 depositNonce, address depositor) public view override returns (uint256) {\n        return\n            depositNonce == 0\n                ? SPOKE_POOL.numberOfDeposits()\n                : SPOKE_POOL.getUnsafeDepositId(address(this), depositor.toBytes32(), depositNonce);\n    }\n\n    function _destinationSettler(uint256 chainId) internal view override returns (address) {\n        if (destinationSettlers[chainId] == address(0)) revert NoDestinationSettlerForChain(chainId);\n        return destinationSettlers[chainId];\n    }\n}\n"
    },
    "contracts/erc7683/ERC7683.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/// @title GaslessCrossChainOrder CrossChainOrder type\n/// @notice Standard order struct to be signed by users, disseminated to fillers, and submitted to origin settler contracts\nstruct GaslessCrossChainOrder {\n    /// @dev The contract address that the order is meant to be settled by.\n    /// Fillers send this order to this contract address on the origin chain\n    address originSettler;\n    /// @dev The address of the user who is initiating the swap,\n    /// whose input tokens will be taken and escrowed\n    address user;\n    /// @dev Nonce to be used as replay protection for the order\n    uint256 nonce;\n    /// @dev The chainId of the origin chain\n    uint256 originChainId;\n    /// @dev The timestamp by which the order must be opened\n    uint32 openDeadline;\n    /// @dev The timestamp by which the order must be filled on the destination chain\n    uint32 fillDeadline;\n    /// @dev Type identifier for the order data. This is an EIP-712 typehash.\n    bytes32 orderDataType;\n    /// @dev Arbitrary implementation-specific data\n    /// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,\n    /// or any other order-type specific information\n    bytes orderData;\n}\n\n/// @title OnchainCrossChainOrder CrossChainOrder type\n/// @notice Standard order struct for user-opened orders, where the user is the msg.sender.\nstruct OnchainCrossChainOrder {\n    /// @dev The timestamp by which the order must be filled on the destination chain\n    uint32 fillDeadline;\n    /// @dev Type identifier for the order data. This is an EIP-712 typehash.\n    bytes32 orderDataType;\n    /// @dev Arbitrary implementation-specific data\n    /// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,\n    /// or any other order-type specific information\n    bytes orderData;\n}\n\n/// @title ResolvedCrossChainOrder type\n/// @notice An implementation-generic representation of an order intended for filler consumption\n/// @dev Defines all requirements for filling an order by unbundling the implementation-specific orderData.\n/// @dev Intended to improve integration generalization by allowing fillers to compute the exact input and output information of any order\nstruct ResolvedCrossChainOrder {\n    /// @dev The address of the user who is initiating the transfer\n    address user;\n    /// @dev The chainId of the origin chain\n    uint256 originChainId;\n    /// @dev The timestamp by which the order must be opened\n    uint32 openDeadline;\n    /// @dev The timestamp by which the order must be filled on the destination chain(s)\n    uint32 fillDeadline;\n    /// @dev The unique identifier for this order within this settlement system\n    bytes32 orderId;\n    /// @dev The max outputs that the filler will send. It's possible the actual amount depends on the state of the destination\n    ///      chain (destination dutch auction, for instance), so these outputs should be considered a cap on filler liabilities.\n    Output[] maxSpent;\n    /// @dev The minimum outputs that must to be given to the filler as part of order settlement. Similar to maxSpent, it's possible\n    ///      that special order types may not be able to guarantee the exact amount at open time, so this should be considered\n    ///      a floor on filler receipts.\n    Output[] minReceived;\n    /// @dev Each instruction in this array is parameterizes a single leg of the fill. This provides the filler with the information\n    ///      necessary to perform the fill on the destination(s).\n    FillInstruction[] fillInstructions;\n}\n\n/// @notice Tokens that must be receive for a valid order fulfillment\nstruct Output {\n    /// @dev The address of the ERC20 token on the destination chain\n    /// @dev address(0) used as a sentinel for the native token\n    bytes32 token;\n    /// @dev The amount of the token to be sent\n    uint256 amount;\n    /// @dev The address to receive the output tokens\n    bytes32 recipient;\n    /// @dev The destination chain for this output\n    uint256 chainId;\n}\n\n/// @title FillInstruction type\n/// @notice Instructions to parameterize each leg of the fill\n/// @dev Provides all the origin-generated information required to produce a valid fill leg\nstruct FillInstruction {\n    /// @dev The contract address that the order is meant to be settled by\n    uint64 destinationChainId;\n    /// @dev The contract address that the order is meant to be filled on\n    bytes32 destinationSettler;\n    /// @dev The data generated on the origin chain needed by the destinationSettler to process the fill\n    bytes originData;\n}\n\n/// @title IOriginSettler\n/// @notice Standard interface for settlement contracts on the origin chain\ninterface IOriginSettler {\n    /// @notice Signals that an order has been opened\n    /// @param orderId a unique order identifier within this settlement system\n    /// @param resolvedOrder resolved order that would be returned by resolve if called instead of Open\n    event Open(bytes32 indexed orderId, ResolvedCrossChainOrder resolvedOrder);\n\n    /// @notice Opens a gasless cross-chain order on behalf of a user.\n    /// @dev To be called by the filler.\n    /// @dev This method must emit the Open event\n    /// @param order The GaslessCrossChainOrder definition\n    /// @param signature The user's signature over the order\n    /// @param originFillerData Any filler-defined data required by the settler\n    function openFor(\n        GaslessCrossChainOrder calldata order,\n        bytes calldata signature,\n        bytes calldata originFillerData\n    ) external;\n\n    /// @notice Opens a cross-chain order\n    /// @dev To be called by the user\n    /// @dev This method must emit the Open event\n    /// @param order The OnchainCrossChainOrder definition\n    function open(OnchainCrossChainOrder calldata order) external;\n\n    /// @notice Resolves a specific GaslessCrossChainOrder into a generic ResolvedCrossChainOrder\n    /// @dev Intended to improve standardized integration of various order types and settlement contracts\n    /// @param order The GaslessCrossChainOrder definition\n    /// @param originFillerData Any filler-defined data required by the settler\n    /// @return ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order\n    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData)\n        external\n        view\n        returns (ResolvedCrossChainOrder memory);\n\n    /// @notice Resolves a specific OnchainCrossChainOrder into a generic ResolvedCrossChainOrder\n    /// @dev Intended to improve standardized integration of various order types and settlement contracts\n    /// @param order The OnchainCrossChainOrder definition\n    /// @return ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order\n    function resolve(OnchainCrossChainOrder calldata order) external view returns (ResolvedCrossChainOrder memory);\n}\n\n/// @title IDestinationSettler\n/// @notice Standard interface for settlement contracts on the destination chain\ninterface IDestinationSettler {\n    /// @notice Fills a single leg of a particular order on the destination chain\n    /// @param orderId Unique order identifier for this order\n    /// @param originData Data emitted on the origin to parameterize the fill\n    /// @param fillerData Data provided by the filler to inform the fill or express their preferences\n    function fill(\n        bytes32 orderId,\n        bytes calldata originData,\n        bytes calldata fillerData\n    ) external;\n}\n"
    },
    "contracts/erc7683/ERC7683OrderDepositor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../external/interfaces/IPermit2.sol\";\nimport { V3SpokePoolInterface } from \"../interfaces/V3SpokePoolInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Output, GaslessCrossChainOrder, OnchainCrossChainOrder, ResolvedCrossChainOrder, IOriginSettler, FillInstruction } from \"./ERC7683.sol\";\nimport { AcrossOrderData, AcrossOriginFillerData, ERC7683Permit2Lib, ACROSS_ORDER_DATA_TYPE_HASH } from \"./ERC7683Permit2Lib.sol\";\nimport { AddressToBytes32, Bytes32ToAddress } from \"../libraries/AddressConverters.sol\";\n\n/**\n * @notice ERC7683OrderDepositor processes an external order type and translates it into an AcrossV3 deposit.\n * @dev This contract is abstract because it is intended to be usable by a contract that can accept the deposit\n * as well as one that sends the deposit to another contract.\n * @custom:security-contact bugs@across.to\n */\nabstract contract ERC7683OrderDepositor is IOriginSettler {\n    using SafeERC20 for IERC20;\n    using Bytes32ToAddress for bytes32;\n    using AddressToBytes32 for address;\n\n    error WrongSettlementContract();\n    error WrongChainId();\n    error WrongOrderDataType();\n    error WrongExclusiveRelayer();\n    error NoDestinationSettlerForChain(uint256 chainId);\n\n    // Permit2 contract for this network.\n    IPermit2 public immutable PERMIT2;\n\n    // QUOTE_BEFORE_DEADLINE is subtracted from the deadline to get the quote timestamp.\n    // This is a somewhat arbitrary conversion, but order creators need some way to precompute the quote timestamp.\n    uint256 public immutable QUOTE_BEFORE_DEADLINE;\n\n    /**\n     * @notice Construct the Permit2Depositor.\n     * @param _permit2 Permit2 contract\n     * @param _quoteBeforeDeadline quoteBeforeDeadline is subtracted from the deadline to get the quote timestamp.\n     */\n    constructor(IPermit2 _permit2, uint256 _quoteBeforeDeadline) {\n        PERMIT2 = _permit2;\n        QUOTE_BEFORE_DEADLINE = _quoteBeforeDeadline;\n    }\n\n    /**\n     * @notice Open the order on behalf of the user.\n     * @dev This will pull in the user's funds and make the order available to be filled.\n     * @param order the ERC7683 compliant order.\n     * @param signature signature for the EIP-712 compliant order type.\n     * @param originFillerData Across-specific fillerData.\n     */\n    function openFor(\n        GaslessCrossChainOrder calldata order,\n        bytes calldata signature,\n        bytes calldata originFillerData\n    ) external {\n        (\n            ResolvedCrossChainOrder memory resolvedOrder,\n            AcrossOrderData memory acrossOrderData,\n            AcrossOriginFillerData memory acrossOriginFillerData\n        ) = _resolveFor(order, originFillerData);\n\n        // Verify Permit2 signature and pull user funds into this contract\n        _processPermit2Order(order, acrossOrderData, signature);\n\n        _callDeposit(\n            order.user,\n            acrossOrderData.recipient.toAddress(),\n            acrossOrderData.inputToken,\n            acrossOrderData.outputToken,\n            acrossOrderData.inputAmount,\n            acrossOrderData.outputAmount,\n            acrossOrderData.destinationChainId,\n            acrossOriginFillerData.exclusiveRelayer,\n            acrossOrderData.depositNonce,\n            // Note: simplifying assumption to avoid quote timestamps that cause orders to expire before the deadline.\n            SafeCast.toUint32(order.openDeadline - QUOTE_BEFORE_DEADLINE),\n            order.fillDeadline,\n            acrossOrderData.exclusivityPeriod,\n            acrossOrderData.message\n        );\n\n        emit Open(keccak256(resolvedOrder.fillInstructions[0].originData), resolvedOrder);\n    }\n\n    /**\n     * @notice Opens the order.\n     * @dev Unlike openFor, this method is callable by the user.\n     * @dev This will pull in the user's funds and make the order available to be filled.\n     * @param order the ERC7683 compliant order.\n     */\n    function open(OnchainCrossChainOrder calldata order) external {\n        (ResolvedCrossChainOrder memory resolvedOrder, AcrossOrderData memory acrossOrderData) = _resolve(order);\n\n        IERC20(acrossOrderData.inputToken).safeTransferFrom(msg.sender, address(this), acrossOrderData.inputAmount);\n\n        _callDeposit(\n            msg.sender,\n            acrossOrderData.recipient.toAddress(),\n            acrossOrderData.inputToken,\n            acrossOrderData.outputToken,\n            acrossOrderData.inputAmount,\n            acrossOrderData.outputAmount,\n            acrossOrderData.destinationChainId,\n            acrossOrderData.exclusiveRelayer,\n            acrossOrderData.depositNonce,\n            // Note: simplifying assumption to avoid the order type having to bake in the quote timestamp.\n            SafeCast.toUint32(block.timestamp),\n            order.fillDeadline,\n            acrossOrderData.exclusivityPeriod,\n            acrossOrderData.message\n        );\n\n        emit Open(keccak256(resolvedOrder.fillInstructions[0].originData), resolvedOrder);\n    }\n\n    /**\n     * @notice Constructs a ResolvedOrder from a GaslessCrossChainOrder and originFillerData.\n     * @param order the ERC-7683 compliant order.\n     * @param originFillerData Across-specific fillerData.\n     */\n    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData)\n        public\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder)\n    {\n        (resolvedOrder, , ) = _resolveFor(order, originFillerData);\n    }\n\n    /**\n     * @notice Constructs a ResolvedOrder from a CrossChainOrder.\n     * @param order the ERC7683 compliant order.\n     */\n    function resolve(OnchainCrossChainOrder calldata order)\n        public\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder)\n    {\n        (resolvedOrder, ) = _resolve(order);\n    }\n\n    /**\n     * @notice Decodes the Across specific orderData and fillerData into descriptive types.\n     * @param orderData the orderData field of the ERC7683 compliant order.\n     * @param fillerData Across-specific fillerData.\n     * @return acrossOrderData decoded AcrossOrderData.\n     * @return acrossOriginFillerData decoded AcrossOriginFillerData.\n     */\n    function decode(bytes memory orderData, bytes memory fillerData)\n        public\n        pure\n        returns (AcrossOrderData memory, AcrossOriginFillerData memory)\n    {\n        return (abi.decode(orderData, (AcrossOrderData)), abi.decode(fillerData, (AcrossOriginFillerData)));\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint32) {\n        return SafeCast.toUint32(block.timestamp); // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Convenience method to compute the Across depositId for orders sent through 7683.\n     * @dev if a 0 depositNonce is used, the depositId will not be deterministic (meaning it can change depending on\n     * when the open txn is mined), but you will be safe from collisions. See the unsafeDepositV3 method on SpokePool\n     * for more details on how to choose between deterministic and non-deterministic.\n     * @param depositNonce the depositNonce field in the order.\n     * @param depositor the sender or signer of the order.\n     * @return the resulting Across depositId.\n     */\n    function computeDepositId(uint256 depositNonce, address depositor) public view virtual returns (uint256);\n\n    function _resolveFor(GaslessCrossChainOrder calldata order, bytes calldata fillerData)\n        internal\n        view\n        returns (\n            ResolvedCrossChainOrder memory resolvedOrder,\n            AcrossOrderData memory acrossOrderData,\n            AcrossOriginFillerData memory acrossOriginFillerData\n        )\n    {\n        // Ensure that order was intended to be settled by Across.\n        if (order.originSettler != address(this)) {\n            revert WrongSettlementContract();\n        }\n\n        if (order.originChainId != block.chainid) {\n            revert WrongChainId();\n        }\n\n        if (order.orderDataType != ACROSS_ORDER_DATA_TYPE_HASH) {\n            revert WrongOrderDataType();\n        }\n\n        // Extract Across-specific params.\n        (acrossOrderData, acrossOriginFillerData) = decode(order.orderData, fillerData);\n\n        if (\n            acrossOrderData.exclusiveRelayer != address(0) &&\n            acrossOrderData.exclusiveRelayer != acrossOriginFillerData.exclusiveRelayer\n        ) {\n            revert WrongExclusiveRelayer();\n        }\n\n        Output[] memory maxSpent = new Output[](1);\n        maxSpent[0] = Output({\n            token: acrossOrderData.outputToken.toBytes32(),\n            amount: acrossOrderData.outputAmount,\n            recipient: acrossOrderData.recipient,\n            chainId: acrossOrderData.destinationChainId\n        });\n\n        // We assume that filler takes repayment on the origin chain in which case the filler output\n        // will always be equal to the input amount. If the filler requests repayment somewhere else then\n        // the filler output will be equal to the input amount less a fee based on the chain they request\n        // repayment on.\n        Output[] memory minReceived = new Output[](1);\n        minReceived[0] = Output({\n            token: acrossOrderData.inputToken.toBytes32(),\n            amount: acrossOrderData.inputAmount,\n            recipient: acrossOriginFillerData.exclusiveRelayer.toBytes32(),\n            chainId: block.chainid\n        });\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        V3SpokePoolInterface.V3RelayData memory relayData;\n        relayData.depositor = order.user.toBytes32();\n        relayData.recipient = acrossOrderData.recipient;\n        relayData.exclusiveRelayer = acrossOriginFillerData.exclusiveRelayer.toBytes32();\n        relayData.inputToken = acrossOrderData.inputToken.toBytes32();\n        relayData.outputToken = acrossOrderData.outputToken.toBytes32();\n        relayData.inputAmount = acrossOrderData.inputAmount;\n        relayData.outputAmount = acrossOrderData.outputAmount;\n        relayData.originChainId = block.chainid;\n        relayData.depositId = computeDepositId(acrossOrderData.depositNonce, order.user);\n        relayData.fillDeadline = order.fillDeadline;\n        relayData.exclusivityDeadline = acrossOrderData.exclusivityPeriod;\n        relayData.message = acrossOrderData.message;\n        fillInstructions[0] = FillInstruction({\n            destinationChainId: SafeCast.toUint64(acrossOrderData.destinationChainId),\n            destinationSettler: _destinationSettler(acrossOrderData.destinationChainId).toBytes32(),\n            originData: abi.encode(relayData)\n        });\n\n        resolvedOrder = ResolvedCrossChainOrder({\n            user: order.user,\n            originChainId: order.originChainId,\n            openDeadline: order.openDeadline,\n            fillDeadline: order.fillDeadline,\n            minReceived: minReceived,\n            maxSpent: maxSpent,\n            fillInstructions: fillInstructions,\n            orderId: keccak256(abi.encode(relayData, acrossOrderData.destinationChainId))\n        });\n    }\n\n    function _resolve(OnchainCrossChainOrder calldata order)\n        internal\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder, AcrossOrderData memory acrossOrderData)\n    {\n        if (order.orderDataType != ACROSS_ORDER_DATA_TYPE_HASH) {\n            revert WrongOrderDataType();\n        }\n\n        // Extract Across-specific params.\n        acrossOrderData = abi.decode(order.orderData, (AcrossOrderData));\n\n        Output[] memory maxSpent = new Output[](1);\n        maxSpent[0] = Output({\n            token: acrossOrderData.outputToken.toBytes32(),\n            amount: acrossOrderData.outputAmount,\n            recipient: acrossOrderData.recipient,\n            chainId: acrossOrderData.destinationChainId\n        });\n\n        // We assume that filler takes repayment on the origin chain in which case the filler output\n        // will always be equal to the input amount. If the filler requests repayment somewhere else then\n        // the filler output will be equal to the input amount less a fee based on the chain they request\n        // repayment on.\n        Output[] memory minReceived = new Output[](1);\n        minReceived[0] = Output({\n            token: acrossOrderData.inputToken.toBytes32(),\n            amount: acrossOrderData.inputAmount,\n            recipient: acrossOrderData.exclusiveRelayer.toBytes32(),\n            chainId: block.chainid\n        });\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        V3SpokePoolInterface.V3RelayData memory relayData;\n        relayData.depositor = msg.sender.toBytes32();\n        relayData.recipient = acrossOrderData.recipient;\n        relayData.exclusiveRelayer = acrossOrderData.exclusiveRelayer.toBytes32();\n        relayData.inputToken = acrossOrderData.inputToken.toBytes32();\n        relayData.outputToken = acrossOrderData.outputToken.toBytes32();\n        relayData.inputAmount = acrossOrderData.inputAmount;\n        relayData.outputAmount = acrossOrderData.outputAmount;\n        relayData.originChainId = block.chainid;\n        relayData.depositId = computeDepositId(acrossOrderData.depositNonce, msg.sender);\n        relayData.fillDeadline = order.fillDeadline;\n        relayData.exclusivityDeadline = acrossOrderData.exclusivityPeriod;\n        relayData.message = acrossOrderData.message;\n        fillInstructions[0] = FillInstruction({\n            destinationChainId: SafeCast.toUint64(acrossOrderData.destinationChainId),\n            destinationSettler: _destinationSettler(acrossOrderData.destinationChainId).toBytes32(),\n            originData: abi.encode(relayData)\n        });\n\n        resolvedOrder = ResolvedCrossChainOrder({\n            user: msg.sender,\n            originChainId: block.chainid,\n            openDeadline: type(uint32).max, // no deadline since the user is sending it\n            fillDeadline: order.fillDeadline,\n            minReceived: minReceived,\n            maxSpent: maxSpent,\n            fillInstructions: fillInstructions,\n            orderId: keccak256(abi.encode(relayData, acrossOrderData.destinationChainId))\n        });\n    }\n\n    function _processPermit2Order(\n        GaslessCrossChainOrder memory order,\n        AcrossOrderData memory acrossOrderData,\n        bytes memory signature\n    ) internal {\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\n            permitted: IPermit2.TokenPermissions({\n                token: acrossOrderData.inputToken,\n                amount: acrossOrderData.inputAmount\n            }),\n            nonce: order.nonce,\n            deadline: order.openDeadline\n        });\n\n        IPermit2.SignatureTransferDetails memory signatureTransferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: acrossOrderData.inputAmount\n        });\n\n        // Pull user funds.\n        PERMIT2.permitWitnessTransferFrom(\n            permit,\n            signatureTransferDetails,\n            order.user,\n            ERC7683Permit2Lib.hashOrder(order, ERC7683Permit2Lib.hashOrderData(acrossOrderData)), // witness data hash\n            ERC7683Permit2Lib.PERMIT2_ORDER_TYPE, // witness data type string\n            signature\n        );\n    }\n\n    function _callDeposit(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityPeriod,\n        bytes memory message\n    ) internal virtual;\n\n    function _destinationSettler(uint256 chainId) internal view virtual returns (address);\n}\n"
    },
    "contracts/erc7683/ERC7683Permit2Lib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../external/interfaces/IPermit2.sol\";\nimport { GaslessCrossChainOrder } from \"./ERC7683.sol\";\n\n// Data unique to every CrossChainOrder settled on Across\nstruct AcrossOrderData {\n    address inputToken;\n    uint256 inputAmount;\n    address outputToken;\n    uint256 outputAmount;\n    uint256 destinationChainId;\n    bytes32 recipient;\n    address exclusiveRelayer;\n    /// @notice User needs to be careful not to re-use a deposit nonce when depositing into Across otherwise the\n    /// user risks their deposit being unfillable. See @across/contracts/SpokePool.sol#unsafeDeposit() for\n    /// more details on this situation.\n    uint256 depositNonce;\n    uint32 exclusivityPeriod;\n    bytes message;\n}\n\nstruct AcrossOriginFillerData {\n    address exclusiveRelayer;\n}\n\nstruct AcrossDestinationFillerData {\n    uint256 repaymentChainId;\n}\n\nbytes constant ACROSS_ORDER_DATA_TYPE = abi.encodePacked(\n    \"AcrossOrderData(\",\n    \"address inputToken,\",\n    \"uint256 inputAmount,\",\n    \"address outputToken,\",\n    \"uint256 outputAmount,\",\n    \"uint256 destinationChainId,\",\n    \"bytes32 recipient,\",\n    \"address exclusiveRelayer,\"\n    \"uint256 depositNonce,\",\n    \"uint32 exclusivityPeriod,\",\n    \"bytes message)\"\n);\n\nbytes32 constant ACROSS_ORDER_DATA_TYPE_HASH = keccak256(ACROSS_ORDER_DATA_TYPE);\n\n/**\n * @notice ERC7683Permit2Lib knows how to process a particular type of external Permit2Order so that it can be used in Across.\n * @dev This library is responsible for definining the ERC712 type strings/hashes and performing hashes on the types.\n * @custom:security-contact bugs@across.to\n */\nlibrary ERC7683Permit2Lib {\n    bytes internal constant GASLESS_CROSS_CHAIN_ORDER_TYPE =\n        abi.encodePacked(\n            \"GaslessCrossChainOrder(\",\n            \"address originSettler,\",\n            \"address user,\",\n            \"uint256 nonce,\",\n            \"uint256 originChainId,\",\n            \"uint32 openDeadline,\",\n            \"uint32 fillDeadline,\",\n            \"bytes32 orderDataType,\",\n            \"AcrossOrderData orderData)\"\n        );\n\n    bytes internal constant GASLESS_CROSS_CHAIN_ORDER_EIP712_TYPE =\n        abi.encodePacked(GASLESS_CROSS_CHAIN_ORDER_TYPE, ACROSS_ORDER_DATA_TYPE);\n    bytes32 internal constant GASLESS_CROSS_CHAIN_ORDER_TYPE_HASH = keccak256(GASLESS_CROSS_CHAIN_ORDER_EIP712_TYPE);\n\n    string private constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n    string internal constant PERMIT2_ORDER_TYPE =\n        string(\n            abi.encodePacked(\n                \"GaslessCrossChainOrder witness)\",\n                ACROSS_ORDER_DATA_TYPE,\n                GASLESS_CROSS_CHAIN_ORDER_TYPE,\n                TOKEN_PERMISSIONS_TYPE\n            )\n        );\n\n    // Hashes an order to get an order hash. Needed for permit2.\n    function hashOrder(GaslessCrossChainOrder memory order, bytes32 orderDataHash) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    GASLESS_CROSS_CHAIN_ORDER_TYPE_HASH,\n                    order.originSettler,\n                    order.user,\n                    order.nonce,\n                    order.originChainId,\n                    order.openDeadline,\n                    order.fillDeadline,\n                    order.orderDataType,\n                    orderDataHash\n                )\n            );\n    }\n\n    function hashOrderData(AcrossOrderData memory orderData) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    ACROSS_ORDER_DATA_TYPE_HASH,\n                    orderData.inputToken,\n                    orderData.inputAmount,\n                    orderData.outputToken,\n                    orderData.outputAmount,\n                    orderData.destinationChainId,\n                    orderData.recipient,\n                    orderData.exclusiveRelayer,\n                    orderData.depositNonce,\n                    orderData.exclusivityPeriod,\n                    keccak256(orderData.message)\n                )\n            );\n    }\n}\n"
    },
    "contracts/Ethereum_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @notice Ethereum L1 specific SpokePool. Used on Ethereum L1 to facilitate L2->L1 transfers.\n * @custom:security-contact bugs@across.to\n */\ncontract Ethereum_SpokePool is SpokePool, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    )\n        SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            // Ethereum_SpokePool does not use OFT messaging; setting destination eid and fee cap to 0\n            0,\n            0\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Ethereum SpokePool.\n     * @dev crossDomainAdmin is unused on this contract.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(uint32 _initialDepositId, address _withdrawalRecipient) public initializer {\n        __Ownable_init();\n        __SpokePool_init(_initialDepositId, _withdrawalRecipient, _withdrawalRecipient);\n    }\n\n    /**************************************\n     *          INTERNAL FUNCTIONS           *\n     **************************************/\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        IERC20Upgradeable(l2TokenAddress).safeTransfer(withdrawalRecipient, amountToReturn);\n    }\n\n    // The SpokePool deployed to the same network as the HubPool must be owned by the HubPool.\n    // A core assumption of this contract system is that the HubPool is deployed on Ethereum.\n    function _requireAdminSender() internal override onlyOwner {}\n}\n"
    },
    "contracts/external/interfaces/CCTPInterfaces.sol": {
      "content": "/**\n * Copyright (C) 2015, 2016, 2017 Dapphub\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/**\n * Imported as-is from commit 139d8d0ce3b5531d3c7ec284f89d946dfb720016 of:\n *   * https://github.com/walkerq/evm-cctp-contracts/blob/139d8d0ce3b5531d3c7ec284f89d946dfb720016/src/TokenMessenger.sol\n * Changes applied post-import:\n *   * Removed a majority of code from this contract and converted the needed function signatures in this interface.\n */\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @return _nonce unique nonce reserved by message\n     */\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64 _nonce);\n\n    /**\n     * @notice Minter responsible for minting and burning tokens on the local domain\n     * @dev A TokenMessenger stores a TokenMinter contract which extends the TokenController contract.\n     * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMessenger.sol#L110\n     * @return minter Token Minter contract.\n     */\n    function localMinter() external view returns (ITokenMinter minter);\n}\n\n// Source: https://github.com/circlefin/evm-cctp-contracts/blob/63ab1f0ac06ce0793c0bbfbb8d09816bc211386d/src/v2/TokenMessengerV2.sol#L138C1-L166C15\ninterface ITokenMessengerV2 {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - maxFee is greater than or equal to `amount`.\n     * - MessageTransmitterV2#sendMessage reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain to receive message on\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken token to burn `amount` of, on local domain\n     * @param destinationCaller authorized caller on the destination domain, as bytes32. If equal to bytes32(0),\n     * any address can broadcast the message.\n     * @param maxFee maximum fee to pay on the destination domain, specified in units of burnToken\n     * @param minFinalityThreshold the minimum finality at which a burn message will be attested to.\n     */\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold\n    ) external;\n}\n\n/**\n * A TokenMessenger stores a TokenMinter contract which extends the TokenController contract. The TokenController\n * contract has a burnLimitsPerMessage public mapping which can be queried to find the per-message burn limit\n * for a given token:\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMinter.sol#L33\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/roles/TokenController.sol#L69C40-L69C60\n *\n */\ninterface ITokenMinter {\n    /**\n     * @notice Supported burnable tokens on the local domain\n     * local token (address) => maximum burn amounts per message\n     * @param token address of token contract\n     * @return burnLimit maximum burn amount per message for token\n     */\n    function burnLimitsPerMessage(address token) external view returns (uint256);\n}\n\n/**\n * IMessageTransmitter in CCTP inherits IRelayer and IReceiver, but here we only import sendMessage from IRelayer:\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IMessageTransmitter.sol#L25\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IRelayer.sol#L23-L35\n */\ninterface IMessageTransmitter {\n    /**\n     * @notice Sends an outgoing message from the source domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external returns (uint64);\n}\n"
    },
    "contracts/external/interfaces/IERC20Auth.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/*\n * @notice Minimal interface for an EIP-3009 compliant token.\n * https://eips.ethereum.org/EIPS/eip-3009\n */\ninterface IERC20Auth {\n    /**\n     * @notice Receive a transfer with a signed authorization from the payer\n     * @dev This has an additional check to ensure that the payee's address matches\n     * the caller of this function to prevent front-running attacks. (See security\n     * considerations)\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function receiveWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/external/interfaces/IHelios.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/// @notice SP1HeliosLightClient\n/// https://github.com/succinctlabs/sp1-helios/blob/776337bf8b63bcf9beebad143e8981020dec2b52/contracts/src/SP1Helios.sol\ninterface IHelios {\n    /// @notice Gets the value of a storage slot at a specific block\n    /// @dev Function added to Helios in https://github.com/across-protocol/sp1-helios/pull/2\n    function getStorageSlot(\n        uint256 blockNumber,\n        address contractAddress,\n        bytes32 slot\n    ) external view returns (bytes32);\n\n    function headTimestamp() external view returns (uint256);\n}\n"
    },
    "contracts/external/interfaces/IOpUSDCBridgeAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * Imported from https://github.com/defi-wonderland/opUSDC\n * https://github.com/defi-wonderland/opUSDC/blob/ef22e5731f1655bf5249b2160452cce9aa06ff3f/src/interfaces/IOpUSDCBridgeAdapter.sol#L198C1-L204C84\n */\ninterface IOpUSDCBridgeAdapter {\n    /**\n     * @notice Send tokens to another chain through the linked adapter\n     * @param _to The target address on the destination chain\n     * @param _amount The amount of tokens to send\n     * @param _minGasLimit Minimum gas limit that the message can be executed with\n     */\n    function sendMessage(\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit\n    ) external;\n}\n"
    },
    "contracts/external/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPermit2 {\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n\n    struct TokenPermissions {\n        address token;\n        uint256 amount;\n    }\n\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    struct SignatureTransferDetails {\n        address to;\n        uint256 requestedAmount;\n    }\n\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n}\n"
    },
    "contracts/external/interfaces/IPolygonZkEVMBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Interface of Polygon zkEVM's Canonical Bridge\n * See https://github.com/0xPolygonHermez/zkevm-contracts/blob/53e95f3a236d8bea87c27cb8714a5d21496a3b20/contracts/interfaces/IPolygonZkEVMBridge.sol\n */\ninterface IPolygonZkEVMBridge {\n    /**\n     * @notice Deposit add a new leaf to the merkle tree\n     * @param destinationNetwork Network destination\n     * @param destinationAddress Address destination\n     * @param amount Amount of tokens\n     * @param token Token address, 0 address is reserved for ether\n     * @param forceUpdateGlobalExitRoot Indicates if the new global exit root is updated or not\n     * @param permitData Raw data of the call `permit` of the token\n     */\n    function bridgeAsset(\n        uint32 destinationNetwork,\n        address destinationAddress,\n        uint256 amount,\n        address token,\n        bool forceUpdateGlobalExitRoot,\n        bytes calldata permitData\n    ) external payable;\n\n    /**\n     * @notice Bridge message and send ETH value\n     * @param destinationNetwork Network destination\n     * @param destinationAddress Address destination\n     * @param forceUpdateGlobalExitRoot Indicates if the new global exit root is updated or not\n     * @param metadata Message metadata\n     */\n    function bridgeMessage(\n        uint32 destinationNetwork,\n        address destinationAddress,\n        bool forceUpdateGlobalExitRoot,\n        bytes calldata metadata\n    ) external payable;\n}\n"
    },
    "contracts/external/interfaces/LineaInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Interface of Linea's Canonical Message Service\n * See https://github.com/Consensys/linea-contracts/blob/3cf85529fd4539eb06ba998030c37e47f98c528a/contracts/interfaces/IMessageService.sol\n */\ninterface IMessageService {\n    /**\n     * @notice Sends a message for transporting from the given chain.\n     * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n     * @param _to The destination address on the destination chain.\n     * @param _fee The message service fee on the origin chain.\n     * @param _calldata The calldata used by the destination message service to call the destination contract.\n     */\n    function sendMessage(\n        address _to,\n        uint256 _fee,\n        bytes calldata _calldata\n    ) external payable;\n\n    /**\n     * @notice Returns the original sender of the message on the origin layer.\n     */\n    function sender() external view returns (address);\n\n    /**\n     * @notice Minimum fee to use when sending a message. Currently, only exists on L2MessageService.\n     * See https://github.com/Consensys/linea-contracts/blob/3cf85529fd4539eb06ba998030c37e47f98c528a/contracts/messageService/l2/L2MessageService.sol#L37\n     */\n    function minimumFeeInWei() external view returns (uint256);\n}\n\n/**\n * @notice Interface of Linea's Canonical Token Bridge\n * See https://github.com/Consensys/linea-contracts/blob/3cf85529fd4539eb06ba998030c37e47f98c528a/contracts/tokenBridge/interfaces/ITokenBridge.sol\n */\ninterface ITokenBridge {\n    /**\n     * @notice This function is the single entry point to bridge tokens to the\n     *   other chain, both for native and already bridged tokens. You can use it\n     *   to bridge any ERC20. If the token is bridged for the first time an ERC20\n     *   (BridgedToken.sol) will be automatically deployed on the target chain.\n     * @dev User should first allow the bridge to transfer tokens on his behalf.\n     *   Alternatively, you can use `bridgeTokenWithPermit` to do so in a single\n     *   transaction. If you want the transfer to be automatically executed on the\n     *   destination chain. You should send enough ETH to pay the postman fees.\n     *   Note that Linea can reserve some tokens (which use a dedicated bridge).\n     *   In this case, the token cannot be bridged. Linea can only reserve tokens\n     *   that have not been bridged yet.\n     *   Linea can pause the bridge for security reason. In this case new bridge\n     *   transaction would revert.\n     * @param _token The address of the token to be bridged.\n     * @param _amount The amount of the token to be bridged.\n     * @param _recipient The address that will receive the tokens on the other chain.\n     */\n    function bridgeToken(\n        address _token,\n        uint256 _amount,\n        address _recipient\n    ) external payable;\n}\n\ninterface IUSDCBridge {\n    function usdc() external view returns (address);\n\n    /**\n     * @dev Sends the sender's USDC from L1 to the recipient on L2, locks the USDC sent\n     * in this contract and sends a message to the message bridge\n     * contract to mint the equivalent USDC on L2\n     * @param amount The amount of USDC to send\n     * @param to The recipient's address to receive the funds\n     */\n    function depositTo(uint256 amount, address to) external payable;\n}\n"
    },
    "contracts/external/interfaces/SuccinctInterfaces.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// These interfaces are a subset of the Succinct interfaces here: https://github.com/succinctlabs/telepathy-contracts.\n\n// This interface should be implemented by any contract wanting to receive messages sent over the Succinct bridge.\ninterface ITelepathyHandler {\n    function handleTelepathy(\n        uint16 _sourceChainId,\n        address _senderAddress,\n        bytes memory _data\n    ) external returns (bytes4);\n}\n\n// This interface represents the contract that we call into to send messages over the Succinct AMB.\ninterface ITelepathyBroadcaster {\n    function send(\n        uint16 _recipientChainId,\n        address _recipientAddress,\n        bytes calldata _data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/external/interfaces/WETH9Interface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Interface for the WETH9 contract.\n */\ninterface WETH9Interface {\n    /**\n     * @notice Burn Wrapped Ether and receive native Ether.\n     * @param wad Amount of WETH to unwrap and send to caller.\n     */\n    function withdraw(uint256 wad) external;\n\n    /**\n     * @notice Lock native Ether and mint Wrapped Ether ERC20\n     * @dev msg.value is amount of Wrapped Ether to mint/Ether to lock.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Get balance of WETH held by `guy`.\n     * @param guy Address to get balance of.\n     * @return wad Amount of WETH held by `guy`.\n     */\n    function balanceOf(address guy) external view returns (uint256 wad);\n\n    /**\n     * @notice Transfer `wad` of WETH from caller to `guy`.\n     * @param guy Address to send WETH to.\n     * @param wad Amount of WETH to send.\n     * @return ok True if transfer succeeded.\n     */\n    function transfer(address guy, uint256 wad) external returns (bool);\n}\n"
    },
    "contracts/external/Multicall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0; // Bumped version\n\n/**\n * This contract has been copied from the MD1/Multicall repository.\n * @dev https://github.com/mds1/multicall/blob/ebd8b64457454fc10037b3a3ea858f9c08dad4d3/src/Multicall3.sol\n * @dev changelog: pragma solidity ^0.8.12 -> pragma solidity ^0.8.0\n **/\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    /// @notice Backwards-compatible call aggregation with Multicall\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return returnData An array of bytes containing the responses\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length; ) {\n            bool success;\n            call = calls[i];\n            (success, returnData[i]) = call.target.call(call.callData);\n            require(success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls without requiring success\n    /// @param requireSuccess If true, require all calls to succeed\n    /// @param calls An array of Call structs\n    /// @return returnData An array of Result structs\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        public\n        payable\n        returns (Result[] memory returnData)\n    {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            call = calls[i];\n            (result.success, result.returnData) = call.target.call(call.callData);\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        public\n        payable\n        returns (\n            uint256 blockNumber,\n            bytes32 blockHash,\n            Result[] memory returnData\n        )\n    {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function blockAndAggregate(Call[] calldata calls)\n        public\n        payable\n        returns (\n            uint256 blockNumber,\n            bytes32 blockHash,\n            Result[] memory returnData\n        )\n    {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n    }\n\n    /// @notice Aggregate calls, ensuring each returns success if required\n    /// @param calls An array of Call3 structs\n    /// @return returnData An array of Result structs\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3 calldata calli;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            (result.success, result.returnData) = calli.target.call(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x64)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Aggregate calls with a msg value\n    /// @notice Reverts if msg.value is less than the sum of the call values\n    /// @param calls An array of Call3Value structs\n    /// @return returnData An array of Result structs\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3Value calldata calli;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            uint256 val = calli.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n            (result.success, result.returnData) = calli.target.call{ value: val }(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x84)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n    }\n\n    /// @notice Returns the block hash for the given block number\n    /// @param blockNumber The block number\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /// @notice Returns the block number\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        blockNumber = block.number;\n    }\n\n    /// @notice Returns the block coinbase\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n\n    /// @notice Returns the block difficulty\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.difficulty;\n    }\n\n    /// @notice Returns the block gas limit\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    /// @notice Returns the block timestamp\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    /// @notice Returns the (ETH) balance of a given address\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    /// @notice Returns the block hash of the last block\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        unchecked {\n            blockHash = blockhash(block.number - 1);\n        }\n    }\n\n    /// @notice Gets the base fee of the given block\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n    function getBasefee() public view returns (uint256 basefee) {\n        basefee = block.basefee;\n    }\n\n    /// @notice Returns the chain id\n    function getChainId() public view returns (uint256 chainid) {\n        chainid = block.chainid;\n    }\n}\n"
    },
    "contracts/external/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/**\n * Copyright (C) 2015, 2016, 2017 Dapphub\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Imported as at commit 33d01d471437e1ab6861e4545ea4bb3895fd4d74 from:\n * UMAprotocol/protocol/packages/core/contracts/financial-templates/common/WETH9.sol\n * Changes applied post-import:\n * - Corrected SPDX-License-Identifier & reinstated GPLv3 license header.\n * - Permit transferFrom() to be overridden by marking it virtual.\n */\n\npragma solidity ^0.8.0;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    fallback() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    /**\n     * @dev Local change: marked virtual to allow overriding.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public virtual returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/handlers/MulticallHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/SpokePoolMessageHandler.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title Across Multicall contract that allows a user to specify a series of calls that should be made by the handler\n * via the message field in the deposit.\n * @dev This contract makes the calls blindly. The contract will send any remaining tokens The caller should ensure that the tokens recieved by the handler are completely consumed.\n */\ncontract MulticallHandler is AcrossMessageHandler, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    struct Call {\n        address target;\n        bytes callData;\n        uint256 value;\n    }\n\n    struct Replacement {\n        address token;\n        uint256 offset;\n    }\n\n    struct Instructions {\n        //  Calls that will be attempted.\n        Call[] calls;\n        // Where the tokens go if any part of the call fails.\n        // Leftover tokens are sent here as well if the action succeeds.\n        address fallbackRecipient;\n    }\n\n    // Emitted when one of the calls fails. Note: all calls are reverted in this case.\n    event CallsFailed(Call[] calls, address indexed fallbackRecipient);\n\n    // Emitted when there are leftover tokens that are sent to the fallbackRecipient.\n    event DrainedTokens(address indexed recipient, address indexed token, uint256 indexed amount);\n\n    // Errors\n    error CallReverted(uint256 index, Call[] calls);\n    error NotSelf();\n    error InvalidCall(uint256 index, Call[] calls);\n    error ReplacementCallFailed(bytes callData);\n    error CalldataTooShort(uint256 callDataLength, uint256 offset);\n\n    modifier onlySelf() {\n        _requireSelf();\n        _;\n    }\n\n    /**\n     * @notice Main entrypoint for the handler called by the SpokePool contract.\n     * @dev This will execute all calls encoded in the msg. The caller is responsible for making sure all tokens are\n     * drained from this contract by the end of the series of calls. If not, they can be stolen.\n     * A drainLeftoverTokens call can be included as a way to drain any remaining tokens from this contract.\n     * @param message abi encoded array of Call structs, containing a target, callData, and value for each call that\n     * the contract should make.\n     */\n    function handleV3AcrossMessage(address token, uint256, address, bytes memory message) external nonReentrant {\n        Instructions memory instructions = abi.decode(message, (Instructions));\n\n        // If there is no fallback recipient, call and revert if the inner call fails.\n        if (instructions.fallbackRecipient == address(0)) {\n            this.attemptCalls(instructions.calls);\n            return;\n        }\n\n        // Otherwise, try the call and send to the fallback recipient if any tokens are leftover.\n        (bool success, ) = address(this).call(abi.encodeCall(this.attemptCalls, (instructions.calls)));\n        if (!success) emit CallsFailed(instructions.calls, instructions.fallbackRecipient);\n\n        // If there are leftover tokens, send them to the fallback recipient regardless of execution success.\n        _drainRemainingTokens(token, payable(instructions.fallbackRecipient));\n    }\n\n    function attemptCalls(Call[] memory calls) external onlySelf {\n        uint256 length = calls.length;\n        for (uint256 i = 0; i < length; ++i) {\n            Call memory call = calls[i];\n\n            // If we are calling an EOA with calldata, assume target was incorrectly specified and revert.\n            if (call.callData.length > 0 && call.target.code.length == 0) {\n                revert InvalidCall(i, calls);\n            }\n\n            (bool success, ) = call.target.call{ value: call.value }(call.callData);\n            if (!success) revert CallReverted(i, calls);\n        }\n    }\n\n    function drainLeftoverTokens(address token, address payable destination) external onlySelf {\n        _drainRemainingTokens(token, destination);\n    }\n\n    function _drainRemainingTokens(address token, address payable destination) internal {\n        if (token != address(0)) {\n            // ERC20 token.\n            uint256 amount = IERC20(token).balanceOf(address(this));\n            if (amount > 0) {\n                IERC20(token).safeTransfer(destination, amount);\n                emit DrainedTokens(destination, token, amount);\n            }\n        } else {\n            // Send native token\n            uint256 amount = address(this).balance;\n            if (amount > 0) {\n                destination.sendValue(amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Executes a call while replacing specified calldata offsets with current token/native balances.\n     * @dev Modifies calldata in-place using OR operations. Target calldata positions must be zeroed out.\n     * Cannot handle negative balances, making it incompatible with DEXs requiring negative input amounts.\n     * For native balance (token = address(0)), the entire balance is used as call value.\n     * @param target The contract address to call\n     * @param callData The calldata to execute, with zero values at replacement positions\n     * @param value The native token value to send (ignored if native balance replacement is used)\n     * @param replacement Array of Replacement structs specifying token addresses and byte offsets for balance injection\n     */\n    function makeCallWithBalance(\n        address target,\n        bytes memory callData,\n        uint256 value,\n        Replacement[] calldata replacement\n    ) external onlySelf {\n        for (uint256 i = 0; i < replacement.length; i++) {\n            uint256 bal = 0;\n            if (replacement[i].token != address(0)) {\n                bal = IERC20(replacement[i].token).balanceOf(address(this));\n            } else {\n                bal = address(this).balance;\n\n                // If we're using the native balance, we assume that the caller wants to send the full value to the target.\n                value = bal;\n            }\n\n            // + 32 to skip the length of the calldata\n            uint256 offset = replacement[i].offset + 32;\n\n            // 32 has already been added to the offset, and the replacement value is 32 bytes long, so\n            // we don't need to add 32 here. We just directly compare the offset with the length of the calldata.\n            if (offset > callData.length) revert CalldataTooShort(callData.length, offset);\n\n            assembly (\"memory-safe\") {\n                // Get the pointer to the offset that the caller wants to overwrite.\n                let ptr := add(callData, offset)\n                // Get the current value at the offset.\n                let current := mload(ptr)\n                // Or the current value with the new value.\n                // Reasoning:\n                // - caller should 0-out any portion that they want overwritten.\n                // - if the caller is representing the balance in a smaller integer, like a uint160 or uint128,\n                //   the higher bits will be 0 and not overwrite any other data in the calldata assuming\n                //   the balance is small enough to fit in the smaller integer.\n                // - The catch: the smaller integer where they want to store the balance must end no\n                //   earlier than the 32nd byte in their calldata. Otherwise, this would require a\n                //   negative offset, which is not possible.\n                let val := or(bal, current)\n                // Store the new value at the offset.\n                mstore(ptr, val)\n            }\n        }\n\n        (bool success, ) = target.call{ value: value }(callData);\n        if (!success) revert ReplacementCallFailed(callData);\n    }\n\n    function _requireSelf() internal view {\n        // Must be called by this contract to ensure that this cannot be triggered without the explicit consent of the\n        // depositor (for a valid relay).\n        if (msg.sender != address(this)) revert NotSelf();\n    }\n\n    // Used if the caller is trying to unwrap the native token to this contract.\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/ArbitrumBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Staging ground for incoming and outgoing messages\n * @notice Unlike the standard Eth bridge, native token bridge escrows the custom ERC20 token which is\n * used as native currency on upper layer.\n * @dev Fees are paid in this token. There are certain restrictions on the native token:\n *       - The token can't be rebasing or have a transfer fee\n *       - The token must only be transferrable via a call to the token address itself\n *       - The token must only be able to set allowance via a call to the token address itself\n *       - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\n *       - The token must have a max of 2^256 - 1 wei total supply unscaled\n *       - The token must have a max of 2^256 - 1 wei total supply when scaled to 18 decimals\n */\ninterface ArbitrumERC20Bridge {\n    /**\n     * @notice Returns token that is escrowed in bridge on the lower layer and minted on the upper layer as native currency.\n     * @dev This function doesn't exist on the generic Bridge interface.\n     * @return address of the native token.\n     */\n    function nativeToken() external view returns (address);\n\n    /**\n     * @dev number of decimals used by the native token\n     *      This is set on bridge initialization using nativeToken.decimals()\n     *      If the token does not have decimals() method, we assume it have 0 decimals\n     */\n    function nativeTokenDecimals() external view returns (uint8);\n}\n\n/**\n * @title Inbox for user and contract originated messages\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\n * to await inclusion in the SequencerInbox\n */\ninterface ArbitrumInboxLike {\n    /**\n     * @dev we only use this function to check the native token used by the bridge, so we hardcode the interface\n     * to return an ArbitrumERC20Bridge instead of a more generic Bridge interface.\n     * @return address of the bridge.\n     */\n    function bridge() external view returns (ArbitrumERC20Bridge);\n\n    /**\n     * @notice Put a message in the inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @dev Caller must set msg.value equal to at least `maxSubmissionCost + maxGas * gasPriceBid`.\n     *      all msg.value will deposited to callValueRefundAddress on the upper layer\n     * @dev More details can be found here: https://developer.arbitrum.io/arbos/l1-to-l2-messaging\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's (upper layer) balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on (upper layer) balance\n     * @param callValueRefundAddress callvalue gets credited here on upper layer if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's upper layer balance to cover upper layer execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for upper layer execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the source chain inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed\n     * funds come from the deposit alone, rather than falling back on the user's balance\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\n     * createRetryableTicket method is the recommended standard.\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's source chain balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on source chain balance\n     * @param callValueRefundAddress callvalue gets credited here on source chain if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's balance to cover execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of the message\n     * @return unique message number of the retryable transaction\n     */\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n}\n\n/**\n * @notice Interface which extends ArbitrumInboxLike with functions used to interact with bridges that use a custom gas token.\n */\ninterface ArbitrumCustomGasTokenInbox is ArbitrumInboxLike {\n    /**\n     * @notice Put a message in the inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @notice Overloads the `createRetryableTicket` function but is not payable, and should only be called when paying\n     * for message using a custom gas token.\n     * @dev all tokenTotalFeeAmount will be deposited to callValueRefundAddress on upper layer\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @dev In case of native token having non-18 decimals: tokenTotalFeeAmount is denominated in native token's decimals. All other value params - callValue, maxSubmissionCost and maxFeePerGas are denominated in child chain's native 18 decimals.\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's upper layer balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost. In case this address is a contract, funds will be received in its alias on upper layer.\n     * @param callValueRefundAddress callvalue gets credited here on upper layer if retryable txn times out or gets cancelled. In case this address is a contract, funds will be received in its alias on upper layer.\n     * @param gasLimit Max gas deducted from user's balance to cover execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\n     * @param data ABI encoded data of message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 tokenTotalFeeAmount,\n        bytes calldata data\n    ) external returns (uint256);\n}\n\n/**\n * @notice Generic gateway contract for bridging standard ERC20s to/from Arbitrum-like networks.\n * @notice These function signatures are shared between the L1 and L2 gateway router contracts.\n */\ninterface ArbitrumL1ERC20GatewayLike {\n    /**\n     * @notice Deprecated in favor of outboundTransferCustomRefund but still used in custom bridges\n     * like the DAI bridge.\n     * @dev Refunded to aliased address of sender if sender has code on source chain, otherwise to to sender's EOA on destination chain.\n     * @param _sourceToken address of ERC20\n     * @param _to Account to be credited with the tokens at the destination (can be the user's account or a contract),\n     * not subject to aliasing. This account, or its alias if it has code in the source chain, will also be able to\n     * cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's balance to cover execution\n     * @param _gasPriceBid Gas price for execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransfer(\n        address _sourceToken,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    /**\n     * @notice get ERC20 gateway for token.\n     * @param _token ERC20 address.\n     * @return address of ERC20 gateway.\n     */\n    function getGateway(address _token) external view returns (address);\n\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum-like networks.\n     * @dev Upper layer address alias will not be applied to the following types of addresses on lower layer:\n     *      - an externally-owned account\n     *      - a contract in construction\n     *      - an address where a contract will be created\n     *      - an address where a contract lived, but was destroyed\n     * @param _sourceToken address of ERC20 on source chain.\n     * @param _refundTo Account, or its alias if it has code on the source chain, to be credited with excess gas refund at destination\n     * @param _to Account to be credited with the tokens in the L3 (can be the user's L3 account or a contract),\n     * not subject to aliasing. This account, or its alias if it has code on the source chain, will also be able to\n     * cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's balance to cover execution\n     * @param _gasPriceBid Gas price for execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransferCustomRefund(\n        address _sourceToken,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n\ninterface ArbitrumL2ERC20GatewayLike {\n    /**\n     * @notice Fetches the l2 token address from the gateway router for the input l1 token address\n     * @param _l1Erc20 address of the l1 token.\n     */\n    function calculateL2TokenAddress(address _l1Erc20) external view returns (address);\n\n    /**\n     * @notice Withdraws a specified amount of an l2 token to an l1 token.\n     * @param _l1Token address of the token to withdraw on L1.\n     * @param _to address on L1 which will receive the tokens upon withdrawal.\n     * @param _amount amount of the token to withdraw.\n     * @param _data encoded data to send to the gateway router.\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/HubPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Concise list of functions in HubPool implementation.\n */\ninterface HubPoolInterface {\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\n    struct PoolRebalanceLeaf {\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).\n        uint256 chainId;\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\n        uint256[] bundleLpFees;\n        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative\n        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This\n        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does\n        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous\n        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's\n        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.\n        int256[] netSendAmounts;\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1\n        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that\n        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.\n        int256[] runningBalances;\n        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.\n        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where\n        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under\n        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with\n        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one\n        // leaf for a specific chainId should have a groupIndex equal to 0.\n        uint256 groupIndex;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint8 leafId;\n        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel\n        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero\n        // relays on this chain in this bundle in the order of whitelisting.\n        address[] l1Tokens;\n    }\n\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves\n    // that can be executed later to:\n    // - Send funds from this contract to a SpokePool or vice versa\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \"slow\" relay\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\n    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\n    struct RootBundle {\n        // Contains leaves instructing this contract to send funds to SpokePools.\n        bytes32 poolRebalanceRoot;\n        // Relayer refund merkle root to be published to a SpokePool.\n        bytes32 relayerRefundRoot;\n        // Slow relay merkle root to be published to a SpokePool.\n        bytes32 slowRelayRoot;\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\n        uint256 claimedBitMap;\n        // Proposer of this root bundle.\n        address proposer;\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\n        // of leaves are executed, a new root bundle can be proposed\n        uint8 unclaimedPoolRebalanceLeafCount;\n        // When root bundle challenge period passes and this root bundle becomes executable.\n        uint32 challengePeriodEndTimestamp;\n    }\n\n    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the\n    // cumulative LP positions and if this token is enabled for deposits.\n    struct PooledToken {\n        // LP token given to LPs of a specific L1 token.\n        address lpToken;\n        // True if accepting new LP's.\n        bool isEnabled;\n        // Timestamp of last LP fee update.\n        uint32 lastLpFeeUpdate;\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\n        // back later.\n        int256 utilizedReserves;\n        // Number of LP funds held in contract less utilized reserves.\n        uint256 liquidReserves;\n        // Number of LP funds reserved to pay out to LPs as fees.\n        uint256 undistributedLpFees;\n    }\n\n    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\n    struct CrossChainContract {\n        address adapter;\n        address spokePool;\n    }\n\n    function setPaused(bool pause) external;\n\n    function emergencyDeleteProposal() external;\n\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\n\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\n\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\n\n    function setLiveness(uint32 newLiveness) external;\n\n    function setIdentifier(bytes32 newIdentifier) external;\n\n    function setCrossChainContracts(\n        uint256 l2ChainId,\n        address adapter,\n        address spokePool\n    ) external;\n\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\n\n    function removeLiquidity(\n        address l1Token,\n        uint256 lpTokenAmount,\n        bool sendEth\n    ) external;\n\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);\n\n    function sync(address l1Token) external;\n\n    function proposeRootBundle(\n        uint256[] memory bundleEvaluationBlockNumbers,\n        uint8 poolRebalanceLeafCount,\n        bytes32 poolRebalanceRoot,\n        bytes32 relayerRefundRoot,\n        bytes32 slowRelayRoot\n    ) external;\n\n    function executeRootBundle(\n        uint256 chainId,\n        uint256 groupIndex,\n        uint256[] memory bundleLpFees,\n        int256[] memory netSendAmounts,\n        int256[] memory runningBalances,\n        uint8 leafId,\n        address[] memory l1Tokens,\n        bytes32[] memory proof\n    ) external;\n\n    function disputeRootBundle() external;\n\n    function claimProtocolFeesCaptured(address l1Token) external;\n\n    function setPoolRebalanceRoute(\n        uint256 destinationChainId,\n        address l1Token,\n        address destinationToken\n    ) external;\n\n    function setDepositRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        bool depositsEnabled\n    ) external;\n\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\n        external\n        view\n        returns (address destinationToken);\n\n    function loadEthForL2Calls() external payable;\n}\n"
    },
    "contracts/interfaces/IHypXERC20Router.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Interface for interfacing with Hyperlane's xERC20 messaging\n */\ninterface IHypXERC20Router {\n    /**\n     * @notice Retuns the underlying token available for bridging\n     */\n    function wrappedToken() external view returns (address);\n\n    /**\n     * @notice Returns the gas payment required to dispatch a message to the given domain's router.\n     * @param _destinationDomain The domain of the router.\n     * @return _gasPayment Payment computed by the registered InterchainGasPaymaster.\n     */\n    function quoteGasPayment(uint32 _destinationDomain) external view returns (uint256);\n\n    /**\n     * @notice Transfers `_amountOrId` token to `_recipient` on `_destination` domain.\n     * @dev Delegates transfer logic to `_transferFromSender` implementation.\n     * @dev Emits `SentTransferRemote` event on the origin chain.\n     * @param _destination The identifier of the destination chain.\n     * @param _recipient The address of the recipient on the destination chain.\n     * @param _amountOrId The amount or identifier of tokens to be sent to the remote recipient.\n     * @return messageId The identifier of the dispatched message.\n     */\n    function transferRemote(\n        uint32 _destination,\n        bytes32 _recipient,\n        uint256 _amountOrId\n    ) external payable returns (bytes32 messageId);\n}\n"
    },
    "contracts/interfaces/IOFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice This file contains minimal copies of relevant structs / interfaces for OFT bridging. Source code link:\n * https://github.com/LayerZero-Labs/LayerZero-v2/blob/9a4049ae3a374e1c0ef01ac9fb53dd83f4257a68/packages/layerzero-v2/evm/oapp/contracts/oft/interfaces/IOFT.sol\n * It's also published as a part of an npm package: @layerzerolabs/oft-evm. The published code is incompatible with\n * our compiler version requirements, so we copy it here instead\n */\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\n/**\n * @dev Struct representing token parameters for the OFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination endpoint ID.\n    bytes32 to; // Recipient address.\n    uint256 amountLD; // Amount to send in local decimals.\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n}\n\n/**\n * @dev Struct representing OFT receipt information.\n */\nstruct OFTReceipt {\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n}\n\n/**\n * @title IOFT\n * @dev Interface for the OftChain (OFT) token.\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\n * @dev This specific interface ID is '0x02e49c2c'.\n */\ninterface IOFT {\n    /**\n     * @notice Retrieves the address of the token associated with the OFT.\n     * @return token The address of the ERC20 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\n}\n"
    },
    "contracts/interfaces/LpTokenFactoryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @notice Factory to create new LP ERC20 tokens that represent a liquidity provider's position. HubPool is the\n * intended client of this contract.\n */\ninterface LpTokenFactoryInterface {\n    /**\n     * @notice Deploys new LP token for L1 token. Sets caller as minter and burner of token.\n     * @param l1Token L1 token to name in LP token name.\n     * @return address of new LP token.\n     */\n    function createLpToken(address l1Token) external returns (address);\n}\n"
    },
    "contracts/interfaces/SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @notice Contains common data structures and functions used by all SpokePool implementations.\n */\ninterface SpokePoolInterface {\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\n    struct RelayerRefundLeaf {\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that\n        // is negative. This is just the negative of this value.\n        uint256 amountToReturn;\n        // Used to verify that this is being executed on the correct destination chainId.\n        uint256 chainId;\n        // This array designates how much each of those addresses should be refunded.\n        uint256[] refundAmounts;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint32 leafId;\n        // The associated L2TokenAddress that these claims apply to.\n        address l2TokenAddress;\n        // Must be same length as refundAmounts and designates each address that must be refunded.\n        address[] refundAddresses;\n    }\n\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\n    // by \"data workers\" via inclusion proofs to execute leaves in the roots.\n    struct RootBundle {\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\n        bytes32 slowRelayRoot;\n        // Merkle root of relayer refunds for successful relays.\n        bytes32 relayerRefundRoot;\n        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of\n        // 256x(2^248) leaves per root.\n        mapping(uint256 => uint256) claimedBitmap;\n    }\n\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\n\n    function setWithdrawalRecipient(address newWithdrawalRecipient) external;\n\n    function pauseDeposits(bool pause) external;\n\n    function pauseFills(bool pause) external;\n\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\n\n    function emergencyDeleteRootBundle(uint256 rootBundleId) external;\n\n    function depositDeprecated_5947912356(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 maxCount\n    ) external payable;\n\n    function depositFor(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 maxCount\n    ) external payable;\n\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) external payable;\n\n    function chainId() external view returns (uint256);\n\n    error NotEOA();\n    error InvalidDepositorSignature();\n    error InvalidRelayerFeePct();\n    error MaxTransferSizeExceeded();\n    error InvalidCrossDomainAdmin();\n    error InvalidWithdrawalRecipient();\n    error DepositsArePaused();\n    error FillsArePaused();\n}\n"
    },
    "contracts/interfaces/SpokePoolMessageHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// This interface is expected to be implemented by any contract that expects to receive messages from the SpokePool.\ninterface AcrossMessageHandler {\n    function handleV3AcrossMessage(\n        address tokenSent,\n        uint256 amount,\n        address relayer,\n        bytes memory message\n    ) external;\n}\n"
    },
    "contracts/interfaces/SpokePoolPeripheryInterface.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { IPermit2 } from \"../external/interfaces/IPermit2.sol\";\n\n/**\n * @title SpokePoolPeriphery\n * @notice Contract for performing more complex interactions with an Across spoke pool deployment.\n * @custom:security-contact bugs@across.to\n */\ninterface SpokePoolPeripheryInterface {\n    // Enum describing the method of transferring tokens to an exchange.\n    enum TransferType {\n        // Approve the exchange so that it may transfer tokens from this contract.\n        Approval, // 0\n        // Transfer tokens to the exchange before calling it in this contract.\n        Transfer, // 1\n        // Approve the exchange by authorizing a transfer with Permit2.\n        Permit2Approval // 2\n    }\n\n    // Submission fees can be set by user to pay whoever submits the transaction in a gasless flow.\n    // These are assumed to be in the same currency that is input into the contract.\n    struct Fees {\n        // Amount of fees to pay recipient for submitting transaction.\n        uint256 amount;\n        // Recipient of fees amount.\n        address recipient;\n    }\n\n    // Params we'll need caller to pass in to specify an Across Deposit. The input token will be swapped into first\n    // before submitting a bridge deposit, which is why we don't include the input token amount as it is not known\n    // until after the swap.\n    struct BaseDepositData {\n        // Token deposited on origin chain.\n        address inputToken;\n        // Token received on destination chain.\n        bytes32 outputToken;\n        // Amount of output token to be received by recipient.\n        uint256 outputAmount;\n        // The account credited with deposit who can submit speedups to the Across deposit.\n        address depositor;\n        // The account that will receive the output token on the destination chain. If the output token is\n        // wrapped native token, then if this is an EOA then they will receive native token on the destination\n        // chain and if this is a contract then they will receive an ERC20.\n        bytes32 recipient;\n        // The destination chain identifier.\n        uint256 destinationChainId;\n        // The account that can exclusively fill the deposit before the exclusivity parameter.\n        bytes32 exclusiveRelayer;\n        // Timestamp of the deposit used by system to charge fees. Must be within short window of time into the past\n        // relative to this chain's current time or deposit will revert.\n        uint32 quoteTimestamp;\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\n        uint32 fillDeadline;\n        // The timestamp or offset on the destination chain after which anyone can fill the deposit. A detailed description on\n        // how the parameter is interpreted by the V3 spoke pool can be found at https://github.com/across-protocol/contracts/blob/fa67f5e97eabade68c67127f2261c2d44d9b007e/contracts/SpokePool.sol#L476\n        uint32 exclusivityParameter;\n        // Data that is forwarded to the recipient if the recipient is a contract.\n        bytes message;\n    }\n\n    // Minimum amount of parameters needed to perform a swap on an exchange specified. We include information beyond just the router calldata\n    // and exchange address so that we may ensure that the swap was performed properly.\n    struct SwapAndDepositData {\n        // Amount of fees to pay for submitting transaction. Unused in gasful flows.\n        Fees submissionFees;\n        // Deposit data to use when interacting with the Across spoke pool.\n        BaseDepositData depositData;\n        // Token to swap.\n        address swapToken;\n        // Address of the exchange to use in the swap.\n        address exchange;\n        // Method of transferring tokens to the exchange.\n        TransferType transferType;\n        // Amount of the token to swap on the exchange.\n        uint256 swapTokenAmount;\n        // Minimum output amount of the exchange, and, by extension, the minimum required amount to deposit into an Across spoke pool.\n        uint256 minExpectedInputTokenAmount;\n        // The calldata to use when calling the exchange.\n        bytes routerCalldata;\n        // When enabled (true), if the swap returns more tokens than minExpectedInputTokenAmount,\n        // the outputAmount will be increased proportionally.\n        // When disabled (false), the original outputAmount is used regardless of how many tokens are returned.\n        bool enableProportionalAdjustment;\n        // Address of the SpokePool to use for depositing tokens after swap.\n        address spokePool;\n        // User nonce to prevent replay attacks.\n        uint256 nonce;\n    }\n\n    // Extended deposit data to be used specifically for signing off on periphery deposits.\n    struct DepositData {\n        // Amount of fees to pay for submitting transaction. Unused in gasful flows.\n        Fees submissionFees;\n        // Deposit data describing the parameters for the V3 Across deposit.\n        BaseDepositData baseDepositData;\n        // The precise input amount to deposit into the spoke pool.\n        uint256 inputAmount;\n        // Address of the SpokePool to use for depositing tokens.\n        address spokePool;\n        // User nonce to prevent replay attacks.\n        uint256 nonce;\n    }\n\n    /**\n     * @notice Passthrough function to `depositV3()` on the SpokePool contract for native token deposits.\n     * @dev Protects the caller from losing their ETH (or other native token) by reverting if the SpokePool address\n     * they intended to call does not exist on this chain. Because this contract can be deployed at the same address\n     * everywhere callers should be protected even if the transaction is submitted to an unintended network.\n     * This contract should only be used for native token deposits, as this problem only exists for native tokens.\n     * @param recipient Address (as bytes32) to receive funds on destination chain.\n     * @param inputToken Token to lock into this contract to initiate deposit.\n     * @param inputAmount Amount of tokens to deposit.\n     * @param outputAmount Amount of tokens to receive on destination chain.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     * @param exclusiveRelayer Address (as bytes32) of the relayer who has exclusive rights to fill this deposit. Can be set to\n     * 0x0 if no period is desired. If so, then must set exclusivityParameter to 0.\n     * @param exclusivityParameter Timestamp or offset, after which any relayer can fill this deposit. Must set\n     * to 0 if exclusiveRelayer is set to 0x0, and vice versa.\n     * @param fillDeadline Timestamp after which this deposit can no longer be filled.\n     */\n    function depositNative(\n        address spokePool,\n        bytes32 recipient,\n        address inputToken,\n        uint256 inputAmount,\n        bytes32 outputToken,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes memory message\n    ) external payable;\n\n    /**\n     * @notice Swaps tokens on this chain via specified router before submitting Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev If msg.value is sent, the swapToken in swapAndDepositData must implement the WETH9 interface for wrapping native tokens.\n     * @param swapAndDepositData Specifies the data needed to perform a swap on a generic exchange.\n     */\n    function swapAndBridge(SwapAndDepositData calldata swapAndDepositData) external payable;\n\n    /**\n     * @notice Swaps an EIP-2612 token on this chain via specified router before submitting Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev If the swapToken does not implement `permit` to the specifications of EIP-2612, the permit call result will be ignored and the function will continue.\n     * @dev If the swapToken in swapData does not implement `permit` to the specifications of EIP-2612, this function will fail.\n     * @dev The nonce for the swapAndDepositData signature must be retrieved from permitNonces(signatureOwner).\n     * @dev Design Decision: We use separate nonce tracking for permit-based functions versus\n     * receiveWithAuthorization-based functions, which creates a theoretical replay attack that we think is\n     * incredibly unlikely because this would require:\n     * 1. A token implementing both ERC-2612 and ERC-3009\n     * 2. A user using the same nonces for swapAndBridgeWithPermit and for swapAndBridgeWithAuthorization\n     * 3. Issuing these signatures within a short amount of time (limited by fillDeadlineBuffer)\n     * @param signatureOwner The owner of the permit signature and swapAndDepositData signature. Assumed to be the depositor for the Across spoke pool.\n     * @param swapAndDepositData Specifies the params we need to perform a swap on a generic exchange.\n     * @param deadline Deadline before which the permit signature is valid.\n     * @param permitSignature Permit signature encoded as (bytes32 r, bytes32 s, uint8 v).\n     * @param swapAndDepositDataSignature The signature against the input swapAndDepositData encoded as (bytes32 r, bytes32 s, uint8 v).\n     */\n    function swapAndBridgeWithPermit(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        uint256 deadline,\n        bytes calldata permitSignature,\n        bytes calldata swapAndDepositDataSignature\n    ) external;\n\n    /**\n     * @notice Uses permit2 to transfer tokens from a user before swapping a token on this chain via specified router and submitting an Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev This function assumes the caller has properly set an allowance for the permit2 contract on this network.\n     * @dev This function assumes that the amount of token to be swapped is equal to the amount of the token to be received from permit2.\n     * @param signatureOwner The owner of the permit2 signature and depositor for the Across spoke pool.\n     * @param swapAndDepositData Specifies the params we need to perform a swap on a generic exchange.\n     * @param permit The permit data signed over by the owner.\n     * @param signature The permit2 signature to verify against the deposit data.\n     */\n    function swapAndBridgeWithPermit2(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        IPermit2.PermitTransferFrom calldata permit,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * @notice Swaps an EIP-3009 token on this chain via specified router before submitting Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev If swapToken does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.\n     * @dev The nonce for the receiveWithAuthorization signature should match the nonce in the SwapAndDepositData.\n     * This nonce is managed by the ERC-3009 token contract.\n     * @param signatureOwner The owner of the EIP3009 signature and swapAndDepositData signature. Assumed to be the depositor for the Across spoke pool.\n     * @param swapAndDepositData Specifies the params we need to perform a swap on a generic exchange.\n     * @param validAfter The unix time after which the `receiveWithAuthorization` signature is valid.\n     * @param validBefore The unix time before which the `receiveWithAuthorization` signature is valid.\n     * @param receiveWithAuthSignature EIP3009 signature encoded as (bytes32 r, bytes32 s, uint8 v).\n     * @param swapAndDepositDataSignature The signature against the input swapAndDepositData encoded as (bytes32 r, bytes32 s, uint8 v).\n     */\n    function swapAndBridgeWithAuthorization(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes calldata receiveWithAuthSignature,\n        bytes calldata swapAndDepositDataSignature\n    ) external;\n\n    /**\n     * @notice Deposits an EIP-2612 token Across input token into the Spoke Pool contract.\n     * @dev If the token does not implement `permit` to the specifications of EIP-2612, the permit call result will be ignored and the function will continue.\n     * @dev If `acrossInputToken` does not implement `permit` to the specifications of EIP-2612, this function will fail.\n     * @dev The nonce for the depositData signature must be retrieved from permitNonces(signatureOwner).\n     * @dev Design Decision: We use separate nonce tracking for permit-based functions versus\n     * receiveWithAuthorization-based functions, which creates a theoretical replay attack that we think is\n     * incredibly unlikely because this would require:\n     * 1. A token implementing both ERC-2612 and ERC-3009\n     * 2. A user using the same nonces for depositWithPermit and for depositWithAuthorization\n     * 3. Issuing these signatures within a short amount of time (limited by fillDeadlineBuffer)\n     * @param signatureOwner The owner of the permit signature and depositData signature. Assumed to be the depositor for the Across spoke pool.\n     * @param depositData Specifies the Across deposit params to send.\n     * @param deadline Deadline before which the permit signature is valid.\n     * @param permitSignature Permit signature encoded as (bytes32 r, bytes32 s, uint8 v).\n     * @param depositDataSignature The signature against the input depositData encoded as (bytes32 r, bytes32 s, uint8 v).\n     */\n    function depositWithPermit(\n        address signatureOwner,\n        DepositData calldata depositData,\n        uint256 deadline,\n        bytes calldata permitSignature,\n        bytes calldata depositDataSignature\n    ) external;\n\n    /**\n     * @notice Uses permit2 to transfer and submit an Across deposit to the Spoke Pool contract.\n     * @dev This function assumes the caller has properly set an allowance for the permit2 contract on this network.\n     * @dev This function assumes that the amount of token to be swapped is equal to the amount of the token to be received from permit2.\n     * @param signatureOwner The owner of the permit2 signature and depositor for the Across spoke pool.\n     * @param depositData Specifies the Across deposit params we'll send after the swap.\n     * @param permit The permit data signed over by the owner.\n     * @param signature The permit2 signature to verify against the deposit data.\n     */\n    function depositWithPermit2(\n        address signatureOwner,\n        DepositData calldata depositData,\n        IPermit2.PermitTransferFrom calldata permit,\n        bytes calldata signature\n    ) external;\n\n    /**\n     * @notice Deposits an EIP-3009 compliant Across input token into the Spoke Pool contract.\n     * @dev If `acrossInputToken` does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.\n     * @dev The nonce for the receiveWithAuthorization signature should match the nonce in the DepositData.\n     * This nonce is managed by the ERC-3009 token contract.\n     * @param signatureOwner The owner of the EIP3009 signature and depositData signature. Assumed to be the depositor for the Across spoke pool.\n     * @param depositData Specifies the Across deposit params to send.\n     * @param validAfter The unix time after which the `receiveWithAuthorization` signature is valid.\n     * @param validBefore The unix time before which the `receiveWithAuthorization` signature is valid.\n     * @param receiveWithAuthSignature EIP3009 signature encoded as (bytes32 r, bytes32 s, uint8 v).\n     * @param depositDataSignature The signature against the input depositData encoded as (bytes32 r, bytes32 s, uint8 v).\n     */\n    function depositWithAuthorization(\n        address signatureOwner,\n        DepositData calldata depositData,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes calldata receiveWithAuthSignature,\n        bytes calldata depositDataSignature\n    ) external;\n\n    /**\n     * @notice Returns the current permit nonce for a user.\n     * @param user The user whose nonce to return.\n     * @return The current permit nonce for the user.\n     */\n    function permitNonces(address user) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/V3SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contains structs and functions used by SpokePool contracts to facilitate universal settlement.\ninterface V3SpokePoolInterface {\n    /**************************************\n     *              ENUMS                 *\n     **************************************/\n\n    // Fill status tracks on-chain state of deposit, uniquely identified by relayHash.\n    enum FillStatus {\n        Unfilled,\n        RequestedSlowFill,\n        Filled\n    }\n    // Fill type is emitted in the FilledRelay event to assist Dataworker with determining which types of\n    // fills to refund (e.g. only fast fills) and whether a fast fill created a sow fill excess.\n    enum FillType {\n        FastFill,\n        // Fast fills are normal fills that do not replace a slow fill request.\n        ReplacedSlowFill,\n        // Replaced slow fills are fast fills that replace a slow fill request. This type is used by the Dataworker\n        // to know when to send excess funds from the SpokePool to the HubPool because they can no longer be used\n        // for a slow fill execution.\n        SlowFill\n    }\n    // Slow fills are requested via requestSlowFill and executed by executeSlowRelayLeaf after a bundle containing\n    // the slow fill is validated.\n\n    /**************************************\n     *              STRUCTS               *\n     **************************************/\n\n    // This struct represents the data to fully specify a **unique** relay submitted on this chain.\n    // This data is hashed with the chainId() and saved by the SpokePool to prevent collisions and protect against\n    // replay attacks on other chains. If any portion of this data differs, the relay is considered to be\n    // completely distinct.\n    struct V3RelayData {\n        // The bytes32 that made the deposit on the origin chain.\n        bytes32 depositor;\n        // The recipient bytes32 on the destination chain.\n        bytes32 recipient;\n        // This is the exclusive relayer who can fill the deposit before the exclusivity deadline.\n        bytes32 exclusiveRelayer;\n        // Token that is deposited on origin chain by depositor.\n        bytes32 inputToken;\n        // Token that is received on destination chain by recipient.\n        bytes32 outputToken;\n        // The amount of input token deposited by depositor.\n        uint256 inputAmount;\n        // The amount of output token to be received by recipient.\n        uint256 outputAmount;\n        // Origin chain id.\n        uint256 originChainId;\n        // The id uniquely identifying this deposit on the origin chain.\n        uint256 depositId;\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\n        uint32 fillDeadline;\n        // The timestamp on the destination chain after which any relayer can fill the deposit.\n        uint32 exclusivityDeadline;\n        // Data that is forwarded to the recipient.\n        bytes message;\n    }\n\n    // Same as V3RelayData but using addresses instead of bytes32 & depositId is uint32.\n    // Will be deprecated in favor of V3RelayData in the future.\n    struct V3RelayDataLegacy {\n        address depositor;\n        address recipient;\n        address exclusiveRelayer;\n        address inputToken;\n        address outputToken;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        uint256 originChainId;\n        uint32 depositId;\n        uint32 fillDeadline;\n        uint32 exclusivityDeadline;\n        bytes message;\n    }\n\n    // Contains parameters passed in by someone who wants to execute a slow relay leaf.\n    struct V3SlowFill {\n        V3RelayData relayData;\n        uint256 chainId;\n        uint256 updatedOutputAmount;\n    }\n\n    // Contains information about a relay to be sent along with additional information that is not unique to the\n    // relay itself but is required to know how to process the relay. For example, \"updatedX\" fields can be used\n    // by the relayer to modify fields of the relay with the depositor's permission, and \"repaymentChainId\" is specified\n    // by the relayer to determine where to take a relayer refund, but doesn't affect the uniqueness of the relay.\n    struct V3RelayExecutionParams {\n        V3RelayData relay;\n        bytes32 relayHash;\n        uint256 updatedOutputAmount;\n        bytes32 updatedRecipient;\n        bytes updatedMessage;\n        uint256 repaymentChainId;\n    }\n\n    // Packs together parameters emitted in FilledRelay because there are too many emitted otherwise.\n    // Similar to V3RelayExecutionParams, these parameters are not used to uniquely identify the deposit being\n    // filled so they don't have to be unpacked by all clients.\n    struct V3RelayExecutionEventInfo {\n        bytes32 updatedRecipient;\n        bytes32 updatedMessageHash;\n        uint256 updatedOutputAmount;\n        FillType fillType;\n    }\n\n    // Represents the parameters required for a V3 deposit operation in the SpokePool.\n    struct DepositV3Params {\n        bytes32 depositor;\n        bytes32 recipient;\n        bytes32 inputToken;\n        bytes32 outputToken;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        uint256 destinationChainId;\n        bytes32 exclusiveRelayer;\n        uint256 depositId;\n        uint32 quoteTimestamp;\n        uint32 fillDeadline;\n        uint32 exclusivityParameter;\n        bytes message;\n    }\n\n    /**************************************\n     *              EVENTS                *\n     **************************************/\n\n    event FundsDeposited(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed destinationChainId,\n        uint256 indexed depositId,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 indexed depositor,\n        bytes32 recipient,\n        bytes32 exclusiveRelayer,\n        bytes message\n    );\n\n    event RequestedSpeedUpDeposit(\n        uint256 updatedOutputAmount,\n        uint256 indexed depositId,\n        bytes32 indexed depositor,\n        bytes32 updatedRecipient,\n        bytes updatedMessage,\n        bytes depositorSignature\n    );\n\n    event FilledRelay(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 repaymentChainId,\n        uint256 indexed originChainId,\n        uint256 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 exclusiveRelayer,\n        bytes32 indexed relayer,\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 messageHash,\n        V3RelayExecutionEventInfo relayExecutionInfo\n    );\n\n    event RequestedSlowFill(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed originChainId,\n        uint256 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 exclusiveRelayer,\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 messageHash\n    );\n\n    event ClaimedRelayerRefund(\n        bytes32 indexed l2TokenAddress,\n        bytes32 indexed refundAddress,\n        uint256 amount,\n        address indexed caller\n    );\n\n    /**************************************\n     *              FUNCTIONS             *\n     **************************************/\n\n    function deposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositNow(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function unsafeDeposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable;\n\n    function speedUpDeposit(\n        bytes32 depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function speedUpV3Deposit(\n        address depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function fillRelay(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress\n    ) external;\n\n    function fillV3Relay(V3RelayDataLegacy calldata relayData, uint256 repaymentChainId) external;\n\n    function fillRelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function requestSlowFill(V3RelayData calldata relayData) external;\n\n    function executeSlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) external;\n\n    function claimRelayerRefund(bytes32 l2TokenAddress, bytes32 refundAddress) external;\n\n    /**************************************\n     *              ERRORS                *\n     **************************************/\n\n    error DisabledRoute();\n    error InvalidQuoteTimestamp();\n    error InvalidFillDeadline();\n    error InvalidExclusiveRelayer();\n    error MsgValueDoesNotMatchInputAmount();\n    error NotExclusiveRelayer();\n    error NoSlowFillsInExclusivityWindow();\n    error RelayFilled();\n    error InvalidSlowFillRequest();\n    error ExpiredFillDeadline();\n    error InvalidMerkleProof();\n    error InvalidChainId();\n    error InvalidMerkleLeaf();\n    error ClaimedMerkleLeaf();\n    error InvalidPayoutAdjustmentPct();\n    error WrongERC7683OrderId();\n    error LowLevelCallFailed(bytes data);\n    error InsufficientSpokePoolBalanceToExecuteLeaf();\n    error NoRelayerRefundToClaim();\n\n    /**************************************\n     *             LEGACY EVENTS          *\n     **************************************/\n\n    // Note: these events are unused, but included in the ABI for ease of migration.\n    event V3FundsDeposited(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed destinationChainId,\n        uint32 indexed depositId,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address indexed depositor,\n        address recipient,\n        address exclusiveRelayer,\n        bytes message\n    );\n\n    event RequestedSpeedUpV3Deposit(\n        uint256 updatedOutputAmount,\n        uint32 indexed depositId,\n        address indexed depositor,\n        address updatedRecipient,\n        bytes updatedMessage,\n        bytes depositorSignature\n    );\n\n    // Legacy struct only used to preserve the FilledV3Relay event definition.\n    struct LegacyV3RelayExecutionEventInfo {\n        address updatedRecipient;\n        bytes updatedMessage;\n        uint256 updatedOutputAmount;\n        FillType fillType;\n    }\n\n    event FilledV3Relay(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 repaymentChainId,\n        uint256 indexed originChainId,\n        uint32 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address exclusiveRelayer,\n        address indexed relayer,\n        address depositor,\n        address recipient,\n        bytes message,\n        LegacyV3RelayExecutionEventInfo relayExecutionInfo\n    );\n\n    event RequestedV3SlowFill(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed originChainId,\n        uint32 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address exclusiveRelayer,\n        address depositor,\n        address recipient,\n        bytes message\n    );\n}\n"
    },
    "contracts/interfaces/ZkStackBridgeHub.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title BridgeHubInterface\n * @notice This interface is shared between ZkStack adapters. It is the main interaction point for bridging to ZkStack chains.\n */\ninterface BridgeHubInterface {\n    struct L2TransactionRequestDirect {\n        uint256 chainId;\n        uint256 mintValue;\n        address l2Contract;\n        uint256 l2Value;\n        bytes l2Calldata;\n        uint256 l2GasLimit;\n        uint256 l2GasPerPubdataByteLimit;\n        bytes[] factoryDeps;\n        address refundRecipient;\n    }\n\n    /**\n     * @notice the mailbox is called directly after the sharedBridge received the deposit.\n     * This assumes that either ether is the base token or the msg.sender has approved mintValue allowance for the\n     * sharedBridge. This means this is not ideal for contract calls, as the contract would have to handle token\n     * allowance of the base Token.\n     * @param _request the direct request.\n     */\n    function requestL2TransactionDirect(L2TransactionRequestDirect calldata _request)\n        external\n        payable\n        returns (bytes32 canonicalTxHash);\n\n    struct L2TransactionRequestTwoBridgesOuter {\n        uint256 chainId;\n        uint256 mintValue;\n        uint256 l2Value;\n        uint256 l2GasLimit;\n        uint256 l2GasPerPubdataByteLimit;\n        address refundRecipient;\n        address secondBridgeAddress;\n        uint256 secondBridgeValue;\n        bytes secondBridgeCalldata;\n    }\n\n    /**\n     * @notice After depositing funds to the sharedBridge, the secondBridge is called to return the actual L2 message\n     * which is sent to the Mailbox. This assumes that either ether is the base token or the msg.sender has approved\n     * the sharedBridge with the mintValue, and also the necessary approvals are given for the second bridge. The logic\n     * of this bridge is to allow easy depositing for bridges. Each contract that handles the users ERC20 tokens needs\n     * approvals from the user, this contract allows the user to approve for each token only its respective bridge.\n     * This function is great for contract calls to L2, the secondBridge can be any contract.\n     * @param _request the two bridges request.\n     */\n    function requestL2TransactionTwoBridges(L2TransactionRequestTwoBridgesOuter calldata _request)\n        external\n        payable\n        returns (bytes32 canonicalTxHash);\n\n    /**\n     * @notice Gets the shared bridge.\n     * @dev The shared bridge manages ERC20 tokens.\n     */\n    function sharedBridge() external view returns (address);\n\n    /**\n     * @notice Gets the base token for a chain.\n     * @dev Base token == native token.\n     */\n    function baseToken(uint256 _chainId) external view returns (address);\n\n    /**\n     * @notice Computes the base transaction cost for a transaction.\n     * @param _chainId the chain the transaction is being sent to.\n     * @param _gasPrice the l1 gas price at time of execution.\n     * @param _l2GasLimit the gas limit for the l2 transaction.\n     * @param _l2GasPerPubdataByteLimit configuration value that changes infrequently.\n     */\n    function l2TransactionBaseCost(\n        uint256 _chainId,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/Lens_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./ZkSync_SpokePool.sol\";\n\n/**\n * @notice Lens specific SpokePool. Wrapper around the ZkSync_SpokePool contract.\n * @dev Resources for compiling and deploying contracts with hardhat: https://era.zksync.io/docs/tools/hardhat/hardhat-zksync-solc.html\n * @custom:security-contact bugs@across.to\n */\ncontract Lens_SpokePool is ZkSync_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        IERC20 _circleUSDC,\n        ZkBridgeLike _zkUSDCBridge,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    )\n        ZkSync_SpokePool(\n            _wrappedNativeTokenAddress,\n            _circleUSDC,\n            _zkUSDCBridge,\n            _cctpTokenMessenger,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer\n        )\n    {}\n}\n"
    },
    "contracts/libraries/AddressConverters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary Bytes32ToAddress {\n    /**************************************\n     *              ERRORS                *\n     **************************************/\n    error InvalidBytes32();\n\n    function toAddress(bytes32 _bytes32) internal pure returns (address) {\n        checkAddress(_bytes32);\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    function toAddressUnchecked(bytes32 _bytes32) internal pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    function checkAddress(bytes32 _bytes32) internal pure {\n        if (uint256(_bytes32) >> 160 != 0) {\n            revert InvalidBytes32();\n        }\n    }\n}\n\nlibrary AddressToBytes32 {\n    function toBytes32(address _address) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n"
    },
    "contracts/libraries/CircleCCTPAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\nimport { AddressToBytes32 } from \"../libraries/AddressConverters.sol\";\n\nlibrary CircleDomainIds {\n    uint32 public constant Ethereum = 0;\n    uint32 public constant Optimism = 2;\n    uint32 public constant Arbitrum = 3;\n    uint32 public constant Solana = 5;\n    uint32 public constant Base = 6;\n    uint32 public constant Polygon = 7;\n    uint32 public constant DoctorWho = 10;\n    uint32 public constant Linea = 11;\n    uint32 public constant UNINITIALIZED = type(uint32).max;\n}\n\n/**\n * @notice Facilitate bridging USDC via Circle's CCTP.\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\n * @custom:security-contact bugs@across.to\n */\nabstract contract CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n    /**\n     * @notice The domain ID that CCTP will transfer funds to.\n     * @dev This identifier is assigned by Circle and is not related to a chain ID.\n     * @dev Official domain list can be found here: https://developers.circle.com/stablecoins/docs/supported-domains\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n\n    uint32 public immutable recipientCircleDomainId;\n\n    /**\n     * @notice The official USDC contract address on this chain.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/usdc-on-main-networks\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IERC20 public immutable usdcToken;\n\n    /**\n     * @notice The official Circle CCTP token bridge contract endpoint.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ITokenMessenger public immutable cctpTokenMessenger;\n\n    /**\n     * @notice Indicates if the CCTP V2 TokenMessenger is being used.\n     * @dev This is determined by checking if the feeRecipient() function exists and returns a non-zero address.\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    bool public immutable cctpV2;\n\n    /**\n     * @notice intiailizes the CircleCCTPAdapter contract.\n     * @param _usdcToken USDC address on the current chain.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP. If the zero address is passed, CCTP bridging will be disabled.\n     * @param _recipientCircleDomainId The domain ID that CCTP will transfer funds to.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        IERC20 _usdcToken,\n        /// @dev This should ideally be an address but it's kept as an ITokenMessenger to avoid rippling changes to the\n        /// constructors for every SpokePool/Adapter.\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId\n    ) {\n        usdcToken = _usdcToken;\n        cctpTokenMessenger = _cctpTokenMessenger;\n        recipientCircleDomainId = _recipientCircleDomainId;\n\n        // Only the CCTP V2 TokenMessenger has a feeRecipient() function, so we use it to\n        // figure out if we are using CCTP V2 or V1. `success` can be true even if the contract doesn't\n        // implement feeRecipient but it has a fallback function so to be extra safe, we check the return value\n        // of feeRecipient() as well.\n        (bool success, bytes memory feeRecipient) = address(cctpTokenMessenger).staticcall(\n            abi.encodeWithSignature(\"feeRecipient()\")\n        );\n        // In case of a call to nonexistent contract or a call to a contract with a fallback function which\n        // doesn't return any data, feeRecipient can be empty so check its length.\n        // Even with this check, it's possible that the contract has implemented a fallback function that returns\n        // 32 bytes of data but its not actually the feeRecipient address. This is extremely low risk but worth\n        // mentioning that the following check is not 100% safe.\n        cctpV2 = (success &&\n            feeRecipient.length == 32 &&\n            address(uint160(uint256(bytes32(feeRecipient)))) != address(0));\n    }\n\n    /**\n     * @notice Returns whether or not the CCTP bridge is enabled.\n     * @dev If the CCTPTokenMessenger is the zero address, CCTP bridging is disabled.\n     */\n    function _isCCTPEnabled() internal view returns (bool) {\n        return address(cctpTokenMessenger) != address(0);\n    }\n\n    /**\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\n     * @param to Address to receive USDC on the new domain.\n     * @param amount Amount of USDC to transfer.\n     */\n    function _transferUsdc(address to, uint256 amount) internal {\n        _transferUsdc(to.toBytes32(), amount);\n    }\n\n    /**\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\n     * @param to Address to receive USDC on the new domain represented as bytes32.\n     * @param amount Amount of USDC to transfer.\n     */\n    function _transferUsdc(bytes32 to, uint256 amount) internal {\n        // Only approve the exact amount to be transferred\n        usdcToken.safeIncreaseAllowance(address(cctpTokenMessenger), amount);\n        // Submit the amount to be transferred to bridge via the TokenMessenger.\n        // If the amount to send exceeds the burn limit per message, then split the message into smaller parts.\n        // @dev We do not care about casting cctpTokenMessenger to ITokenMessengerV2 since both V1 and V2\n        // expose a localMinter() view function that returns either an ITokenMinterV1 or ITokenMinterV2. Regardless,\n        // we only care about the burnLimitsPerMessage function which is available in both versions and performs\n        // the same logic, therefore we purposefully do not re-cast the cctpTokenMessenger and cctpMinter\n        // to the specific version.\n        ITokenMinter cctpMinter = cctpTokenMessenger.localMinter();\n        uint256 burnLimit = cctpMinter.burnLimitsPerMessage(address(usdcToken));\n        uint256 remainingAmount = amount;\n        while (remainingAmount > 0) {\n            uint256 partAmount = remainingAmount > burnLimit ? burnLimit : remainingAmount;\n            if (cctpV2) {\n                // Uses the CCTP V2 \"standard transfer\" speed and\n                // therefore pays no additional fee for the transfer to be sped up.\n                ITokenMessengerV2(address(cctpTokenMessenger)).depositForBurn(\n                    partAmount,\n                    recipientCircleDomainId,\n                    to,\n                    address(usdcToken),\n                    // The following parameters are new in this function from V2 to V1, can read more here:\n                    // https://developers.circle.com/stablecoins/evm-smart-contracts\n                    bytes32(0), // destinationCaller is set to bytes32(0) to indicate that anyone can call\n                    // receiveMessage on the destination to finalize the transfer\n                    0, // maxFee can be set to 0 for a \"standard transfer\"\n                    2000 // minFinalityThreshold can be set to 2000 for a \"standard transfer\",\n                    // https://github.com/circlefin/evm-cctp-contracts/blob/63ab1f0ac06ce0793c0bbfbb8d09816bc211386d/src/v2/FinalityThresholds.sol#L21\n                );\n            } else {\n                cctpTokenMessenger.depositForBurn(partAmount, recipientCircleDomainId, to, address(usdcToken));\n            }\n            remainingAmount -= partAmount;\n        }\n    }\n}\n"
    },
    "contracts/libraries/CrossDomainAddressUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title AddressUtils\n * @notice This library contains internal functions for manipulating addresses.\n */\nlibrary CrossDomainAddressUtils {\n    // L1 addresses are transformed during l1->l2 calls.\n    // This cannot be pulled directly from Arbitrum contracts because their contracts are not 0.8.X compatible and\n    // this operation takes advantage of overflows, whose behavior changed in 0.8.0.\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + uint160(0x1111000000000000000000000000000000001111));\n        }\n    }\n}\n"
    },
    "contracts/libraries/OFTTransportAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IOFT, SendParam, MessagingFee, OFTReceipt } from \"../interfaces/IOFT.sol\";\nimport { AddressToBytes32 } from \"../libraries/AddressConverters.sol\";\n\n/**\n * @notice Facilitate bridging tokens via LayerZero's OFT.\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\n * @custom:security-contact bugs@across.to\n */\ncontract OFTTransportAdapter {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n\n    /** @notice Empty bytes array used for OFT messaging parameters */\n    bytes public constant EMPTY_MSG_BYTES = new bytes(0);\n\n    /**\n     * @notice Fee cap checked before sending messages to OFTMessenger\n     * @dev Conservative (high) cap to not interfere with operations under normal conditions\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable OFT_FEE_CAP;\n\n    /**\n     * @notice The destination endpoint id in the OFT messaging protocol.\n     * @dev Source https://docs.layerzero.network/v2/developers/evm/technical-reference/deployed-contracts.\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable OFT_DST_EID;\n\n    /** @notice Thrown when OFT fee exceeds the configured cap */\n    error OftFeeCapExceeded();\n\n    /** @notice Thrown when contract has insufficient balance to pay OFT fees */\n    error OftInsufficientBalanceForFee();\n\n    /** @notice Thrown when LayerZero token fee is not zero (only native fees supported) */\n    error OftLzFeeNotZero();\n\n    /** @notice Thrown when amount received differs from expected amount */\n    error OftIncorrectAmountReceivedLD();\n\n    /** @notice Thrown when amount sent differs from expected amount */\n    error OftIncorrectAmountSentLD();\n\n    /**\n     * @notice intiailizes the OFTTransportAdapter contract.\n     * @param _oftDstEid the endpoint ID that OFT protocol will transfer funds to.\n     * @param _feeCap a fee cap we check against before sending a message with value to OFTMessenger as fees.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(uint32 _oftDstEid, uint256 _feeCap) {\n        OFT_DST_EID = _oftDstEid;\n        OFT_FEE_CAP = _feeCap;\n    }\n\n    /**\n     * @notice transfer token to the other dstEid (e.g. chain) via OFT messaging protocol\n     * @dev the caller has to provide both _token and _messenger. The caller is responsible for knowing the correct _messenger\n     * @param _token token we're sending on current chain.\n     * @param _messenger corresponding OFT messenger on current chain.\n     * @param _to address to receive a transfer on the destination chain.\n     * @param _amount amount to send.\n     */\n    function _transferViaOFT(IERC20 _token, IOFT _messenger, address _to, uint256 _amount) internal {\n        bytes32 to = _to.toBytes32();\n\n        SendParam memory sendParam = SendParam(\n            OFT_DST_EID,\n            to,\n            /**\n             * _amount, _amount here specify `amountLD` and `minAmountLD`. Setting `minAmountLD` equal to `amountLD` protects us\n             * from any changes to the sent amount due to internal OFT contract logic, e.g. `_removeDust`. Meaning that if any\n             * dust is subtracted, the `.send()` should revert\n             */\n            _amount,\n            _amount,\n            /**\n             * EMPTY_MSG_BYTES, EMPTY_MSG_BYTES, EMPTY_MSG_BYTES here specify `extraOptions`, `composeMsg` and `oftCmd`.\n             * These can be set to empty bytes arrays for the purposes of sending a simple cross-chain transfer.\n             */\n            EMPTY_MSG_BYTES,\n            EMPTY_MSG_BYTES,\n            EMPTY_MSG_BYTES\n        );\n\n        // `false` in the 2nd param here refers to `bool _payInLzToken`. We will pay in native token, so set to `false`\n        MessagingFee memory fee = _messenger.quoteSend(sendParam, false);\n        // Create a stack variable to optimize gas usage on subsequent reads\n        uint256 nativeFee = fee.nativeFee;\n        if (nativeFee > OFT_FEE_CAP) revert OftFeeCapExceeded();\n        if (nativeFee > address(this).balance) revert OftInsufficientBalanceForFee();\n        if (fee.lzTokenFee != 0) revert OftLzFeeNotZero();\n\n        // Approve the exact _amount for `_messenger` to spend. Fee will be paid in native token\n        _token.forceApprove(address(_messenger), _amount);\n\n        (, OFTReceipt memory oftReceipt) = _messenger.send{ value: nativeFee }(sendParam, fee, address(this));\n\n        // The HubPool expects that the amount received by the SpokePool is exactly the sent amount\n        if (_amount != oftReceipt.amountReceivedLD) revert OftIncorrectAmountReceivedLD();\n        // Also check the amount sent on origin chain to harden security\n        if (_amount != oftReceipt.amountSentLD) revert OftIncorrectAmountSentLD();\n    }\n}\n"
    },
    "contracts/libraries/OFTTransportAdapterWithStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { OFTTransportAdapter } from \"./OFTTransportAdapter.sol\";\nimport { AdapterStore, MessengerTypes } from \"../AdapterStore.sol\";\n\n/**\n * @dev A wrapper of `OFTTransportAdapter` to be used by chain-specific adapters\n * @custom:security-contact bugs@across.to\n */\ncontract OFTTransportAdapterWithStore is OFTTransportAdapter {\n    /** @notice Helper storage contract to keep track of token => IOFT relationships */\n    AdapterStore public immutable OFT_ADAPTER_STORE;\n\n    /**\n     * @notice Initializes the OFTTransportAdapterWithStore contract\n     * @param _oftDstEid The endpoint ID that OFT protocol will transfer funds to\n     * @param _feeCap Fee cap checked before sending messages to OFTMessenger\n     * @param _adapterStore Address of the AdapterStore contract\n     */\n    constructor(uint32 _oftDstEid, uint256 _feeCap, address _adapterStore) OFTTransportAdapter(_oftDstEid, _feeCap) {\n        OFT_ADAPTER_STORE = AdapterStore(_adapterStore);\n    }\n\n    /**\n     * @notice Retrieves the OFT messenger address for a given token\n     * @param _token Token address to look up messenger for\n     * @return Address of the OFT messenger for the token\n     */\n    function _getOftMessenger(address _token) internal view returns (address) {\n        return OFT_ADAPTER_STORE.crossChainMessengers(MessengerTypes.OFT_MESSENGER, OFT_DST_EID, _token);\n    }\n}\n"
    },
    "contracts/libraries/PeripherySigningLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { SpokePoolPeripheryInterface } from \"../interfaces/SpokePoolPeripheryInterface.sol\";\n\nlibrary PeripherySigningLib {\n    string internal constant EIP712_FEES_TYPE = \"Fees(uint256 amount,address recipient)\";\n    string internal constant EIP712_BASE_DEPOSIT_DATA_TYPE =\n        \"BaseDepositData(address inputToken,bytes32 outputToken,uint256 outputAmount,address depositor,bytes32 recipient,uint256 destinationChainId,bytes32 exclusiveRelayer,uint32 quoteTimestamp,uint32 fillDeadline,uint32 exclusivityParameter,bytes message)\";\n    string internal constant EIP712_DEPOSIT_DATA_TYPE =\n        \"DepositData(Fees submissionFees,BaseDepositData baseDepositData,uint256 inputAmount,address spokePool,uint256 nonce)\";\n    string internal constant EIP712_SWAP_AND_DEPOSIT_DATA_TYPE =\n        \"SwapAndDepositData(Fees submissionFees,BaseDepositData depositData,address swapToken,address exchange,uint8 transferType,uint256 swapTokenAmount,uint256 minExpectedInputTokenAmount,bytes routerCalldata,bool enableProportionalAdjustment,address spokePool,uint256 nonce)\";\n\n    // EIP712 Type hashes.\n    bytes32 internal constant EIP712_FEES_TYPEHASH = keccak256(abi.encodePacked(EIP712_FEES_TYPE));\n    bytes32 internal constant EIP712_BASE_DEPOSIT_DATA_TYPEHASH =\n        keccak256(abi.encodePacked(EIP712_BASE_DEPOSIT_DATA_TYPE));\n    bytes32 internal constant EIP712_DEPOSIT_DATA_TYPEHASH =\n        keccak256(abi.encodePacked(EIP712_DEPOSIT_DATA_TYPE, EIP712_BASE_DEPOSIT_DATA_TYPE, EIP712_FEES_TYPE));\n    bytes32 internal constant EIP712_SWAP_AND_DEPOSIT_DATA_TYPEHASH =\n        keccak256(abi.encodePacked(EIP712_SWAP_AND_DEPOSIT_DATA_TYPE, EIP712_BASE_DEPOSIT_DATA_TYPE, EIP712_FEES_TYPE));\n\n    // EIP712 Type strings.\n    string internal constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n    string internal constant EIP712_SWAP_AND_DEPOSIT_TYPE_STRING =\n        string(\n            abi.encodePacked(\n                \"SwapAndDepositData witness)\",\n                EIP712_BASE_DEPOSIT_DATA_TYPE,\n                EIP712_FEES_TYPE,\n                EIP712_SWAP_AND_DEPOSIT_DATA_TYPE,\n                TOKEN_PERMISSIONS_TYPE\n            )\n        );\n    string internal constant EIP712_DEPOSIT_TYPE_STRING =\n        string(\n            abi.encodePacked(\n                \"DepositData witness)\",\n                EIP712_BASE_DEPOSIT_DATA_TYPE,\n                EIP712_DEPOSIT_DATA_TYPE,\n                EIP712_FEES_TYPE,\n                TOKEN_PERMISSIONS_TYPE\n            )\n        );\n\n    error InvalidSignature();\n\n    /**\n     * @notice Creates the EIP712 compliant hashed data corresponding to the BaseDepositData struct.\n     * @param baseDepositData Input struct whose values are hashed.\n     * @dev BaseDepositData is only used as a nested struct for both DepositData and SwapAndDepositData.\n     */\n    function hashBaseDepositData(\n        SpokePoolPeripheryInterface.BaseDepositData calldata baseDepositData\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_BASE_DEPOSIT_DATA_TYPEHASH,\n                    baseDepositData.inputToken,\n                    baseDepositData.outputToken,\n                    baseDepositData.outputAmount,\n                    baseDepositData.depositor,\n                    baseDepositData.recipient,\n                    baseDepositData.destinationChainId,\n                    baseDepositData.exclusiveRelayer,\n                    baseDepositData.quoteTimestamp,\n                    baseDepositData.fillDeadline,\n                    baseDepositData.exclusivityParameter,\n                    keccak256(baseDepositData.message)\n                )\n            );\n    }\n\n    /**\n     * @notice Creates the EIP712 compliant hashed data corresponding to the Fees struct.\n     * @param fees Input struct whose values are hashed.\n     * @dev Fees is only used as a nested struct for both DepositData and SwapAndDepositData.\n     */\n    function hashFees(SpokePoolPeripheryInterface.Fees calldata fees) internal pure returns (bytes32) {\n        return keccak256(abi.encode(EIP712_FEES_TYPEHASH, fees.amount, fees.recipient));\n    }\n\n    /**\n     * @notice Creates the EIP712 compliant hashed data corresponding to the DepositData struct.\n     * @param depositData Input struct whose values are hashed.\n     */\n    function hashDepositData(\n        SpokePoolPeripheryInterface.DepositData calldata depositData\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_DEPOSIT_DATA_TYPEHASH,\n                    hashFees(depositData.submissionFees),\n                    hashBaseDepositData(depositData.baseDepositData),\n                    depositData.inputAmount,\n                    depositData.spokePool,\n                    depositData.nonce\n                )\n            );\n    }\n\n    /**\n     * @notice Creates the EIP712 compliant hashed data corresponding to the SwapAndDepositData struct.\n     * @param swapAndDepositData Input struct whose values are hashed.\n     */\n    function hashSwapAndDepositData(\n        SpokePoolPeripheryInterface.SwapAndDepositData calldata swapAndDepositData\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_SWAP_AND_DEPOSIT_DATA_TYPEHASH,\n                    hashFees(swapAndDepositData.submissionFees),\n                    hashBaseDepositData(swapAndDepositData.depositData),\n                    swapAndDepositData.swapToken,\n                    swapAndDepositData.exchange,\n                    swapAndDepositData.transferType,\n                    swapAndDepositData.swapTokenAmount,\n                    swapAndDepositData.minExpectedInputTokenAmount,\n                    keccak256(swapAndDepositData.routerCalldata),\n                    swapAndDepositData.enableProportionalAdjustment,\n                    swapAndDepositData.spokePool,\n                    swapAndDepositData.nonce\n                )\n            );\n    }\n\n    /**\n     * @notice Reads an input bytes, and, assuming it is a signature for a 32-byte hash, returns the v, r, and s values.\n     * @param _signature The input signature to deserialize.\n     */\n    function deserializeSignature(bytes calldata _signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        if (_signature.length != 65) revert InvalidSignature();\n        v = uint8(_signature[64]);\n        r = bytes32(_signature[0:32]);\n        s = bytes32(_signature[32:64]);\n    }\n}\n"
    },
    "contracts/Lockable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n * @dev The reason why we use this local contract instead of importing from uma/contracts is because of the addition\n * of the internal method `functionCallStackOriginatesFromOutsideThisContract` which doesn't exist in the one exported\n * by uma/contracts.\n * @custom:security-contact bugs@across.to\n */\ncontract Lockable {\n    bool internal _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a nonReentrant function from another nonReentrant function is not supported. It is possible to\n     * prevent this from happening by making the nonReentrant function external, and making it call a private\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a nonReentrant() state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is currently in a non-entered state, meaning that the origination of the call\n     * came from outside the contract. This is relevant with fallback/receive methods to see if the call came from ETH\n     * being dropped onto the contract externally or due to ETH dropped on the contract from within a method in this\n     * contract, such as unwrapping WETH to ETH within the contract.\n     */\n    function functionCallStackOriginatesFromOutsideThisContract() internal view returns (bool) {\n        return _notEntered;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every nonReentrant() method.\n    // On entry into a function, _preEntranceCheck() should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call _postEntranceSet(), perform its logic, and\n    // then call _postEntranceReset().\n    // View-only methods can simply call _preEntranceCheck() to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "contracts/LpTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LpTokenFactoryInterface.sol\";\n\nimport \"@uma/core/contracts/common/implementation/ExpandedERC20.sol\";\n\n/**\n * @notice Factory to create new LP ERC20 tokens that represent a liquidity provider's position. HubPool is the\n * intended client of this contract.\n * @custom:security-contact bugs@across.to\n */\ncontract LpTokenFactory is LpTokenFactoryInterface {\n    /**\n     * @notice Deploys new LP token for L1 token. Sets caller as minter and burner of token.\n     * @param l1Token L1 token to name in LP token name.\n     * @return address of new LP token.\n     */\n    function createLpToken(address l1Token) public returns (address) {\n        ExpandedERC20 lpToken = new ExpandedERC20(\n            _concatenate(\"Across V2 \", IERC20Metadata(l1Token).name(), \" LP Token\"), // LP Token Name\n            _concatenate(\"Av2-\", IERC20Metadata(l1Token).symbol(), \"-LP\"), // LP Token Symbol\n            IERC20Metadata(l1Token).decimals() // LP Token Decimals\n        );\n\n        lpToken.addMinter(msg.sender); // Set the caller as the LP Token's minter.\n        lpToken.addBurner(msg.sender); // Set the caller as the LP Token's burner.\n        lpToken.resetOwner(msg.sender); // Set the caller as the LP Token's owner.\n\n        return address(lpToken);\n    }\n\n    function _concatenate(\n        string memory a,\n        string memory b,\n        string memory c\n    ) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b, c));\n    }\n}\n"
    },
    "contracts/merkle-distributor/AcrossMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@uma/core/contracts/merkle-distributor/implementation/MerkleDistributor.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title  Extended MerkleDistributor contract.\n * @notice Adds additional constraints governing who can claim leaves from merkle windows.\n * @custom:security-contact bugs@across.to\n */\ncontract AcrossMerkleDistributor is MerkleDistributor {\n    using SafeERC20 for IERC20;\n\n    // Addresses that can claim on user's behalf.\n    mapping(address => bool) public whitelistedClaimers;\n\n    /****************************************\n     *                EVENTS\n     ****************************************/\n    event WhitelistedClaimer(address indexed claimer, bool indexed whitelist);\n    event ClaimFor(\n        address indexed caller,\n        uint256 windowIndex,\n        address indexed account,\n        uint256 accountIndex,\n        uint256 amount,\n        address indexed rewardToken\n    );\n\n    /****************************\n     *      ADMIN FUNCTIONS\n     ****************************/\n\n    /**\n     * @notice Updates whitelisted claimer status.\n     * @dev Callable only by owner.\n     * @param newContract Reset claimer contract to this address.\n     * @param whitelist True to whitelist claimer, False otherwise.\n     */\n    function whitelistClaimer(address newContract, bool whitelist) external onlyOwner {\n        whitelistedClaimers[newContract] = whitelist;\n        emit WhitelistedClaimer(newContract, whitelist);\n    }\n\n    /****************************\n     *    NON-ADMIN FUNCTIONS\n     ****************************/\n\n    /**\n     * @notice Batch claims to reduce gas versus individual submitting all claims. Method will fail\n     *         if any individual claims within the batch would fail.\n     * @dev    All claim recipients must be equal to msg.sender.\n     * @param claims array of claims to claim.\n     */\n    function claimMulti(Claim[] memory claims) public override {\n        uint256 claimCount = claims.length;\n        for (uint256 i = 0; i < claimCount; i++) {\n            require(claims[i].account == msg.sender, \"invalid claimer\");\n        }\n        super.claimMulti(claims);\n    }\n\n    /**\n     * @notice Claim amount of reward tokens for account, as described by Claim input object.\n     * @dev    Claim recipient must be equal to msg.sender.\n     * @param _claim claim object describing amount, accountIndex, account, window index, and merkle proof.\n     */\n    function claim(Claim memory _claim) public override {\n        require(_claim.account == msg.sender, \"invalid claimer\");\n        super.claim(_claim);\n    }\n\n    /**\n     * @notice Executes merkle leaf claim on behaf of user. This can only be called by a trusted\n     *         claimer address. This function is designed to be called atomically with other transactions\n     *         that ultimately return the claimed amount to the rightful recipient. For example,\n     *         AcceleratingDistributor could call this function and then stake atomically on behalf of the user.\n     * @dev    Caller must be in whitelistedClaimers struct set to \"true\".\n     * @param _claim leaf to claim.\n     */\n\n    function claimFor(Claim memory _claim) public {\n        require(whitelistedClaimers[msg.sender], \"unwhitelisted claimer\");\n        _verifyAndMarkClaimed(_claim);\n        merkleWindows[_claim.windowIndex].rewardToken.safeTransfer(msg.sender, _claim.amount);\n        emit ClaimFor(\n            msg.sender,\n            _claim.windowIndex,\n            _claim.account,\n            _claim.accountIndex,\n            _claim.amount,\n            address(merkleWindows[_claim.windowIndex].rewardToken)\n        );\n    }\n}\n"
    },
    "contracts/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"./interfaces/HubPoolInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @notice Library to help with merkle roots, proofs, and claims.\n * @custom:security-contact bugs@across.to\n */\nlibrary MerkleLib {\n    /**\n     * @notice Verifies that a repayment is contained within a merkle root.\n     * @param root the merkle root.\n     * @param rebalance the rebalance struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the pool rebalance proof correctly shows inclusion of the rebalance within the tree.\n     */\n    function verifyPoolRebalance(\n        bytes32 root,\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));\n    }\n\n    /**\n     * @notice Verifies that a relayer refund is contained within a merkle root.\n     * @param root the merkle root.\n     * @param refund the refund struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the relayer refund proof correctly shows inclusion of the refund within the tree.\n     */\n    function verifyRelayerRefund(\n        bytes32 root,\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(refund)));\n    }\n\n    function verifyV3SlowRelayFulfillment(\n        bytes32 root,\n        V3SpokePoolInterface.V3SlowFill memory slowRelayFulfillment,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\n    }\n\n    // The following functions are primarily copied from\n    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.\n\n    /**\n     * @notice Tests whether a claim is contained within a claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to check in the bitmap.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to mark in the bitmap.\n     */\n    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    /**\n     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.\n     * @param index the index to check in the bitmap. Uint8 type enforces that index can't be > 255.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (bool) {\n        uint256 mask = (1 << index);\n        return claimedBitMap & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap. Uint8 type enforces that index\n     * can't be > 255.\n     * @param index the index to mark in the bitmap.\n     * @return uint256 representing the modified input claimedBitMap with the index set to true.\n     */\n    function setClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (uint256) {\n        return claimedBitMap | (1 << index);\n    }\n}\n"
    },
    "contracts/Ovm_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol\";\nimport \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\n\n// https://github.com/ethereum-optimism/optimism/blob/bf51c4935261634120f31827c3910aa631f6bf9c/packages/contracts-bedrock/contracts/L2/L2StandardBridge.sol\ninterface IL2ERC20Bridge {\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable;\n\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external;\n}\n\n/**\n * @notice OVM specific SpokePool. Uses OVM cross-domain-enabled logic to implement admin only access to functions. * Optimism, Base, and Boba each implement this spoke pool and set their chain specific contract addresses for l2Eth and l2Weth.\n * @custom:security-contact bugs@across.to\n */\ncontract Ovm_SpokePool is SpokePool, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // \"l1Gas\" parameter used in call to bridge tokens from this contract back to L1 via IL2ERC20Bridge. Currently\n    // unused by bridge but included for future compatibility.\n    uint32 public l1Gas;\n\n    // ETH is an ERC20 on OVM.\n    address public l2Eth;\n\n    // Address of the Optimism L2 messenger.\n    address public constant MESSENGER = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n    // @dev This storage slot is reserved to replace the old messenger public variable that has now been\n    // replaced by the above constant.\n    address private __deprecated_messenger;\n\n    // Stores alternative token bridges to use for L2 tokens that don't go over the standard bridge. This is needed\n    // to support non-standard ERC20 tokens on Optimism, such as DAI which uses a custom bridge with the same\n    // interface as the standard bridge.\n    mapping(address => address) public tokenBridges;\n\n    // Stores mapping of L2 tokens to L1 equivalent tokens. If a mapping is defined for a given L2 token, then\n    // the mapped L1 token can be used in _bridgeTokensToHubPool which can then call bridgeERC20To, which\n    // requires specfiying an L1 token.\n    mapping(address => address) public remoteL1Tokens;\n\n    event SetL1Gas(uint32 indexed newL1Gas);\n    event SetL2TokenBridge(address indexed l2Token, address indexed tokenBridge);\n    event SetRemoteL1Token(address indexed l2Token, address indexed l1Token);\n\n    error NotCrossDomainAdmin();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            // Ovm_SpokePool does not use OFT messaging; setting destination eid and fee cap to 0\n            0,\n            0\n        )\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the OVM SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     * @param _l2Eth Address of L2 ETH token. Usually should be Lib_PreeployAddresses.OVM_ETH but sometimes this can\n     * be different, like with Boba which flips the WETH and OVM_ETH addresses.\n     */\n    function __OvmSpokePool_init(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient,\n        address _l2Eth\n    ) public onlyInitializing {\n        l1Gas = 5_000_000;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        //slither-disable-next-line missing-zero-check\n        l2Eth = _l2Eth;\n    }\n\n    /*******************************************\n     *    OPTIMISM-SPECIFIC ADMIN FUNCTIONS    *\n     *******************************************/\n\n    /**\n     * @notice Change L1 gas limit. Callable only by admin.\n     * @param newl1Gas New L1 gas limit to set.\n     */\n    function setL1GasLimit(uint32 newl1Gas) public onlyAdmin nonReentrant {\n        l1Gas = newl1Gas;\n        emit SetL1Gas(newl1Gas);\n    }\n\n    function setRemoteL1Token(address l2Token, address l1Token) public onlyAdmin nonReentrant {\n        remoteL1Tokens[l2Token] = l1Token;\n        emit SetRemoteL1Token(l2Token, l1Token);\n    }\n\n    /**\n     * @notice Set bridge contract for L2 token used to withdraw back to L1.\n     * @dev If this mapping isn't set for an L2 token, then the standard bridge will be used to bridge this token.\n     * @param tokenBridge Address of token bridge\n     */\n    function setTokenBridge(address l2Token, address tokenBridge) public onlyAdmin nonReentrant {\n        tokenBridges[l2Token] = tokenBridge;\n        emit SetL2TokenBridge(l2Token, tokenBridge);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Wraps any ETH into WETH before executing leaves. This is necessary because SpokePool receives\n     * ETH over the canonical token bridge instead of WETH.\n     */\n    function _preExecuteLeafHook(address l2TokenAddress) internal override {\n        if (l2TokenAddress == address(wrappedNativeToken)) _depositEthToWeth();\n    }\n\n    // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is necessary because\n    // this SpokePool will receive ETH from the canonical token bridge instead of WETH. Its not sufficient to execute\n    // this logic inside a fallback method that executes when this contract receives ETH because ETH is an ERC20\n    // on the OVM.\n    function _depositEthToWeth() internal {\n        //slither-disable-next-line arbitrary-send-eth\n        if (address(this).balance > 0) wrappedNativeToken.deposit{ value: address(this).balance }();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual override {\n        // If the token being bridged is WETH then we need to first unwrap it to ETH and then send ETH over the\n        // canonical bridge. On Optimism, this is address 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n        if (l2TokenAddress == address(wrappedNativeToken)) {\n            WETH9Interface(l2TokenAddress).withdraw(amountToReturn); // Unwrap into ETH.\n            l2TokenAddress = l2Eth; // Set the l2TokenAddress to ETH.\n            IL2ERC20Bridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo{ value: amountToReturn }(\n                l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                amountToReturn, // _amount.\n                l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n        // If the token is USDC && CCTP bridge is enabled, then bridge USDC via CCTP.\n        else if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        }\n        // Note we'll default to withdrawTo instead of bridgeERC20To unless the remoteL1Tokens mapping is set for\n        // the l2TokenAddress. withdrawTo should be used to bridge back non-native L2 tokens\n        // (i.e. non-native L2 tokens have a canonical L1 token). If we should bridge \"native L2\" tokens then\n        // we'd need to call bridgeERC20To and give allowance to the tokenBridge to spend l2Token from this contract.\n        // Therefore for native tokens we should set ensure that remoteL1Tokens is set for the l2TokenAddress.\n        else {\n            IL2ERC20Bridge tokenBridge = IL2ERC20Bridge(\n                tokenBridges[l2TokenAddress] == address(0)\n                    ? Lib_PredeployAddresses.L2_STANDARD_BRIDGE\n                    : tokenBridges[l2TokenAddress]\n            );\n            if (remoteL1Tokens[l2TokenAddress] != address(0)) {\n                // If there is a mapping for this L2 token to an L1 token, then use the L1 token address and\n                // call bridgeERC20To.\n                IERC20(l2TokenAddress).safeIncreaseAllowance(address(tokenBridge), amountToReturn);\n                address remoteL1Token = remoteL1Tokens[l2TokenAddress];\n                tokenBridge.bridgeERC20To(\n                    l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                    remoteL1Token, // Remote token to be received on L1 side. If the\n                    // remoteL1Token on the other chain does not recognize the local token as the correct\n                    // pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n                    // this chain.\n                    withdrawalRecipient, // _to\n                    amountToReturn, // _amount\n                    l1Gas, // _l1Gas\n                    \"\" // _data\n                );\n            } else {\n                tokenBridge.withdrawTo(\n                    l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                    withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                    amountToReturn, // _amount.\n                    l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                    \"\" // _data. We don't need to send any data for the bridging action.\n                );\n            }\n        }\n    }\n\n    // Apply OVM-specific transformation to cross domain admin address on L1.\n    function _requireAdminSender() internal view override {\n        if (LibOptimismUpgradeable.crossChainSender(MESSENGER) != crossDomainAdmin) revert NotCrossDomainAdmin();\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added, so that the total number of slots taken by this contract remains constant. Per-contract\n    // storage layout information  can be found in storage-layouts/\n    // This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[999] private __gap;\n}\n"
    },
    "contracts/PermissionSplitterProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @notice This contract is designed to own an Ownable \"target\" contract and gate access to specific\n * function selectors based on specific roles. Practically, this contract should own the HubPool contract.\n * All ownable function calls to target should be sent through this contract's fallback function.\n * @custom:security-contact bugs@across.to\n */\ncontract PermissionSplitterProxy is AccessControl, MultiCaller {\n    // Inherited admin role from AccessControl. Should be assigned to Across DAO Safe.\n    // bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    // Maps function signatures to role identifiers, which gatekeeps access to these functions to\n    // only role holders.\n    mapping(bytes4 => bytes32) public roleForSelector;\n\n    // The contract that should be owned by this contract and whose function selectors will be gated\n    // by roleForSelector.\n    address public target;\n\n    event TargetUpdated(address indexed newTarget);\n    event RoleForSelectorSet(bytes4 indexed selector, bytes32 indexed role);\n\n    /**\n     * @notice constructs PermissionSplitterProxy\n     */\n    constructor(address _target) {\n        _init(_target);\n    }\n\n    /**\n     * @notice Change target contract.\n     * @dev Public function! This has two underscores in front to prevent any collisions with the target contract.\n     * @dev Only callable by default admin role holder.\n     * @param _target New target contract.\n     */\n    function __setTarget(address _target) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    /**\n     * @notice Change role ID for function selector. Only role holder can call function selector\n     * on target.\n     * @dev Public function! This has two underscores in front to prevent any collisions with the target contract.\n     * @dev Only callable by default admin role holder.\n     * @param selector Function selector to map to role.\n     * @param role Only this role holder can call function selector on the target\n     */\n    function __setRoleForSelector(bytes4 selector, bytes32 role) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        roleForSelector[selector] = role;\n        emit RoleForSelectorSet(selector, role);\n    }\n\n    function _init(address _target) internal virtual {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        __setTarget(_target);\n    }\n\n    function _isAllowedToCall(address caller, bytes calldata callData) internal view virtual returns (bool) {\n        bytes4 selector;\n        if (callData.length < 4) {\n            // This handles any empty callData, which is a call to the fallback function.\n            selector = bytes4(0);\n        } else {\n            selector = bytes4(callData[:4]);\n        }\n        return hasRole(DEFAULT_ADMIN_ROLE, caller) || hasRole(roleForSelector[selector], caller);\n    }\n\n    /**\n     * @dev Forwards the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     * Note: this function is a modified _delegate function here:\n     // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/002a7c8812e73c282b91e14541ce9b93a6de1172/contracts/proxy/Proxy.sol#L22-L45\n     */\n    function _forward(address _target) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := call(gas(), _target, callvalue(), 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // call returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Executes an action on the target.\n    function _executeAction() internal virtual {\n        require(_isAllowedToCall(msg.sender, msg.data), \"Not allowed to call\");\n        _forward(target);\n    }\n\n    /**\n     * @dev Fallback function that forwards calls to the target. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _executeAction();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the target. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _executeAction();\n    }\n}\n"
    },
    "contracts/permit2-order/Permit2Depositor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Permit2OrderLib.sol\";\nimport \"../external/interfaces/IPermit2.sol\";\nimport \"../interfaces/V3SpokePoolInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AddressToBytes32 } from \"../libraries/AddressConverters.sol\";\n\n/**\n * @notice Permit2Depositor processes an external order type and translates it into an AcrossV3 deposit.\n */\ncontract Permit2Depositor {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n\n    // SpokePool that this contract can deposit to.\n    V3SpokePoolInterface public immutable SPOKE_POOL;\n\n    // Permit2 contract\n    IPermit2 public immutable PERMIT2;\n\n    // quoteBeforeDeadline is subtracted from the deadline to get the quote timestamp.\n    // This is a somewhat arbitrary conversion, but order creators need some way to precompute the quote timestamp.\n    uint256 public immutable QUOTE_BEFORE_DEADLINE;\n\n    /**\n     * @notice Construct the Permit2Depositor.\n     * @param _spokePool SpokePool that this contract can deposit to.\n     * @param _permit2 Permit2 contract\n     * @param _quoteBeforeDeadline quoteBeforeDeadline is subtracted from the deadline to get the quote timestamp.\n     */\n    constructor(\n        V3SpokePoolInterface _spokePool,\n        IPermit2 _permit2,\n        uint256 _quoteBeforeDeadline\n    ) {\n        SPOKE_POOL = _spokePool;\n        PERMIT2 = _permit2;\n        QUOTE_BEFORE_DEADLINE = _quoteBeforeDeadline;\n    }\n\n    /**\n     * @notice Uses a permit2 order to deposit to a SpokePool.\n     * @param signedOrder Signed external order type that is processed to produce the deposit. See Permit2OrderLib for details\n     * @param destinationChainFillerAddress Address of the filler on the destination chain. Specified by caller\n     * to avoid issue if destination and current network have different address derivation schemes.\n     */\n    function permit2Deposit(SignedOrder calldata signedOrder, address destinationChainFillerAddress) external {\n        CrossChainLimitOrder memory order = Permit2OrderLib._processPermit2Order(PERMIT2, signedOrder);\n        uint32 fillDeadline = SafeCast.toUint32(block.timestamp + order.info.fillPeriod);\n\n        // User input amount and filler collateral are added together to get the deposit amount.\n        // If the user gets filled correctly, the filler gets their collateral back.\n        // If the user is not filled or filled by someone else, the filler loses their collateral.\n        uint256 amountToDeposit = order.input.amount + order.fillerCollateral.amount;\n\n        IERC20(order.input.token).safeIncreaseAllowance(address(SPOKE_POOL), amountToDeposit);\n        SPOKE_POOL.deposit(\n            order.info.offerer.toBytes32(),\n            // Note: Permit2OrderLib checks that order only has a single output.\n            order.outputs[0].recipient.toBytes32(),\n            order.input.token.toBytes32(),\n            order.outputs[0].token.toBytes32(),\n            amountToDeposit,\n            order.outputs[0].amount,\n            order.outputs[0].chainId,\n            destinationChainFillerAddress.toBytes32(),\n            SafeCast.toUint32(order.info.initiateDeadline - QUOTE_BEFORE_DEADLINE),\n            fillDeadline,\n            // The entire fill period is exclusive.\n            fillDeadline,\n            \"\"\n        );\n    }\n}\n"
    },
    "contracts/permit2-order/Permit2Order.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// General Settlement Info.\nstruct SettlementInfo {\n    // The contract intended for settlement.\n    address settlerContract;\n    // User who created the order.\n    address offerer;\n    // The nonce of the order for replay protection.\n    uint256 nonce;\n    // Latest timestamp at which the order can be brought onchain.\n    uint256 initiateDeadline;\n    // Max delay between the order being brought onchain and the fill.\n    uint32 fillPeriod;\n    // The rest of the fields are unused in Across.\n    uint32 challengePeriod;\n    uint32 proofPeriod;\n    address settlementOracle;\n    address validationContract;\n    bytes validationData;\n}\n\n// Input token info.\nstruct InputToken {\n    address token;\n    uint256 amount;\n    uint256 maxAmount;\n}\n\n// Callateral token info.\nstruct CollateralToken {\n    address token;\n    uint256 amount;\n}\n\n// Output information.\nstruct OutputToken {\n    address recipient;\n    address token;\n    uint256 amount;\n    uint256 chainId;\n}\n\n// Full order struct that the user signs.\nstruct CrossChainLimitOrder {\n    // General order info.\n    SettlementInfo info;\n    // User's input token.\n    InputToken input;\n    // Filler's provided collateral.\n    CollateralToken fillerCollateral;\n    // Unused in Across.\n    CollateralToken challengerCollateral;\n    // Outputs. Today, Across only supports a single output.\n    OutputToken[] outputs;\n}\n\n// Encoded order + Permit2 signature.\nstruct SignedOrder {\n    bytes order;\n    bytes sig;\n}\n"
    },
    "contracts/permit2-order/Permit2OrderLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./Permit2Order.sol\";\nimport \"../external/interfaces/IPermit2.sol\";\n\n/**\n * @notice Permit2OrderLib knows how to process a particular type of external Permit2Order so that it can be used in Across.\n * @dev This library is responsible for validating the order and communicating with Permit2 to pull the tokens in.\n * This is a library to allow it to be pulled directly into the SpokePool in a future version.\n */\nlibrary Permit2OrderLib {\n    // Errors\n    error WrongSettlerContract();\n    error AfterDeadline();\n    error ValidationContractNotAllowed();\n    error MultipleOutputsNotAllowed();\n    error InputAndCollateralNotEqual();\n\n    // Type strings and hashes\n    bytes private constant OUTPUT_TOKEN_TYPE =\n        \"OutputToken(address recipient,address token,uint256 amount,uint256 chainId)\";\n    bytes32 private constant OUTPUT_TOKEN_TYPE_HASH = keccak256(OUTPUT_TOKEN_TYPE);\n\n    bytes internal constant ORDER_TYPE =\n        abi.encodePacked(\n            \"CrossChainLimitOrder(\",\n            \"address settlerContract,\",\n            \"address offerer,\",\n            \"uint256 nonce,\",\n            \"uint256 initiateDeadline,\",\n            \"uint32 fillPeriod\",\n            \"uint32 challengePeriod\",\n            \"uint32 proofPeriod\",\n            \"address settlementOracle\",\n            \"address validationContract,\",\n            \"bytes validationData,\",\n            \"address inputToken,\",\n            \"uint256 inputAmount,\",\n            \"address collateralToken,\",\n            \"uint256 collateralAmount,\",\n            \"address challengerCollateralToken,\",\n            \"uint256 challengerCollateralAmount,\",\n            \"OutputToken[] outputs)\",\n            OUTPUT_TOKEN_TYPE\n        );\n    bytes32 internal constant ORDER_TYPE_HASH = keccak256(ORDER_TYPE);\n    string private constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n    string internal constant PERMIT2_ORDER_TYPE =\n        string(abi.encodePacked(\"CrossChainLimitOrder witness)\", ORDER_TYPE, TOKEN_PERMISSIONS_TYPE));\n\n    // Hashes a single output.\n    function _hashOutput(OutputToken memory output) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(OUTPUT_TOKEN_TYPE_HASH, output.recipient, output.token, output.amount, output.chainId)\n            );\n    }\n\n    // Hashes the output array. Since we only allow a single output, it just grabs the first element.\n    function _hashOutputs(OutputToken[] memory outputs) internal pure returns (bytes32) {\n        // Across only allows a single output, so only hash\n        return keccak256(abi.encodePacked(_hashOutput(outputs[0])));\n    }\n\n    // Hashes an order to get an order hash. Needed for permit2.\n    function _hashOrder(CrossChainLimitOrder memory order) internal pure returns (bytes32) {\n        bytes memory part1 = abi.encode(\n            ORDER_TYPE_HASH,\n            order.info.settlerContract,\n            order.info.offerer,\n            order.info.nonce,\n            order.info.initiateDeadline,\n            order.info.fillPeriod,\n            order.info.challengePeriod,\n            order.info.proofPeriod,\n            order.info.settlementOracle,\n            order.info.validationContract,\n            keccak256(order.info.validationData),\n            order.input.token,\n            order.input.amount\n        );\n\n        // avoid stack too deep\n        bytes memory part2 = abi.encode(\n            order.fillerCollateral.token,\n            order.fillerCollateral.amount,\n            order.challengerCollateral.token,\n            order.challengerCollateral.amount,\n            _hashOutputs(order.outputs)\n        );\n\n        return keccak256(abi.encodePacked(part1, part2));\n    }\n\n    function _processPermit2Order(IPermit2 permit2, SignedOrder calldata signedOrder)\n        internal\n        returns (CrossChainLimitOrder memory)\n    {\n        CrossChainLimitOrder memory limitOrder = abi.decode(signedOrder.order, (CrossChainLimitOrder));\n\n        if (address(this) != limitOrder.info.settlerContract) revert WrongSettlerContract();\n        if (block.timestamp > limitOrder.info.initiateDeadline) revert AfterDeadline();\n        if (limitOrder.info.validationContract != address(0)) revert ValidationContractNotAllowed();\n        if (limitOrder.outputs.length != 1) revert MultipleOutputsNotAllowed();\n        if (limitOrder.fillerCollateral.token != limitOrder.input.token) revert InputAndCollateralNotEqual();\n\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\n            permitted: IPermit2.TokenPermissions({ token: limitOrder.input.token, amount: limitOrder.input.maxAmount }),\n            nonce: limitOrder.info.nonce,\n            deadline: limitOrder.info.initiateDeadline\n        });\n\n        IPermit2.SignatureTransferDetails memory signatureTransferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: limitOrder.input.amount\n        });\n\n        // Pull user funds.\n        permit2.permitWitnessTransferFrom(\n            permit,\n            signatureTransferDetails,\n            limitOrder.info.offerer,\n            _hashOrder(limitOrder),\n            PERMIT2_ORDER_TYPE,\n            signedOrder.sig\n        );\n\n        // Pull filler collateral.\n        permit2.transferFrom(\n            msg.sender,\n            address(this),\n            uint160(limitOrder.fillerCollateral.amount),\n            limitOrder.fillerCollateral.token\n        );\n\n        return limitOrder;\n    }\n}\n"
    },
    "contracts/Polygon_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./PolygonTokenBridger.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\n\n/**\n * @notice IFxMessageProcessor represents interface to process messages.\n */\ninterface IFxMessageProcessor {\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @notice Polygon specific SpokePool.\n * @custom:security-contact bugs@across.to\n */\ncontract Polygon_SpokePool is IFxMessageProcessor, SpokePool, CircleCCTPAdapter {\n    using SafeERC20Upgradeable for PolygonIERC20Upgradeable;\n\n    // Address of FxChild which sends and receives messages to and from L1.\n    address public fxChild;\n\n    // Contract deployed on L1 and L2 processes all cross-chain transfers between this contract and the HubPool.\n    // Required because bridging tokens from Polygon to Ethereum has special constraints.\n    PolygonTokenBridger public polygonTokenBridger;\n\n    // Internal variable that only flips temporarily to true upon receiving messages from L1. Used to authenticate that\n    // the caller is the fxChild AND that the fxChild called processMessageFromRoot\n    bool private callValidated;\n\n    error MulticallExecuteLeaf();\n\n    event SetFxChild(address indexed newFxChild);\n    event SetPolygonTokenBridger(address indexed polygonTokenBridger);\n    event ReceivedMessageFromL1(address indexed caller, address indexed rootMessageSender);\n\n    error CallValidatedAlreadySet();\n    error CallValidatedNotSet();\n    error DelegateCallFailed();\n    error NotHubPool();\n    error NotFxChild();\n\n    // Note: validating calls this way ensures that strange calls coming from the fxChild won't be misinterpreted.\n    // Put differently, just checking that msg.sender == fxChild is not sufficient.\n    // All calls that have admin privileges must be fired from within the processMessageFromRoot method that's gone\n    // through validation where the sender is checked and the root (mainnet) sender is also validated.\n    // This modifier sets the callValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure callValidated is set to True only once at beginning of processMessageFromRoot, which prevents\n        // processMessageFromRoot from being re-entered.\n        if (callValidated) revert CallValidatedAlreadySet();\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed. See comment for `_requireAdminSender` for more details.\n        callValidated = true;\n\n        _;\n\n        // Reset callValidated to false to disallow admin calls after this method exits.\n        callValidated = false;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            // Polygon_SpokePool does not use OFT messaging; setting destination eid and fee cap to 0\n            0,\n            0\n        )\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Polygon SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _polygonTokenBridger Token routing contract that sends tokens from here to HubPool. Changeable by Admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     * @param _fxChild FxChild contract, changeable by Admin.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        PolygonTokenBridger _polygonTokenBridger,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient,\n        address _fxChild\n    ) public initializer {\n        callValidated = false;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setPolygonTokenBridger(payable(_polygonTokenBridger));\n        //slither-disable-next-line missing-zero-check\n        _setFxChild(_fxChild);\n    }\n\n    /********************************************************\n     *    POLYGON-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change FxChild address. Callable only by admin via processMessageFromRoot.\n     * @param newFxChild New FxChild.\n     */\n    function setFxChild(address newFxChild) public onlyAdmin nonReentrant {\n        _setFxChild(newFxChild);\n    }\n\n    /**\n     * @notice Change polygonTokenBridger address. Callable only by admin via processMessageFromRoot.\n     * @param newPolygonTokenBridger New Polygon Token Bridger contract.\n     */\n    function setPolygonTokenBridger(address payable newPolygonTokenBridger) public onlyAdmin nonReentrant {\n        _setPolygonTokenBridger(newPolygonTokenBridger);\n    }\n\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(\n        uint256, /*stateId*/\n        address rootMessageSender,\n        bytes calldata data\n    ) public validateInternalCalls {\n        // Validation logic.\n        if (msg.sender != fxChild) revert NotFxChild();\n        if (rootMessageSender != crossDomainAdmin) revert NotHubPool();\n\n        // This uses delegatecall to take the information in the message and process it as a function call on this contract.\n        /// This is a safe delegatecall because its made to address(this) so there is no risk of delegating to a\n        /// selfdestruct().\n        //slither-disable-start low-level-calls\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(data);\n        //slither-disable-end low-level-calls\n        if (!success) revert DelegateCallFailed();\n\n        emit ReceivedMessageFromL1(msg.sender, rootMessageSender);\n    }\n\n    /**\n     * @notice Allows the caller to trigger the wrapping of any unwrapped matic tokens.\n     * @dev Unlike other ERC20 transfers, Matic transfers from L1 -> L2 bridging don't result in an L2 call into\n     * the contract receiving the tokens, so wrapping must be done via a separate transaction. In other words,\n     * we can't rely upon a `fallback()` method being triggered to wrap MATIC upon receiving it.\n     */\n    function wrap() public nonReentrant {\n        _wrap();\n    }\n\n    /**\n     * @notice Override multicall so that it cannot include executeRelayerRefundLeaf\n     * as one of the calls combined with other public function calls and blocks nested multicalls in general, which\n     * don't have any practical use case. We also block nested multicalls which could be used to bypass\n     * this check and there are no practical use cases for nested multicalls.\n     * @dev Multicalling a single transaction will always succeed.\n     * @dev Multicalling execute functions without combining other public function calls will succeed.\n     * @dev Nested multicalls will always fail.\n     * @dev Multicalling public function calls without combining execute functions will succeed.\n     */\n    function _validateMulticallData(bytes[] calldata data) internal pure override {\n        bool hasOtherPublicFunctionCall = false;\n        bool hasExecutedLeafCall = false;\n        for (uint256 i = 0; i < data.length; i++) {\n            bytes4 selector = bytes4(data[i][:4]);\n            if (selector == MultiCallerUpgradeable.multicall.selector) {\n                revert MulticallExecuteLeaf();\n            } else if (selector == SpokePoolInterface.executeRelayerRefundLeaf.selector) {\n                if (hasOtherPublicFunctionCall) revert MulticallExecuteLeaf();\n                hasExecutedLeafCall = true;\n            } else {\n                if (hasExecutedLeafCall) revert MulticallExecuteLeaf();\n                hasOtherPublicFunctionCall = true;\n            }\n        }\n    }\n\n    /**\n     * @notice This function can send an L2 to L1 message so we are extra cautious about preventing a griefing vector\n     * whereby someone batches this call with a bunch of other calls and produces a very large L2 burn transaction.\n     * This might make the L2 -> L1 message fail due to exceeding the L1 calldata limit.\n     */\n\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable override {\n        // AddressLibUpgradeable.isContract isn't a sufficient check because it checks the contract code size of\n        // msg.sender which is 0 if called from a constructor function on msg.sender. This is why we check if\n        // msg.sender is equal to tx.origin which is fine as long as Polygon supports the tx.origin opcode. We also\n        // check if the msg.sender has delegated their code to a contract via EIP7702.\n        // solhint-disable-next-line avoid-tx-origin\n        if (relayerRefundLeaf.amountToReturn > 0 && (msg.sender != tx.origin || msg.sender.code.length > 0))\n            revert NotEOA();\n        super.executeRelayerRefundLeaf(rootBundleId, relayerRefundLeaf, proof);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _setFxChild(address _fxChild) internal {\n        //slither-disable-next-line missing-zero-check\n        fxChild = _fxChild;\n        emit SetFxChild(_fxChild);\n    }\n\n    function _setPolygonTokenBridger(address payable _polygonTokenBridger) internal {\n        polygonTokenBridger = PolygonTokenBridger(_polygonTokenBridger);\n        emit SetPolygonTokenBridger(address(_polygonTokenBridger));\n    }\n\n    function _preExecuteLeafHook(address) internal override {\n        // Wraps MATIC --> WMATIC before distributing tokens from this contract.\n        _wrap();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // WARNING: Withdrawing MATIC can result in the L1 PolygonTokenBridger.startExitWithBurntTokens() failing\n        // due to a MAX_LOGS constraint imposed by the ERC20Predicate, so if this SpokePool will be used to withdraw\n        // MATIC then additional constraints need to be imposed to limit the # of logs produed by the L2 withdrawal\n        // transaction. Currently, MATIC is not a supported token in Across for this SpokePool.\n\n        // If the token is USDC, we need to use the CCTP bridge to transfer it to the hub pool.\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        } else {\n            PolygonIERC20Upgradeable(l2TokenAddress).safeIncreaseAllowance(\n                address(polygonTokenBridger),\n                amountToReturn\n            );\n            // Note: WrappedNativeToken is WMATIC on matic, so this tells the tokenbridger that this is an unwrappable native token.\n            polygonTokenBridger.send(PolygonIERC20Upgradeable(l2TokenAddress), amountToReturn);\n        }\n    }\n\n    function _wrap() internal {\n        uint256 balance = address(this).balance;\n        //slither-disable-next-line arbitrary-send-eth\n        if (balance > 0) wrappedNativeToken.deposit{ value: balance }();\n    }\n\n    // @dev: This contract will trigger admin functions internally via the `processMessageFromRoot`, which is why\n    // the `callValidated` check is made below  and why we use the `validateInternalCalls` modifier on\n    // `processMessageFromRoot`. This prevents calling the admin functions from any other method besides\n    // `processMessageFromRoot`.\n    function _requireAdminSender() internal view override {\n        if (!callValidated) revert CallValidatedNotSet();\n    }\n}\n"
    },
    "contracts/PolygonTokenBridger.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Lockable.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n// Polygon Registry contract that stores their addresses.\ninterface PolygonRegistry {\n    function erc20Predicate() external returns (address);\n}\n\n// Polygon ERC20Predicate contract that handles Plasma exits (only used for Matic).\ninterface PolygonERC20Predicate {\n    function startExitWithBurntTokens(bytes calldata data) external;\n}\n\n// ERC20s (on polygon) compatible with polygon's bridge have a withdraw method.\ninterface PolygonIERC20Upgradeable is IERC20Upgradeable {\n    function withdraw(uint256 amount) external;\n}\n\ninterface MaticToken {\n    function withdraw(uint256 amount) external payable;\n}\n\n/**\n * @notice Contract deployed on Ethereum and Polygon to facilitate token transfers from Polygon to the HubPool and back.\n * @dev Because Polygon only allows withdrawals from a particular address to go to that same address on mainnet, we need to\n * have some sort of contract that can guarantee identical addresses on Polygon and Ethereum. This contract is intended\n * to be completely immutable, so it's guaranteed that the contract on each side is  configured identically as long as\n * it is created via create2. create2 is an alternative creation method that uses a different address determination\n * mechanism from normal create.\n * Normal create: address = hash(deployer_address, deployer_nonce)\n * create2:       address = hash(0xFF, sender, salt, bytecode)\n *  This ultimately allows create2 to generate deterministic addresses that don't depend on the transaction count of the\n * sender.\n * @custom:security-contact bugs@across.to\n */\ncontract PolygonTokenBridger is Lockable {\n    using SafeERC20Upgradeable for PolygonIERC20Upgradeable;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Gas token for Polygon.\n    MaticToken public constant MATIC = MaticToken(0x0000000000000000000000000000000000001010);\n\n    // Should be set to HubPool on Ethereum, or unused on Polygon.\n    address public immutable destination;\n\n    // Registry that stores L1 polygon addresses.\n    PolygonRegistry public immutable l1PolygonRegistry;\n\n    // WETH contract on Ethereum.\n    WETH9Interface public immutable l1Weth;\n\n    // Wrapped Matic on Polygon\n    address public immutable l2WrappedMatic;\n\n    // Chain id for the L1 that this contract is deployed on or communicates with.\n    // For example: if this contract were meant to facilitate transfers from polygon to mainnet, this value would be\n    // the mainnet chainId 1.\n    uint256 public immutable l1ChainId;\n\n    // Chain id for the L2 that this contract is deployed on or communicates with.\n    // For example: if this contract were meant to facilitate transfers from polygon to mainnet, this value would be\n    // the polygon chainId 137.\n    uint256 public immutable l2ChainId;\n\n    modifier onlyChainId(uint256 chainId) {\n        _requireChainId(chainId);\n        _;\n    }\n\n    /**\n     * @notice Constructs Token Bridger contract.\n     * @param _destination Where to send tokens to for this network.\n     * @param _l1PolygonRegistry L1 registry that stores updated addresses of polygon contracts. This should always be\n     * set to the L1 registry regardless if whether it's deployed on L2 or L1.\n     * @param _l1Weth L1 WETH address.\n     * @param _l2WrappedMatic L2 address of wrapped matic token.\n     * @param _l1ChainId the chain id for the L1 in this environment.\n     * @param _l2ChainId the chain id for the L2 in this environment.\n     */\n    constructor(\n        address _destination,\n        PolygonRegistry _l1PolygonRegistry,\n        WETH9Interface _l1Weth,\n        address _l2WrappedMatic,\n        uint256 _l1ChainId,\n        uint256 _l2ChainId\n    ) {\n        //slither-disable-next-line missing-zero-check\n        destination = _destination;\n        l1PolygonRegistry = _l1PolygonRegistry;\n        l1Weth = _l1Weth;\n        //slither-disable-next-line missing-zero-check\n        l2WrappedMatic = _l2WrappedMatic;\n        l1ChainId = _l1ChainId;\n        l2ChainId = _l2ChainId;\n    }\n\n    /**\n     * @notice Called by Polygon SpokePool to send tokens over bridge to contract with the same address as this.\n     * @notice The caller of this function must approve this contract to spend amount of token.\n     * @param token Token to bridge.\n     * @param amount Amount to bridge.\n     */\n    function send(PolygonIERC20Upgradeable token, uint256 amount) public nonReentrant onlyChainId(l2ChainId) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // In the wMatic case, this unwraps. For other ERC20s, this is the burn/send action.\n        token.withdraw(token.balanceOf(address(this)));\n\n        // This takes the token that was withdrawn and calls withdraw on the \"native\" ERC20.\n        if (address(token) == l2WrappedMatic) MATIC.withdraw{ value: address(this).balance }(address(this).balance);\n    }\n\n    /**\n     * @notice Called by someone to send tokens to the destination, which should be set to the HubPool.\n     * @param token Token to send to destination.\n     */\n    function retrieve(IERC20Upgradeable token) public nonReentrant onlyChainId(l1ChainId) {\n        if (address(token) == address(l1Weth)) {\n            // For WETH, there is a pre-deposit step to ensure any ETH that has been sent to the contract is captured.\n            //slither-disable-next-line arbitrary-send-eth\n            l1Weth.deposit{ value: address(this).balance }();\n        }\n        token.safeTransfer(destination, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Called to initiate an l1 exit (withdrawal) of matic tokens that have been sent over the plasma bridge.\n     * @param data the proof data to trigger the exit. Can be generated using the maticjs-plasma package.\n     */\n    function callExit(bytes memory data) public nonReentrant onlyChainId(l1ChainId) {\n        PolygonERC20Predicate erc20Predicate = PolygonERC20Predicate(l1PolygonRegistry.erc20Predicate());\n        erc20Predicate.startExitWithBurntTokens(data);\n    }\n\n    receive() external payable {\n        // This method is empty to avoid any gas expendatures that might cause transfers to fail.\n        // Note: the fact that there is _no_ code in this function means that matic can be erroneously transferred in\n        // to the contract on the polygon side. These tokens would be locked indefinitely since the receive function\n        // cannot be called on the polygon side. While this does have some downsides, the lack of any functionality\n        // in this function means that it has no chance of running out of gas on transfers, which is a much more\n        // important benefit. This just makes the matic token risk similar to that of ERC20s that are erroneously\n        // sent to the contract.\n    }\n\n    function _requireChainId(uint256 chainId) internal view {\n        require(block.chainid == chainId, \"Cannot run method on this chain\");\n    }\n}\n"
    },
    "contracts/PolygonZkEVM_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./external/interfaces/IPolygonZkEVMBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Define interface for PolygonZkEVM Bridge message receiver\n * See https://github.com/0xPolygonHermez/zkevm-contracts/blob/53e95f3a236d8bea87c27cb8714a5d21496a3b20/contracts/interfaces/IBridgeMessageReceiver.sol\n */\ninterface IBridgeMessageReceiver {\n    /**\n     * @notice This will be called by the Polygon zkEVM Bridge on L2 to relay a message sent from the HubPool.\n     * @param originAddress Address of the original message sender on L1.\n     * @param originNetwork Polygon zkEVM's internal network id of source chain.\n     * @param data Data to be received and executed on this contract.\n     */\n    function onMessageReceived(\n        address originAddress,\n        uint32 originNetwork,\n        bytes memory data\n    ) external payable;\n}\n\n/**\n * @notice Polygon zkEVM Spoke pool.\n * @custom:security-contact bugs@across.to\n */\ncontract PolygonZkEVM_SpokePool is SpokePool, IBridgeMessageReceiver {\n    using SafeERC20 for IERC20;\n\n    // Address of Polygon zkEVM's Canonical Bridge on L2.\n    IPolygonZkEVMBridge public l2PolygonZkEVMBridge;\n\n    // Polygon zkEVM's internal network id for L1.\n    uint32 public constant POLYGON_ZKEVM_L1_NETWORK_ID = 0;\n\n    // Warning: this variable should _never_ be touched outside of this contract. It is intentionally set to be\n    // private. Leaving it set to true can permanently disable admin calls.\n    bool private adminCallValidated;\n\n    /**************************************\n     *               ERRORS               *\n     **************************************/\n    error AdminCallValidatedAlreadySet();\n    error CallerNotBridge();\n    error OriginSenderNotCrossDomain();\n    error SourceChainNotHubChain();\n    error AdminCallNotValidated();\n\n    /**************************************\n     *               EVENTS               *\n     **************************************/\n    event SetPolygonZkEVMBridge(address indexed newPolygonZkEVMBridge, address indexed oldPolygonZkEVMBridge);\n    event ReceivedMessageFromL1(address indexed caller, address indexed originAddress);\n\n    // Note: validating calls this way ensures that strange calls coming from the onMessageReceived won't be\n    // misinterpreted. Put differently, just checking that originAddress == crossDomainAdmint is not sufficient.\n    // All calls that have admin privileges must be fired from within the onMessageReceived method that's gone\n    // through validation where the sender is checked and the sender from the other chain is also validated.\n    // This modifier sets the adminCallValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure adminCallValidated is set to True only once at beginning of onMessageReceived, which prevents\n        // onMessageReceived from being re-entered.\n        if (adminCallValidated) {\n            revert AdminCallValidatedAlreadySet();\n        }\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed.\n        adminCallValidated = true;\n\n        _;\n\n        // Reset adminCallValidated to false to disallow admin calls after this method exits.\n        adminCallValidated = false;\n    }\n\n    /**\n     * @notice Construct Polygon zkEVM specific SpokePool.\n     * @param _wrappedNativeTokenAddress Address of WETH on Polygon zkEVM.\n     * @param _depositQuoteTimeBuffer Quote timestamps can't be set more than this amount\n     * into the past from the block time of the deposit.\n     * @param _fillDeadlineBuffer Fill deadlines can't be set more than this amount\n     * into the future from the block time of the deposit.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    )\n        SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            // PolygonZkEVM_SpokePool does not use OFT messaging; setting destination eid and fee cap to 0\n            0,\n            0\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Polygon zkEVM SpokePool.\n     * @param _l2PolygonZkEVMBridge Address of Polygon zkEVM's canonical bridge contract on L2.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        IPolygonZkEVMBridge _l2PolygonZkEVMBridge,\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setL2PolygonZkEVMBridge(_l2PolygonZkEVMBridge);\n    }\n\n    /**\n     * @notice Admin can reset the Polygon zkEVM bridge contract address.\n     * @param _l2PolygonZkEVMBridge Address of the new canonical bridge.\n     */\n    function setL2PolygonZkEVMBridge(IPolygonZkEVMBridge _l2PolygonZkEVMBridge) external onlyAdmin {\n        _setL2PolygonZkEVMBridge(_l2PolygonZkEVMBridge);\n    }\n\n    /**\n     * @notice This will be called by the Polygon zkEVM Bridge on L2 to relay a message sent from the HubPool.\n     * @param _originAddress Address of the original message sender on L1.\n     * @param _originNetwork Polygon zkEVM's internal network id of source chain.\n     * @param _data Data to be received and executed on this contract.\n     */\n    function onMessageReceived(\n        address _originAddress,\n        uint32 _originNetwork,\n        bytes memory _data\n    ) external payable override validateInternalCalls {\n        if (msg.sender != address(l2PolygonZkEVMBridge)) {\n            revert CallerNotBridge();\n        }\n        if (_originAddress != crossDomainAdmin) {\n            revert OriginSenderNotCrossDomain();\n        }\n        if (_originNetwork != POLYGON_ZKEVM_L1_NETWORK_ID) {\n            revert SourceChainNotHubChain();\n        }\n\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(_data);\n        require(success, \"delegatecall failed\");\n\n        emit ReceivedMessageFromL1(msg.sender, _originAddress);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Wraps any ETH into WETH before executing base function. This is necessary because SpokePool receives\n     * ETH over the canonical token bridge instead of WETH.\n     */\n    function _preExecuteLeafHook(address l2TokenAddress) internal override {\n        if (l2TokenAddress == address(wrappedNativeToken)) _depositEthToWeth();\n    }\n\n    // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is necessary because\n    // this SpokePool will receive ETH from the canonical token bridge instead of WETH. This may not be neccessary\n    // if ETH on Polygon zkEVM is treated as ETH and the fallback() function is triggered when this contract receives\n    // ETH. We will have to test this but this function for now allows the contract to safely convert all of its\n    // held ETH into WETH at the cost of higher gas costs.\n    function _depositEthToWeth() internal {\n        //slither-disable-next-line arbitrary-send-eth\n        if (address(this).balance > 0) wrappedNativeToken.deposit{ value: address(this).balance }();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // SpokePool is expected to receive ETH from the L1 HubPool, then we need to first unwrap it to ETH and then\n        // send ETH directly via the native L2 bridge.\n        if (l2TokenAddress == address(wrappedNativeToken)) {\n            WETH9Interface(l2TokenAddress).withdraw(amountToReturn); // Unwrap into ETH.\n            l2PolygonZkEVMBridge.bridgeAsset{ value: amountToReturn }(\n                POLYGON_ZKEVM_L1_NETWORK_ID,\n                withdrawalRecipient,\n                amountToReturn,\n                address(0),\n                true, // Indicates if the new global exit root is updated or not, which is true for asset bridges\n                \"\"\n            );\n        } else {\n            IERC20(l2TokenAddress).safeIncreaseAllowance(address(l2PolygonZkEVMBridge), amountToReturn);\n            l2PolygonZkEVMBridge.bridgeAsset(\n                POLYGON_ZKEVM_L1_NETWORK_ID,\n                withdrawalRecipient,\n                amountToReturn,\n                l2TokenAddress,\n                true, // Indicates if the new global exit root is updated or not, which is true for asset bridges\n                \"\"\n            );\n        }\n    }\n\n    // Check that the onMessageReceived method has validated the method to ensure the sender is authenticated.\n    function _requireAdminSender() internal view override {\n        if (!adminCallValidated) {\n            revert AdminCallNotValidated();\n        }\n    }\n\n    function _setL2PolygonZkEVMBridge(IPolygonZkEVMBridge _newL2PolygonZkEVMBridge) internal {\n        address oldL2PolygonZkEVMBridge = address(l2PolygonZkEVMBridge);\n        l2PolygonZkEVMBridge = _newL2PolygonZkEVMBridge;\n        emit SetPolygonZkEVMBridge(address(_newL2PolygonZkEVMBridge), oldL2PolygonZkEVMBridge);\n    }\n}\n"
    },
    "contracts/SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport \"./MerkleLib.sol\";\nimport \"./erc7683/ERC7683.sol\";\nimport \"./erc7683/ERC7683Permit2Lib.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolMessageHandler.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"./upgradeable/MultiCallerUpgradeable.sol\";\nimport \"./upgradeable/EIP712CrossChainUpgradeable.sol\";\nimport \"./upgradeable/AddressLibUpgradeable.sol\";\nimport \"./libraries/AddressConverters.sol\";\nimport { IOFT } from \"./interfaces/IOFT.sol\";\nimport { OFTTransportAdapter } from \"./libraries/OFTTransportAdapter.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title SpokePool\n * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.\n * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a \"data worker\",\n * submits a proof that the relayer correctly submitted a relay on this SpokePool.\n * @custom:security-contact bugs@across.to\n */\nabstract contract SpokePool is\n    V3SpokePoolInterface,\n    SpokePoolInterface,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    MultiCallerUpgradeable,\n    EIP712CrossChainUpgradeable,\n    IDestinationSettler,\n    OFTTransportAdapter\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressLibUpgradeable for address;\n    using Bytes32ToAddress for bytes32;\n    using AddressToBytes32 for address;\n\n    // Address of the L1 contract that acts as the owner of this SpokePool. This should normally be set to the HubPool\n    // address. The crossDomainAdmin address is unused when the SpokePool is deployed to the same chain as the HubPool.\n    address public crossDomainAdmin;\n\n    // Address of the L1 contract that will send tokens to and receive tokens from this contract to fund relayer\n    // refunds and slow relays.\n    address public withdrawalRecipient;\n\n    // Note: The following two storage variables prefixed with DEPRECATED used to be variables that could be set by\n    // the cross-domain admin. Admins ended up not changing these in production, so to reduce\n    // gas in deposit/fill functions, we are converting them to private variables to maintain the contract\n    // storage layout and replacing them with immutable or constant variables, because retrieving a constant\n    // value is cheaper than retrieving a storage variable. Please see out the immutable/constant variable section.\n    WETH9Interface private DEPRECATED_wrappedNativeToken;\n    uint32 private DEPRECATED_depositQuoteTimeBuffer;\n\n    // `numberOfDeposits` acts as a counter to generate unique deposit identifiers for this spoke pool.\n    // It is a uint32 that increments with each `depositV3` call. In the `FundsDeposited` event, it is\n    // implicitly cast to uint256 by setting its most significant bits to 0, reducing the risk of ID collisions\n    // with unsafe deposits. However, this variable's name could be improved (e.g., `depositNonceCounter`)\n    // since it does not accurately reflect the total number of deposits, as `unsafeDeposit` can bypass this increment.\n    uint32 public numberOfDeposits;\n\n    // Whether deposits and fills are disabled.\n    bool public pausedFills;\n    bool public pausedDeposits;\n\n    // This contract can store as many root bundles as the HubPool chooses to publish here.\n    RootBundle[] public rootBundles;\n\n    // Origin token to destination token routings can be turned on or off, which can enable or disable deposits.\n    mapping(address => mapping(uint256 => bool)) private DEPRECATED_enabledDepositRoutes;\n\n    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay\n    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to\n    // relay, the fees, and the agents are all parameters included in the hash key.\n    mapping(bytes32 => uint256) private DEPRECATED_relayFills;\n\n    // Note: We will likely un-deprecate the fill and deposit counters to implement a better\n    // dynamic LP fee mechanism but for now we'll deprecate it to reduce bytecode\n    // in deposit/fill functions. These counters are designed to implement a fee mechanism that is based on a\n    // canonical history of deposit and fill events and how they update a virtual running balance of liabilities and\n    // assets, which then determines the LP fee charged to relays.\n\n    // This keeps track of the worst-case liabilities due to fills.\n    // It is never reset. Users should only rely on it to determine the worst-case increase in liabilities between\n    // two points. This is used to provide frontrunning protection to ensure the relayer's assumptions about the state\n    // upon which their expected repayments are based will not change before their transaction is mined.\n    mapping(address => uint256) private DEPRECATED_fillCounter;\n\n    // This keeps track of the total running deposits for each token. This allows depositors to protect themselves from\n    // frontrunning that might change their worst-case quote.\n    mapping(address => uint256) private DEPRECATED_depositCounter;\n\n    // This tracks the number of identical refunds that have been requested.\n    // The intention is to allow an off-chain system to know when this could be a duplicate and ensure that the other\n    // requests are known and accounted for.\n    mapping(bytes32 => uint256) private DEPRECATED_refundsRequested;\n\n    // Mapping of V3 relay hashes to fill statuses. Distinguished from relayFills\n    // to eliminate any chance of collision between pre and post V3 relay hashes.\n    mapping(bytes32 => uint256) public fillStatuses;\n\n    // Mapping of L2TokenAddress to relayer to outstanding refund amount. Used when a relayer repayment fails for some\n    // reason (eg blacklist) to track their outstanding liability, thereby letting them claim it later.\n    mapping(address => mapping(address => uint256)) public relayerRefund;\n\n    // Mapping of L2 token address to L2 IOFT messenger address. Required to support bridging via OFT standard\n    mapping(address l2TokenAddress => address l2OftMessenger) public oftMessengers;\n\n    /**************************************************************\n     *                CONSTANT/IMMUTABLE VARIABLES                *\n     **************************************************************/\n    // Constant and immutable variables do not take up storage slots and are instead added to the contract bytecode\n    // at compile time. The difference between them is that constant variables must be declared inline, meaning\n    // that they cannot be changed in production without changing the contract code, while immutable variables\n    // can be set in the constructor. Therefore we use the immutable keyword for variables that we might want to be\n    // different for each child contract (one obvious example of this is the wrappedNativeToken) or that we might\n    // want to update in the future like depositQuoteTimeBuffer. Constants are unlikely to ever be changed.\n\n    // Address of wrappedNativeToken contract for this network. If an origin token matches this, then the caller can\n    // optionally instruct this contract to wrap native tokens when depositing (ie ETH->WETH or MATIC->WMATIC).\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    WETH9Interface public immutable wrappedNativeToken;\n\n    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces\n    // caller to use an approximately \"current\" realized fee.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable depositQuoteTimeBuffer;\n\n    // The fill deadline can only be set this far into the future from the timestamp of the deposit on this contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable fillDeadlineBuffer;\n\n    uint256 public constant MAX_TRANSFER_SIZE = 1e36;\n\n    bytes32 public constant UPDATE_BYTES32_DEPOSIT_DETAILS_HASH =\n        keccak256(\n            \"UpdateDepositDetails(uint256 depositId,uint256 originChainId,uint256 updatedOutputAmount,bytes32 updatedRecipient,bytes updatedMessage)\"\n        );\n    // Default chain Id used to signify that no repayment is requested, for example when executing a slow fill.\n    uint256 public constant EMPTY_REPAYMENT_CHAIN_ID = 0;\n    // Default address used to signify that no relayer should be credited with a refund, for example\n    // when executing a slow fill.\n    bytes32 public constant EMPTY_RELAYER = bytes32(0);\n    // This is the magic value that signals to the off-chain validator\n    // that this deposit can never expire. A deposit with this fill deadline should always be eligible for a\n    // slow fill, meaning that its output token and input token must be \"equivalent\". Therefore, this value is only\n    // used as a fillDeadline in deposit(), a soon to be deprecated function that also hardcodes outputToken to\n    // the zero address, which forces the off-chain validator to replace the output token with the equivalent\n    // token for the input token. By using this magic value, off-chain validators do not have to keep\n    // this event in their lookback window when querying for expired deposits.\n    uint32 public constant INFINITE_FILL_DEADLINE = type(uint32).max;\n\n    // One year in seconds. If `exclusivityParameter` is set to a value less than this, then the emitted\n    // exclusivityDeadline in a deposit event will be set to the current time plus this value.\n    uint32 public constant MAX_EXCLUSIVITY_PERIOD_SECONDS = 31_536_000;\n\n    // EIP-7702 prefix for delegated wallets.\n    bytes3 internal constant EIP7702_PREFIX = 0xef0100;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n    event SetXDomainAdmin(address indexed newAdmin);\n    event SetWithdrawalRecipient(address indexed newWithdrawalRecipient);\n    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);\n    event RelayedRootBundle(\n        uint32 indexed rootBundleId,\n        bytes32 indexed relayerRefundRoot,\n        bytes32 indexed slowRelayRoot\n    );\n    event ExecutedRelayerRefundRoot(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint256[] refundAmounts,\n        uint32 indexed rootBundleId,\n        uint32 indexed leafId,\n        address l2TokenAddress,\n        address[] refundAddresses,\n        bool deferredRefunds,\n        address caller\n    );\n    event TokensBridged(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint32 indexed leafId,\n        bytes32 indexed l2TokenAddress,\n        address caller\n    );\n    event EmergencyDeletedRootBundle(uint256 indexed rootBundleId);\n    event PausedDeposits(bool isPaused);\n    event PausedFills(bool isPaused);\n    event SetOFTMessenger(address indexed token, address indexed messenger);\n\n    error OFTTokenMismatch();\n\n    /**\n     * @notice Construct the SpokePool. Normally, logic contracts used in upgradeable proxies shouldn't\n     * have constructors since the following code will be executed within the logic contract's state, not the\n     * proxy contract's state. However, if we restrict the constructor to setting only immutable variables, then\n     * we are safe because immutable variables are included in the logic contract's bytecode rather than its storage.\n     * @dev Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be\n     * taken over by an attacker, which may impact the proxy. To prevent the implementation contract from being\n     * used, you should invoke the _disableInitializers function in the constructor to automatically lock it when\n     * it is deployed:\n     * @param _wrappedNativeTokenAddress wrappedNativeToken address for this network to set.\n     * @param _depositQuoteTimeBuffer depositQuoteTimeBuffer to set. Quote timestamps can't be set more than this amount\n     * into the past from the block time of the deposit.\n     * @param _fillDeadlineBuffer fillDeadlineBuffer to set. Fill deadlines can't be set more than this amount\n     * into the future from the block time of the deposit.\n     * @param _oftDstEid destination endpoint id for OFT messaging\n     * @param _oftFeeCap fee cap in native token when paying for cross-chain OFT transfers\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        uint32 _oftDstEid,\n        uint256 _oftFeeCap\n    ) OFTTransportAdapter(_oftDstEid, _oftFeeCap) {\n        wrappedNativeToken = WETH9Interface(_wrappedNativeTokenAddress);\n        depositQuoteTimeBuffer = _depositQuoteTimeBuffer;\n        fillDeadlineBuffer = _fillDeadlineBuffer;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Construct the base SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function __SpokePool_init(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public onlyInitializing {\n        numberOfDeposits = _initialDepositId;\n        __EIP712_init(\"ACROSS-V2\", \"1.0.0\");\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n        _setWithdrawalRecipient(_withdrawalRecipient);\n    }\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     * @dev This should be set to cross domain admin for specific SpokePool.\n     */\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    modifier unpausedDeposits() {\n        if (pausedDeposits) revert DepositsArePaused();\n        _;\n    }\n\n    modifier unpausedFills() {\n        if (pausedFills) revert FillsArePaused();\n        _;\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    // Allows cross domain admin to upgrade UUPS proxy implementation.\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {}\n\n    /**\n     * @notice Pauses deposit-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects `deposit()` but not `speedUpDeposit()`, so that existing deposits can be sped up and still\n     * relayed.\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseDeposits(bool pause) public override onlyAdmin nonReentrant {\n        pausedDeposits = pause;\n        emit PausedDeposits(pause);\n    }\n\n    /**\n     * @notice Pauses fill-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects fillRelayWithUpdatedDeposit() and fillRelay().\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseFills(bool pause) public override onlyAdmin nonReentrant {\n        pausedFills = pause;\n        emit PausedFills(pause);\n    }\n\n    /**\n     * @notice Change cross domain admin address. Callable by admin only.\n     * @param newCrossDomainAdmin New cross domain admin.\n     */\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyAdmin nonReentrant {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    /**\n     * @notice Change L1 withdrawal recipient address. Callable by admin only.\n     * @param newWithdrawalRecipient New withdrawal recipient address.\n     */\n    function setWithdrawalRecipient(address newWithdrawalRecipient) public override onlyAdmin nonReentrant {\n        _setWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    /**\n     * @notice This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill\n     * slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is\n     * designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\n     * @param relayerRefundRoot Merkle root containing relayer refund leaves that can be individually executed via\n     * executeRelayerRefundLeaf().\n     * @param slowRelayRoot Merkle root containing slow relay fulfillment leaves that can be individually executed via\n     * executeSlowRelayLeaf().\n     */\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) public override onlyAdmin nonReentrant {\n        uint32 rootBundleId = uint32(rootBundles.length);\n        RootBundle storage rootBundle = rootBundles.push();\n        rootBundle.relayerRefundRoot = relayerRefundRoot;\n        rootBundle.slowRelayRoot = slowRelayRoot;\n        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayRoot);\n    }\n\n    /**\n     * @notice This method is intended to only be used in emergencies where a bad root bundle has reached the\n     * SpokePool.\n     * @param rootBundleId Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256\n     * to ensure that a small input range doesn't limit which indices this method is able to reach.\n     */\n    function emergencyDeleteRootBundle(uint256 rootBundleId) public override onlyAdmin nonReentrant {\n        // Deleting a struct containing a mapping does not delete the mapping in Solidity, therefore the bitmap's\n        // data will still remain potentially leading to vulnerabilities down the line. The way around this would\n        // be to iterate through every key in the mapping and resetting the value to 0, but this seems expensive and\n        // would require a new list in storage to keep track of keys.\n        //slither-disable-next-line mapping-deletion\n        delete rootBundles[rootBundleId];\n        emit EmergencyDeletedRootBundle(rootBundleId);\n    }\n\n    /**\n     * @notice Add token -> OFTMessenger relationship. Callable only by admin.\n     * @param token token address on the current chain\n     * @param messenger IOFT contract address on the current chain for the specified token. Acts as a 'mailbox'\n     */\n    function setOftMessenger(address token, address messenger) external onlyAdmin nonReentrant {\n        _setOftMessenger(token, messenger);\n    }\n\n    /**************************************\n     *    LEGACY DEPOSITOR FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @dev DEPRECATION NOTICE: this function is deprecated and will be removed in the future.\n     *      Please use deposit (under DEPOSITOR FUNCTIONS below) or depositV3 instead.\n     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock\n     * tokens in this contract and receive a destination token on the destination chain. The origin => destination\n     * token mapping is stored on the L1 HubPool.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @dev Produces a FundsDeposited event with an infinite expiry, meaning that this deposit can never expire.\n     * Moreover, the event's outputToken is set to 0x0 meaning that this deposit can always be slow filled.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function depositDeprecated_5947912356(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable nonReentrant unpausedDeposits {\n        _deposit(\n            msg.sender,\n            recipient,\n            originToken,\n            amount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message\n        );\n    }\n\n    /**\n     * @dev DEPRECATION NOTICE: this function is deprecated and will be removed in the future.\n     *      Please use the other deposit or depositV3 instead.\n     * @notice The only difference between depositFor and deposit is that the depositor address stored\n     * in the relay hash can be overridden by the caller. This means that the passed in depositor\n     * can speed up the deposit, which is useful if the deposit is taken from the end user to a middle layer\n     * contract, like an aggregator or the SpokePoolVerifier, before calling deposit on this contract.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @param depositor Address who is credited for depositing funds on origin chain and can speed up the deposit.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function depositFor(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable nonReentrant unpausedDeposits {\n        _deposit(depositor, recipient, originToken, amount, destinationChainId, relayerFeePct, quoteTimestamp, message);\n    }\n\n    /********************************************\n     *            DEPOSITOR FUNCTIONS           *\n     ********************************************/\n\n    /**\n     * @notice Previously, this function allowed the caller to specify the exclusivityDeadline, otherwise known as the\n     * as exact timestamp on the destination chain before which only the exclusiveRelayer could fill the deposit. Now,\n     * the caller is expected to pass in a number that will be interpreted either as an offset or a fixed\n     * timestamp depending on its value.\n     * @notice Request to bridge input token cross chain to a destination chain and receive a specified amount\n     * of output tokens. The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs,\n     * the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and the system fee that they'll be charged.\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, less a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp. This must be a valid, non-zero address if the exclusivity deadline is\n     * greater than the current block.timestamp. If the exclusivity deadline is < currentTime, then this must be\n     * address(0), and vice versa if this is address(0).\n     * @param quoteTimestamp The HubPool timestamp that is used to determine the system fee paid by the depositor.\n     *  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp,\n     * the fill will revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where\n     * currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\n     * event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address),\n     * can fill this deposit. There are three ways to use this parameter:\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\n     *        meaning that there is no exclusivity period.\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function deposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable override nonReentrant unpausedDeposits {\n        // Increment the `numberOfDeposits` counter to ensure a unique deposit ID for this spoke pool.\n        DepositV3Params memory params = DepositV3Params({\n            depositor: depositor,\n            recipient: recipient,\n            inputToken: inputToken,\n            outputToken: outputToken,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            destinationChainId: destinationChainId,\n            exclusiveRelayer: exclusiveRelayer,\n            depositId: numberOfDeposits++,\n            quoteTimestamp: quoteTimestamp,\n            fillDeadline: fillDeadline,\n            exclusivityParameter: exclusivityParameter,\n            message: message\n        });\n        _depositV3(params);\n    }\n\n    /**\n     * @notice A version of `deposit` that accepts `address` types for backward compatibility.\n     * This function allows bridging of input tokens cross-chain to a destination chain, receiving a specified amount of output tokens.\n     * The relayer is refunded in input tokens on a repayment chain of their choice, minus system fees, after an optimistic challenge\n     * window. The exclusivity period is specified as an offset from the current block timestamp.\n     *\n     * @dev This version mirrors the original `depositV3` function, but uses `address` types for `depositor`, `recipient`,\n     * `inputToken`, `outputToken`, and `exclusiveRelayer` for compatibility with contracts using the `address` type.\n     *\n     * The key functionality and logic remain identical, ensuring interoperability across both versions.\n     *\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to initiate the deposit.\n     * The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal\n     * to the wrapped native token, the caller can optionally pass in native token as msg.value, provided msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.\n     * @param inputAmount The amount of input tokens pulled from the caller's account and locked into this contract. This\n     * amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, less a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token as a valid\n     * deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer exclusively allowed to fill this deposit before the exclusivity deadline.\n     * @param quoteTimestamp The HubPool timestamp that determines the system fee paid by the depositor. This must be set\n     * between [currentTime - depositQuoteTimeBuffer, currentTime] where currentTime is block.timestamp on this chain.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will\n     * revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where currentTime is block.timestamp\n     * on this chain.\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\n     * event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address),\n     * can fill this deposit. There are three ways to use this parameter:\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\n     *        meaning that there is no exclusivity period.\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract. If the\n     * message is not empty, the recipient contract must implement `handleV3AcrossMessage()` or the fill will revert.\n     */\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable override {\n        deposit(\n            depositor.toBytes32(),\n            recipient.toBytes32(),\n            inputToken.toBytes32(),\n            outputToken.toBytes32(),\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer.toBytes32(),\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice See deposit for details. This function is identical to deposit except that it does not use the\n     * global deposit ID counter as a deposit nonce, instead allowing the caller to pass in a deposit nonce. This\n     * function is designed to be used by anyone who wants to pre-compute their resultant relay data hash, which\n     * could be useful for filling a deposit faster and avoiding any risk of a relay hash unexpectedly changing\n     * due to another deposit front-running this one and incrementing the global deposit ID counter.\n     * @dev This is labeled \"unsafe\" because there is no guarantee that the depositId emitted in the resultant\n     * FundsDeposited event is unique which means that the\n     * corresponding fill might collide with an existing relay hash on the destination chain SpokePool,\n     * which would make this deposit unfillable. In this case, the depositor would subsequently receive a refund\n     * of `inputAmount` of `inputToken` on the origin chain after the fill deadline. Re-using a depositNonce is very\n     * dangerous when combined with `speedUpDeposit`, as a speed up signature can be re-used for any deposits\n     * with the same deposit ID.\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\n     * @param depositNonce The nonce that uniquely identifies this deposit. This function will combine this parameter\n     * with the msg.sender address to create a unique uint256 depositNonce and ensure that the msg.sender cannot\n     * use this function to front-run another depositor's unsafe deposit. This function guarantees that the resultant\n     * deposit nonce will not collide with a safe uint256 deposit nonce whose 24 most significant bytes are always 0.\n     * @param depositor See identically named parameter in depositV3() comments.\n     * @param recipient See identically named parameter in depositV3() comments.\n     * @param inputToken See identically named parameter in depositV3() comments.\n     * @param outputToken See identically named parameter in depositV3() comments.\n     * @param inputAmount See identically named parameter in depositV3() comments.\n     * @param outputAmount See identically named parameter in depositV3() comments.\n     * @param destinationChainId See identically named parameter in depositV3() comments.\n     * @param exclusiveRelayer See identically named parameter in depositV3() comments.\n     * @param quoteTimestamp See identically named parameter in depositV3() comments.\n     * @param fillDeadline See identically named parameter in depositV3() comments.\n     * @param exclusivityParameter See identically named parameter in depositV3() comments.\n     * @param message See identically named parameter in depositV3() comments.\n     */\n    function unsafeDeposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable nonReentrant unpausedDeposits {\n        // @dev Create the uint256 deposit ID by concatenating the msg.sender and depositor address with the inputted\n        // depositNonce parameter. The resultant 32 byte string will be hashed and then casted to an \"unsafe\"\n        // uint256 deposit ID. The probability that the resultant ID collides with a \"safe\" deposit ID is\n        // equal to the chance that the first 28 bytes of the hash are 0, which is too small for us to consider.\n\n        uint256 depositId = getUnsafeDepositId(msg.sender, depositor, depositNonce);\n        DepositV3Params memory params = DepositV3Params({\n            depositor: depositor,\n            recipient: recipient,\n            inputToken: inputToken,\n            outputToken: outputToken,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            destinationChainId: destinationChainId,\n            exclusiveRelayer: exclusiveRelayer,\n            depositId: depositId,\n            quoteTimestamp: quoteTimestamp,\n            fillDeadline: fillDeadline,\n            exclusivityParameter: exclusivityParameter,\n            message: message\n        });\n        _depositV3(params);\n    }\n\n    /**\n     * @notice Submits deposit and sets quoteTimestamp to current Time. Sets fill and exclusivity\n     * deadlines as offsets added to the current time. This function is designed to be called by users\n     * such as Multisig contracts who do not have certainty when their transaction will mine.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline, which is the deadline for the\n     * relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the\n     * destination chain.\n     * @param exclusivityParameter See identically named parameter in deposit() comments.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositNow(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable override {\n        deposit(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            uint32(getCurrentTime()),\n            uint32(getCurrentTime()) + fillDeadlineOffset,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice A version of `depositNow` that supports addresses as input types for backward compatibility.\n     * This function submits a deposit and sets `quoteTimestamp` to the current time. The `fill` and `exclusivity` deadlines\n     * are set as offsets added to the current time. It is designed to be called by users, including Multisig contracts, who may\n     * not have certainty when their transaction will be mined.\n     *\n     * @dev This version is identical to the original `depositV3Now` but uses `address` types for `depositor`, `recipient`,\n     * `inputToken`, `outputToken`, and `exclusiveRelayer` to support compatibility with older systems.\n     * It maintains the same logic and purpose, ensuring interoperability with both versions.\n     *\n     * @param depositor The account credited with the deposit, who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive the native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to initiate the deposit.\n     * Equivalent tokens on the relayer's repayment chain will be sent as a refund. If this is the wrapped native token,\n     * msg.value must equal inputTokenAmount when passed.\n     * @param outputToken The token the relayer will send to the recipient on the destination chain. Must be an ERC20.\n     * @param inputAmount The amount of input tokens pulled from the caller's account and locked into this contract.\n     * This amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled with the input token as a valid deposit route\n     * from this spoke pool, or the transaction will revert.\n     * @param exclusiveRelayer The relayer exclusively allowed to fill the deposit before the exclusivity deadline.\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline. After this timestamp, fills on the\n     * destination chain will revert.\n     * @param exclusivityParameter See identically named parameter in deposit() comments.\n     * @param message The message to send to the recipient on the destination chain. If the recipient is a contract, it must\n     * implement `handleV3AcrossMessage()` if the message is not empty, or the fill will revert.\n     */\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable override {\n        depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            uint32(getCurrentTime()),\n            uint32(getCurrentTime()) + fillDeadlineOffset,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice Depositor can use this function to signal to relayer to use updated output amount, recipient,\n     * and/or message. The speed up signature uniquely identifies the speed up based only on\n     * depositor, deposit ID and origin chain, so using this function in conjunction with unsafeDeposit is risky\n     * due to the chance of repeating a deposit ID.\n     * @dev the depositor and depositId must match the params in a FundsDeposited event that the depositor\n     * wants to speed up. The relayer has the option but not the obligation to use this updated information\n     * when filling the deposit via fillRelayWithUpdatedDeposit().\n     * @param depositor Depositor that must sign the depositorSignature and was the original depositor.\n     * @param depositId Deposit ID to speed up.\n     * @param updatedOutputAmount New output amount to use for this deposit. Should be lower than previous value\n     * otherwise relayer has no incentive to use this updated value.\n     * @param updatedRecipient New recipient to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param updatedMessage New message to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account. If depositor is a contract, then should implement EIP1271 to sign as a contract. See\n     * _verifyUpdateV3DepositMessage() for more details about how this signature should be constructed.\n     */\n    function speedUpDeposit(\n        bytes32 depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant {\n        _verifyUpdateV3DepositMessage(\n            depositor.toAddress(),\n            depositId,\n            chainId(),\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature,\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n        );\n\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\n        // from the following event to submit a fill with updated relay data.\n        emit RequestedSpeedUpDeposit(\n            updatedOutputAmount,\n            depositId,\n            depositor,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n    }\n\n    /**\n     * @notice A version of `speedUpDeposit` using `address` types for backward compatibility.\n     * This function allows the depositor to signal to the relayer to use updated output amount, recipient, and/or message\n     * when filling a deposit. This can be useful when the deposit needs to be modified after the original transaction has\n     * been mined.\n     *\n     * @dev The `depositor` and `depositId` must match the parameters in a `FundsDeposited` event that the depositor wants to speed up.\n     * The relayer is not obligated but has the option to use this updated information when filling the deposit using\n     * `fillRelayWithUpdatedDeposit()`. This version uses `address` types for compatibility with systems relying on\n     * `address`-based implementations.\n     *\n     * @param depositor The depositor that must sign the `depositorSignature` and was the original depositor.\n     * @param depositId The deposit ID to speed up.\n     * @param updatedOutputAmount The new output amount to use for this deposit. It should be lower than the previous value,\n     * otherwise the relayer has no incentive to use this updated value.\n     * @param updatedRecipient The new recipient for this deposit. Can be modified if the original recipient is a contract that\n     * expects to receive a message from the relay and needs to be changed.\n     * @param updatedMessage The new message for this deposit. Can be modified if the recipient is a contract that expects\n     * to receive a message from the relay and needs to be updated.\n     * @param depositorSignature The signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account.\n     * If the depositor is a contract, it should implement EIP1271 to sign as a contract. See `_verifyUpdateV3DepositMessage()`\n     * for more details on how the signature should be constructed.\n     */\n    function speedUpV3Deposit(\n        address depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public {\n        _verifyUpdateV3DepositMessage(\n            depositor,\n            depositId,\n            chainId(),\n            updatedOutputAmount,\n            updatedRecipient.toBytes32(),\n            updatedMessage,\n            depositorSignature,\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n        );\n\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\n        // from the following event to submit a fill with updated relay data.\n        emit RequestedSpeedUpDeposit(\n            updatedOutputAmount,\n            depositId,\n            depositor.toBytes32(),\n            updatedRecipient.toBytes32(),\n            updatedMessage,\n            depositorSignature\n        );\n    }\n\n    /**************************************\n     *         RELAYER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Fulfill request to bridge cross chain by sending specified output tokens to the recipient.\n     * @dev The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs, the\n     * relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and a system fee charged to relayers.\n     * @dev The hash of the relayData will be used to uniquely identify the deposit to fill, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters passed to deposit() on the origin chain along with that chain's chainId(). This chain's\n     * chainId() must therefore match the destinationChainId passed into deposit.\n     * Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the\n     * origin SpokePool therefore the relayer should not modify any params in relayData.\n     * @dev Cannot fill more than once. Partial fills are not supported.\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. Should match\n     * all the same-named parameters emitted in the origin chain FundsDeposited event.\n     * - depositor: The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * - recipient The account receiving funds on this chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this\n     * token on the repayment chain will be sent as a refund to the caller.\n     * - outputToken The token that the caller will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund\n     * following an optimistic challenge window in the HubPool.\n     * - outputAmount: The amount of output tokens that the caller will send to the recipient.\n     * - originChainId: The origin chain identifier.\n     * - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * - fillDeadline The deadline for the caller to fill the deposit. After this timestamp,\n     * the fill will revert on the destination chain.\n     * - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this\n     * timestamp, anyone can fill this deposit. Note that if this value was set in deposit by adding an offset\n     * to the deposit's block.timestamp, there is re-org risk for the caller of this method because the event's\n     * block.timestamp can change. Read the comments in `deposit` about the `exclusivityParameter` for more details.\n     * - message The message to send to the recipient if the recipient is a contract that implements a\n     * handleV3AcrossMessage() public function\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain.\n     * @param repaymentAddress Address the relayer wants to be receive their refund at.\n     */\n    function fillRelay(\n        V3RelayData memory relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress\n    ) public override nonReentrant unpausedFills {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer.toAddress() != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: relayData.outputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: repaymentChainId\n        });\n\n        _fillRelayV3(relayExecution, repaymentAddress, false);\n    }\n\n    // Exposes the same function as fillRelay but with a legacy V3RelayData struct that takes in address types. Inner\n    // function fillV3Relay() applies reentrancy & non-paused checks.\n    function fillV3Relay(V3RelayDataLegacy calldata relayData, uint256 repaymentChainId) public override {\n        // Convert V3RelayDataLegacy to V3RelayData using the .toBytes32() method.\n        V3RelayData memory convertedRelayData = V3RelayData({\n            depositor: relayData.depositor.toBytes32(),\n            recipient: relayData.recipient.toBytes32(),\n            exclusiveRelayer: relayData.exclusiveRelayer.toBytes32(),\n            inputToken: relayData.inputToken.toBytes32(),\n            outputToken: relayData.outputToken.toBytes32(),\n            inputAmount: relayData.inputAmount,\n            outputAmount: relayData.outputAmount,\n            originChainId: relayData.originChainId,\n            depositId: relayData.depositId,\n            fillDeadline: relayData.fillDeadline,\n            exclusivityDeadline: relayData.exclusivityDeadline,\n            message: relayData.message\n        });\n\n        fillRelay(convertedRelayData, repaymentChainId, msg.sender.toBytes32());\n    }\n\n    /**\n     * @notice Identical to fillV3Relay except that the relayer wants to use a depositor's updated output amount,\n     * recipient, and/or message. The relayer should only use this function if they can supply a message signed\n     * by the depositor that contains the fill's matching deposit ID along with updated relay parameters.\n     * If the signature can be verified, then this function will emit a FilledV3Event that will be used by\n     * the system for refund verification purposes. In other words, this function is an alternative way to fill a\n     * a deposit than fillV3Relay.\n     * @dev Subject to same exclusivity deadline rules as fillV3Relay().\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. See fillV3Relay().\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. See fillV3Relay().\n     * @param repaymentAddress Address the relayer wants to be receive their refund at.\n     * @param updatedOutputAmount New output amount to use for this deposit.\n     * @param updatedRecipient New recipient to use for this deposit.\n     * @param updatedMessage New message to use for this deposit.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account.\n     */\n    function fillRelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant unpausedFills {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer.toAddress() != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: updatedOutputAmount,\n            updatedRecipient: updatedRecipient,\n            updatedMessage: updatedMessage,\n            repaymentChainId: repaymentChainId\n        });\n\n        _verifyUpdateV3DepositMessage(\n            relayData.depositor.toAddress(),\n            relayData.depositId,\n            relayData.originChainId,\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature,\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n        );\n\n        _fillRelayV3(relayExecution, repaymentAddress, false);\n    }\n\n    /**\n     * @notice Request Across to send LP funds to this contract to fulfill a slow fill relay\n     * for a deposit in the next bundle.\n     * @dev Slow fills are not possible unless the input and output tokens are \"equivalent\", i.e.\n     * they route to the same L1 token via PoolRebalanceRoutes.\n     * @dev Slow fills are created by inserting slow fill objects into a merkle tree that is included\n     * in the next HubPool \"root bundle\". Once the optimistic challenge window has passed, the HubPool\n     * will relay the slow root to this chain via relayRootBundle(). Once the slow root is relayed,\n     * the slow fill can be executed by anyone who calls executeSlowRelayLeaf().\n     * @dev Cannot request a slow fill if the fill deadline has passed.\n     * @dev Cannot request a slow fill if the relay has already been filled or a slow fill has already been requested.\n     * @param relayData struct containing all the data needed to identify the deposit that should be\n     * slow filled. If any of the params are missing or different from the origin chain deposit,\n     * then Across will not include a slow fill for the intended deposit.\n     */\n    function requestSlowFill(V3RelayData calldata relayData) public override nonReentrant unpausedFills {\n        uint32 currentTime = uint32(getCurrentTime());\n        // If a depositor has set an exclusivity deadline, then only the exclusive relayer should be able to\n        // fast fill within this deadline. Moreover, the depositor should expect to get *fast* filled within\n        // this deadline, not slow filled. As a simplifying assumption, we will not allow slow fills to be requested\n        // during this exclusivity period.\n        if (_fillIsExclusive(relayData.exclusivityDeadline, currentTime)) {\n            revert NoSlowFillsInExclusivityWindow();\n        }\n        if (relayData.fillDeadline < currentTime) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = getV3RelayHash(relayData);\n        if (fillStatuses[relayHash] != uint256(FillStatus.Unfilled)) revert InvalidSlowFillRequest();\n        fillStatuses[relayHash] = uint256(FillStatus.RequestedSlowFill);\n\n        emit RequestedSlowFill(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayData.depositor,\n            relayData.recipient,\n            _hashNonEmptyMessage(relayData.message)\n        );\n    }\n\n    /**\n     * @notice Fills a single leg of a particular order on the destination chain\n     * @dev ERC-7683 fill function.\n     * @param orderId Unique order identifier for this order\n     * @param originData Data emitted on the origin to parameterize the fill\n     * @param fillerData Data provided by the filler to inform the fill or express their preferences\n     */\n    function fill(bytes32 orderId, bytes calldata originData, bytes calldata fillerData) external {\n        if (keccak256(abi.encode(originData, chainId())) != orderId) {\n            revert WrongERC7683OrderId();\n        }\n\n        // Ensure that the call is not malformed. If the call is malformed, abi.decode will fail.\n        V3SpokePoolInterface.V3RelayData memory relayData = abi.decode(originData, (V3SpokePoolInterface.V3RelayData));\n        AcrossDestinationFillerData memory destinationFillerData = abi.decode(\n            fillerData,\n            (AcrossDestinationFillerData)\n        );\n\n        // Must do a delegatecall because the function requires the inputs to be calldata.\n        (bool success, bytes memory data) = address(this).delegatecall(\n            abi.encodeCall(\n                V3SpokePoolInterface.fillRelay,\n                (relayData, destinationFillerData.repaymentChainId, msg.sender.toBytes32())\n            )\n        );\n        if (!success) {\n            revert LowLevelCallFailed(data);\n        }\n    }\n\n    /**************************************\n     *         DATA WORKER FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @notice Executes a slow relay leaf stored as part of a root bundle relayed by the HubPool.\n     * @dev Executing a slow fill leaf is equivalent to filling the relayData so this function cannot be used to\n     * double fill a recipient. The relayData that is filled is included in the slowFillLeaf and is hashed\n     * like any other fill sent through a fill method.\n     * @dev There is no relayer credited with filling this relay since funds are sent directly out of this contract.\n     * @param slowFillLeaf Contains all data necessary to uniquely identify a relay for this chain. This struct is\n     * hashed and included in a merkle root that is relayed to all spoke pools.\n     * - relayData: struct containing all the data needed to identify the original deposit to be slow filled.\n     * - chainId: chain identifier where slow fill leaf should be executed. If this doesn't match this chain's\n     * chainId, then this function will revert.\n     * - updatedOutputAmount: Amount to be sent to recipient out of this contract's balance. Can be set differently\n     * from relayData.outputAmount to charge a different fee because this deposit was \"slow\" filled. Usually,\n     * this will be set higher to reimburse the recipient for waiting for the slow fill.\n     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.\n     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.\n     */\n    function executeSlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) public override nonReentrant {\n        V3RelayData memory relayData = slowFillLeaf.relayData;\n\n        _preExecuteLeafHook(relayData.outputToken.toAddress());\n\n        // @TODO In the future consider allowing way for slow fill leaf to be created with updated\n        // deposit params like outputAmount, message and recipient.\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: slowFillLeaf.updatedOutputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: EMPTY_REPAYMENT_CHAIN_ID // Repayment not relevant for slow fills.\n        });\n\n        _verifyV3SlowFill(relayExecution, rootBundleId, proof);\n\n        // - No relayer to refund for slow fill executions.\n        _fillRelayV3(relayExecution, EMPTY_RELAYER, true);\n    }\n\n    /**\n     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they\n     * sent to the recipient plus a relayer fee.\n     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.\n     * @param relayerRefundLeaf Contains all data necessary to reconstruct leaf contained in root bundle and to\n     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.\n     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.\n     */\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable virtual override nonReentrant {\n        _preExecuteLeafHook(relayerRefundLeaf.l2TokenAddress);\n\n        if (relayerRefundLeaf.chainId != chainId()) revert InvalidChainId();\n\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Check that proof proves that relayerRefundLeaf is contained within the relayer refund root.\n        // Note: This should revert if the relayerRefundRoot is uninitialized.\n        if (!MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof)) {\n            revert InvalidMerkleProof();\n        }\n\n        _setClaimedLeaf(rootBundleId, relayerRefundLeaf.leafId);\n\n        bool deferredRefunds = _distributeRelayerRefunds(\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.refundAmounts,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses\n        );\n\n        emit ExecutedRelayerRefundRoot(\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.refundAmounts,\n            rootBundleId,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses,\n            deferredRefunds,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Enables a relayer to claim outstanding repayments. Should virtually never be used, unless for some reason\n     * relayer repayment transfer fails for reasons such as token transfer reverts due to blacklisting. In this case,\n     * the relayer can still call this method and claim the tokens to a new address.\n     * @param l2TokenAddress Address of the L2 token to claim refunds for.\n     * @param refundAddress Address to send the refund to.\n     */\n    function claimRelayerRefund(bytes32 l2TokenAddress, bytes32 refundAddress) external {\n        uint256 refund = relayerRefund[l2TokenAddress.toAddress()][msg.sender];\n        if (refund == 0) revert NoRelayerRefundToClaim();\n        relayerRefund[l2TokenAddress.toAddress()][msg.sender] = 0;\n        IERC20Upgradeable(l2TokenAddress.toAddress()).safeTransfer(refundAddress.toAddress(), refund);\n\n        emit ClaimedRelayerRefund(l2TokenAddress, refundAddress, refund, msg.sender);\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns chain ID for this network.\n     * @dev Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\n     */\n    function chainId() public view virtual override returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Returns the deposit ID for an unsafe deposit. This function is used to compute the deposit ID\n     * in unsafeDeposit and is provided as a convenience.\n     * @dev msgSender and depositor are both used as inputs to allow passthrough depositors to create unique\n     * deposit hash spaces for unique depositors.\n     * @param msgSender The caller of the transaction used as input to produce the deposit ID.\n     * @param depositor The depositor address used as input to produce the deposit ID.\n     * @param depositNonce The nonce used as input to produce the deposit ID.\n     * @return The deposit ID for the unsafe deposit.\n     */\n    function getUnsafeDepositId(\n        address msgSender,\n        bytes32 depositor,\n        uint256 depositNonce\n    ) public pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(msgSender, depositor, depositNonce)));\n    }\n\n    function getRelayerRefund(address l2TokenAddress, address refundAddress) public view returns (uint256) {\n        return relayerRefund[l2TokenAddress][refundAddress];\n    }\n\n    function getV3RelayHash(V3RelayData memory relayData) public view returns (bytes32) {\n        return keccak256(abi.encode(relayData, chainId()));\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    function _depositV3(DepositV3Params memory params) internal {\n        // Verify depositor is a valid EVM address.\n        params.depositor.checkAddress();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits/fills if this is undesirable.\n        // This will underflow if quoteTimestamp is more than depositQuoteTimeBuffer;\n        // this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        uint256 currentTime = getCurrentTime();\n        if (currentTime < params.quoteTimestamp || currentTime - params.quoteTimestamp > depositQuoteTimeBuffer)\n            revert InvalidQuoteTimestamp();\n\n        // fillDeadline is relative to the destination chain.\n        // Dont allow fillDeadline to be more than several bundles into the future.\n        // This limits the maximum required lookback for dataworker and relayer instances.\n        if (params.fillDeadline > currentTime + fillDeadlineBuffer) revert InvalidFillDeadline();\n\n        // There are three cases for setting the exclusivity deadline using the exclusivity parameter:\n        // 1. If this parameter is 0, then there is no exclusivity period and emit 0 for the deadline. This\n        //    means that fillers of this deposit do not have to worry about the block.timestamp of this event changing\n        //    due to re-orgs when filling this deposit.\n        // 2. If the exclusivity parameter is less than or equal to MAX_EXCLUSIVITY_PERIOD_SECONDS, then the exclusivity\n        //    deadline is set to the block.timestamp of this event plus the exclusivity parameter. This means that the\n        //    filler of this deposit assumes re-org risk when filling this deposit because the block.timestamp of this\n        //    event affects the exclusivity deadline.\n        // 3. Otherwise, interpret this parameter as a timestamp and emit it as the exclusivity deadline. This means\n        //    that the filler of this deposit will not assume re-org risk related to the block.timestamp of this\n        //    event changing.\n        uint32 exclusivityDeadline = params.exclusivityParameter;\n        if (exclusivityDeadline > 0) {\n            if (exclusivityDeadline <= MAX_EXCLUSIVITY_PERIOD_SECONDS) {\n                exclusivityDeadline += uint32(currentTime);\n            }\n\n            // As a safety measure, prevent caller from inadvertently locking funds during exclusivity period\n            //  by forcing them to specify an exclusive relayer.\n            if (params.exclusiveRelayer == bytes32(0)) revert InvalidExclusiveRelayer();\n        }\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending the native token. In this case, the native token should be\n        // wrapped.\n        if (params.inputToken == address(wrappedNativeToken).toBytes32() && msg.value > 0) {\n            if (msg.value != params.inputAmount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the caller as per normal.\n            // Note: this includes the case where the L2 caller has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else {\n            // msg.value should be 0 if input token isn't the wrapped native token.\n            if (msg.value != 0) revert MsgValueDoesNotMatchInputAmount();\n            IERC20Upgradeable(params.inputToken.toAddress()).safeTransferFrom(\n                msg.sender,\n                address(this),\n                params.inputAmount\n            );\n        }\n\n        emit FundsDeposited(\n            params.inputToken,\n            params.outputToken,\n            params.inputAmount,\n            params.outputAmount,\n            params.destinationChainId,\n            params.depositId,\n            params.quoteTimestamp,\n            params.fillDeadline,\n            exclusivityDeadline,\n            params.depositor,\n            params.recipient,\n            params.exclusiveRelayer,\n            params.message\n        );\n    }\n\n    function _deposit(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message\n    ) internal {\n        // We limit the relay fees to prevent the user spending all their funds on fees.\n        if (SignedMath.abs(relayerFeePct) >= 0.5e18) revert InvalidRelayerFeePct();\n        if (amount > MAX_TRANSFER_SIZE) revert MaxTransferSizeExceeded();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits if this is undesirable. This will underflow if\n        // quoteTimestamp is more than depositQuoteTimeBuffer; this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        if (getCurrentTime() - quoteTimestamp > depositQuoteTimeBuffer) revert InvalidQuoteTimestamp();\n\n        // Increment count of deposits so that deposit ID for this spoke pool is unique.\n        uint32 newDepositId = numberOfDeposits++;\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending ETH. In this case, the ETH should be deposited to wrappedNativeToken.\n        if (originToken == address(wrappedNativeToken) && msg.value > 0) {\n            if (msg.value != amount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the user's wallet as per normal.\n            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else {\n            IERC20Upgradeable(originToken).safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit FundsDeposited(\n            originToken.toBytes32(), // inputToken\n            bytes32(0), // outputToken. Setting this to 0x0 means that the outputToken should be assumed to be the\n            // canonical token for the destination chain matching the inputToken. Therefore, this deposit\n            // can always be slow filled.\n            // - setting token to 0x0 will signal to off-chain validator that the \"equivalent\"\n            // token as the inputToken for the destination chain should be replaced here.\n            amount, // inputAmount\n            _computeAmountPostFees(amount, relayerFeePct), // outputAmount\n            // - output amount will be the deposit amount less relayerFeePct, which should now be set\n            // equal to realizedLpFeePct + gasFeePct + capitalCostFeePct where (gasFeePct + capitalCostFeePct)\n            // is equal to the old usage of `relayerFeePct`.\n            destinationChainId,\n            newDepositId,\n            quoteTimestamp,\n            INFINITE_FILL_DEADLINE, // fillDeadline. Default to infinite expiry because\n            // expired deposits refunds could be a breaking change for existing users of this function.\n            0, // exclusivityDeadline. Setting this to 0 along with the exclusiveRelayer to 0x0 means that there\n            // is no exclusive deadline\n            depositor.toBytes32(),\n            recipient.toBytes32(),\n            bytes32(0), // exclusiveRelayer. Setting this to 0x0 will signal to off-chain validator that there\n            // is no exclusive relayer.\n            message\n        );\n    }\n\n    function _distributeRelayerRefunds(\n        uint256 _chainId,\n        uint256 amountToReturn,\n        uint256[] memory refundAmounts,\n        uint32 leafId,\n        address l2TokenAddress,\n        address[] memory refundAddresses\n    ) internal returns (bool deferredRefunds) {\n        uint256 numRefunds = refundAmounts.length;\n        if (refundAddresses.length != numRefunds) revert InvalidMerkleLeaf();\n\n        if (numRefunds > 0) {\n            uint256 spokeStartBalance = IERC20Upgradeable(l2TokenAddress).balanceOf(address(this));\n            uint256 totalRefundedAmount = 0; // Track the total amount refunded.\n\n            // Send each relayer refund address the associated refundAmount for the L2 token address.\n            // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.\n            for (uint256 i = 0; i < numRefunds; ++i) {\n                if (refundAmounts[i] > 0) {\n                    totalRefundedAmount += refundAmounts[i];\n\n                    // Only if the total refunded amount exceeds the spoke starting balance, should we revert. This\n                    // ensures that bundles are atomic, if we have sufficient balance to refund all relayers and\n                    // prevents can only re-pay some of the relayers.\n                    if (totalRefundedAmount > spokeStartBalance) revert InsufficientSpokePoolBalanceToExecuteLeaf();\n\n                    bool success = _noRevertTransfer(l2TokenAddress, refundAddresses[i], refundAmounts[i]);\n\n                    // If the transfer failed then track a deferred transfer for the relayer. Given this function would\n                    // have reverted if there was insufficient balance, this will only happen if the transfer call\n                    // reverts. This will only occur if the underlying transfer method on the l2Token reverts due to\n                    // recipient blacklisting or other related modifications to the l2Token.transfer method.\n                    if (!success) {\n                        relayerRefund[l2TokenAddress][refundAddresses[i]] += refundAmounts[i];\n                        deferredRefunds = true;\n                    }\n                }\n            }\n        }\n        // If leaf's amountToReturn is positive, then send L2 --> L1 message to bridge tokens back via\n        // chain-specific bridging method.\n        if (amountToReturn > 0) {\n            _bridgeTokensToHubPool(amountToReturn, l2TokenAddress);\n\n            emit TokensBridged(amountToReturn, _chainId, leafId, l2TokenAddress.toBytes32(), msg.sender);\n        }\n    }\n\n    // Re-implementation of OZ _callOptionalReturnBool to use private logic. Function executes a transfer and returns a\n    // bool indicating if the external call was successful, rather than reverting. Original method:\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/28aed34dc5e025e61ea0390c18cac875bfde1a78/contracts/token/ERC20/utils/SafeERC20.sol#L188\n    function _noRevertTransfer(address token, address to, uint256 amount) internal returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        bytes memory data = abi.encodeCall(IERC20Upgradeable.transfer, (to, amount));\n        assembly {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n\n    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {\n        if (newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = newCrossDomainAdmin;\n        emit SetXDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function _setWithdrawalRecipient(address newWithdrawalRecipient) internal {\n        if (newWithdrawalRecipient == address(0)) revert InvalidWithdrawalRecipient();\n        withdrawalRecipient = newWithdrawalRecipient;\n        emit SetWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    function _preExecuteLeafHook(address) internal virtual {\n        // This method by default is a no-op. Different child spoke pools might want to execute functionality here\n        // such as wrapping any native tokens owned by the contract into wrapped tokens before proceeding with\n        // executing the leaf.\n    }\n\n    // Should be overriden by implementing contract depending on how L2 handles sending tokens to L1.\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual;\n\n    function _setClaimedLeaf(uint32 rootBundleId, uint32 leafId) internal {\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Verify the leafId in the leaf has not yet been claimed.\n        if (MerkleLib.isClaimed(rootBundle.claimedBitmap, leafId)) revert ClaimedMerkleLeaf();\n\n        // Set leaf as claimed in bitmap. This is passed by reference to the storage rootBundle.\n        MerkleLib.setClaimed(rootBundle.claimedBitmap, leafId);\n    }\n\n    function _verifyUpdateV3DepositMessage(\n        address depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature,\n        bytes32 hashType\n    ) internal view {\n        // A depositor can request to modify an un-relayed deposit by signing a hash containing the updated\n        // details and information uniquely identifying the deposit to relay. This information ensures\n        // that this signature cannot be re-used for other deposits.\n        bytes32 expectedTypedDataV4Hash = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    hashType,\n                    depositId,\n                    originChainId,\n                    updatedOutputAmount,\n                    updatedRecipient,\n                    keccak256(updatedMessage)\n                )\n            ),\n            originChainId\n        );\n        _verifyDepositorSignature(depositor, expectedTypedDataV4Hash, depositorSignature);\n    }\n\n    // This function is isolated and made virtual to allow different L2's to implement chain specific recovery of\n    // signers from signatures because some L2s might not support ecrecover. To be safe, consider always reverting\n    // this function for L2s where ecrecover is different from how it works on Ethereum, otherwise there is the\n    // potential to forge a signature from the depositor using a different private key than the original depositor's.\n    function _verifyDepositorSignature(\n        address depositor,\n        bytes32 ethSignedMessageHash,\n        bytes memory depositorSignature\n    ) internal view virtual {\n        // Note:\n        // - We don't need to worry about re-entrancy from a contract deployed at the depositor address since the method\n        //   `SignatureChecker.isValidSignatureNow` is a view method. Re-entrancy can happen, but it cannot affect state.\n        // - EIP-1271 signatures are supported. This means that a signature valid now, may not be valid later and vice-versa.\n        // - For an EIP-1271 signature to work, the depositor contract address must map to a deployed contract on the destination\n        //   chain that can validate the signature.\n        // - Regular signatures from an EOA are also supported.\n        bool isValid = SignatureChecker.isValidSignatureNow(depositor, ethSignedMessageHash, depositorSignature);\n        if (!isValid) revert InvalidDepositorSignature();\n    }\n\n    function _verifyV3SlowFill(\n        V3RelayExecutionParams memory relayExecution,\n        uint32 rootBundleId,\n        bytes32[] memory proof\n    ) internal view {\n        V3SlowFill memory slowFill = V3SlowFill({\n            relayData: relayExecution.relay,\n            chainId: chainId(),\n            updatedOutputAmount: relayExecution.updatedOutputAmount\n        });\n\n        if (!MerkleLib.verifyV3SlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, slowFill, proof)) {\n            revert InvalidMerkleProof();\n        }\n    }\n\n    function _computeAmountPostFees(uint256 amount, int256 feesPct) private pure returns (uint256) {\n        return (amount * uint256(int256(1e18) - feesPct)) / 1e18;\n    }\n\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends wrappedNativeToken.\n    function _unwrapwrappedNativeTokenTo(address payable to, uint256 amount) internal {\n        if (!address(to).isContract() || _is7702DelegatedWallet(to)) {\n            wrappedNativeToken.withdraw(amount);\n            AddressLibUpgradeable.sendValue(to, amount);\n        } else {\n            IERC20Upgradeable(address(wrappedNativeToken)).safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Checks if an address is a 7702 delegated wallet (EOA with delegated code).\n     * @param account The address to check.\n     * @return True if the address is a 7702 delegated wallet, false otherwise.\n     */\n    function _is7702DelegatedWallet(address account) internal view returns (bool) {\n        return bytes3(account.code) == EIP7702_PREFIX;\n    }\n\n    // @param relayer: relayer who is actually credited as filling this deposit. Can be different from\n    // exclusiveRelayer if passed exclusivityDeadline or if slow fill.\n    function _fillRelayV3(V3RelayExecutionParams memory relayExecution, bytes32 relayer, bool isSlowFill) internal {\n        V3RelayData memory relayData = relayExecution.relay;\n\n        if (relayData.fillDeadline < getCurrentTime()) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = relayExecution.relayHash;\n\n        // If a slow fill for this fill was requested then the relayFills value for this hash will be\n        // FillStatus.RequestedSlowFill. Therefore, if this is the status, then this fast fill\n        // will be replacing the slow fill. If this is a slow fill execution, then the following variable\n        // is trivially true. We'll emit this value in the FilledRelay\n        // event to assist the Dataworker in knowing when to return funds back to the HubPool that can no longer\n        // be used for a slow fill execution.\n        FillType fillType = isSlowFill\n            ? FillType.SlowFill // The following is true if this is a fast fill that was sent after a slow fill request.\n            : (\n                fillStatuses[relayExecution.relayHash] == uint256(FillStatus.RequestedSlowFill)\n                    ? FillType.ReplacedSlowFill\n                    : FillType.FastFill\n            );\n\n        // @dev This function doesn't support partial fills. Therefore, we associate the relay hash with\n        // an enum tracking its fill status. All filled relays, whether slow or fast fills, are set to the Filled\n        // status. However, we also use this slot to track whether this fill had a slow fill requested. Therefore\n        // we can include a bool in the FilledRelay event making it easy for the dataworker to compute if this\n        // fill was a fast fill that replaced a slow fill and therefore this SpokePool has excess funds that it\n        // needs to send back to the HubPool.\n        if (fillStatuses[relayHash] == uint256(FillStatus.Filled)) revert RelayFilled();\n        fillStatuses[relayHash] = uint256(FillStatus.Filled);\n\n        // @dev Before returning early, emit events to assist the dataworker in being able to know which fills were\n        // successful.\n        emit FilledRelay(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayExecution.repaymentChainId,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayer,\n            relayData.depositor,\n            relayData.recipient,\n            _hashNonEmptyMessage(relayData.message),\n            V3RelayExecutionEventInfo({\n                updatedRecipient: relayExecution.updatedRecipient,\n                updatedMessageHash: _hashNonEmptyMessage(relayExecution.updatedMessage),\n                updatedOutputAmount: relayExecution.updatedOutputAmount,\n                fillType: fillType\n            })\n        );\n\n        address outputToken = relayData.outputToken.toAddress();\n        uint256 amountToSend = relayExecution.updatedOutputAmount;\n        address recipientToSend = relayExecution.updatedRecipient.toAddress();\n        // If relay token is wrappedNativeToken then unwrap and send native token.\n        // Stack too deep.\n        if (relayData.outputToken.toAddress() == address(wrappedNativeToken)) {\n            // Note: useContractFunds is True if we want to send funds to the recipient directly out of this contract,\n            // otherwise we expect the caller to send funds to the recipient. If useContractFunds is True and the\n            // recipient wants wrappedNativeToken, then we can assume that wrappedNativeToken is already in the\n            // contract, otherwise we'll need the user to send wrappedNativeToken to this contract. Regardless, we'll\n            // need to unwrap it to native token before sending to the user.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, address(this), amountToSend);\n            _unwrapwrappedNativeTokenTo(payable(recipientToSend), amountToSend);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else {\n            // Note: Similar to note above, send token directly from the contract to the user in the slow relay case.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, recipientToSend, amountToSend);\n            else IERC20Upgradeable(outputToken).safeTransfer(recipientToSend, amountToSend);\n        }\n\n        bytes memory updatedMessage = relayExecution.updatedMessage;\n        if (updatedMessage.length > 0 && recipientToSend.isContract()) {\n            AcrossMessageHandler(recipientToSend).handleV3AcrossMessage(\n                outputToken,\n                amountToSend,\n                msg.sender,\n                updatedMessage\n            );\n        }\n    }\n\n    // Determine whether the exclusivityDeadline implies active exclusivity.\n    function _fillIsExclusive(uint32 exclusivityDeadline, uint32 currentTime) internal pure returns (bool) {\n        return exclusivityDeadline >= currentTime;\n    }\n\n    // Helper for emitting message hash. For easier easier human readability we return bytes32(0) for empty message.\n    function _hashNonEmptyMessage(bytes memory message) internal pure returns (bytes32) {\n        if (message.length == 0) return bytes32(0);\n        else return keccak256(message);\n    }\n\n    function _setOftMessenger(address _token, address _messenger) private {\n        if (_messenger != address(0) && IOFT(_messenger).token() != _token) {\n            revert OFTTokenMismatch();\n        }\n        oftMessengers[_token] = _messenger;\n        emit SetOFTMessenger(_token, _messenger);\n    }\n\n    function _getOftMessenger(address _token) internal view returns (address) {\n        return oftMessengers[_token];\n    }\n\n    // Implementing contract needs to override this to ensure that only the appropriate cross chain admin can execute\n    // certain admin functions. For L2 contracts, the cross chain admin refers to some L1 address or contract, and for\n    // L1, this would just be the same admin of the HubPool.\n    function _requireAdminSender() internal virtual;\n\n    // Added to enable the this contract to receive native token (ETH). Used when unwrapping wrappedNativeToken.\n    receive() external payable {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added, so that the total number of slots taken by this contract remains constant. Per-contract\n    // storage layout information  can be found in storage-layouts/\n    // This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[997] private __gap;\n}\n"
    },
    "contracts/SpokePoolPeriphery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { MultiCaller } from \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { V3SpokePoolInterface } from \"./interfaces/V3SpokePoolInterface.sol\";\nimport { IERC20Auth } from \"./external/interfaces/IERC20Auth.sol\";\nimport { WETH9Interface } from \"./external/interfaces/WETH9Interface.sol\";\nimport { IPermit2 } from \"./external/interfaces/IPermit2.sol\";\nimport { PeripherySigningLib } from \"./libraries/PeripherySigningLib.sol\";\nimport { SpokePoolPeripheryInterface } from \"./interfaces/SpokePoolPeripheryInterface.sol\";\nimport { AddressToBytes32 } from \"./libraries/AddressConverters.sol\";\n\n/**\n * @title SwapProxy\n * @notice A dedicated proxy contract that isolates swap execution to mitigate frontrunning vulnerabilities.\n * The SpokePoolPeriphery transfers tokens to this contract, which performs the swap and returns tokens back to the periphery.\n * @custom:security-contact bugs@across.to\n */\ncontract SwapProxy is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // Canonical Permit2 contract address\n    IPermit2 public immutable permit2;\n\n    // EIP 1271 magic bytes indicating a valid signature.\n    bytes4 private constant EIP1271_VALID_SIGNATURE = 0x1626ba7e;\n\n    // EIP 1271 bytes indicating an invalid signature.\n    bytes4 private constant EIP1271_INVALID_SIGNATURE = 0xffffffff;\n\n    // Mapping from (token, spender) to nonce for Permit2 operations\n    mapping(address => mapping(address => uint48)) private permit2Nonces;\n\n    // Slot for checking whether this contract is expecting a callback from permit2. Used to confirm whether it should return a valid signature response.\n    bool private expectingPermit2Callback;\n\n    // Errors\n    error SwapFailed();\n    error UnsupportedTransferType();\n    error InvalidExchange();\n\n    /**\n     * @notice Constructs a new SwapProxy.\n     * @param _permit2 Address of the canonical permit2 contract.\n     */\n    constructor(address _permit2) {\n        permit2 = IPermit2(_permit2);\n    }\n\n    /**\n     * @notice Executes a swap on the given exchange with the provided calldata.\n     * @param inputToken The token to swap from\n     * @param outputToken The token to swap to\n     * @param inputAmount The amount of input tokens to swap\n     * @param exchange The exchange to perform the swap\n     * @param transferType The method of transferring tokens to the exchange\n     * @param routerCalldata The calldata to execute on the exchange\n     * @return outputAmount The actual amount of output tokens received from the swap\n     */\n    function performSwap(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        address exchange,\n        SpokePoolPeripheryInterface.TransferType transferType,\n        bytes calldata routerCalldata\n    ) external nonReentrant returns (uint256 outputAmount) {\n        // Prevent nonce invalidation attack by disallowing exchange to be the permit2 address\n        if (exchange == address(permit2)) revert InvalidExchange();\n\n        // We'll return the final balance of output tokens\n\n        // The exchange will either receive funds from this contract via:\n        // 1. A direct approval to spend funds on this contract (TransferType.Approval),\n        // 2. A direct transfer of funds to the exchange (TransferType.Transfer), or\n        // 3. A permit2 approval (TransferType.Permit2Approval)\n        if (transferType == SpokePoolPeripheryInterface.TransferType.Approval) {\n            IERC20(inputToken).forceApprove(exchange, inputAmount);\n        } else if (transferType == SpokePoolPeripheryInterface.TransferType.Transfer) {\n            IERC20(inputToken).safeTransfer(exchange, inputAmount);\n        } else if (transferType == SpokePoolPeripheryInterface.TransferType.Permit2Approval) {\n            IERC20(inputToken).forceApprove(address(permit2), inputAmount);\n            expectingPermit2Callback = true;\n            permit2.permit(\n                address(this), // owner\n                IPermit2.PermitSingle({\n                    details: IPermit2.PermitDetails({\n                        token: inputToken,\n                        amount: uint160(inputAmount),\n                        expiration: uint48(block.timestamp),\n                        nonce: permit2Nonces[inputToken][exchange]++\n                    }),\n                    spender: exchange,\n                    sigDeadline: block.timestamp\n                }), // permitSingle\n                \"\" // signature is unused. The only verification for a valid signature is if we are at this code block.\n            );\n            expectingPermit2Callback = false;\n        } else {\n            revert UnsupportedTransferType();\n        }\n\n        // Execute the swap\n        (bool success, ) = exchange.call(routerCalldata);\n        if (!success) revert SwapFailed();\n\n        // Get the final output token balance\n        uint256 outputBalance = IERC20(outputToken).balanceOf(address(this));\n\n        // Transfer all output tokens back to the periphery\n        IERC20(outputToken).safeTransfer(msg.sender, outputBalance);\n\n        // Return the net amount received from the swap\n        return outputBalance;\n    }\n\n    /**\n     * @notice Verifies that the signer is the owner of the signing contract.\n     * @dev This function is called by Permit2 during the permit process\n     * and we need to return a valid signature result to allow permit2 to succeed.\n     */\n    function isValidSignature(bytes32, bytes calldata) external view returns (bytes4 magicBytes) {\n        magicBytes = (msg.sender == address(permit2) && expectingPermit2Callback)\n            ? EIP1271_VALID_SIGNATURE\n            : EIP1271_INVALID_SIGNATURE;\n    }\n}\n\n/**\n * @title SpokePoolPeriphery\n * @notice Contract for performing more complex interactions with an Across spoke pool deployment.\n * @custom:security-contact bugs@across.to\n */\ncontract SpokePoolPeriphery is SpokePoolPeripheryInterface, ReentrancyGuard, MultiCaller, EIP712 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using AddressToBytes32 for address;\n\n    // Canonical Permit2 contract address.\n    IPermit2 public immutable permit2;\n\n    // Swap proxy used for isolating all swap operations\n    SwapProxy public immutable swapProxy;\n\n    // Mapping from user address to their current nonce\n    mapping(address => uint256) public permitNonces;\n\n    event SwapBeforeBridge(\n        address exchange,\n        bytes exchangeCalldata,\n        address indexed swapToken,\n        address indexed acrossInputToken,\n        uint256 swapTokenAmount,\n        uint256 acrossInputAmount,\n        bytes32 indexed acrossOutputToken,\n        uint256 acrossOutputAmount\n    );\n\n    /****************************************\n     *                ERRORS                *\n     ****************************************/\n    error MinimumExpectedInputAmount();\n    error InvalidMsgValue();\n    error InvalidSignature();\n    error InvalidMinExpectedInputAmount();\n    error InvalidNonce();\n\n    /**\n     * @notice Construct a new Periphery contract.\n     * @param _permit2 Address of the canonical permit2 contract.\n     */\n    constructor(IPermit2 _permit2) EIP712(\"ACROSS-PERIPHERY\", \"1.0.0\") {\n        require(address(_permit2) != address(0), \"Permit2 cannot be zero address\");\n        require(_isContract(address(_permit2)), \"Permit2 must be a contract\");\n        permit2 = _permit2;\n\n        // Deploy the swap proxy with reference to the permit2 address\n        swapProxy = new SwapProxy(address(_permit2));\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function depositNative(\n        address spokePool,\n        bytes32 recipient,\n        address inputToken,\n        uint256 inputAmount,\n        bytes32 outputToken,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes memory message\n    ) external payable override nonReentrant {\n        // Set msg.sender as the depositor so that msg.sender can speed up the deposit.\n        V3SpokePoolInterface(spokePool).deposit{ value: msg.value }(\n            msg.sender.toBytes32(),\n            recipient,\n            inputToken.toBytes32(),\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     * @dev Revert case: When enableProportionalAdjustment is true, the calculation\n     * depositData.outputAmount * returnAmount may overflow if the product exceeds 2^256-1,\n     * causing immediate transaction revert even when the final division result would fit.\n     * This case should be extremely rare as both values would need to be > 1e18 * 1e18.\n     * Users will only see a generic failure without explanatory error message.\n     * @dev Does not support native tokens as swap output. Only ERC20 tokens can be deposited via this function.\n     */\n    function swapAndBridge(SwapAndDepositData calldata swapAndDepositData) external payable override nonReentrant {\n        // If a user performs a swapAndBridge with the swap token as the native token, wrap the value and treat the rest of transaction\n        // as though the user deposited a wrapped native token.\n        if (msg.value != 0) {\n            if (msg.value != swapAndDepositData.swapTokenAmount) revert InvalidMsgValue();\n            // Assume swapToken implements WETH9 interface if sending value\n            WETH9Interface(swapAndDepositData.swapToken).deposit{ value: msg.value }();\n        } else {\n            // Transfer ERC20 tokens from sender to this contract\n            IERC20(swapAndDepositData.swapToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                swapAndDepositData.swapTokenAmount\n            );\n        }\n\n        _swapAndBridge(swapAndDepositData);\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     * @dev Revert case: When enableProportionalAdjustment is true, the calculation\n     * depositData.outputAmount * returnAmount may overflow if the product exceeds 2^256-1,\n     * causing immediate transaction revert even when the final division result would fit.\n     * This case should be extremely rare as both values would need to be > 1e18 * 1e18.\n     * Users will only see a generic failure without explanatory error message.\n     * @dev Does not support native tokens as swap output. Only ERC20 tokens can be deposited via this function.\n     */\n    function swapAndBridgeWithPermit(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        uint256 deadline,\n        bytes calldata permitSignature,\n        bytes calldata swapAndDepositDataSignature\n    ) external override nonReentrant {\n        (bytes32 r, bytes32 s, uint8 v) = PeripherySigningLib.deserializeSignature(permitSignature);\n        // Load variables used in this function onto the stack.\n        address _swapToken = swapAndDepositData.swapToken;\n        uint256 _swapTokenAmount = swapAndDepositData.swapTokenAmount;\n        uint256 _submissionFeeAmount = swapAndDepositData.submissionFees.amount;\n        address _submissionFeeRecipient = swapAndDepositData.submissionFees.recipient;\n        uint256 _pullAmount = _submissionFeeAmount + _swapTokenAmount;\n\n        // For permit transactions, we wrap the call in a try/catch block so that the transaction will continue even if the call to\n        // permit fails. For example, this may be useful if the permit signature, which can be redeemed by anyone, is executed by somebody\n        // other than this contract.\n        try IERC20Permit(_swapToken).permit(signatureOwner, address(this), _pullAmount, deadline, v, r, s) {} catch {}\n        IERC20(_swapToken).safeTransferFrom(signatureOwner, address(this), _pullAmount);\n        _paySubmissionFees(_swapToken, _submissionFeeRecipient, _submissionFeeAmount);\n        // Verify and increment nonce to prevent replay attacks.\n        _validateAndIncrementNonce(signatureOwner, swapAndDepositData.nonce);\n        // Verify that the signatureOwner signed the input swapAndDepositData.\n        _validateSignature(\n            signatureOwner,\n            PeripherySigningLib.hashSwapAndDepositData(swapAndDepositData),\n            swapAndDepositDataSignature\n        );\n        _swapAndBridge(swapAndDepositData);\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     * @dev Revert case: When enableProportionalAdjustment is true, the calculation\n     * depositData.outputAmount * returnAmount may overflow if the product exceeds 2^256-1,\n     * causing immediate transaction revert even when the final division result would fit.\n     * This case should be extremely rare as both values would need to be > 1e18 * 1e18.\n     * Users will only see a generic failure without explanatory error message.\n     * @dev Does not support native tokens as swap output. Only ERC20 tokens can be deposited via this function.\n     */\n    function swapAndBridgeWithPermit2(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        IPermit2.PermitTransferFrom calldata permit,\n        bytes calldata signature\n    ) external override nonReentrant {\n        bytes32 witness = PeripherySigningLib.hashSwapAndDepositData(swapAndDepositData);\n        uint256 _submissionFeeAmount = swapAndDepositData.submissionFees.amount;\n        IPermit2.SignatureTransferDetails memory transferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: swapAndDepositData.swapTokenAmount + _submissionFeeAmount\n        });\n\n        permit2.permitWitnessTransferFrom(\n            permit,\n            transferDetails,\n            signatureOwner,\n            witness,\n            PeripherySigningLib.EIP712_SWAP_AND_DEPOSIT_TYPE_STRING,\n            signature\n        );\n        _paySubmissionFees(\n            swapAndDepositData.swapToken,\n            swapAndDepositData.submissionFees.recipient,\n            _submissionFeeAmount\n        );\n        _swapAndBridge(swapAndDepositData);\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     * @dev Revert case: When enableProportionalAdjustment is true, the calculation\n     * depositData.outputAmount * returnAmount may overflow if the product exceeds 2^256-1,\n     * causing immediate transaction revert even when the final division result would fit.\n     * This case should be extremely rare as both values would need to be > 1e18 * 1e18.\n     * Users will only see a generic failure without explanatory error message.\n     * @dev Does not support native tokens as swap output. Only ERC20 tokens can be deposited via this function.\n     */\n    function swapAndBridgeWithAuthorization(\n        address signatureOwner,\n        SwapAndDepositData calldata swapAndDepositData,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes calldata receiveWithAuthSignature,\n        bytes calldata swapAndDepositDataSignature\n    ) external override nonReentrant {\n        (bytes32 r, bytes32 s, uint8 v) = PeripherySigningLib.deserializeSignature(receiveWithAuthSignature);\n        uint256 _submissionFeeAmount = swapAndDepositData.submissionFees.amount;\n        // While any contract can vacuously implement `receiveWithAuthorization` (or just have a fallback),\n        // if tokens were not sent to this contract, by this call to swapData.swapToken, this function will revert\n        // when attempting to swap tokens it does not own.\n        IERC20Auth(address(swapAndDepositData.swapToken)).receiveWithAuthorization(\n            signatureOwner,\n            address(this),\n            swapAndDepositData.swapTokenAmount + _submissionFeeAmount,\n            validAfter,\n            validBefore,\n            bytes32(swapAndDepositData.nonce),\n            v,\n            r,\n            s\n        );\n        _paySubmissionFees(\n            swapAndDepositData.swapToken,\n            swapAndDepositData.submissionFees.recipient,\n            _submissionFeeAmount\n        );\n\n        // Note: No need to validate our internal nonce for receiveWithAuthorization\n        // as EIP-3009 has its own nonce mechanism that prevents replay attacks.\n        //\n        // Design Decision: We reuse the receiveWithAuthorization nonce for our signatures,\n        // but not for permit, which creates a theoretical replay attack that we think is\n        // incredibly unlikely because this would require:\n        // 1. A token implementing both ERC-2612 and ERC-3009\n        // 2. A user using the same nonces for swapAndBridgeWithPermit and for swapAndBridgeWithAuthorization\n        // 3. Issuing these signatures within a short amount of time (limited by fillDeadlineBuffer)\n        // Verify that the signatureOwner signed the input swapAndDepositData.\n        _validateSignature(\n            signatureOwner,\n            PeripherySigningLib.hashSwapAndDepositData(swapAndDepositData),\n            swapAndDepositDataSignature\n        );\n        _swapAndBridge(swapAndDepositData);\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function depositWithPermit(\n        address signatureOwner,\n        DepositData calldata depositData,\n        uint256 deadline,\n        bytes calldata permitSignature,\n        bytes calldata depositDataSignature\n    ) external override nonReentrant {\n        (bytes32 r, bytes32 s, uint8 v) = PeripherySigningLib.deserializeSignature(permitSignature);\n        // Load variables used in this function onto the stack.\n        address _inputToken = depositData.baseDepositData.inputToken;\n        uint256 _inputAmount = depositData.inputAmount;\n        uint256 _submissionFeeAmount = depositData.submissionFees.amount;\n        address _submissionFeeRecipient = depositData.submissionFees.recipient;\n        uint256 _pullAmount = _submissionFeeAmount + _inputAmount;\n\n        // For permit transactions, we wrap the call in a try/catch block so that the transaction will continue even if the call to\n        // permit fails. For example, this may be useful if the permit signature, which can be redeemed by anyone, is executed by somebody\n        // other than this contract.\n        try IERC20Permit(_inputToken).permit(signatureOwner, address(this), _pullAmount, deadline, v, r, s) {} catch {}\n        IERC20(_inputToken).safeTransferFrom(signatureOwner, address(this), _pullAmount);\n        _paySubmissionFees(_inputToken, _submissionFeeRecipient, _submissionFeeAmount);\n\n        // Verify and increment nonce to prevent replay attacks.\n        _validateAndIncrementNonce(signatureOwner, depositData.nonce);\n        // Verify that the signatureOwner signed the input depositData.\n        _validateSignature(signatureOwner, PeripherySigningLib.hashDepositData(depositData), depositDataSignature);\n        _deposit(\n            depositData.spokePool,\n            depositData.baseDepositData.depositor,\n            depositData.baseDepositData.recipient,\n            _inputToken,\n            depositData.baseDepositData.outputToken,\n            _inputAmount,\n            depositData.baseDepositData.outputAmount,\n            depositData.baseDepositData.destinationChainId,\n            depositData.baseDepositData.exclusiveRelayer,\n            depositData.baseDepositData.quoteTimestamp,\n            depositData.baseDepositData.fillDeadline,\n            depositData.baseDepositData.exclusivityParameter,\n            depositData.baseDepositData.message\n        );\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function depositWithPermit2(\n        address signatureOwner,\n        DepositData calldata depositData,\n        IPermit2.PermitTransferFrom calldata permit,\n        bytes calldata signature\n    ) external override nonReentrant {\n        bytes32 witness = PeripherySigningLib.hashDepositData(depositData);\n        uint256 _submissionFeeAmount = depositData.submissionFees.amount;\n        IPermit2.SignatureTransferDetails memory transferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: depositData.inputAmount + _submissionFeeAmount\n        });\n\n        permit2.permitWitnessTransferFrom(\n            permit,\n            transferDetails,\n            signatureOwner,\n            witness,\n            PeripherySigningLib.EIP712_DEPOSIT_TYPE_STRING,\n            signature\n        );\n        _paySubmissionFees(\n            depositData.baseDepositData.inputToken,\n            depositData.submissionFees.recipient,\n            _submissionFeeAmount\n        );\n\n        _deposit(\n            depositData.spokePool,\n            depositData.baseDepositData.depositor,\n            depositData.baseDepositData.recipient,\n            depositData.baseDepositData.inputToken,\n            depositData.baseDepositData.outputToken,\n            depositData.inputAmount,\n            depositData.baseDepositData.outputAmount,\n            depositData.baseDepositData.destinationChainId,\n            depositData.baseDepositData.exclusiveRelayer,\n            depositData.baseDepositData.quoteTimestamp,\n            depositData.baseDepositData.fillDeadline,\n            depositData.baseDepositData.exclusivityParameter,\n            depositData.baseDepositData.message\n        );\n    }\n\n    /**\n     * @inheritdoc SpokePoolPeripheryInterface\n     */\n    function depositWithAuthorization(\n        address signatureOwner,\n        DepositData calldata depositData,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes calldata receiveWithAuthSignature,\n        bytes calldata depositDataSignature\n    ) external override nonReentrant {\n        // Load variables used multiple times onto the stack.\n        uint256 _inputAmount = depositData.inputAmount;\n        uint256 _submissionFeeAmount = depositData.submissionFees.amount;\n\n        // Redeem the receiveWithAuthSignature.\n        (bytes32 r, bytes32 s, uint8 v) = PeripherySigningLib.deserializeSignature(receiveWithAuthSignature);\n        IERC20Auth(depositData.baseDepositData.inputToken).receiveWithAuthorization(\n            signatureOwner,\n            address(this),\n            _inputAmount + _submissionFeeAmount,\n            validAfter,\n            validBefore,\n            bytes32(depositData.nonce),\n            v,\n            r,\n            s\n        );\n        _paySubmissionFees(\n            depositData.baseDepositData.inputToken,\n            depositData.submissionFees.recipient,\n            _submissionFeeAmount\n        );\n\n        // Note: No need to validate our internal nonce for receiveWithAuthorization\n        // as EIP-3009 has its own nonce mechanism that prevents replay attacks.\n        //\n        // Design Decision: We reuse the receiveWithAuthorization nonce for our signatures,\n        // but not for permit, which creates a theoretical replay attack that we think is\n        // incredibly unlikely because this would require:\n        // 1. A token implementing both ERC-2612 and ERC-3009\n        // 2. A user using the same nonces for depositWithPermit and for depositWithAuthorization\n        // 3. Issuing these signatures within a short amount of time (limited by fillDeadlineBuffer)\n        // Verify that the signatureOwner signed the input depositData.\n        _validateSignature(signatureOwner, PeripherySigningLib.hashDepositData(depositData), depositDataSignature);\n        _deposit(\n            depositData.spokePool,\n            depositData.baseDepositData.depositor,\n            depositData.baseDepositData.recipient,\n            depositData.baseDepositData.inputToken,\n            depositData.baseDepositData.outputToken,\n            _inputAmount,\n            depositData.baseDepositData.outputAmount,\n            depositData.baseDepositData.destinationChainId,\n            depositData.baseDepositData.exclusiveRelayer,\n            depositData.baseDepositData.quoteTimestamp,\n            depositData.baseDepositData.fillDeadline,\n            depositData.baseDepositData.exclusivityParameter,\n            depositData.baseDepositData.message\n        );\n    }\n\n    /**\n     * @notice Returns the contract's EIP712 domain separator, used to sign hashed DepositData/SwapAndDepositData types.\n     */\n    function domainSeparator() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @notice Validates that the typed data hash corresponds to the input signature owner and corresponding signature.\n     * @param signatureOwner The alledged signer of the input hash.\n     * @param typedDataHash The EIP712 data hash to check the signature against.\n     * @param signature The signature to validate.\n     */\n    function _validateSignature(address signatureOwner, bytes32 typedDataHash, bytes calldata signature) private view {\n        if (!SignatureChecker.isValidSignatureNow(signatureOwner, _hashTypedDataV4(typedDataHash), signature)) {\n            revert InvalidSignature();\n        }\n    }\n\n    /**\n     * @notice Validates and increments the user's nonce to prevent replay attacks.\n     * @param user The user whose nonce is being validated.\n     * @param providedNonce The provided nonce value.\n     */\n    function _validateAndIncrementNonce(address user, uint256 providedNonce) private {\n        if (permitNonces[user] != providedNonce) {\n            revert InvalidNonce();\n        }\n        permitNonces[user]++;\n    }\n\n    /**\n     * @notice Approves the spoke pool and calls `depositV3` function with the specified input parameters.\n     * @param depositor The address on the origin chain which should be treated as the depositor by Across, and will therefore receive refunds if this deposit\n     * is unfilled.\n     * @param recipient The address on the destination chain which should receive outputAmount of outputToken.\n     * @param inputToken The token to deposit on the origin chain.\n     * @param outputToken The token to receive on the destination chain.\n     * @param inputAmount The amount of the input token to deposit.\n     * @param outputAmount The amount of the output token to receive.\n     * @param destinationChainId The network ID for the destination chain.\n     * @param exclusiveRelayer The optional address for an Across relayer which may fill the deposit exclusively.\n     * @param quoteTimestamp The timestamp at which the relay and LP fee was calculated.\n     * @param fillDeadline The timestamp at which the deposit must be filled before it will be refunded by Across.\n     * @param exclusivityParameter The deadline or offset during which the exclusive relayer has rights to fill the deposit without contention.\n     * @param message The message to execute on the destination chain.\n     */\n    function _deposit(\n        address spokePool,\n        address depositor,\n        bytes32 recipient,\n        address inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) private {\n        IERC20(inputToken).forceApprove(spokePool, inputAmount);\n        V3SpokePoolInterface(spokePool).deposit(\n            depositor.toBytes32(),\n            recipient,\n            inputToken.toBytes32(),\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice Swaps a token on the origin chain before depositing into the Across spoke pool atomically.\n     * @param swapAndDepositData The parameters to use when calling both the swap on an exchange and bridging via an Across spoke pool.\n     */\n    function _swapAndBridge(SwapAndDepositData calldata swapAndDepositData) private {\n        // Load variables we use multiple times onto the stack.\n        IERC20 _swapToken = IERC20(swapAndDepositData.swapToken);\n        IERC20 _acrossInputToken = IERC20(swapAndDepositData.depositData.inputToken);\n        address _exchange = swapAndDepositData.exchange;\n        uint256 _swapTokenAmount = swapAndDepositData.swapTokenAmount;\n\n        // Transfer tokens to the swap proxy for executing the swap\n        _swapToken.safeTransfer(address(swapProxy), _swapTokenAmount);\n\n        // Execute the swap via the swap proxy using the appropriate transfer type\n        // This function will swap _swapToken for _acrossInputToken and return the amount of _acrossInputToken received\n        uint256 returnAmount = swapProxy.performSwap(\n            address(_swapToken),\n            address(_acrossInputToken),\n            _swapTokenAmount,\n            _exchange,\n            swapAndDepositData.transferType,\n            swapAndDepositData.routerCalldata\n        );\n\n        // Sanity check that received amount from swap is enough to submit Across deposit with.\n        if (returnAmount < swapAndDepositData.minExpectedInputTokenAmount) revert MinimumExpectedInputAmount();\n\n        // Calculate adjusted output amount based on whether proportional adjustment is enabled\n        if (swapAndDepositData.minExpectedInputTokenAmount == 0) revert InvalidMinExpectedInputAmount();\n        uint256 adjustedOutputAmount;\n        if (swapAndDepositData.enableProportionalAdjustment) {\n            // Adjust the output amount proportionally based on the returned input amount\n            adjustedOutputAmount =\n                (swapAndDepositData.depositData.outputAmount * returnAmount) /\n                swapAndDepositData.minExpectedInputTokenAmount;\n        } else {\n            // Use the fixed output amount without adjustment\n            adjustedOutputAmount = swapAndDepositData.depositData.outputAmount;\n        }\n\n        emit SwapBeforeBridge(\n            _exchange,\n            swapAndDepositData.routerCalldata,\n            address(_swapToken),\n            address(_acrossInputToken),\n            _swapTokenAmount,\n            returnAmount,\n            swapAndDepositData.depositData.outputToken,\n            adjustedOutputAmount\n        );\n\n        // Deposit the swapped tokens into Across and bridge them using remainder of input params.\n        _deposit(\n            swapAndDepositData.spokePool,\n            swapAndDepositData.depositData.depositor,\n            swapAndDepositData.depositData.recipient,\n            address(_acrossInputToken),\n            swapAndDepositData.depositData.outputToken,\n            returnAmount,\n            adjustedOutputAmount,\n            swapAndDepositData.depositData.destinationChainId,\n            swapAndDepositData.depositData.exclusiveRelayer,\n            swapAndDepositData.depositData.quoteTimestamp,\n            swapAndDepositData.depositData.fillDeadline,\n            swapAndDepositData.depositData.exclusivityParameter,\n            swapAndDepositData.depositData.message\n        );\n    }\n\n    function _paySubmissionFees(address feeToken, address recipient, uint256 amount) private {\n        if (amount > 0) {\n            // Use msg.sender as recipient if recipient is zero address, otherwise use the specified recipient\n            address feeRecipient = recipient == address(0) ? msg.sender : recipient;\n            IERC20(feeToken).safeTransfer(feeRecipient, amount);\n        }\n    }\n\n    /**\n     * @notice Internal function to check if an address is a contract\n     * @dev This is a replacement for OpenZeppelin's isContract function which is deprecated\n     * @param addr The address to check\n     * @return True if the address is a contract, false otherwise\n     */\n    function _isContract(address addr) private view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/Succinct_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./external/interfaces/SuccinctInterfaces.sol\";\n\n/**\n * @notice Succinct Spoke pool.\n */\ncontract Succinct_SpokePool is SpokePool, ITelepathyHandler {\n    // Address of the succinct AMB contract.\n    address public succinctTargetAmb;\n\n    // Chain where HubPool is deployed that is linked to this SpokePool.\n    uint16 public hubChainId;\n\n    // Warning: this variable should _never_ be touched outside of this contract. It is intentionally set to be\n    // private. Leaving it set to true can permanently disable admin calls.\n    bool private adminCallValidated;\n\n    event SetSuccinctTargetAmb(address indexed newSuccinctTargetAmb);\n    event ReceivedMessageFromL1(address indexed caller, address indexed rootMessageSender);\n\n    // Note: validating calls this way ensures that strange calls coming from the succinctTargetAmb won't be\n    // misinterpreted. Put differently, just checking that msg.sender == succinctTargetAmb is not sufficient.\n    // All calls that have admin privileges must be fired from within the handleTelepathy method that's gone\n    // through validation where the sender is checked and the sender from the other chain is also validated.\n    // This modifier sets the adminCallValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure adminCallValidated is set to True only once at beginning of processMessageFromRoot, which prevents\n        // processMessageFromRoot from being re-entered.\n        require(!adminCallValidated, \"adminCallValidated already set\");\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed.\n        adminCallValidated = true;\n\n        _;\n\n        // Reset adminCallValidated to false to disallow admin calls after this method exits.\n        adminCallValidated = false;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    )\n        SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            // Succinct_SpokePool does not use OFT messaging; setting destination eid and fee cap to 0\n            0,\n            0\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Succinct SpokePool.\n     * @param _hubChainId Chain ID of the chain where the HubPool is deployed.\n     * @param _succinctTargetAmb Address of the succinct AMB contract.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint16 _hubChainId,\n        address _succinctTargetAmb,\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        succinctTargetAmb = _succinctTargetAmb;\n        hubChainId = _hubChainId;\n    }\n\n    /**\n     * @notice Admin can reset the succinct contract address.\n     * @param _succinctTargetAmb Address of the succinct AMB contract.\n     */\n    function setSuccinctTargetAmb(address _succinctTargetAmb) external onlyAdmin {\n        succinctTargetAmb = _succinctTargetAmb;\n        emit SetSuccinctTargetAmb(_succinctTargetAmb);\n    }\n\n    /**\n     * @notice This will be called by Succinct AMB on this network to relay a message sent from the HubPool.\n     * @param _sourceChainId Chain ID of the chain where the message originated.\n     * @param _senderAddress Address of the sender on the chain where the message originated.\n     * @param _data Data to be received and executed on this contract.\n     */\n    function handleTelepathy(\n        uint16 _sourceChainId,\n        address _senderAddress,\n        bytes memory _data\n    ) external override validateInternalCalls returns (bytes4) {\n        // Validate msg.sender as succinct, the x-chain sender as being the hubPool (the admin) and the source chain as\n        // 1 (mainnet).\n        require(msg.sender == succinctTargetAmb, \"caller not succinct AMB\");\n        require(_senderAddress == crossDomainAdmin, \"sender not hubPool\");\n        require(_sourceChainId == hubChainId, \"source chain not hub chain\");\n\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(_data);\n        require(success, \"delegatecall failed\");\n\n        emit ReceivedMessageFromL1(msg.sender, _senderAddress);\n        return ITelepathyHandler.handleTelepathy.selector;\n    }\n\n    function _bridgeTokensToHubPool(uint256, address) internal override {\n        // This method is a no-op. If the chain intends to include bridging functionality, this must be overriden.\n        // If not, leaving this unimplemented means this method may be triggered, but the result will be that no\n        // balance is transferred.\n    }\n\n    // Check that the handleTelepathy method has validated the method to ensure the sender is authenticated.\n    function _requireAdminSender() internal view override {\n        require(adminCallValidated, \"Admin call not validated\");\n    }\n}\n"
    },
    "contracts/test/AcrossMessageHandlerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../SpokePool.sol\";\nimport \"../interfaces/V3SpokePoolInterface.sol\";\n\ncontract AcrossMessageHandlerMock is AcrossMessageHandler {\n    function handleV3AcrossMessage(\n        address tokenSent,\n        uint256 amount,\n        address relayer,\n        bytes memory message\n    ) external override {}\n}\n"
    },
    "contracts/test/ArbitrumMocks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ncontract ArbitrumMockErc20GatewayRouter {\n    function outboundTransferCustomRefund(\n        address,\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256,\n        bytes calldata _data\n    ) external payable returns (bytes memory) {\n        return _data;\n    }\n\n    function outboundTransfer(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256,\n        bytes calldata _data\n    ) external payable returns (bytes memory) {\n        return _data;\n    }\n\n    function getGateway(address) external view returns (address) {\n        return address(this);\n    }\n}\n\ncontract Inbox {\n    function createRetryableTicket(\n        address,\n        uint256,\n        uint256,\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) external pure returns (uint256) {\n        return 0;\n    }\n}\n\ncontract L2GatewayRouter {\n    mapping(address => address) l2Tokens;\n\n    event OutboundTransfer(address indexed l1Token, address indexed to, uint256 amount);\n\n    function outboundTransfer(\n        address l1Token,\n        address to,\n        uint256 amount,\n        bytes memory\n    ) public payable returns (bytes memory) {\n        emit OutboundTransfer(l1Token, to, amount);\n        return \"\";\n    }\n\n    function calculateL2TokenAddress(address l1Token) external view returns (address) {\n        return l2Tokens[l1Token];\n    }\n\n    function setL2TokenAddress(address l1Token, address l2Token) external {\n        l2Tokens[l1Token] = l2Token;\n    }\n}\n"
    },
    "contracts/test/ExpandedERC20WithBlacklist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@uma/core/contracts/common/implementation/ExpandedERC20.sol\";\n\ncontract ExpandedERC20WithBlacklist is ExpandedERC20 {\n    mapping(address => bool) public isBlackListed;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ExpandedERC20(name, symbol, decimals) {}\n\n    function setBlacklistStatus(address account, bool status) external {\n        isBlackListed[account] = status;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(!isBlackListed[to], \"Recipient is blacklisted\");\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/test/interfaces/MockV2SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Contains common data structures and functions used by all SpokePool implementations.\n */\ninterface MockV2SpokePoolInterface {\n    struct RelayData {\n        bytes32 depositor;\n        bytes32 recipient;\n        bytes32 destinationToken;\n        uint256 amount;\n        uint256 originChainId;\n        uint256 destinationChainId;\n        int64 realizedLpFeePct;\n        int64 relayerFeePct;\n        uint32 depositId;\n        bytes message;\n    }\n\n    struct RelayExecution {\n        RelayData relay;\n        bytes32 relayHash;\n        int64 updatedRelayerFeePct;\n        bytes32 updatedRecipient;\n        bytes updatedMessage;\n        uint256 repaymentChainId;\n        uint256 maxTokensToSend;\n        uint256 maxCount;\n        bool slowFill;\n        int256 payoutAdjustmentPct;\n    }\n\n    struct SlowFill {\n        RelayData relayData;\n        int256 payoutAdjustmentPct;\n    }\n}\n"
    },
    "contracts/test/MerkleLibTest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../MerkleLib.sol\";\nimport \"../interfaces/HubPoolInterface.sol\";\nimport \"../interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/MockV2SpokePoolInterface.sol\";\nimport \"./V2MerkleLib.sol\";\n\n/**\n * @notice Contract to test the MerkleLib.\n */\ncontract MerkleLibTest {\n    mapping(uint256 => uint256) public claimedBitMap;\n\n    uint256 public claimedBitMap1D;\n\n    function verifyPoolRebalance(\n        bytes32 root,\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifyPoolRebalance(root, rebalance, proof);\n    }\n\n    function verifyRelayerRefund(\n        bytes32 root,\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifyRelayerRefund(root, refund, proof);\n    }\n\n    function verifySlowRelayFulfillment(\n        bytes32 root,\n        MockV2SpokePoolInterface.SlowFill memory slowFill,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return V2MerkleLib.verifySlowRelayFulfillment(root, slowFill, proof);\n    }\n\n    function verifyV3SlowRelayFulfillment(\n        bytes32 root,\n        V3SpokePoolInterface.V3SlowFill memory slowFill,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifyV3SlowRelayFulfillment(root, slowFill, proof);\n    }\n\n    function isClaimed(uint256 index) public view returns (bool) {\n        return MerkleLib.isClaimed(claimedBitMap, index);\n    }\n\n    function setClaimed(uint256 index) public {\n        MerkleLib.setClaimed(claimedBitMap, index);\n    }\n\n    function isClaimed1D(uint8 index) public view returns (bool) {\n        return MerkleLib.isClaimed1D(claimedBitMap1D, index);\n    }\n\n    function setClaimed1D(uint8 index) public {\n        claimedBitMap1D = MerkleLib.setClaimed1D(claimedBitMap1D, index);\n    }\n}\n"
    },
    "contracts/test/MockBedrockStandardBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../Ovm_SpokePool.sol\";\n\n// Provides payable withdrawTo interface introduced on Bedrock\ncontract MockBedrockL2StandardBridge is IL2ERC20Bridge {\n    event ERC20WithdrawalInitiated(address indexed l2Token, address indexed to, uint256 amount);\n\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32,\n        bytes calldata\n    ) external payable {\n        emit ERC20WithdrawalInitiated(_l2Token, _to, _amount);\n    }\n\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32,\n        bytes calldata\n    ) external {\n        // Check that caller has approved this contract to pull funds, mirroring mainnet's behavior\n        IERC20(_localToken).transferFrom(msg.sender, address(this), _amount);\n        IERC20(_remoteToken).transfer(_to, _amount);\n    }\n}\n\ncontract MockBedrockL1StandardBridge {\n    event ETHDepositInitiated(address indexed to, uint256 amount);\n    event ERC20DepositInitiated(address indexed to, address l1Token, address l2Token, uint256 amount);\n\n    function depositERC20To(\n        address l1Token,\n        address l2Token,\n        address to,\n        uint256 amount,\n        uint32,\n        bytes calldata\n    ) external {\n        IERC20(l1Token).transferFrom(msg.sender, address(this), amount);\n        emit ERC20DepositInitiated(to, l1Token, l2Token, amount);\n    }\n\n    function depositETHTo(\n        address to,\n        uint32,\n        bytes calldata\n    ) external payable {\n        emit ETHDepositInitiated(to, msg.value);\n    }\n}\n\ncontract MockBedrockCrossDomainMessenger {\n    event MessageSent(address indexed target);\n\n    address private msgSender;\n\n    function sendMessage(\n        address target,\n        bytes calldata,\n        uint32\n    ) external {\n        emit MessageSent(target);\n    }\n\n    // Impersonates making a call on L2 from L1.\n    function impersonateCall(address target, bytes memory data) external payable returns (bytes memory) {\n        msgSender = msg.sender;\n        (bool success, bytes memory returnData) = target.call{ value: msg.value }(data);\n\n        // Revert if call reverted.\n        if (!success) {\n            assembly {\n                revert(add(32, returnData), mload(returnData))\n            }\n        }\n        return returnData;\n    }\n\n    function xDomainMessageSender() external view returns (address) {\n        return msgSender;\n    }\n}\n"
    },
    "contracts/test/MockBlastUsdYieldManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { USDYieldManager } from \"../Blast_DaiRetriever.sol\";\n\ncontract MockBlastUsdYieldManager is USDYieldManager {\n    bool public shouldFail;\n\n    constructor() {\n        shouldFail = false;\n    }\n\n    function setShouldFail(bool _shouldFail) external {\n        shouldFail = _shouldFail;\n    }\n\n    function claimWithdrawal(uint256 _requestId, uint256 _hintId) external returns (bool success) {\n        success = !shouldFail;\n    }\n}\n"
    },
    "contracts/test/MockCaller.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/SpokePoolInterface.sol\";\n\n// Used for calling SpokePool.sol functions from a contract instead of an EOA. Can be used to simulate aggregator\n// or pooled relayer behavior. Makes all calls from constructor to make sure SpokePool is not relying on checking the\n// caller's code size which is 0 at construction time.\n\ncontract MockCaller {\n    constructor(\n        address _spokePool,\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) {\n        require(_spokePool != address(this), \"spokePool not external\");\n        SpokePoolInterface(_spokePool).executeRelayerRefundLeaf(rootBundleId, relayerRefundLeaf, proof);\n    }\n}\n"
    },
    "contracts/test/MockCCTP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\n\ncontract MockCCTPMinter is ITokenMinter {\n    function burnLimitsPerMessage(address) external pure returns (uint256) {\n        return type(uint256).max;\n    }\n}\n\ncontract MockCCTPMessenger is ITokenMessenger {\n    ITokenMinter private minter;\n\n    constructor(ITokenMinter _minter) {\n        minter = _minter;\n    }\n\n    function depositForBurn(\n        uint256,\n        uint32,\n        bytes32,\n        address\n    ) external pure returns (uint64 _nonce) {\n        return 0;\n    }\n\n    function localMinter() external view returns (ITokenMinter) {\n        return minter;\n    }\n}\n"
    },
    "contracts/test/MockERC1271.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MockERC1271\n * @notice Implements mocked ERC1271 contract for testing.\n */\ncontract MockERC1271 is IERC1271, Ownable {\n    constructor(address originalOwner) {\n        transferOwnership(originalOwner);\n    }\n\n    function isValidSignature(bytes32 hash, bytes memory signature) public view override returns (bytes4 magicValue) {\n        return ECDSA.recover(hash, signature) == owner() ? this.isValidSignature.selector : bytes4(0);\n    }\n}\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { IERC20Auth } from \"../external/interfaces/IERC20Auth.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\n/**\n * @title MockERC20\n * @notice Implements mocked ERC20 contract with various features.\n */\ncontract MockERC20 is IERC20Auth, ERC20Permit {\n    bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =\n        keccak256(\n            \"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\"\n        );\n    // Expose the typehash in ERC20Permit.\n    bytes32 public constant PERMIT_TYPEHASH_EXTERNAL =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    constructor() ERC20Permit(\"MockERC20\") ERC20(\"MockERC20\", \"ERC20\") {}\n\n    // This does no nonce checking.\n    function receiveWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(validAfter <= block.timestamp && validBefore >= block.timestamp, \"Invalid time bounds\");\n        require(msg.sender == to, \"Receiver not caller\");\n        bytes memory signature = bytes.concat(r, s, bytes1(v));\n\n        bytes32 structHash = keccak256(\n            abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce)\n        );\n        bytes32 sigHash = _hashTypedDataV4(structHash);\n        require(SignatureChecker.isValidSignatureNow(from, sigHash, signature), \"Invalid signature\");\n        _transfer(from, to, value);\n    }\n\n    function hashTypedData(bytes32 typedData) external view returns (bytes32) {\n        return _hashTypedDataV4(typedData);\n    }\n}\n"
    },
    "contracts/test/MockHubPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { HubPoolInterface } from \"../interfaces/HubPoolInterface.sol\";\n\n/// @title MockHubPool for Token Relay between Layer 1 and Layer 2\n/// @dev This contract acts as a mock implementation for testing purposes,\n///      simulating the behavior of a hub pool that can relay tokens and messages\n///      between Ethereum (Layer 1) and a Layer 2 solution like Optimism.\n///      It delegates calls to an external chain adapter contract for actual execution.\ncontract MockHubPool {\n    /// @notice Emitted when the adapter contract address is changed.\n    event AdapterChanged(address indexed oldAdapter, address indexed newAdapter);\n\n    /// @notice The address of the contract owner, set to the deployer of the contract.\n    address public immutable owner;\n    /// @notice The address of the adapter contract responsible for handling\n    ///         token relay and message passing to Layer 2.\n    address public adapter;\n\n    HubPoolInterface.RootBundle public rootBundleProposal;\n\n    /// @notice Creates a new MockHubPool and sets the owner and initial adapter.\n    /// @param _adapter The address of the initial adapter contract.\n    constructor(address _adapter) {\n        adapter = _adapter;\n        owner = msg.sender; // Set the contract deployer as the owner\n    }\n\n    /// @notice Ensures that a function is callable only by the contract owner.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    /// @notice Fallback function to receive ETH.\n    fallback() external payable {} // solhint-disable-line no-empty-blocks\n\n    /// @notice Receive function to handle direct ETH transfers.\n    receive() external payable {} // solhint-disable-line no-empty-blocks\n\n    /// @notice Changes the adapter contract address.\n    /// @dev This function can only be called by the contract owner.\n    /// @param _adapter The new adapter contract address.\n    function changeAdapter(address _adapter) public onlyOwner {\n        require(_adapter != address(0), \"NO_ZERO_ADDRESS\");\n        address _oldAdapter = adapter;\n        adapter = _adapter;\n        emit AdapterChanged(_oldAdapter, _adapter);\n    }\n\n    function setPendingRootBundle(HubPoolInterface.RootBundle memory _rootBundleProposal) external {\n        rootBundleProposal = _rootBundleProposal;\n    }\n\n    /// @notice Relays tokens from L1 to L2 using the adapter contract.\n    /// @dev This function delegates the call to the adapter contract.\n    /// @param l1Token The address of the L1 token to relay.\n    /// @param l2Token The address of the L2 token to receive.\n    /// @param amount The amount of tokens to relay.\n    /// @param to The address on L2 to receive the tokens.\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external {\n        (bool success, ) = adapter.delegatecall(\n            abi.encodeWithSignature(\n                \"relayTokens(address,address,uint256,address)\",\n                l1Token, // l1Token.\n                l2Token, // l2Token.\n                amount, // amount.\n                to // to. This should be the spokePool.\n            )\n        );\n        require(success, \"delegatecall failed\");\n    }\n\n    /// @notice Queries the balance of a user for a specific L2 token using the adapter contract.\n    /// @dev This function delegates the call to the adapter contract to execute the balance check.\n    /// @param l2Token The address of the L2 token.\n    /// @param user The user address whose balance is being queried.\n    function balanceOf(address l2Token, address user) external {\n        (bool success, ) = adapter.delegatecall(\n            abi.encodeWithSignature(\n                \"relayMessage(address,bytes)\",\n                l2Token,\n                abi.encodeWithSignature(\"balanceOf(address)\", user) // message\n            )\n        );\n        require(success, \"delegatecall failed\");\n    }\n\n    /// @notice Relays an arbitrary message to the L2 chain via the adapter contract.\n    /// @dev This function delegates the call to the adapter contract to execute the message relay.\n    /// @param target The address of the target contract on L2.\n    /// @param l2CallData The calldata to send to the target contract on L2. (must be abi encoded)\n    function arbitraryMessage(address target, bytes memory l2CallData) external {\n        (bool success, ) = adapter.delegatecall(\n            abi.encodeWithSignature(\"relayMessage(address,bytes)\", target, l2CallData)\n        );\n        require(success, \"delegatecall failed\");\n    }\n}\n"
    },
    "contracts/test/MockOFTMessenger.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IOFT.sol\";\n\n/**\n * @notice Facilitate bridging tokens via LayerZero's OFT.\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\n * @custom:security-contact bugs@across.to\n */\ncontract MockOFTMessenger is IOFT {\n    address public token;\n    uint256 public nativeFee;\n    uint256 public lzFee;\n    uint256 public amountSentLDToReturn;\n    uint256 public amountReceivedLDToReturn;\n    bool public useCustomReceipt;\n\n    constructor(address _token) {\n        token = _token;\n    }\n\n    function quoteSend(\n        SendParam calldata, /*_sendParam*/\n        bool /*_payInLzToken*/\n    ) external view returns (MessagingFee memory) {\n        return MessagingFee(nativeFee, lzFee);\n    }\n\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata, /*_fee*/\n        address /*_refundAddress*/\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory) {\n        if (useCustomReceipt) {\n            return (\n                MessagingReceipt(0, 0, MessagingFee(0, 0)),\n                OFTReceipt(amountSentLDToReturn, amountReceivedLDToReturn)\n            );\n        }\n        return (MessagingReceipt(0, 0, MessagingFee(0, 0)), OFTReceipt(_sendParam.amountLD, _sendParam.amountLD));\n    }\n\n    function setLDAmountsToReturn(uint256 _amountSentLD, uint256 _amountReceivedLD) external {\n        amountSentLDToReturn = _amountSentLD;\n        amountReceivedLDToReturn = _amountReceivedLD;\n        useCustomReceipt = true;\n    }\n\n    function resetReceipt() external {\n        useCustomReceipt = false;\n    }\n\n    function setFeesToReturn(uint256 _nativeFee, uint256 _lzFee) external {\n        nativeFee = _nativeFee;\n        lzFee = _lzFee;\n    }\n}\n"
    },
    "contracts/test/MockOptimism_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../Ovm_SpokePool.sol\";\n\n/**\n * @notice Mock Optimism Spoke pool allowing deployer to override constructor params.\n */\ncontract MockOptimism_SpokePool is Ovm_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wrappedNativeTokenAddress)\n        Ovm_SpokePool(_wrappedNativeTokenAddress, 1 hours, 9 hours, IERC20(address(0)), ITokenMessenger(address(0)))\n    {} // solhint-disable-line no-empty-blocks\n\n    function initialize(\n        address l2Eth,\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _hubPool\n    ) public initializer {\n        __OvmSpokePool_init(_initialDepositId, _crossDomainAdmin, _hubPool, l2Eth);\n    }\n}\n"
    },
    "contracts/test/MockPermit2.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport { IPermit2 } from \"../external/interfaces/IPermit2.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC1271 } from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\n// Taken from https://github.com/Uniswap/permit2/blob/main/src/EIP712.sol\ncontract Permit2EIP712 {\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private constant _HASHED_NAME = keccak256(\"Permit2\");\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    constructor() {\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME);\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            block.chainid == _CACHED_CHAIN_ID\n                ? _CACHED_DOMAIN_SEPARATOR\n                : _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME);\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 nameHash) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, block.chainid, address(this)));\n    }\n\n    function _hashTypedData(bytes32 dataHash) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), dataHash));\n    }\n}\n\ncontract MockPermit2 is IPermit2, Permit2EIP712 {\n    using SafeERC20 for IERC20;\n\n    mapping(address => mapping(uint256 => uint256)) public nonceBitmap;\n    mapping(address => mapping(address => mapping(address => uint256))) public allowance;\n\n    bytes32 public constant _TOKEN_PERMISSIONS_TYPEHASH = keccak256(\"TokenPermissions(address token,uint256 amount)\");\n    string public constant _PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB =\n        \"PermitWitnessTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline,\";\n\n    error SignatureExpired();\n    error InvalidAmount();\n    error InvalidNonce();\n    error AllowanceExpired();\n    error InsufficientAllowance();\n\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory _permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external override {\n        _permitTransferFrom(\n            _permit,\n            transferDetails,\n            owner,\n            hashWithWitness(_permit, witness, witnessTypeString),\n            signature\n        );\n    }\n\n    function transferFrom(address from, address to, uint160 amount, address token) external {\n        _transfer(from, to, amount, token);\n    }\n\n    // This is not a copy of permit2's permit.\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external {\n        if (block.timestamp > permitSingle.sigDeadline) revert SignatureExpired();\n\n        // Verify the signer address from the signature.\n        SignatureVerification.verify(signature, _hashTypedData(keccak256(abi.encode(permitSingle))), owner);\n\n        allowance[owner][permitSingle.details.token][permitSingle.spender] = permitSingle.details.amount;\n    }\n\n    // This is not a copy of permit2's permit.\n    function _transfer(address from, address to, uint160 amount, address token) private {\n        uint256 allowed = allowance[from][token][msg.sender];\n\n        if (allowed != type(uint160).max) {\n            if (amount > allowed) {\n                revert InsufficientAllowance();\n            } else {\n                unchecked {\n                    allowance[from][token][msg.sender] = uint160(allowed) - amount;\n                }\n            }\n        }\n\n        // Transfer the tokens from the from address to the recipient.\n        IERC20(token).safeTransferFrom(from, to, amount);\n    }\n\n    function _permitTransferFrom(\n        PermitTransferFrom memory _permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 dataHash,\n        bytes calldata signature\n    ) private {\n        uint256 requestedAmount = transferDetails.requestedAmount;\n\n        if (block.timestamp > _permit.deadline) revert SignatureExpired();\n        if (requestedAmount > _permit.permitted.amount) revert InvalidAmount();\n\n        _useUnorderedNonce(owner, _permit.nonce);\n\n        SignatureVerification.verify(signature, _hashTypedData(dataHash), owner);\n\n        IERC20(_permit.permitted.token).safeTransferFrom(owner, transferDetails.to, requestedAmount);\n    }\n\n    function bitmapPositions(uint256 nonce) private pure returns (uint256 wordPos, uint256 bitPos) {\n        wordPos = uint248(nonce >> 8);\n        bitPos = uint8(nonce);\n    }\n\n    function _useUnorderedNonce(address from, uint256 nonce) internal {\n        (uint256 wordPos, uint256 bitPos) = bitmapPositions(nonce);\n        uint256 bit = 1 << bitPos;\n        uint256 flipped = nonceBitmap[from][wordPos] ^= bit;\n\n        if (flipped & bit == 0) revert InvalidNonce();\n    }\n\n    function hashWithWitness(\n        PermitTransferFrom memory _permit,\n        bytes32 witness,\n        string calldata witnessTypeString\n    ) internal view returns (bytes32) {\n        bytes32 typeHash = keccak256(abi.encodePacked(_PERMIT_TRANSFER_FROM_WITNESS_TYPEHASH_STUB, witnessTypeString));\n\n        bytes32 tokenPermissionsHash = _hashTokenPermissions(_permit.permitted);\n        return\n            keccak256(abi.encode(typeHash, tokenPermissionsHash, msg.sender, _permit.nonce, _permit.deadline, witness));\n    }\n\n    function _hashTokenPermissions(TokenPermissions memory permitted) private pure returns (bytes32) {\n        return keccak256(abi.encode(_TOKEN_PERMISSIONS_TYPEHASH, permitted));\n    }\n}\n\n// Taken from https://github.com/Uniswap/permit2/blob/main/src/libraries/SignatureVerification.sol\nlibrary SignatureVerification {\n    error InvalidSignatureLength();\n    error InvalidSignature();\n    error InvalidSigner();\n    error InvalidContractSignature();\n\n    bytes32 constant UPPER_BIT_MASK = (0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n\n    function verify(bytes calldata signature, bytes32 hash, address claimedSigner) internal view {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (claimedSigner.code.length == 0) {\n            if (signature.length == 65) {\n                (r, s) = abi.decode(signature, (bytes32, bytes32));\n                v = uint8(signature[64]);\n            } else if (signature.length == 64) {\n                // EIP-2098\n                bytes32 vs;\n                (r, vs) = abi.decode(signature, (bytes32, bytes32));\n                s = vs & UPPER_BIT_MASK;\n                v = uint8(uint256(vs >> 255)) + 27;\n            } else {\n                revert InvalidSignatureLength();\n            }\n            address signer = ecrecover(hash, v, r, s);\n            if (signer == address(0)) revert InvalidSignature();\n            if (signer != claimedSigner) revert InvalidSigner();\n        } else {\n            bytes4 magicValue = IERC1271(claimedSigner).isValidSignature(hash, signature);\n            if (magicValue != IERC1271.isValidSignature.selector) revert InvalidContractSignature();\n        }\n    }\n}\n"
    },
    "contracts/test/MockSpokePool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../SpokePool.sol\";\nimport \"./interfaces/MockV2SpokePoolInterface.sol\";\nimport \"./V2MerkleLib.sol\";\nimport { AddressToBytes32, Bytes32ToAddress } from \"../libraries/AddressConverters.sol\";\n\n/**\n * @title MockSpokePool\n * @notice Implements abstract contract for testing.\n */\ncontract MockSpokePool is SpokePool, MockV2SpokePoolInterface, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressToBytes32 for address;\n    using Bytes32ToAddress for bytes32;\n\n    uint256 private chainId_;\n    uint256 private currentTime;\n    mapping(bytes32 => uint256) private relayFills;\n\n    uint256 public constant SLOW_FILL_MAX_TOKENS_TO_SEND = 1e40;\n\n    bytes32 public constant UPDATE_DEPOSIT_DETAILS_HASH =\n        keccak256(\n            \"UpdateDepositDetails(uint256 depositId,uint256 originChainId,int64 updatedRelayerFeePct,address updatedRecipient,bytes updatedMessage)\"\n        );\n\n    event BridgedToHubPool(uint256 amount, address token);\n    event PreLeafExecuteHook(bytes32 token);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wrappedNativeTokenAddress) SpokePool(_wrappedNativeTokenAddress, 1 hours, 9 hours, 0, 0) {} // solhint-disable-line no-empty-blocks\n\n    function initialize(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _hubPool\n    ) public initializer {\n        __Ownable_init();\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _hubPool);\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    function setCurrentTime(uint256 time) external {\n        currentTime = time;\n    }\n\n    function distributeRelayerRefunds(\n        uint256 _chainId,\n        uint256 amountToReturn,\n        uint256[] memory refundAmounts,\n        uint32 leafId,\n        address l2TokenAddress,\n        address[] memory refundAddresses\n    ) external {\n        _distributeRelayerRefunds(_chainId, amountToReturn, refundAmounts, leafId, l2TokenAddress, refundAddresses);\n    }\n\n    function _verifyUpdateDepositMessage(\n        address depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        int64 updatedRelayerFeePct,\n        bytes32 updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature\n    ) internal view {\n        bytes32 expectedTypedDataV4Hash = _hashTypedDataV4(\n            // EIP-712 compliant hash struct: https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct\n            keccak256(\n                abi.encode(\n                    UPDATE_DEPOSIT_DETAILS_HASH,\n                    depositId,\n                    originChainId,\n                    updatedRelayerFeePct,\n                    updatedRecipient,\n                    keccak256(updatedMessage)\n                )\n            ),\n            // By passing in the origin chain id, we enable the verification of the signature on a different chain\n            originChainId\n        );\n        _verifyDepositorSignature(depositor, expectedTypedDataV4Hash, depositorSignature);\n    }\n\n    function verifyUpdateV3DepositMessageBytes32(\n        bytes32 depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature\n    ) public view {\n        return\n            _verifyUpdateV3DepositMessage(\n                depositor.toAddress(),\n                depositId,\n                originChainId,\n                updatedOutputAmount,\n                updatedRecipient,\n                updatedMessage,\n                depositorSignature,\n                UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n            );\n    }\n\n    function verifyUpdateV3DepositMessage(\n        address depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature\n    ) public view {\n        return\n            _verifyUpdateV3DepositMessage(\n                depositor,\n                depositId,\n                originChainId,\n                updatedOutputAmount,\n                updatedRecipient.toBytes32(),\n                updatedMessage,\n                depositorSignature,\n                UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n            );\n    }\n\n    function fillRelayV3Internal(\n        V3RelayExecutionParams memory relayExecution,\n        bytes32 relayer,\n        bool isSlowFill\n    ) external {\n        _fillRelayV3(relayExecution, relayer, isSlowFill);\n    }\n\n    // This function is nonReentrant in order to allow caller to test whether a different function\n    // is reentrancy protected or not.\n    function callback(bytes memory data) external payable nonReentrant {\n        (bool success, bytes memory result) = address(this).call{ value: msg.value }(data);\n        require(success, string(result));\n    }\n\n    function setFillStatus(bytes32 relayHash, FillType fillType) external {\n        fillStatuses[relayHash] = uint256(fillType);\n    }\n\n    function getCurrentTime() public view override returns (uint256) {\n        return currentTime;\n    }\n\n    function _preExecuteLeafHook(address token) internal override {\n        emit PreLeafExecuteHook(token.toBytes32());\n    }\n\n    function _bridgeTokensToHubPool(uint256 amount, address token) internal override {\n        emit BridgedToHubPool(amount, token);\n    }\n\n    function _requireAdminSender() internal override onlyOwner {} // solhint-disable-line no-empty-blocks\n\n    function chainId() public view override(SpokePool) returns (uint256) {\n        // If chainId_ is set then return it, else do nothing and return the parent chainId().\n        return chainId_ == 0 ? super.chainId() : chainId_;\n    }\n\n    function setChainId(uint256 _chainId) public {\n        chainId_ = _chainId;\n    }\n\n    function _computeAmountPreFees(uint256 amount, int64 feesPct) private pure returns (uint256) {\n        return (1e18 * amount) / uint256((int256(1e18) - feesPct));\n    }\n\n    function __computeAmountPostFees(uint256 amount, int256 feesPct) private pure returns (uint256) {\n        return (amount * uint256(int256(1e18) - feesPct)) / 1e18;\n    }\n\n    function _getRelayHash(MockV2SpokePoolInterface.RelayData memory relayData) private pure returns (bytes32) {\n        return keccak256(abi.encode(relayData));\n    }\n\n    function _fillRelay(RelayExecution memory relayExecution) internal returns (uint256 fillAmountPreFees) {\n        MockV2SpokePoolInterface.RelayData memory relayData = relayExecution.relay;\n\n        require(relayFills[relayExecution.relayHash] < relayData.amount, \"relay filled\");\n\n        fillAmountPreFees = _computeAmountPreFees(\n            relayExecution.maxTokensToSend,\n            (relayData.realizedLpFeePct + relayExecution.updatedRelayerFeePct)\n        );\n        require(fillAmountPreFees > 0, \"fill amount pre fees is 0\");\n\n        uint256 amountRemainingInRelay = relayData.amount - relayFills[relayExecution.relayHash];\n        if (amountRemainingInRelay < fillAmountPreFees) {\n            fillAmountPreFees = amountRemainingInRelay;\n        }\n\n        uint256 amountToSend = __computeAmountPostFees(\n            fillAmountPreFees,\n            relayData.realizedLpFeePct + relayExecution.updatedRelayerFeePct\n        );\n\n        if (relayExecution.payoutAdjustmentPct != 0) {\n            require(relayExecution.payoutAdjustmentPct >= -1e18, \"payoutAdjustmentPct too small\");\n            require(relayExecution.payoutAdjustmentPct <= 100e18, \"payoutAdjustmentPct too large\");\n\n            amountToSend = __computeAmountPostFees(amountToSend, -relayExecution.payoutAdjustmentPct);\n            require(amountToSend <= relayExecution.maxTokensToSend, \"Somehow hit maxTokensToSend!\");\n        }\n\n        bool localRepayment = relayExecution.repaymentChainId == relayExecution.relay.destinationChainId;\n        require(\n            localRepayment || relayExecution.relay.amount == fillAmountPreFees || relayExecution.slowFill,\n            \"invalid repayment chain\"\n        );\n\n        relayFills[relayExecution.relayHash] += fillAmountPreFees;\n\n        if (msg.sender.toBytes32() == relayExecution.updatedRecipient && !relayExecution.slowFill) {\n            return fillAmountPreFees;\n        }\n\n        if (relayData.destinationToken == address(wrappedNativeToken).toBytes32()) {\n            if (!relayExecution.slowFill) {\n                IERC20Upgradeable(relayData.destinationToken.toAddress()).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amountToSend\n                );\n            }\n            _unwrapwrappedNativeTokenTo(payable(relayExecution.updatedRecipient.toAddress()), amountToSend);\n        } else {\n            if (!relayExecution.slowFill) {\n                IERC20Upgradeable(relayData.destinationToken.toAddress()).safeTransferFrom(\n                    msg.sender,\n                    relayExecution.updatedRecipient.toAddress(),\n                    amountToSend\n                );\n            } else {\n                IERC20Upgradeable(relayData.destinationToken.toAddress()).safeTransfer(\n                    relayExecution.updatedRecipient.toAddress(),\n                    amountToSend\n                );\n            }\n        }\n    }\n\n    function _verifySlowFill(\n        RelayExecution memory relayExecution,\n        uint32 rootBundleId,\n        bytes32[] memory proof\n    ) internal view {\n        SlowFill memory slowFill = SlowFill({\n            relayData: relayExecution.relay,\n            payoutAdjustmentPct: relayExecution.payoutAdjustmentPct\n        });\n\n        require(\n            V2MerkleLib.verifySlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, slowFill, proof),\n            \"Invalid slow relay proof\"\n        );\n    }\n}\n"
    },
    "contracts/test/MockSpokePoolV2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./MockSpokePool.sol\";\n\n/**\n * @title MockSpokePoolV2\n * @notice Upgrades MockSpokePool for no practical reason other than to demonstrate\n * upgradeability options\n */\ncontract MockSpokePoolV2 is MockSpokePool {\n    event NewEvent(bool value);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wrappedNativeTokenAddress) MockSpokePool(_wrappedNativeTokenAddress) {} // solhint-disable-line no-empty-blocks\n\n    // Demonstrative of how we could reset state variables in a V2 contract conveniently while initializing new\n    // modules. The `reinitializer` modifier is required to create new Initializable contracts.\n    function reinitialize(address _hubPool) public reinitializer(2) {\n        _setWithdrawalRecipient(_hubPool);\n    }\n\n    // Demonstrative new function we could add in a V2 contract.\n    function emitEvent() external {\n        emit NewEvent(true);\n    }\n}\n"
    },
    "contracts/test/MockZkStackBridgeHub.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { BridgeHubInterface } from \"../interfaces/ZkStackBridgeHub.sol\";\n\ncontract MockBridgeHub is BridgeHubInterface {\n    address public immutable sharedBridge;\n\n    constructor(address _sharedBridge) {\n        sharedBridge = _sharedBridge;\n    }\n\n    mapping(uint256 => address) baseTokens;\n\n    function setBaseToken(uint256 _chainId, address _baseToken) external {\n        baseTokens[_chainId] = _baseToken;\n    }\n\n    function requestL2TransactionDirect(L2TransactionRequestDirect calldata _request)\n        external\n        payable\n        returns (bytes32 canonicalTxHash)\n    {\n        canonicalTxHash = keccak256(abi.encode(_request));\n    }\n\n    function requestL2TransactionTwoBridges(L2TransactionRequestTwoBridgesOuter calldata _request)\n        external\n        payable\n        returns (bytes32 canonicalTxHash)\n    {\n        canonicalTxHash = keccak256(abi.encode(_request));\n    }\n\n    function baseToken(uint256 _chainId) external view returns (address) {\n        return baseTokens[_chainId] == address(0) ? address(1) : baseTokens[_chainId];\n    }\n\n    function l2TransactionBaseCost(\n        uint256,\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256) {\n        return _gasPrice + _l2GasLimit * _l2GasPerPubdataByteLimit;\n    }\n}\n"
    },
    "contracts/test/PolygonERC20Test.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@uma/core/contracts/common/implementation/ExpandedERC20.sol\";\nimport \"../PolygonTokenBridger.sol\";\n\n/**\n * @notice Simulated Polygon ERC20 for use in testing PolygonTokenBridger.\n */\ncontract PolygonERC20Test is ExpandedERC20 {\n    constructor() ExpandedERC20(\"Polygon Test\", \"POLY_TEST\", 18) {} // solhint-disable-line no-empty-blocks\n\n    function withdraw(uint256 amount) public {\n        _burn(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/test/PolygonMocks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract RootChainManagerMock {\n    function depositEtherFor(address user) external payable {} // solhint-disable-line no-empty-blocks\n\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external {} // solhint-disable-line no-empty-blocks\n}\n\ncontract FxStateSenderMock {\n    // solhint-disable-next-line no-empty-blocks\n    function sendMessageToChild(address _receiver, bytes calldata _data) external {}\n}\n\ncontract DepositManagerMock {\n    function depositERC20ForUser(\n        address token,\n        address user,\n        uint256 amount // solhint-disable-next-line no-empty-blocks\n    ) external {} // solhint-disable-line no-empty-blocks\n}\n\ncontract PolygonRegistryMock {\n    // solhint-disable-next-line no-empty-blocks\n    function erc20Predicate() external returns (address predicate) {}\n}\n\ncontract PolygonERC20PredicateMock {\n    // solhint-disable-next-line no-empty-blocks\n    function startExitWithBurntTokens(bytes calldata data) external {}\n}\n\ncontract PolygonERC20Mock is ERC20 {\n    // solhint-disable-next-line no-empty-blocks\n    constructor() ERC20(\"Test ERC20\", \"TEST\") {}\n\n    // solhint-disable-next-line no-empty-blocks\n    function withdraw(uint256 amount) external {}\n}\n"
    },
    "contracts/test/SuccinctMocks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ncontract TelepathyBroadcasterMock {\n    function send(\n        uint16,\n        address,\n        bytes calldata\n    ) external pure returns (bytes32) {\n        return bytes32(0);\n    }\n}\n"
    },
    "contracts/test/V2MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/MockV2SpokePoolInterface.sol\";\n\n/**\n * @notice Library to help with merkle roots, proofs, and claims.\n */\nlibrary V2MerkleLib {\n    function verifySlowRelayFulfillment(\n        bytes32 root,\n        MockV2SpokePoolInterface.SlowFill memory slowRelayFulfillment,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\n    }\n}\n"
    },
    "contracts/upgradeable/AddressLibUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title AddressUpgradeable\n * @dev Collection of functions related to the address type\n * @notice Logic is 100% copied from \"@openzeppelin/contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\" but one\n * comment is added to clarify why we allow delegatecall() in this contract, which is typically unsafe for use in\n * upgradeable implementation contracts.\n * @dev See https://docs.openzeppelin.com/upgrades-plugins/1.x/faq#delegatecall-selfdestruct for more details.\n * @custom:security-contact bugs@across.to\n */\nlibrary AddressLibUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/upgradeable/EIP712CrossChainUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * This contract is based on OpenZeppelin's implementation:\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/cryptography/EIP712Upgradeable.sol\n *\n * NOTE: Modified version that allows to build a domain separator that relies on a different chain id than the chain this\n * contract is deployed to. An example use case we want to support is:\n * - User A signs a message on chain with id = 1\n * - User B executes a method by verifying user A's EIP-712 compliant signature on a chain with id != 1\n * @custom:security-contact bugs@across.to\n */\nabstract contract EIP712CrossChainUpgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator depending on the `originChainId`.\n     * @param originChainId Chain id of network where message originates from.\n     * @return bytes32 EIP-712-compliant domain separator.\n     */\n    function _domainSeparatorV4(uint256 originChainId) internal view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, originChainId));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 structHash = keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * ));\n     * bytes32 digest = _hashTypedDataV4(structHash, originChainId);\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     * @param structHash Hashed struct as defined in https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n     * @param originChainId Chain id of network where message originates from.\n     * @return bytes32 Hash digest that is recoverable via `EDCSA.recover`.\n     */\n    function _hashTypedDataV4(bytes32 structHash, uint256 originChainId) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(originChainId), structHash);\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added, so that the total number of slots taken by this contract remains constant. Per-contract\n    // storage layout information  can be found in storage-layouts/\n    // This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/upgradeable/MultiCallerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title MultiCallerUpgradeable\n * @notice Logic is 100% copied from \"@uma/core/contracts/common/implementation/MultiCaller.sol\" but one\n * comment is added to clarify why we allow delegatecall() in this contract, which is typically unsafe for use in\n * upgradeable implementation contracts.\n * @dev See https://docs.openzeppelin.com/upgrades-plugins/1.x/faq#delegatecall-selfdestruct for more details.\n * @custom:security-contact bugs@across.to\n */\ncontract MultiCallerUpgradeable {\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function _validateMulticallData(bytes[] calldata data) internal virtual {\n        // no-op\n    }\n\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        _validateMulticallData(data);\n\n        uint256 dataLength = data.length;\n        results = new bytes[](dataLength);\n\n        //slither-disable-start calls-loop\n        for (uint256 i = 0; i < dataLength; ++i) {\n            // Typically, implementation contracts used in the upgradeable proxy pattern shouldn't call `delegatecall`\n            // because it could allow a malicious actor to call this implementation contract directly (rather than\n            // through a proxy contract) and then selfdestruct() the contract, thereby freezing the upgradeable\n            // proxy. However, since we're only delegatecall-ing into this contract, then we can consider this\n            // use of delegatecall() safe.\n\n            //slither-disable-start low-level-calls\n            /// @custom:oz-upgrades-unsafe-allow delegatecall\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n            //slither-disable-end low-level-calls\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                //slither-disable-next-line assembly\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n        //slither-disable-end calls-loop\n    }\n\n    function tryMulticall(bytes[] calldata data) external returns (Result[] memory results) {\n        _validateMulticallData(data);\n\n        uint256 dataLength = data.length;\n        results = new Result[](dataLength);\n\n        //slither-disable-start calls-loop\n        for (uint256 i = 0; i < dataLength; ++i) {\n            // The delegatecall here is safe for the same reasons outlined in the first multicall function.\n            Result memory result = results[i];\n            //slither-disable-start low-level-calls\n            /// @custom:oz-upgrades-unsafe-allow delegatecall\n            (result.success, result.returnData) = address(this).delegatecall(data[i]);\n            //slither-disable-end low-level-calls\n        }\n        //slither-disable-end calls-loop\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added, so that the total number of slots taken by this contract remains constant. Per-contract\n    // storage layout information  can be found in storage-layouts/\n    // This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/ZkSync_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { CircleCCTPAdapter, CircleDomainIds, ITokenMessenger } from \"./libraries/CircleCCTPAdapter.sol\";\nimport { CrossDomainAddressUtils } from \"./libraries/CrossDomainAddressUtils.sol\";\nimport \"./SpokePool.sol\";\n\n// https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/zksync/contracts/bridge/L2ERC20Bridge.sol#L104\ninterface ZkBridgeLike {\n    function withdraw(\n        address _l1Receiver,\n        address _l2Token,\n        uint256 _amount\n    ) external;\n}\n\ninterface IL2ETH {\n    function withdraw(address _l1Receiver) external payable;\n}\n\n/**\n * @notice ZkSync specific SpokePool, intended to be compiled with `@matterlabs/hardhat-zksync-solc`.\n * @dev Resources for compiling and deploying contracts with hardhat: https://era.zksync.io/docs/tools/hardhat/hardhat-zksync-solc.html\n * @custom:security-contact bugs@across.to\n */\ncontract ZkSync_SpokePool is SpokePool, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // On Ethereum, avoiding constructor parameters and putting them into constants reduces some of the gas cost\n    // upon contract deployment. On zkSync the opposite is true: deploying the same bytecode for contracts,\n    // while changing only constructor parameters can lead to substantial fee savings. So, the following params\n    // are all set by passing in constructor params where possible.\n\n    // ETH on ZkSync implements a subset of the ERC-20 interface, with additional built-in support to bridge to L1.\n    address public l2Eth;\n\n    // Bridge used to withdraw ERC20's to L1\n    ZkBridgeLike public zkErc20Bridge;\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ZkBridgeLike public immutable zkUSDCBridge;\n\n    event SetZkBridge(address indexed erc20Bridge, address indexed oldErc20Bridge);\n\n    error InvalidBridgeConfig();\n\n    /**\n     * @notice Constructor.\n     * @notice Circle bridged & native USDC are optionally supported via configuration, but are mutually exclusive.\n     * @param _wrappedNativeTokenAddress wrappedNativeToken address for this network to set.\n     * @param _circleUSDC Circle USDC address on the SpokePool. Set to 0x0 to use the standard ERC20 bridge instead.\n     * If not set to zero, then either the zkUSDCBridge or cctpTokenMessenger must be set and will be used to\n     * bridge this token.\n     * @param _zkUSDCBridge Elastic chain custom bridge address for USDC (if deployed, or address(0) to disable).\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP. If the zero address is passed, CCTP bridging will be disabled.\n     * @param _depositQuoteTimeBuffer depositQuoteTimeBuffer to set. Quote timestamps can't be set more than this amount\n     * into the past from the block time of the deposit.\n     * @param _fillDeadlineBuffer fillDeadlineBuffer to set. Fill deadlines can't be set more than this amount\n     * into the future from the block time of the deposit.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        IERC20 _circleUSDC,\n        ZkBridgeLike _zkUSDCBridge,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    )\n        SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            // ZkSync_SpokePool does not use OFT messaging; setting destination eid and fee cap to 0\n            0,\n            0\n        )\n        CircleCCTPAdapter(_circleUSDC, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {\n        address zero = address(0);\n        if (address(_circleUSDC) != zero) {\n            bool zkUSDCBridgeDisabled = address(_zkUSDCBridge) == zero;\n            bool cctpUSDCBridgeDisabled = address(_cctpTokenMessenger) == zero;\n            // Bridged and Native USDC are mutually exclusive.\n            if (zkUSDCBridgeDisabled == cctpUSDCBridgeDisabled) {\n                revert InvalidBridgeConfig();\n            }\n        }\n\n        zkUSDCBridge = _zkUSDCBridge;\n    }\n\n    /**\n     * @notice Initialize the ZkSync SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _zkErc20Bridge Address of L2 ERC20 gateway. Can be reset by admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        ZkBridgeLike _zkErc20Bridge,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        l2Eth = 0x000000000000000000000000000000000000800A;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setZkBridge(_zkErc20Bridge);\n    }\n\n    modifier onlyFromCrossDomainAdmin() {\n        require(msg.sender == CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin), \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /********************************************************\n     *      ZKSYNC-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change L2 token bridge addresses. Callable only by admin.\n     * @param _zkErc20Bridge New address of L2 ERC20 gateway.\n     */\n    function setZkBridge(ZkBridgeLike _zkErc20Bridge) public onlyAdmin nonReentrant {\n        _setZkBridge(_zkErc20Bridge);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Wraps any ETH into WETH before executing base function. This is necessary because SpokePool receives\n     * ETH over the canonical token bridge instead of WETH.\n     */\n    function _preExecuteLeafHook(address l2TokenAddress) internal override {\n        if (l2TokenAddress == address(wrappedNativeToken)) _depositEthToWeth();\n    }\n\n    // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is necessary because\n    // this SpokePool will receive ETH from the canonical token bridge instead of WETH. This may not be neccessary\n    // if ETH on ZkSync is treated as ETH and the fallback() function is triggered when this contract receives\n    // ETH. We will have to test this but this function for now allows the contract to safely convert all of its\n    // held ETH into WETH at the cost of higher gas costs.\n    function _depositEthToWeth() internal {\n        //slither-disable-next-line arbitrary-send-eth\n        if (address(this).balance > 0) wrappedNativeToken.deposit{ value: address(this).balance }();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // SpokePool is expected to receive ETH from the L1 HubPool and currently, withdrawing ETH directly\n        // over the ERC20 Bridge is blocked at the contract level. Therefore, we need to unwrap it before withdrawing.\n        if (l2TokenAddress == address(wrappedNativeToken)) {\n            WETH9Interface(l2TokenAddress).withdraw(amountToReturn); // Unwrap into ETH.\n            // To withdraw tokens, we actually call 'withdraw' on the L2 eth token itself.\n            IL2ETH(l2Eth).withdraw{ value: amountToReturn }(withdrawalRecipient);\n        } else if (l2TokenAddress == address(usdcToken)) {\n            if (_isCCTPEnabled()) {\n                // Circle native USDC via CCTP.\n                _transferUsdc(withdrawalRecipient, amountToReturn);\n            } else {\n                // Matter Labs custom USDC bridge for Circle Bridged (upgradable) USDC.\n                IERC20(l2TokenAddress).forceApprove(address(zkUSDCBridge), amountToReturn);\n                zkUSDCBridge.withdraw(withdrawalRecipient, l2TokenAddress, amountToReturn);\n            }\n        } else {\n            zkErc20Bridge.withdraw(withdrawalRecipient, l2TokenAddress, amountToReturn);\n        }\n    }\n\n    function _setZkBridge(ZkBridgeLike _zkErc20Bridge) internal {\n        address oldErc20Bridge = address(zkErc20Bridge);\n        zkErc20Bridge = _zkErc20Bridge;\n        emit SetZkBridge(address(_zkErc20Bridge), oldErc20Bridge);\n    }\n\n    function _requireAdminSender() internal override onlyFromCrossDomainAdmin {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added, so that the total number of slots taken by this contract remains constant. Per-contract\n    // storage layout information  can be found in storage-layouts/\n    // This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[999] private __gap;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "viaIR": true,
    "debug": {
      "revertStrings": "strip"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
