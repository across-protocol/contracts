{
  "language": "Solidity",
  "sources": {
    "@eth-optimism/contracts/L1/messaging/IL1ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IL1ERC20Bridge\n */\ninterface IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L2 bridge contract.\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external returns (address);\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _amount Amount of the ERC20 to deposit\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ERC20 token.\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\n     *\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Data provided by the sender on L2. This data is provided\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\n     *   length, these contracts provide no guarantees about its content.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\nimport \"./IL1ERC20Bridge.sol\";\n\n/**\n * @title IL1StandardBridge\n */\ninterface IL1StandardBridge is IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev Deposit an amount of the ETH to the caller's balance on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called\n     * before the withdrawal is finalized.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/crosschain/errorsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/errors.sol)\n\npragma solidity ^0.8.4;\n\nerror NotCrossChainCall();\nerror InvalidCrossChainSender(address actual, address expected);\n"
    },
    "@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (crosschain/optimism/LibOptimism.sol)\n\npragma solidity ^0.8.4;\n\nimport {ICrossDomainMessengerUpgradeable as Optimism_Bridge} from \"../../vendor/optimism/ICrossDomainMessengerUpgradeable.sol\";\nimport \"../errorsUpgradeable.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for https://www.optimism.io/[Optimism].\n * See the https://community.optimism.io/docs/developers/bridge/messaging/#accessing-msg-sender[documentation]\n * for the functionality used here.\n */\nlibrary LibOptimismUpgradeable {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `messenger`.\n     */\n    function isCrossChain(address messenger) internal view returns (bool) {\n        return msg.sender == messenger;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `messenger`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address messenger) internal view returns (address) {\n        if (!isCrossChain(messenger)) revert NotCrossChainCall();\n\n        return Optimism_Bridge(messenger).xDomainMessageSender();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport {Initializable} from \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/vendor/optimism/ICrossDomainMessengerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (vendor/optimism/ICrossDomainMessenger.sol)\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessengerUpgradeable {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/ExpandedERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./MultiRole.sol\";\nimport \"../interfaces/ExpandedIERC20.sol\";\n\n/**\n * @title An ERC20 with permissioned burning and minting. The contract deployer will initially\n * be the owner who is capable of adding new roles.\n */\ncontract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\n    enum Roles {\n        // Can set the minter and burner.\n        Owner,\n        // Addresses that can mint new tokens.\n        Minter,\n        // Addresses that can burn tokens that address owns.\n        Burner\n    }\n\n    uint8 _decimals;\n\n    /**\n     * @notice Constructs the ExpandedERC20.\n     * @param _tokenName The name which describes the new token.\n     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\n     * @param _tokenDecimals The number of decimals to define token precision.\n     */\n    constructor(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _tokenDecimals\n    ) ERC20(_tokenName, _tokenSymbol) {\n        _decimals = _tokenDecimals;\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));\n        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\n     * @param recipient address to mint to.\n     * @param value amount of tokens to mint.\n     * @return True if the mint succeeded, or False.\n     */\n    function mint(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Minter))\n        returns (bool)\n    {\n        _mint(recipient, value);\n        return true;\n    }\n\n    /**\n     * @dev Burns `value` tokens owned by `msg.sender`.\n     * @param value amount of tokens to burn.\n     */\n    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     * @return True if the burn succeeded, or False.\n     */\n    function burnFrom(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Burner))\n        returns (bool)\n    {\n        _burn(recipient, value);\n        return true;\n    }\n\n    /**\n     * @notice Add Minter role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Minter role is added.\n     */\n    function addMinter(address account) external virtual override {\n        addMember(uint256(Roles.Minter), account);\n    }\n\n    /**\n     * @notice Add Burner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Burner role is added.\n     */\n    function addBurner(address account) external virtual override {\n        addMember(uint256(Roles.Burner), account);\n    }\n\n    /**\n     * @notice Reset Owner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The new holder of the Owner role.\n     */\n    function resetOwner(address account) external virtual override {\n        resetMember(uint256(Roles.Owner), account);\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiCaller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// This contract is taken from Uniswap's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\n\n/// @title MultiCaller\n/// @notice Enables calling multiple methods in a single call to the contract\ncontract MultiCaller {\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiRole.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nlibrary Exclusive {\n    struct RoleMembership {\n        address member;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.member == memberToCheck;\n    }\n\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\n        roleMembership.member = newMember;\n    }\n\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\n        return roleMembership.member;\n    }\n\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\n        resetMember(roleMembership, initialMember);\n    }\n}\n\nlibrary Shared {\n    struct RoleMembership {\n        mapping(address => bool) members;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.members[memberToCheck];\n    }\n\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\n        require(memberToAdd != address(0x0), \"Cannot add 0x0 to a shared role\");\n        roleMembership.members[memberToAdd] = true;\n    }\n\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\n        roleMembership.members[memberToRemove] = false;\n    }\n\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\n        for (uint256 i = 0; i < initialMembers.length; i++) {\n            addMember(roleMembership, initialMembers[i]);\n        }\n    }\n}\n\n/**\n * @title Base class to manage permissions for the derived class.\n */\nabstract contract MultiRole {\n    using Exclusive for Exclusive.RoleMembership;\n    using Shared for Shared.RoleMembership;\n\n    enum RoleType { Invalid, Exclusive, Shared }\n\n    struct Role {\n        uint256 managingRole;\n        RoleType roleType;\n        Exclusive.RoleMembership exclusiveRoleMembership;\n        Shared.RoleMembership sharedRoleMembership;\n    }\n\n    mapping(uint256 => Role) private roles;\n\n    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\n\n    /**\n     * @notice Reverts unless the caller is a member of the specified roleId.\n     */\n    modifier onlyRoleHolder(uint256 roleId) {\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\n     */\n    modifier onlyRoleManager(uint256 roleId) {\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\n     */\n    modifier onlyExclusive(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\n     */\n    modifier onlyShared(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\n        _;\n    }\n\n    /**\n     * @notice Whether `memberToCheck` is a member of roleId.\n     * @dev Reverts if roleId does not correspond to an initialized role.\n     * @param roleId the Role to check.\n     * @param memberToCheck the address to check.\n     * @return True if `memberToCheck` is a member of `roleId`.\n     */\n    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        revert(\"Invalid roleId\");\n    }\n\n    /**\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n     * initialized, ExclusiveRole.\n     * @param roleId the ExclusiveRole membership to modify.\n     * @param newMember the new ExclusiveRole member.\n     */\n    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Gets the current holder of the exclusive role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n     * @param roleId the ExclusiveRole membership to check.\n     * @return the address of the current ExclusiveRole member.\n     */\n    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n        return roles[roleId].exclusiveRoleMembership.getMember();\n    }\n\n    /**\n     * @notice Adds `newMember` to the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param newMember the new SharedRole member.\n     */\n    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n        emit AddedSharedMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param memberToRemove the current SharedRole member to remove.\n     */\n    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n    }\n\n    /**\n     * @notice Removes caller from the role, `roleId`.\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n     * initialized, SharedRole.\n     * @param roleId the SharedRole membership to modify.\n     */\n    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Reverts if `roleId` is not initialized.\n     */\n    modifier onlyValidRole(uint256 roleId) {\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if `roleId` is initialized.\n     */\n    modifier onlyInvalidRole(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\n        _;\n    }\n\n    /**\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMembers` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createSharedRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address[] memory initialMembers\n    ) internal onlyInvalidRole(roleId) {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Shared;\n        role.managingRole = managingRoleId;\n        role.sharedRoleMembership.init(initialMembers);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage a shared role\"\n        );\n    }\n\n    /**\n     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMember` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createExclusiveRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address initialMember\n    ) internal onlyInvalidRole(roleId) {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Exclusive;\n        role.managingRole = managingRoleId;\n        role.exclusiveRoleMembership.init(initialMember);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage an exclusive role\"\n        );\n    }\n}\n"
    },
    "@uma/core/contracts/common/interfaces/ExpandedIERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title ERC20 interface that includes burn and mint methods.\n */\nabstract contract ExpandedIERC20 is IERC20 {\n    /**\n     * @notice Burns a specific amount of the caller's tokens.\n     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\n     */\n    function burn(uint256 value) external virtual;\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     */\n    function burnFrom(address recipient, uint256 value) external virtual returns (bool);\n\n    /**\n     * @notice Mints tokens and adds them to the balance of the `to` address.\n     * @dev This method should be permissioned to only allow designated parties to mint tokens.\n     */\n    function mint(address to, uint256 value) external virtual returns (bool);\n\n    function addMinter(address account) external virtual;\n\n    function addBurner(address account) external virtual;\n\n    function resetOwner(address account) external virtual;\n}\n"
    },
    "contracts/AlephZero_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Arbitrum only supports v0.8.19\n// See https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/solidity-support#differences-from-solidity-on-ethereum\npragma solidity ^0.8.19;\n\nimport \"./Arbitrum_SpokePool.sol\";\n\n/**\n * @notice AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\n * @custom:security-contact bugs@across.to\n */\ncontract AlephZero_SpokePool is Arbitrum_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        Arbitrum_SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            _l2Usdc,\n            _cctpTokenMessenger\n        )\n    {} // solhint-disable-line no-empty-blocks\n}\n"
    },
    "contracts/Arbitrum_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\nimport { CrossDomainAddressUtils } from \"./libraries/CrossDomainAddressUtils.sol\";\nimport { ArbitrumL2ERC20GatewayLike } from \"./interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\n * @custom:security-contact bugs@across.to\n */\ncontract Arbitrum_SpokePool is SpokePool, CircleCCTPAdapter {\n    // Address of the Arbitrum L2 token gateway to send funds to L1.\n    address public l2GatewayRouter;\n\n    // Admin controlled mapping of arbitrum tokens to L1 counterpart. L1 counterpart addresses\n    // are necessary params used when bridging tokens to L1.\n    mapping(address => address) public whitelistedTokens;\n\n    event SetL2GatewayRouter(address indexed newL2GatewayRouter);\n    event WhitelistedTokens(address indexed l2Token, address indexed l1Token);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the AVM SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _l2GatewayRouter Address of L2 token gateway. Can be reset by admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        address _l2GatewayRouter,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setL2GatewayRouter(_l2GatewayRouter);\n    }\n\n    modifier onlyFromCrossDomainAdmin() {\n        require(msg.sender == CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin), \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /********************************************************\n     *    ARBITRUM-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change L2 gateway router. Callable only by admin.\n     * @param newL2GatewayRouter New L2 gateway router.\n     */\n    function setL2GatewayRouter(address newL2GatewayRouter) public onlyAdmin nonReentrant {\n        _setL2GatewayRouter(newL2GatewayRouter);\n    }\n\n    /**\n     * @notice Add L2 -> L1 token mapping. Callable only by admin.\n     * @param l2Token Arbitrum token.\n     * @param l1Token Ethereum version of l2Token.\n     */\n    function whitelistToken(address l2Token, address l1Token) public onlyAdmin nonReentrant {\n        _whitelistToken(l2Token, l1Token);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // If the l2TokenAddress is UDSC, we need to use the CCTP bridge.\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        } else {\n            // Check that the Ethereum counterpart of the L2 token is stored on this contract.\n            address ethereumTokenToBridge = whitelistedTokens[l2TokenAddress];\n            require(ethereumTokenToBridge != address(0), \"Uninitialized mainnet token\");\n            //slither-disable-next-line unused-return\n            ArbitrumL2ERC20GatewayLike(l2GatewayRouter).outboundTransfer(\n                ethereumTokenToBridge, // _l1Token. Address of the L1 token to bridge over.\n                withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 hub pool contract.\n                amountToReturn, // _amount.\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n    }\n\n    function _setL2GatewayRouter(address _l2GatewayRouter) internal {\n        l2GatewayRouter = _l2GatewayRouter;\n        emit SetL2GatewayRouter(l2GatewayRouter);\n    }\n\n    function _whitelistToken(address _l2Token, address _l1Token) internal {\n        whitelistedTokens[_l2Token] = _l1Token;\n        emit WhitelistedTokens(_l2Token, _l1Token);\n    }\n\n    // Apply AVM-specific transformation to cross domain admin address on L1.\n    function _requireAdminSender() internal override onlyFromCrossDomainAdmin {}\n}\n"
    },
    "contracts/Boba_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Ovm_SpokePool.sol\";\n\n/**\n * @notice Boba Spoke pool. Note that the l2ETH and l2WETH are the opposite as that in Optimism.\n */\ncontract Boba_SpokePool is Ovm_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    )\n        Ovm_SpokePool(\n            _wrappedNativeTokenAddress,\n            _depositQuoteTimeBuffer,\n            _fillDeadlineBuffer,\n            IERC20(address(0)),\n            ITokenMessenger(address(0))\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the OVM Boba SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __OvmSpokePool_init(\n            _initialDepositId,\n            _crossDomainAdmin,\n            _withdrawalRecipient,\n            0x4200000000000000000000000000000000000006\n        );\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport { ArbitrumInboxLike as ArbitrumL1InboxLike, ArbitrumL1ERC20GatewayLike } from \"../interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Arbitrum.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    uint256 public constant L2_MAX_SUBMISSION_COST = 0.01e18;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public constant L2_GAS_PRICE = 5e9; // 5 gWei\n\n    // Native token expected to be sent in L2 message. Should be 0 for only use case of this constant, which\n    // includes is sending messages from L1 to L2.\n    uint256 public constant L2_CALL_VALUE = 0;\n\n    // Gas limit for L2 execution of a cross chain token transfer sent via the inbox.\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n    // Gas limit for L2 execution of a message sent via the inbox.\n    uint32 public constant RELAY_MESSAGE_L2_GAS_LIMIT = 2_000_000;\n\n    address public constant L1_DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\n    address public immutable L2_REFUND_L2_ADDRESS;\n\n    // Inbox system contract to send messages to Arbitrum. Token bridges use this to send tokens to L2.\n    // https://github.com/OffchainLabs/nitro-contracts/blob/f7894d3a6d4035ba60f51a7f1334f0f2d4f02dce/src/bridge/Inbox.sol\n    ArbitrumL1InboxLike public immutable L1_INBOX;\n\n    // Router contract to send tokens to Arbitrum. Routes to correct gateway to bridge tokens. Internally this\n    // contract calls the Inbox.\n    // Generic gateway: https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ArbitrumGateway.sol\n    ArbitrumL1ERC20GatewayLike public immutable L1_ERC20_GATEWAY_ROUTER;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        ArbitrumL1InboxLike _l1ArbitrumInbox,\n        ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter,\n        address _l2RefundL2Address,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Arbitrum) {\n        L1_INBOX = _l1ArbitrumInbox;\n        L1_ERC20_GATEWAY_ROUTER = _l1ERC20GatewayRouter;\n        L2_REFUND_L2_ADDRESS = _l2RefundL2Address;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param target Contract on Arbitrum that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance(RELAY_MESSAGE_L2_GAS_LIMIT);\n\n        L1_INBOX.createRetryableTicket{ value: requiredL1CallValue }(\n            target, // destAddr destination L2 contract address\n            L2_CALL_VALUE, // l2CallValue call value for retryable L2 message\n            L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n            message // data ABI encoded data of L2 message\n        );\n\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        }\n        // If not, we can use the Arbitrum gateway\n        else {\n            uint256 requiredL1CallValue = _contractHasSufficientEthBalance(RELAY_TOKENS_L2_GAS_LIMIT);\n\n            // Approve the gateway, not the router, to spend the hub pool's balance. The gateway, which is different\n            // per L1 token, will temporarily escrow the tokens to be bridged and pull them from this contract.\n            address erc20Gateway = L1_ERC20_GATEWAY_ROUTER.getGateway(l1Token);\n            IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n\n            // `outboundTransfer` expects that the caller includes a bytes message as the last param that includes the\n            // maxSubmissionCost to use when creating an L2 retryable ticket: https://github.com/OffchainLabs/arbitrum/blob/e98d14873dd77513b569771f47b5e05b72402c5e/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L232\n            bytes memory data = abi.encode(L2_MAX_SUBMISSION_COST, \"\");\n\n            // Note: Legacy routers don't have the outboundTransferCustomRefund method, so default to using\n            // outboundTransfer(). Legacy routers are used for the following tokens that are currently enabled:\n            // - DAI: the implementation of `outboundTransfer` at the current DAI custom gateway\n            //        (https://etherscan.io/address/0xD3B5b60020504bc3489D6949d545893982BA3011#writeContract) sets the\n            //        sender as the refund address so the aliased HubPool should receive excess funds. Implementation here:\n            //        https://github.com/makerdao/arbitrum-dai-bridge/blob/11a80385e2622968069c34d401b3d54a59060e87/contracts/l1/L1DaiGateway.sol#L109\n            if (l1Token == L1_DAI) {\n                // This means that the excess ETH to pay for the L2 transaction will be sent to the aliased\n                // contract address on L2, which we'd have to retrieve via a custom adapter, the Arbitrum_RescueAdapter.\n                // To do so, in a single transaction: 1) setCrossChainContracts to Arbitrum_RescueAdapter, 2) relayMessage\n                // with function data = abi.encode(amountToRescue), 3) setCrossChainContracts back to this adapter.\n                L1_ERC20_GATEWAY_ROUTER.outboundTransfer{ value: requiredL1CallValue }(\n                    l1Token,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            } else {\n                L1_ERC20_GATEWAY_ROUTER.outboundTransferCustomRefund{ value: requiredL1CallValue }(\n                    l1Token,\n                    L2_REFUND_L2_ADDRESS,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            }\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue(uint32 l2GasLimit) public pure returns (uint256) {\n        return L2_MAX_SUBMISSION_COST + L2_GAS_PRICE * l2GasLimit;\n    }\n\n    function _contractHasSufficientEthBalance(uint32 l2GasLimit) internal view returns (uint256) {\n        uint256 requiredL1CallValue = getL1CallValue(l2GasLimit);\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n        return requiredL1CallValue;\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_CustomGasToken_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ITokenMessenger as ICCTPTokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\nimport { CircleCCTPAdapter, CircleDomainIds } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ArbitrumERC20Bridge as ArbitrumL1ERC20Bridge, ArbitrumCustomGasTokenInbox as ArbitrumL1InboxLike, ArbitrumL1ERC20GatewayLike } from \"../interfaces/ArbitrumBridge.sol\";\n\n/**\n * @notice Interface for funder contract that this contract pulls from to pay for relayMessage()/relayTokens()\n * fees using a custom gas token.\n */\ninterface FunderInterface {\n    /**\n     * @notice Withdraws amount of token from funder contract to the caller.\n     * @dev Can only be called by owner of Funder contract, which therefore must be\n     * this contract.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     */\n    function withdraw(IERC20 token, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Arbitrum.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @dev This contract is very similar to Arbitrum_Adapter but it allows the caller to pay for submission\n * fees using a custom gas token. This is required to support certain Arbitrum orbit L2s and L3s.\n * @dev https://docs.arbitrum.io/launch-orbit-chain/how-tos/use-a-custom-gas-token\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_CustomGasToken_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n\n    // Amount of gas token allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    // The Arbitrum Inbox requires that this uses 18 decimal precision.\n    uint256 public immutable L2_MAX_SUBMISSION_COST;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    // The Arbitrum Inbox requires that this is specified in gWei (e.g. 1e9 = 1 gWei)\n    uint256 public immutable L2_GAS_PRICE;\n\n    // Native token expected to be sent in L2 message. Should be 0 for most use cases of this constant. This\n    // constant is unused when sending the native gas token over the inbox since the inbox interprets `l2CallValue`\n    // as the amount of the L2 native token to send.\n    uint256 public constant L2_CALL_VALUE = 0;\n\n    // Gas limit for L2 execution of a cross chain token transfer sent via the inbox.\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n    // Gas limit for L2 execution of a message sent via the inbox.\n    uint32 public constant RELAY_MESSAGE_L2_GAS_LIMIT = 2_000_000;\n\n    // The number of decimals of precision for the custom gas token. This is defined in the constructor and not dynamically fetched since decimals are\n    // not part of the standard ERC20 interface.\n    uint8 public immutable NATIVE_TOKEN_DECIMALS;\n\n    // This address on L2 receives extra gas token that is left over after relaying a message via the inbox.\n    address public immutable L2_REFUND_L2_ADDRESS;\n\n    // Inbox system contract to send messages to Arbitrum. Token bridges use this to send tokens to L2.\n    // https://github.com/OffchainLabs/nitro-contracts/blob/f7894d3a6d4035ba60f51a7f1334f0f2d4f02dce/src/bridge/Inbox.sol\n    ArbitrumL1InboxLike public immutable L1_INBOX;\n\n    // Router contract to send tokens to Arbitrum. Routes to correct gateway to bridge tokens. Internally this\n    // contract calls the Inbox.\n    // Generic gateway: https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ArbitrumGateway.sol\n    // Gateway used for communicating with chains that use custom gas tokens:\n    // https://github.com/OffchainLabs/token-bridge-contracts/blob/main/contracts/tokenbridge/ethereum/gateway/L1ERC20Gateway.sol\n    ArbitrumL1ERC20GatewayLike public immutable L1_ERC20_GATEWAY_ROUTER;\n\n    // This token is used to pay for l1 to l2 messages if its configured by an Arbitrum orbit chain.\n    IERC20 public immutable CUSTOM_GAS_TOKEN;\n\n    // Contract that funds Inbox cross chain messages with the custom gas token.\n    FunderInterface public immutable CUSTOM_GAS_TOKEN_FUNDER;\n\n    error InvalidCustomGasToken();\n    error InsufficientCustomGasToken();\n    error InvalidNativeTokenDecimals();\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     * @param _cctpDomainId Circle CCTP domain identifier for the destination chain.\n     * @param _nativeTokenDecimals Number of decimals corresponding to the L2's gas/fee token.\n     * @param _customGasTokenFunder Contract that funds the custom gas token.\n     * @param _l2MaxSubmissionCost Amount of gas token allocated to pay for the base submission fee. The base\n     * submission fee is a parameter unique to Arbitrum retryable transactions. This value is hardcoded\n     * and used for all messages sent by this adapter.\n     * @param _l2GasPrice Gas price bid for L2 execution. Should be set conservatively high to avoid stuck messages.\n     */\n    constructor(\n        ArbitrumL1InboxLike _l1ArbitrumInbox,\n        ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter,\n        address _l2RefundL2Address,\n        IERC20 _l1Usdc,\n        ICCTPTokenMessenger _cctpTokenMessenger,\n        uint32 _cctpDomainId,\n        uint8 _nativeTokenDecimals,\n        FunderInterface _customGasTokenFunder,\n        uint256 _l2MaxSubmissionCost,\n        uint256 _l2GasPrice\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, _cctpDomainId) {\n        L1_INBOX = _l1ArbitrumInbox;\n        L1_ERC20_GATEWAY_ROUTER = _l1ERC20GatewayRouter;\n        L2_REFUND_L2_ADDRESS = _l2RefundL2Address;\n        CUSTOM_GAS_TOKEN = IERC20(L1_INBOX.bridge().nativeToken());\n        if (address(CUSTOM_GAS_TOKEN) == address(0)) revert InvalidCustomGasToken();\n        L2_MAX_SUBMISSION_COST = _l2MaxSubmissionCost;\n        L2_GAS_PRICE = _l2GasPrice;\n        CUSTOM_GAS_TOKEN_FUNDER = _customGasTokenFunder;\n        if (_nativeTokenDecimals == 0) revert InvalidNativeTokenDecimals();\n        NATIVE_TOKEN_DECIMALS = _nativeTokenDecimals;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of the custom gas token\n     * to send a message via the Inbox successfully, or the message will get stuck.\n     * @param target Contract on Arbitrum that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 requiredL1TokenTotalFeeAmount = _pullCustomGas(RELAY_MESSAGE_L2_GAS_LIMIT);\n        CUSTOM_GAS_TOKEN.safeIncreaseAllowance(address(L1_INBOX), requiredL1TokenTotalFeeAmount);\n        L1_INBOX.createRetryableTicket(\n            target, // destAddr destination L2 contract address\n            L2_CALL_VALUE, // l2CallValue call value for retryable L2 message\n            L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n            requiredL1TokenTotalFeeAmount, // tokenTotalFeeAmount amount of fees to be deposited in native token.\n            // This should be in the precision of the custom gas token.\n            message // data ABI encoded data of L2 message\n        );\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH or custom gas token\n     * to send a message via the Inbox successfully, or the message will get stuck.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        }\n        // If not, we can use the Arbitrum gateway\n        else {\n            address erc20Gateway = L1_ERC20_GATEWAY_ROUTER.getGateway(l1Token);\n\n            // If custom gas token, call special functions that handle paying with custom gas tokens.\n            uint256 requiredL1TokenTotalFeeAmount = _pullCustomGas(RELAY_MESSAGE_L2_GAS_LIMIT);\n\n            // Must use Inbox to bridge custom gas token.\n            // Source: https://github.com/OffchainLabs/token-bridge-contracts/blob/5bdf33259d2d9ae52ddc69bc5a9cbc558c4c40c7/contracts/tokenbridge/ethereum/gateway/L1OrbitERC20Gateway.sol#L33\n            if (l1Token == address(CUSTOM_GAS_TOKEN)) {\n                // amount and requiredL1TokenTotalFeeAmount are in the precision of the custom gas token.\n                uint256 amountToBridge = amount + requiredL1TokenTotalFeeAmount;\n                CUSTOM_GAS_TOKEN.safeIncreaseAllowance(address(L1_INBOX), amountToBridge);\n                // Both `l2CallValue` and `tokenTotalFeeAmount` are rounded in the conversion to/from native/18 decimals. `l2CallValue` is rounded down by the call to _fromNativeTo18Decimals()\n                // in cases where the token's decimals exceeds 18, since we would rather round down and be forced to donate a small amount of the l2 token to the spoke pool to cover the roundoff\n                // error than overshoot a transfer amount. `amountToBridge` is rounded up since we would rather overpay for gas and be refunded on l2 than underpay and risk stuck cross-chain messages.\n                L1_INBOX.createRetryableTicket(\n                    to, // destAddr destination L2 contract address\n                    _fromNativeTo18Decimals(amount), // l2CallValue call value for retryable L2 message\n                    L2_MAX_SUBMISSION_COST, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n                    L2_REFUND_L2_ADDRESS, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n                    L2_REFUND_L2_ADDRESS, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n                    RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n                    L2_GAS_PRICE, // gasPriceBid price bid for L2 execution\n                    amountToBridge, // tokenTotalFeeAmount amount of fees to be deposited in native token.\n                    \"0x\" // data ABI encoded data of L2 message\n                );\n            } else {\n                IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n                CUSTOM_GAS_TOKEN.safeIncreaseAllowance(erc20Gateway, requiredL1TokenTotalFeeAmount);\n\n                // To pay for gateway outbound transfer with custom gas token, encode the tokenTotalFeeAmount in the data field:\n                // The data format should be (uint256 maxSubmissionCost, bytes extraData, uint256 tokenTotalFeeAmount).\n                // Source: https://github.com/OffchainLabs/token-bridge-contracts/blob/5bdf33259d2d9ae52ddc69bc5a9cbc558c4c40c7/contracts/tokenbridge/ethereum/gateway/L1OrbitERC20Gateway.sol#L57\n                bytes memory data = abi.encode(L2_MAX_SUBMISSION_COST, \"\", requiredL1TokenTotalFeeAmount);\n                L1_ERC20_GATEWAY_ROUTER.outboundTransferCustomRefund(\n                    l1Token,\n                    L2_REFUND_L2_ADDRESS,\n                    to,\n                    amount,\n                    RELAY_TOKENS_L2_GAS_LIMIT,\n                    L2_GAS_PRICE,\n                    data\n                );\n            }\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Returns required amount of gas token to send a message via the Inbox.\n     * @dev Should return a value in the same precision as the gas token's precision.\n     * @param l2GasLimit L2 gas limit for the message.\n     * @return amount of gas token that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue(uint32 l2GasLimit) public view returns (uint256) {\n        return _from18ToNativeDecimals(L2_MAX_SUBMISSION_COST + L2_GAS_PRICE * l2GasLimit);\n    }\n\n    function _pullCustomGas(uint32 l2GasLimit) internal returns (uint256) {\n        uint256 requiredL1CallValue = getL1CallValue(l2GasLimit);\n        CUSTOM_GAS_TOKEN_FUNDER.withdraw(CUSTOM_GAS_TOKEN, requiredL1CallValue);\n        if (CUSTOM_GAS_TOKEN.balanceOf(address(this)) < requiredL1CallValue) revert InsufficientCustomGasToken();\n        return requiredL1CallValue;\n    }\n\n    function _from18ToNativeDecimals(uint256 amount) internal view returns (uint256) {\n        if (NATIVE_TOKEN_DECIMALS == 18) {\n            return amount;\n        } else if (NATIVE_TOKEN_DECIMALS < 18) {\n            // Round up the division result so that the L1 call value is always sufficient to cover the submission fee.\n            uint256 reductionFactor = 10**(18 - NATIVE_TOKEN_DECIMALS);\n            uint256 divFloor = amount / reductionFactor;\n            uint256 mod = amount % reductionFactor;\n            if (mod != 0) {\n                return divFloor + 1;\n            } else {\n                return divFloor;\n            }\n        } else {\n            return amount * 10**(NATIVE_TOKEN_DECIMALS - 18);\n        }\n    }\n\n    function _fromNativeTo18Decimals(uint256 amount) internal view returns (uint256) {\n        if (NATIVE_TOKEN_DECIMALS == 18) {\n            return amount;\n        } else if (NATIVE_TOKEN_DECIMALS < 18) {\n            return amount * 10**(18 - NATIVE_TOKEN_DECIMALS);\n        } else {\n            return amount / 10**(NATIVE_TOKEN_DECIMALS - 18);\n        }\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_RescueAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"./Arbitrum_Adapter.sol\"; // Used to import `ArbitrumL1ERC20GatewayLike` and `ArbitrumL1InboxLike`\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Meant to copy the Arbitrum_Adapter exactly in how it sends L1 --> L2 messages but is designed only to be\n * used by the owner of the HubPool to retrieve ETH held by its aliased address on L2. This ETH builds up because\n * `relayTokens` calls `l1ERC20GatewayRouter.outboundTransfer` which does not allow the caller to specify an L2 refund\n * address the same way that `l1Inbox.createRetryableTicket` does. This means that the alias address of the caller, the\n * HubPool in this case, receives ETH on L2. This Adapter can be used to send messages to Arbitrum specifically to send\n * transactions as if called by the aliased HubPool address.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_RescueAdapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    uint256 public immutable l2MaxSubmissionCost = 0.01e18;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public immutable l2GasPrice = 5e9; // 5 gWei\n\n    // Gas limit for immediate L2 execution attempt (can be estimated via NodeInterface.estimateRetryableTicket).\n    // NodeInterface precompile interface exists at L2 address 0x00000000000000000000000000000000000000C8\n    uint32 public immutable l2GasLimit = 2_000_000;\n\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\n    address public immutable l2RefundL2Address;\n\n    // L1 HubPool address aliased on L2: https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md#address-aliasing\n    address public immutable aliasedL2HubPoolAddress = 0xd297fA914353c44B2e33EBE05F21846f1048CFeB;\n\n    ArbitrumL1InboxLike public immutable l1Inbox;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     */\n    constructor(ArbitrumL1InboxLike _l1ArbitrumInbox) {\n        l1Inbox = _l1ArbitrumInbox;\n\n        l2RefundL2Address = msg.sender;\n    }\n\n    /**\n     * @notice Send cross-chain message to aliased hub pool address on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param message Data to send to aliased hub pool.\n     */\n    function relayMessage(address, bytes memory message) external payable override {\n        uint256 valueToReturn = abi.decode(message, (uint256));\n\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance();\n\n        // In the rescue ETH setup, we send the transaction to the refund address, we provide a call value equal to the\n        // amount we want to rescue, and we specify an empty calldata, since it's a simple ETH transfer.\n        // Note: we use the unsafe version of createRetryableTicket because it doesn't require the msg.sender to pass\n        // in arbTxCallValue in addition to maxSubmissionCost + maxGas * gasPriceBid.\n        l1Inbox.unsafeCreateRetryableTicket{ value: requiredL1CallValue }(\n            l2RefundL2Address, // destAddr destination L2 contract address\n            valueToReturn, // l2CallValue call value for retryable L2 message\n            l2MaxSubmissionCost, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            l2RefundL2Address, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            l2RefundL2Address, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            l2GasLimit, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            l2GasPrice, // gasPriceBid price bid for L2 execution\n            \"\" // data ABI encoded data of L2 message\n        );\n\n        emit MessageRelayed(aliasedL2HubPoolAddress, \"\");\n    }\n\n    /**\n     * @notice Should never be called.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        revert(\"useless function\");\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue() public pure returns (uint256) {\n        return l2MaxSubmissionCost + l2GasPrice * l2GasLimit;\n    }\n\n    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_SendTokensAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport { ArbitrumL1ERC20GatewayLike } from \"./Arbitrum_Adapter.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice This adapter is built for emergencies to send funds from the Hub to a Spoke in the event that a spoke pool\n * received a duplicate root bundle relay, due to some replay issue.\n */\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_SendTokensAdapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    uint256 public immutable l2MaxSubmissionCost = 0.01e18;\n    uint256 public immutable l2GasPrice = 5e9;\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n\n    ArbitrumL1ERC20GatewayLike public immutable l1ERC20GatewayRouter;\n    address public immutable l2RefundL2Address;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     * @param _l2RefundL2Address L2 address to receive gas refunds on after a message is relayed.\n     */\n    constructor(ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter, address _l2RefundL2Address) {\n        l1ERC20GatewayRouter = _l1ERC20GatewayRouter;\n        l2RefundL2Address = _l2RefundL2Address;\n    }\n\n    /**\n     * @notice Send tokens to SpokePool. Enables HubPool admin to call relaySpokePoolAdminFunction that will trigger\n     * this function.\n     * @dev This performs similar logic to relayTokens in the normal Arbitrum_Adapter by sending tokens\n     * the Arbitrum_SpokePool out of the HubPool.\n     * @param message The encoded address of the ERC20 to send to the rescue address.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        (address l1Token, uint256 amount) = abi.decode(message, (address, uint256));\n\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance();\n\n        // Approve the gateway, not the router, to spend the hub pool's balance. The gateway, which is different\n        // per L1 token, will temporarily escrow the tokens to be bridged and pull them from this contract.\n        address erc20Gateway = l1ERC20GatewayRouter.getGateway(l1Token);\n        IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n\n        // `outboundTransfer` expects that the caller includes a bytes message as the last param that includes the\n        // maxSubmissionCost to use when creating an L2 retryable ticket: https://github.com/OffchainLabs/arbitrum/blob/e98d14873dd77513b569771f47b5e05b72402c5e/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L232\n        bytes memory data = abi.encode(l2MaxSubmissionCost, \"\");\n\n        l1ERC20GatewayRouter.outboundTransferCustomRefund{ value: requiredL1CallValue }(\n            l1Token,\n            l2RefundL2Address,\n            target,\n            amount,\n            RELAY_TOKENS_L2_GAS_LIMIT,\n            l2GasPrice,\n            data\n        );\n\n        // Purposefully not emitting any events so as not to confuse off-chain monitors that track this event.\n        // emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Should never be called.\n     */\n    function relayTokens(\n        address,\n        address,\n        uint256,\n        address\n    ) external payable override {\n        revert(\"relayTokens disabled\");\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue() public pure returns (uint256) {\n        return l2MaxSubmissionCost + l2GasPrice * RELAY_TOKENS_L2_GAS_LIMIT;\n    }\n\n    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}\n"
    },
    "contracts/chain-adapters/Base_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Base. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic.\n * @custom:security-contact bugs@across.to\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Base_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Base system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CrossDomainEnabled(_crossDomainMessenger) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Base) {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Base.\n     * @param target Contract on Base that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Base.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Blast_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport { IL1StandardBridge } from \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\ninterface IL1ERC20Bridge {\n    /// @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n    ///         ERC20 token on the other chain does not recognize the local token as the correct\n    ///         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n    ///         this chain.\n    /// @param _localToken  Address of the ERC20 on this chain.\n    /// @param _remoteToken Address of the corresponding token on the remote chain.\n    /// @param _to          Address of the receiver.\n    /// @param _amount      Amount of local tokens to deposit.\n    /// @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n    /// @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n    ///                     not be triggered with this data, but it will be emitted and can be used\n    ///                     to identify the transaction.\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Blast. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic. It differs from the Base Adapter in that it uses a special\n * Blast contract to bridge WETH and DAI, which are yielding rebasing tokens on L2, WETH and USDB.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Blast_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public immutable L2_GAS_LIMIT; // 200,000 is a reasonable default.\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE; // 0x697402166Fbf2F22E970df8a6486Ef171dbfc524\n\n    // Bridge used to get yielding version of ERC20's on L2.\n    IL1ERC20Bridge public immutable L1_BLAST_BRIDGE; // 0x3a05E5d33d7Ab3864D53aaEc93c8301C1Fa49115 on mainnet.\n    address public immutable L1_DAI; // 0x6B175474E89094C44Da98b954EedeAC495271d0F on mainnet.\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Blast system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        IL1ERC20Bridge l1BlastBridge,\n        address l1Dai,\n        uint32 l2GasLimit\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n        CircleCCTPAdapter(_l1Usdc, ITokenMessenger(address(0)), CircleDomainIds.UNINITIALIZED)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n        L1_BLAST_BRIDGE = l1BlastBridge;\n        L1_DAI = l1Dai;\n        L2_GAS_LIMIT = l2GasLimit;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Blast.\n     * @param target Contract on Blast that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Blast.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If token can be bridged into yield-ing version of ERC20 on L2 side, then use Blast Bridge, otherwise\n        // use standard bridge.\n\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            // @dev: we can use the standard or the blast bridge to deposit ETH here:\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is DAI, then use the L1 Blast Bridge\n        else if (l1Token == L1_DAI) {\n            IERC20(l1Token).safeIncreaseAllowance(address(L1_BLAST_BRIDGE), amount);\n            L1_BLAST_BRIDGE.bridgeERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @custom:security-contact bugs@across.to\n * @dev Helper contract for contracts performing cross-domain communications between L1 and Optimism.\n * @dev This modifies the eth-optimism/CrossDomainEnabled contract only by changing state variables to be\n * immutable for use in contracts like the Optimism_Adapter which use delegateCall().\n */\ncontract CrossDomainEnabled {\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public immutable MESSENGER;\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {\n        MESSENGER = _messenger;\n    }\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\n        return ICrossDomainMessenger(MESSENGER);\n    }\n\n    /**\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  onlyFromCrossDomainAccount())\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes calldata _message\n    ) internal {\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "contracts/chain-adapters/DoctorWho_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Doctor Who. This is a modified version of the Optimism adapter\n * that excludes the custom bridging logic.\n * @custom:security-contact bugs@across.to\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract DoctorWho_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Doctor Who system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.DoctorWho)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Doctor Who.\n     * @param target Contract on Doctor Who that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Doctor Who.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/interfaces/AdapterInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\n * This interface is implemented by an adapter contract that is deployed on L1.\n */\n\ninterface AdapterInterface {\n    event MessageRelayed(address target, bytes message);\n\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\n\n    /**\n     * @notice Send message to `target` on L2.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\n     * to the target contract on L2.\n     * @param target L2 address to send message to.\n     * @param message Message to send to `target`.\n     */\n    function relayMessage(address target, bytes calldata message) external payable;\n\n    /**\n     * @notice Send `amount` of `l1Token` to `to` on L2. `l2Token` is the L2 address equivalent of `l1Token`.\n     * @dev This method is marked payable because relaying the message might require a fee\n     * to be paid by the sender to forward the message to L2. However, it will not send msg.value\n     * to the target contract on L2.\n     * @param l1Token L1 token to bridge.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of `l1Token` to bridge.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable;\n}\n"
    },
    "contracts/chain-adapters/l2/Arbitrum_WithdrawalHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ArbitrumL2ERC20GatewayLike } from \"../../interfaces/ArbitrumBridge.sol\";\nimport { WithdrawalHelperBase } from \"./WithdrawalHelperBase.sol\";\nimport { ITokenMessenger } from \"../../external/interfaces/CCTPInterfaces.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { CrossDomainAddressUtils } from \"../../libraries/CrossDomainAddressUtils.sol\";\n\n/**\n * @title Arbitrum_WithdrawalHelper\n * @notice This contract interfaces with L2-L1 token bridges and withdraws tokens to a single address on L1.\n * @dev This contract should be deployed on Arbitrum L2s which only use CCTP or the canonical Arbitrum gateway router to withdraw tokens.\n * @custom:security-contact bugs@across.to\n */\ncontract Arbitrum_WithdrawalHelper is WithdrawalHelperBase {\n    using SafeERC20 for IERC20;\n\n    // Error which triggers when the supplied L1 token does not match the Arbitrum gateway router's expected L2 token.\n    error InvalidTokenMapping();\n\n    /*\n     * @notice Constructs the Arbitrum_WithdrawalHelper.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network. For Ethereum, this is 0.\n     * @param _l2GatewayRouter Address of the Arbitrum l2 gateway router contract.\n     * @param _tokenRecipient L1 Address which will unconditionally receive tokens withdrawn from this contract.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2GatewayRouter,\n        address _tokenRecipient\n    )\n        WithdrawalHelperBase(\n            _l2Usdc,\n            _cctpTokenMessenger,\n            _wrappedNativeToken,\n            _destinationCircleDomainId,\n            _l2GatewayRouter,\n            _tokenRecipient\n        )\n    {}\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which may execute admin functions on this contract.\n     */\n    function initialize(address _crossDomainAdmin) public initializer {\n        __WithdrawalHelper_init(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Calls CCTP or the Arbitrum gateway router to withdraw tokens back to the TOKEN_RECIPIENT L1 address.\n     * @param l1Token Address of the L1 token to receive.\n     * @param l2Token Address of the L2 token to send back.\n     * @param amountToReturn Amount of l2Token to send back.\n     */\n    function withdrawToken(\n        address l1Token,\n        address l2Token,\n        uint256 amountToReturn\n    ) public override {\n        // If the l2TokenAddress is UDSC, we need to use the CCTP bridge.\n        if (l2Token == address(usdcToken) && _isCCTPEnabled()) {\n            _transferUsdc(TOKEN_RECIPIENT, amountToReturn);\n        } else {\n            if (l2Token == address(WRAPPED_NATIVE_TOKEN)) _wrapNativeToken();\n            // Otherwise, we use the Arbitrum ERC20 Gateway router.\n            ArbitrumL2ERC20GatewayLike tokenBridge = ArbitrumL2ERC20GatewayLike(L2_TOKEN_GATEWAY);\n            // If the gateway router's expected L2 token address does not match then revert. This check does not actually\n            // impact whether the bridge will succeed, since the ERC20 gateway router only requires the L1 token address, but\n            // it is added here to potentially catch scenarios where there was a mistake in the calldata.\n            if (tokenBridge.calculateL2TokenAddress(l1Token) != l2Token) revert InvalidTokenMapping();\n            //slither-disable-next-line unused-return\n            tokenBridge.outboundTransfer(\n                l1Token, // _l1Token. Address of the L1 token to bridge over.\n                TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the recipient.\n                amountToReturn, // _amount.\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n    }\n\n    function _requireAdminSender() internal view override {\n        if (msg.sender != CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin)) revert NotCrossDomainAdmin();\n    }\n}\n"
    },
    "contracts/chain-adapters/l2/Ovm_WithdrawalHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { WithdrawalHelperBase } from \"./WithdrawalHelperBase.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { ITokenMessenger } from \"../../external/interfaces/CCTPInterfaces.sol\";\nimport { Lib_PredeployAddresses } from \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport { LibOptimismUpgradeable } from \"@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol\";\nimport { IL2ERC20Bridge } from \"../../Ovm_SpokePool.sol\";\n\n/**\n * @notice Minimal interface for the Ovm_SpokePool contract. This interface is called to pull state from the network's\n * spoke pool contract to be used by this withdrawal adapter.\n */\ninterface IOvm_SpokePool {\n    // Returns the address of the token bridge for the input l2 token.\n    function tokenBridges(address token) external view returns (address);\n\n    // Returns the address of the l1 token set in the spoke pool for the input l2 token.\n    function remoteL1Tokens(address token) external view returns (address);\n\n    // Returns the address for the representation of ETH on the l2.\n    function l2Eth() external view returns (address);\n\n    // Returns the amount of gas the contract allocates for a token withdrawal.\n    function l1Gas() external view returns (uint32);\n}\n\n/**\n * @title Ovm_WithdrawalAdapter\n * @notice This contract interfaces with L2-L1 token bridges and withdraws tokens to a single address on L1.\n * @dev This contract should be deployed on OpStack L2s which both have a Ovm_SpokePool contract deployed to the L2\n * network AND only use token bridges defined in the Ovm_SpokePool. A notable exception to this requirement is Optimism,\n * which has a special SNX bridge (and thus this adapter will NOT work for Optimism).\n * @custom:security-contact bugs@across.to\n */\ncontract Ovm_WithdrawalHelper is WithdrawalHelperBase {\n    using SafeERC20 for IERC20;\n\n    // Address of the corresponding spoke pool on L2. This is to piggyback off of the spoke pool's supported\n    // token routes/defined token bridges.\n    IOvm_SpokePool public immutable spokePool;\n    // Address of native ETH on the l2. For OpStack chains, this address is used to indicate a native ETH withdrawal.\n    // In general, this address is 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n    address public immutable l2Eth;\n    // Address of the messenger contract on L2. This is by default defined in Lib_PredeployAddresses.\n    address public constant MESSENGER = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n\n    /*\n     * @notice Constructs the Ovm_WithdrawalAdapter.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network. For Ethereum, this\n     * is 0.\n     * @param _l2Gateway Address of the Optimism ERC20 L2 standard bridge contract.\n     * @param _tokenRecipient The L1 address which will unconditionally receive tokens from withdrawals by this contract.\n     * @param _spokePool The contract address of the Ovm_SpokePool which is deployed on this L2 network.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2Gateway,\n        address _tokenRecipient,\n        IOvm_SpokePool _spokePool\n    )\n        WithdrawalHelperBase(\n            _l2Usdc,\n            _cctpTokenMessenger,\n            _wrappedNativeToken,\n            _destinationCircleDomainId,\n            _l2Gateway,\n            _tokenRecipient\n        )\n    {\n        spokePool = _spokePool;\n\n        // This address is immutable in the spoke pool so we query once and save its value locally.\n        l2Eth = spokePool.l2Eth();\n    }\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function initialize(address _crossDomainAdmin) public initializer {\n        __WithdrawalHelper_init(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Calls CCTP or the Optimism token gateway to withdraw tokens back to the recipient.\n     * @param l2Token address of the l2Token to send back.\n     * @param amountToReturn amount of l2Token to send back.\n     * @dev The l1Token parameter is unused since we obtain the l1Token to receive by querying the state of the Ovm_SpokePool deployed\n     * to this network.\n     * @dev This function is a copy of the `_bridgeTokensToHubPool` function found on the Ovm_SpokePool contract here:\n     * https://github.com/across-protocol/contracts/blob/65191dbcded95c8fe050e0f95eb7848e3784e61f/contracts/Ovm_SpokePool.sol#L148.\n     * New lines of code correspond to instances where this contract queries state from the spoke pool, such as determining\n     * the appropriate token bridge for the withdrawal or finding the remoteL1Token to withdraw.\n     */\n    function withdrawToken(\n        address,\n        address l2Token,\n        uint256 amountToReturn\n    ) public override {\n        // Fetch the current l1Gas defined in the Ovm_SpokePool.\n        uint32 l1Gas = spokePool.l1Gas();\n        // If the token being bridged is WETH then we need to first unwrap it to ETH and then send ETH over the\n        // canonical bridge. On Optimism, this is address 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n        if (l2Token == address(WRAPPED_NATIVE_TOKEN)) {\n            // Wrap the contract's balance of the native token if we are withdrawing the L2's native token. We need wrap the contract's balance\n            // and then unwrap the amount to send to account for cases where `amountToReturn` is greater than the contract's native token balance\n            // and wrapped native token balance, but less than their sum.\n            _wrapNativeToken();\n            WETH9Interface(l2Token).withdraw(amountToReturn); // Unwrap into ETH.\n            l2Token = l2Eth; // Set the l2Token to ETH.\n            IL2ERC20Bridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo{ value: amountToReturn }(\n                l2Token, // _l2Token. Address of the L2 token to bridge over.\n                TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                amountToReturn, // _amount.\n                l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n        // If the token is USDC && CCTP bridge is enabled, then bridge USDC via CCTP.\n        else if (l2Token == address(usdcToken) && _isCCTPEnabled()) {\n            _transferUsdc(TOKEN_RECIPIENT, amountToReturn);\n        }\n        // Note we'll default to withdrawTo instead of bridgeERC20To unless the remoteL1Tokens mapping is set for\n        // the l2Token. withdrawTo should be used to bridge back non-native L2 tokens\n        // (i.e. non-native L2 tokens have a canonical L1 token). If we should bridge \"native L2\" tokens then\n        // we'd need to call bridgeERC20To and give allowance to the tokenBridge to spend l2Token from this contract.\n        // Therefore for native tokens we should set ensure that remoteL1Tokens is set for the l2Token.\n        else {\n            IL2ERC20Bridge tokenBridge = IL2ERC20Bridge(\n                spokePool.tokenBridges(l2Token) == address(0)\n                    ? Lib_PredeployAddresses.L2_STANDARD_BRIDGE\n                    : spokePool.tokenBridges(l2Token)\n            );\n            address remoteL1Token = spokePool.remoteL1Tokens(l2Token);\n            if (remoteL1Token != address(0)) {\n                // If there is a mapping for this L2 token to an L1 token, then use the L1 token address and\n                // call bridgeERC20To.\n                IERC20(l2Token).safeIncreaseAllowance(address(tokenBridge), amountToReturn);\n                tokenBridge.bridgeERC20To(\n                    l2Token, // _l2Token. Address of the L2 token to bridge over.\n                    remoteL1Token, // Remote token to be received on L1 side. If the\n                    // remoteL1Token on the other chain does not recognize the local token as the correct\n                    // pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n                    // this chain.\n                    TOKEN_RECIPIENT, // _to\n                    amountToReturn, // _amount\n                    l1Gas, // _l1Gas\n                    \"\" // _data\n                );\n            } else {\n                tokenBridge.withdrawTo(\n                    l2Token, // _l2Token. Address of the L2 token to bridge over.\n                    TOKEN_RECIPIENT, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                    amountToReturn, // _amount.\n                    l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                    \"\" // _data. We don't need to send any data for the bridging action.\n                );\n            }\n        }\n    }\n\n    function _requireAdminSender() internal view override {\n        if (LibOptimismUpgradeable.crossChainSender(MESSENGER) != crossDomainAdmin) revert NotCrossDomainAdmin();\n    }\n}\n"
    },
    "contracts/chain-adapters/l2/WithdrawalHelperBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MultiCaller } from \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport { CircleCCTPAdapter, ITokenMessenger, CircleDomainIds } from \"../../libraries/CircleCCTPAdapter.sol\";\nimport { WETH9Interface } from \"../../external/interfaces/WETH9Interface.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title WithdrawalHelperBase\n * @notice This contract contains general configurations for bridging tokens from an L2 to a single recipient on L1.\n * @dev This contract should be deployed on L2. It provides an interface to withdraw tokens to some address on L1. The only\n * function which must be implemented in contracts which inherit this contract is `withdrawToken`. It is up to that function\n * to determine which bridges to use for an input L2 token. Importantly, that function must also verify that the L2 to L1\n * token mapping is correct so that the bridge call itself can succeed.\n */\nabstract contract WithdrawalHelperBase is CircleCCTPAdapter, MultiCaller, UUPSUpgradeable {\n    // The L2 address of the wrapped native token for this L2.\n    WETH9Interface public immutable WRAPPED_NATIVE_TOKEN;\n    // The L1 address which will unconditionally receive all withdrawals from this contract.\n    address public immutable TOKEN_RECIPIENT;\n    // The address of the primary or default token gateway/canonical bridge contract on L2.\n    address public immutable L2_TOKEN_GATEWAY;\n    // The address of the admin contract on L1,which will likely be the hub pool. As a last resort, this admin can rescue stuck tokens\n    // on this withdrawal helper contract, similar to how it may send admin functions to spoke pools.\n    address public crossDomainAdmin;\n\n    event SetXDomainAdmin(address indexed _crossDomainAdmin);\n\n    // Error which triggers when the cross domain admin was attempted to be set to the zero address.\n    error InvalidCrossDomainAdmin();\n    // Error which triggers when the caller of a protected function is not the cross domain admin.\n    error NotCrossDomainAdmin();\n\n    // Functions which contain this modifier should only be callable via a cross-chain call where the L1 msg.sender is the hub pool.\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    /*\n     * @notice Constructs a new withdrawal helper.\n     * @param _l2Usdc Address of native USDC on the L2.\n     * @param _cctpTokenMessenger Address of the CCTP token messenger contract on L2.\n     * @param _wrappedNativeToken Address of the wrapped native token contract on L2.\n     * @param _destinationCircleDomainId Circle's assigned CCTP domain ID for the destination network.\n     * @param _l2TokenGateway Address of the network's l2 token gateway/bridge contract.\n     * @param _tokenRecipient L1 address which will unconditionally receive all withdrawals originating from this contract.\n     * @dev _disableInitializers() restricts anybody from initializing the implementation contract, which if not done,\n     * may disrupt the proxy if another EOA were to initialize it.\n     */\n    constructor(\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        WETH9Interface _wrappedNativeToken,\n        uint32 _destinationCircleDomainId,\n        address _l2TokenGateway,\n        address _tokenRecipient\n    ) CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, _destinationCircleDomainId) {\n        L2_TOKEN_GATEWAY = _l2TokenGateway;\n        TOKEN_RECIPIENT = _tokenRecipient;\n        WRAPPED_NATIVE_TOKEN = _wrappedNativeToken;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Receives the native token from bridge contracts.\n     * @dev When bridging from L3 to the L2's native token, OpStack bridges will send the \"unwrapped\"/native token to the recipient on L2\n     * during withdrawals. This means that this contract must be able to accept value transfers.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Initializes the withdrawal helper contract.\n     * @param _crossDomainAdmin L1 address of the contract which can send root bundles/messages to this forwarder contract.\n     */\n    function __WithdrawalHelper_init(address _crossDomainAdmin) public onlyInitializing {\n        __UUPSUpgradeable_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n    }\n\n    /*\n     * @notice Sets a new cross domain admin. The admin cannot be the zero address. The cross domain admin is the only address which may call\n     * upgrade this contract.\n     * @param _newCrossDomainAdmin L1 address of the new cross domain admin.\n     */\n    function _setCrossDomainAdmin(address _newCrossDomainAdmin) internal {\n        if (_newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = _newCrossDomainAdmin;\n        emit SetXDomainAdmin(_newCrossDomainAdmin);\n    }\n\n    /*\n     * @notice Withdraws a specified token to L1. This may be implemented uniquely for each L2, since each L2 has various\n     * dependencies to withdraw a token, such as the token bridge to use, mappings for L1 and L2 tokens, and gas configurations.\n     * Notably, withdrawals should always send token back to `TOKEN_RECIPIENT`.\n     * @param l1Token Address of the l1Token to receive.\n     * @param l2Token Address of the l2Token to send back.\n     * @param amountToReturn Amount of l2Token to send back.\n     * @dev Some networks do not require the L1/L2 token argument to withdraw tokens, while others enable contracts to derive the\n     * L1/L2 given knowledge of only one of the addresses. Both arguments are provided to enable a flexible interface; however, due\n     * to this, `withdrawToken` MUST account for situations where the L1/L2 token mapping is incorrect.\n     */\n    function withdrawToken(\n        address l1Token,\n        address l2Token,\n        uint256 amountToReturn\n    ) public virtual;\n\n    /*\n     * @notice Wraps the contract's entire balance of the native token.\n     */\n    function _wrapNativeToken() internal virtual {\n        if (address(this).balance > 0) WRAPPED_NATIVE_TOKEN.deposit{ value: address(this).balance }();\n    }\n\n    /*\n     * @notice Checks that the L1 msg.sender is the `crossDomainAdmin` address.\n     * @dev This implementation must change on a per-chain basis, since each L2 network has their own method of deriving the L1 msg.sender.\n     */\n    function _requireAdminSender() internal virtual;\n\n    /*\n     * @notice Access control check for upgrading this proxy contract\n     * @dev This requires that _requireAdminSender() is properly implemented on all contracts which inherit WithdrawalHelperBase.\n     */\n    function _authorizeUpgrade(address) internal override onlyAdmin {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/chain-adapters/Lisk_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Lisk. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Lisk_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Lisk system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Lisk.\n     * @param target Contract on Lisk that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Lisk.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Mode_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Mode. This is a clone of the Base adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Mode_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Mode system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Mode.\n     * @param target Contract on Mode that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Mode.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/OP_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { CircleCCTPAdapter, CircleDomainIds } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\nimport { IOpUSDCBridgeAdapter } from \"../external/interfaces/IOpUSDCBridgeAdapter.sol\";\nimport { WETH9Interface } from \"../external/interfaces/WETH9Interface.sol\";\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport { CrossDomainEnabled } from \"./CrossDomainEnabled.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to an OP stack chain.\n * @notice This adapter supports the OpUSDCBridgeAdapter interface for bridging into Circle Bridged USDC.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract OP_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n    IOpUSDCBridgeAdapter public immutable L1_OP_USDC_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger World Chain system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        IERC20 _l1Usdc,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IOpUSDCBridgeAdapter _l1USDCBridge\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n        L1_OP_USDC_BRIDGE = _l1USDCBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on World Chain.\n     * @param target Contract on World Chain that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to World Chain.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        } else if (l1Token == address(usdcToken)) {\n            if (_isCCTPEnabled()) {\n                _transferUsdc(to, amount);\n            } else {\n                // Use the relevant OP USDC bridge to received bridged USDC on L2.\n                IERC20(l1Token).safeIncreaseAllowance(address(L1_OP_USDC_BRIDGE), amount);\n                L1_OP_USDC_BRIDGE.sendMessage(to, amount, L2_GAS_LIMIT);\n            }\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(address(L1_STANDARD_BRIDGE), amount);\n            L1_STANDARD_BRIDGE.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Optimism_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Interface for Synthetix custom bridge to Optimism.\n */\ninterface SynthetixBridgeToOptimism is IL1StandardBridge {\n    /**\n     * @notice Send tokens to Optimism.\n     * @param to Address to send tokens to on L2.\n     * @param amount Amount of tokens to send.\n     */\n    function depositTo(address to, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Optimism.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore it's only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Optimism_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    // Optimism has the ability to support \"custom\" bridges. These bridges are not supported by the canonical bridge\n    // and so we need to store the address of the custom token and the associated bridge. In the event we want to\n    // support a new token that is not supported by Optimism, we can add a new custom bridge for it and re-deploy the\n    // adapter. A full list of custom optimism tokens and their associated bridges can be found here:\n    // https://github.com/ethereum-optimism/ethereum-optimism.github.io/blob/master/optimism.tokenlist.json\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant DAI_OPTIMISM_BRIDGE = 0x10E6593CDda8c58a1d0f14C5164B376352a55f2F;\n    address public constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n    address public constant SNX_OPTIMISM_BRIDGE = 0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Optimism system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Optimism)\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Optimism.\n     * @param target Contract on Optimism that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Optimism.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // If the l1Token is USDC, then we send it to the CCTP bridge\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            address bridgeToUse = address(L1_STANDARD_BRIDGE);\n\n            // Check if the L1 token requires a custom bridge. If so, use that bridge over the standard bridge.\n            if (l1Token == DAI) bridgeToUse = DAI_OPTIMISM_BRIDGE; // 1. DAI\n            if (l1Token == SNX) bridgeToUse = SNX_OPTIMISM_BRIDGE; // 2. SNX\n\n            IERC20(l1Token).safeIncreaseAllowance(bridgeToUse, amount);\n            if (l1Token == SNX) SynthetixBridgeToOptimism(bridgeToUse).depositTo(to, amount);\n            else IL1StandardBridge(bridgeToUse).depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Polygon_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Send tokens to Polygon.\n */\ninterface IRootChainManager {\n    /**\n     * @notice Send msg.value of ETH to Polygon\n     * @param user Recipient of ETH on Polygon.\n     */\n    function depositEtherFor(address user) external payable;\n\n    /**\n     * @notice Send ERC20 tokens to Polygon.\n     * @param user Recipient of L2 equivalent tokens on Polygon.\n     * @param rootToken L1 Address of token to send.\n     * @param depositData Data to pass to L2 including amount of tokens to send. Should be abi.encode(amount).\n     */\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external;\n}\n\n/**\n * @notice Send arbitrary messages to Polygon.\n */\ninterface IFxStateSender {\n    /**\n     * @notice Send arbitrary message to Polygon.\n     * @param _receiver Address on Polygon to receive message.\n     * @param _data Message to send to `_receiver` on Polygon.\n     */\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\n}\n\n/**\n * @notice Similar to RootChainManager, but for Matic (Plasma) bridge.\n */\ninterface DepositManager {\n    /**\n     * @notice Send tokens to Polygon. Only used to send MATIC in this Polygon_Adapter.\n     * @param token L1 token to send. Should be MATIC.\n     * @param user Recipient of L2 equivalent tokens on Polygon.\n     * @param amount Amount of `token` to send.\n     */\n    function depositERC20ForUser(\n        address token,\n        address user,\n        uint256 amount\n    ) external;\n}\n\n/**\n * @notice Sends cross chain messages Polygon L2 network.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Polygon_Adapter is AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    IRootChainManager public immutable ROOT_CHAIN_MANAGER;\n    IFxStateSender public immutable FX_STATE_SENDER;\n    DepositManager public immutable DEPOSIT_MANAGER;\n    address public immutable ERC20_PREDICATE;\n    address public immutable L1_MATIC;\n    WETH9Interface public immutable L1_WETH;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _rootChainManager RootChainManager Polygon system contract to deposit tokens over the PoS bridge.\n     * @param _fxStateSender FxStateSender Polygon system contract to send arbitrary messages to L2.\n     * @param _depositManager DepositManager Polygon system contract to deposit tokens over the Plasma bridge (Matic).\n     * @param _erc20Predicate ERC20Predicate Polygon system contract to approve when depositing to the PoS bridge.\n     * @param _l1Matic matic address on l1.\n     * @param _l1Weth WETH address on L1.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP.\n     */\n    constructor(\n        IRootChainManager _rootChainManager,\n        IFxStateSender _fxStateSender,\n        DepositManager _depositManager,\n        address _erc20Predicate,\n        address _l1Matic,\n        WETH9Interface _l1Weth,\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Polygon) {\n        ROOT_CHAIN_MANAGER = _rootChainManager;\n        FX_STATE_SENDER = _fxStateSender;\n        DEPOSIT_MANAGER = _depositManager;\n        ERC20_PREDICATE = _erc20Predicate;\n        L1_MATIC = _l1Matic;\n        L1_WETH = _l1Weth;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Polygon.\n     * @param target Contract on Polygon that will receive message.\n     * @param message Data to send to target.\n     */\n\n    function relayMessage(address target, bytes calldata message) external payable override {\n        FX_STATE_SENDER.sendMessageToChild(target, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Polygon.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            ROOT_CHAIN_MANAGER.depositEtherFor{ value: amount }(to);\n        }\n        // If the l1Token is USDC, then we send it to the CCTP bridge\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else if (l1Token == L1_MATIC) {\n            IERC20(l1Token).safeIncreaseAllowance(address(DEPOSIT_MANAGER), amount);\n            DEPOSIT_MANAGER.depositERC20ForUser(l1Token, to, amount);\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(ERC20_PREDICATE, amount);\n            ROOT_CHAIN_MANAGER.depositFor(to, l1Token, abi.encode(amount));\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Redstone_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Redstone. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Redstone_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Redstone system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Redstone.\n     * @param target Contract on Redstone that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Redstone.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/chain-adapters/Solana_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport { IMessageTransmitter, ITokenMessenger } from \"../external/interfaces/CCTPInterfaces.sol\";\nimport { SpokePoolInterface } from \"../interfaces/SpokePoolInterface.sol\";\nimport { AdapterInterface } from \"./interfaces/AdapterInterface.sol\";\nimport { CircleCCTPAdapter, CircleDomainIds } from \"../libraries/CircleCCTPAdapter.sol\";\nimport { Bytes32ToAddress } from \"../libraries/AddressConverters.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Solana via CCTP.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore it's only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Solana_Adapter is AdapterInterface, CircleCCTPAdapter {\n    /**\n     * @notice We use Bytes32ToAddress library to map a Solana address to an Ethereum address representation.\n     * @dev The Ethereum address is derived from the Solana address by truncating it to its lowest 20 bytes. This same\n     * conversion must be done by the HubPool owner when adding Solana spoke pool and setting the corresponding pool\n     * rebalance and deposit routes.\n     */\n    using Bytes32ToAddress for bytes32;\n\n    /**\n     * @notice The official Circle CCTP MessageTransmitter contract endpoint.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\n     */\n    // solhint-disable-next-line immutable-vars-naming\n    IMessageTransmitter public immutable cctpMessageTransmitter;\n\n    // Solana spoke pool address, decoded from Base58 to bytes32.\n    bytes32 public immutable SOLANA_SPOKE_POOL_BYTES32;\n\n    // Solana spoke pool address, mapped to its EVM address representation.\n    address public immutable SOLANA_SPOKE_POOL_ADDRESS;\n\n    // USDC mint address on Solana, decoded from Base58 to bytes32.\n    bytes32 public immutable SOLANA_USDC_BYTES32;\n\n    // USDC mint address on Solana, mapped to its EVM address representation.\n    address public immutable SOLANA_USDC_ADDRESS;\n\n    // USDC token address on Solana for the spoke pool (vault ATA), decoded from Base58 to bytes32.\n    bytes32 public immutable SOLANA_SPOKE_POOL_USDC_VAULT;\n\n    // Custom errors for constructor argument validation.\n    error InvalidCctpTokenMessenger(address tokenMessenger);\n    error InvalidCctpMessageTransmitter(address messageTransmitter);\n\n    // Custom errors for relayMessage validation.\n    error InvalidRelayMessageTarget(address target);\n    error InvalidOriginToken(address originToken);\n    error InvalidDestinationChainId(uint256 destinationChainId);\n\n    // Custom errors for relayTokens validation.\n    error InvalidL1Token(address l1Token);\n    error InvalidL2Token(address l2Token);\n    error InvalidAmount(uint256 amount);\n    error InvalidTokenRecipient(address to);\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Usdc USDC address on L1.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge tokens via CCTP.\n     * @param _cctpMessageTransmitter MessageTransmitter contract to bridge messages via CCTP.\n     * @param solanaSpokePool Solana spoke pool address, decoded from Base58 to bytes32.\n     * @param solanaUsdc USDC mint address on Solana, decoded from Base58 to bytes32.\n     * @param solanaSpokePoolUsdcVault USDC token address on Solana for the spoke pool, decoded from Base58 to bytes32.\n     */\n    constructor(\n        IERC20 _l1Usdc,\n        ITokenMessenger _cctpTokenMessenger,\n        IMessageTransmitter _cctpMessageTransmitter,\n        bytes32 solanaSpokePool,\n        bytes32 solanaUsdc,\n        bytes32 solanaSpokePoolUsdcVault\n    ) CircleCCTPAdapter(_l1Usdc, _cctpTokenMessenger, CircleDomainIds.Solana) {\n        // Solana adapter requires CCTP TokenMessenger and MessageTransmitter contracts to be set.\n        if (address(_cctpTokenMessenger) == address(0)) {\n            revert InvalidCctpTokenMessenger(address(_cctpTokenMessenger));\n        }\n        if (address(_cctpMessageTransmitter) == address(0)) {\n            revert InvalidCctpMessageTransmitter(address(_cctpMessageTransmitter));\n        }\n\n        cctpMessageTransmitter = _cctpMessageTransmitter;\n\n        SOLANA_SPOKE_POOL_BYTES32 = solanaSpokePool;\n        SOLANA_SPOKE_POOL_ADDRESS = solanaSpokePool.toAddressUnchecked();\n\n        SOLANA_USDC_BYTES32 = solanaUsdc;\n        SOLANA_USDC_ADDRESS = solanaUsdc.toAddressUnchecked();\n\n        SOLANA_SPOKE_POOL_USDC_VAULT = solanaSpokePoolUsdcVault;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Solana.\n     * @dev Only allows sending messages to the Solana spoke pool.\n     * @param target Program on Solana (translated as EVM address) that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        if (target != SOLANA_SPOKE_POOL_ADDRESS) {\n            revert InvalidRelayMessageTarget(target);\n        }\n\n        bytes4 selector = bytes4(message[:4]);\n        if (selector == SpokePoolInterface.setEnableRoute.selector) {\n            cctpMessageTransmitter.sendMessage(\n                CircleDomainIds.Solana,\n                SOLANA_SPOKE_POOL_BYTES32,\n                _translateSetEnableRoute(message)\n            );\n        } else {\n            cctpMessageTransmitter.sendMessage(CircleDomainIds.Solana, SOLANA_SPOKE_POOL_BYTES32, message);\n        }\n\n        // TODO: consider if we need also to emit the translated message.\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Solana.\n     * @dev Only allows bridging USDC to Solana spoke pool.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        if (l1Token != address(usdcToken)) {\n            revert InvalidL1Token(l1Token);\n        }\n        if (l2Token != SOLANA_USDC_ADDRESS) {\n            revert InvalidL2Token(l2Token);\n        }\n        if (amount > type(uint64).max) {\n            revert InvalidAmount(amount);\n        }\n        if (to != SOLANA_SPOKE_POOL_ADDRESS) {\n            revert InvalidTokenRecipient(to);\n        }\n\n        _transferUsdc(SOLANA_SPOKE_POOL_USDC_VAULT, amount);\n\n        // TODO: consider if we need also to emit the translated addresses.\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Translates a message to enable/disable a route on Solana spoke pool.\n     * @param message Message to translate, expecting setEnableRoute(address,uint256,bool).\n     * @return Translated message, using setEnableRoute(bytes32,uint64,bool).\n     */\n    function _translateSetEnableRoute(bytes calldata message) internal view returns (bytes memory) {\n        (address originToken, uint256 destinationChainId, bool enable) = abi.decode(\n            message[4:],\n            (address, uint256, bool)\n        );\n\n        if (originToken != SOLANA_USDC_ADDRESS) {\n            revert InvalidOriginToken(originToken);\n        }\n\n        if (destinationChainId > type(uint64).max) {\n            revert InvalidDestinationChainId(destinationChainId);\n        }\n\n        return\n            abi.encodeWithSignature(\n                \"setEnableRoute(bytes32,uint64,bool)\",\n                SOLANA_USDC_BYTES32,\n                uint64(destinationChainId),\n                enable\n            );\n    }\n}\n"
    },
    "contracts/chain-adapters/Zora_Adapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/CircleCCTPAdapter.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\n\n/**\n * @notice Contract containing logic to send messages from L1 to Zora. This is a clone of the Base/Mode adapter\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n * @custom:security-contact bugs@across.to\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Zora_Adapter is CrossDomainEnabled, AdapterInterface, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    uint32 public constant L2_GAS_LIMIT = 200_000;\n\n    WETH9Interface public immutable L1_WETH;\n\n    IL1StandardBridge public immutable L1_STANDARD_BRIDGE;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Zora system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     * @param _l1Usdc USDC address on L1.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge,\n        IERC20 _l1Usdc\n    )\n        CrossDomainEnabled(_crossDomainMessenger)\n        CircleCCTPAdapter(\n            _l1Usdc,\n            // Hardcode cctp messenger to 0x0 to disable CCTP bridging.\n            ITokenMessenger(address(0)),\n            CircleDomainIds.UNINITIALIZED\n        )\n    {\n        L1_WETH = _l1Weth;\n        L1_STANDARD_BRIDGE = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Zora.\n     * @param target Contract on Zora that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, L2_GAS_LIMIT, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Zora.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(L1_WETH)) {\n            L1_WETH.withdraw(amount);\n            L1_STANDARD_BRIDGE.depositETHTo{ value: amount }(to, L2_GAS_LIMIT, \"\");\n        }\n        // Check if this token is USDC, which requires a custom bridge via CCTP.\n        else if (_isCCTPEnabled() && l1Token == address(usdcToken)) {\n            _transferUsdc(to, amount);\n        } else {\n            IL1StandardBridge _l1StandardBridge = L1_STANDARD_BRIDGE;\n\n            IERC20(l1Token).safeIncreaseAllowance(address(_l1StandardBridge), amount);\n            _l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, L2_GAS_LIMIT, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}\n"
    },
    "contracts/erc7683/ERC7683.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/// @title GaslessCrossChainOrder CrossChainOrder type\n/// @notice Standard order struct to be signed by users, disseminated to fillers, and submitted to origin settler contracts\nstruct GaslessCrossChainOrder {\n    /// @dev The contract address that the order is meant to be settled by.\n    /// Fillers send this order to this contract address on the origin chain\n    address originSettler;\n    /// @dev The address of the user who is initiating the swap,\n    /// whose input tokens will be taken and escrowed\n    address user;\n    /// @dev Nonce to be used as replay protection for the order\n    uint256 nonce;\n    /// @dev The chainId of the origin chain\n    uint256 originChainId;\n    /// @dev The timestamp by which the order must be opened\n    uint32 openDeadline;\n    /// @dev The timestamp by which the order must be filled on the destination chain\n    uint32 fillDeadline;\n    /// @dev Type identifier for the order data. This is an EIP-712 typehash.\n    bytes32 orderDataType;\n    /// @dev Arbitrary implementation-specific data\n    /// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,\n    /// or any other order-type specific information\n    bytes orderData;\n}\n\n/// @title OnchainCrossChainOrder CrossChainOrder type\n/// @notice Standard order struct for user-opened orders, where the user is the msg.sender.\nstruct OnchainCrossChainOrder {\n    /// @dev The timestamp by which the order must be filled on the destination chain\n    uint32 fillDeadline;\n    /// @dev Type identifier for the order data. This is an EIP-712 typehash.\n    bytes32 orderDataType;\n    /// @dev Arbitrary implementation-specific data\n    /// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,\n    /// or any other order-type specific information\n    bytes orderData;\n}\n\n/// @title ResolvedCrossChainOrder type\n/// @notice An implementation-generic representation of an order intended for filler consumption\n/// @dev Defines all requirements for filling an order by unbundling the implementation-specific orderData.\n/// @dev Intended to improve integration generalization by allowing fillers to compute the exact input and output information of any order\nstruct ResolvedCrossChainOrder {\n    /// @dev The address of the user who is initiating the transfer\n    address user;\n    /// @dev The chainId of the origin chain\n    uint256 originChainId;\n    /// @dev The timestamp by which the order must be opened\n    uint32 openDeadline;\n    /// @dev The timestamp by which the order must be filled on the destination chain(s)\n    uint32 fillDeadline;\n    /// @dev The unique identifier for this order within this settlement system\n    bytes32 orderId;\n    /// @dev The max outputs that the filler will send. It's possible the actual amount depends on the state of the destination\n    ///      chain (destination dutch auction, for instance), so these outputs should be considered a cap on filler liabilities.\n    Output[] maxSpent;\n    /// @dev The minimum outputs that must to be given to the filler as part of order settlement. Similar to maxSpent, it's possible\n    ///      that special order types may not be able to guarantee the exact amount at open time, so this should be considered\n    ///      a floor on filler receipts.\n    Output[] minReceived;\n    /// @dev Each instruction in this array is parameterizes a single leg of the fill. This provides the filler with the information\n    ///      necessary to perform the fill on the destination(s).\n    FillInstruction[] fillInstructions;\n}\n\n/// @notice Tokens that must be receive for a valid order fulfillment\nstruct Output {\n    /// @dev The address of the ERC20 token on the destination chain\n    /// @dev address(0) used as a sentinel for the native token\n    bytes32 token;\n    /// @dev The amount of the token to be sent\n    uint256 amount;\n    /// @dev The address to receive the output tokens\n    bytes32 recipient;\n    /// @dev The destination chain for this output\n    uint256 chainId;\n}\n\n/// @title FillInstruction type\n/// @notice Instructions to parameterize each leg of the fill\n/// @dev Provides all the origin-generated information required to produce a valid fill leg\nstruct FillInstruction {\n    /// @dev The contract address that the order is meant to be settled by\n    uint64 destinationChainId;\n    /// @dev The contract address that the order is meant to be filled on\n    bytes32 destinationSettler;\n    /// @dev The data generated on the origin chain needed by the destinationSettler to process the fill\n    bytes originData;\n}\n\n/// @title IOriginSettler\n/// @notice Standard interface for settlement contracts on the origin chain\ninterface IOriginSettler {\n    /// @notice Signals that an order has been opened\n    /// @param orderId a unique order identifier within this settlement system\n    /// @param resolvedOrder resolved order that would be returned by resolve if called instead of Open\n    event Open(bytes32 indexed orderId, ResolvedCrossChainOrder resolvedOrder);\n\n    /// @notice Opens a gasless cross-chain order on behalf of a user.\n    /// @dev To be called by the filler.\n    /// @dev This method must emit the Open event\n    /// @param order The GaslessCrossChainOrder definition\n    /// @param signature The user's signature over the order\n    /// @param originFillerData Any filler-defined data required by the settler\n    function openFor(\n        GaslessCrossChainOrder calldata order,\n        bytes calldata signature,\n        bytes calldata originFillerData\n    ) external;\n\n    /// @notice Opens a cross-chain order\n    /// @dev To be called by the user\n    /// @dev This method must emit the Open event\n    /// @param order The OnchainCrossChainOrder definition\n    function open(OnchainCrossChainOrder calldata order) external;\n\n    /// @notice Resolves a specific GaslessCrossChainOrder into a generic ResolvedCrossChainOrder\n    /// @dev Intended to improve standardized integration of various order types and settlement contracts\n    /// @param order The GaslessCrossChainOrder definition\n    /// @param originFillerData Any filler-defined data required by the settler\n    /// @return ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order\n    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData)\n        external\n        view\n        returns (ResolvedCrossChainOrder memory);\n\n    /// @notice Resolves a specific OnchainCrossChainOrder into a generic ResolvedCrossChainOrder\n    /// @dev Intended to improve standardized integration of various order types and settlement contracts\n    /// @param order The OnchainCrossChainOrder definition\n    /// @return ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order\n    function resolve(OnchainCrossChainOrder calldata order) external view returns (ResolvedCrossChainOrder memory);\n}\n\n/// @title IDestinationSettler\n/// @notice Standard interface for settlement contracts on the destination chain\ninterface IDestinationSettler {\n    /// @notice Fills a single leg of a particular order on the destination chain\n    /// @param orderId Unique order identifier for this order\n    /// @param originData Data emitted on the origin to parameterize the fill\n    /// @param fillerData Data provided by the filler to inform the fill or express their preferences\n    function fill(\n        bytes32 orderId,\n        bytes calldata originData,\n        bytes calldata fillerData\n    ) external;\n}\n"
    },
    "contracts/erc7683/ERC7683OrderDepositor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../external/interfaces/IPermit2.sol\";\nimport { V3SpokePoolInterface } from \"../interfaces/V3SpokePoolInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Output, GaslessCrossChainOrder, OnchainCrossChainOrder, ResolvedCrossChainOrder, IOriginSettler, FillInstruction } from \"./ERC7683.sol\";\nimport { AcrossOrderData, AcrossOriginFillerData, ERC7683Permit2Lib, ACROSS_ORDER_DATA_TYPE_HASH } from \"./ERC7683Permit2Lib.sol\";\nimport { AddressToBytes32, Bytes32ToAddress } from \"../libraries/AddressConverters.sol\";\n\n/**\n * @notice ERC7683OrderDepositor processes an external order type and translates it into an AcrossV3 deposit.\n * @dev This contract is abstract because it is intended to be usable by a contract that can accept the deposit\n * as well as one that sends the deposit to another contract.\n * @custom:security-contact bugs@across.to\n */\nabstract contract ERC7683OrderDepositor is IOriginSettler {\n    using SafeERC20 for IERC20;\n    using Bytes32ToAddress for bytes32;\n    using AddressToBytes32 for address;\n\n    error WrongSettlementContract();\n    error WrongChainId();\n    error WrongOrderDataType();\n    error WrongExclusiveRelayer();\n    error NoDestinationSettlerForChain(uint256 chainId);\n\n    // Permit2 contract for this network.\n    IPermit2 public immutable PERMIT2;\n\n    // QUOTE_BEFORE_DEADLINE is subtracted from the deadline to get the quote timestamp.\n    // This is a somewhat arbitrary conversion, but order creators need some way to precompute the quote timestamp.\n    uint256 public immutable QUOTE_BEFORE_DEADLINE;\n\n    /**\n     * @notice Construct the Permit2Depositor.\n     * @param _permit2 Permit2 contract\n     * @param _quoteBeforeDeadline quoteBeforeDeadline is subtracted from the deadline to get the quote timestamp.\n     */\n    constructor(IPermit2 _permit2, uint256 _quoteBeforeDeadline) {\n        PERMIT2 = _permit2;\n        QUOTE_BEFORE_DEADLINE = _quoteBeforeDeadline;\n    }\n\n    /**\n     * @notice Open the order on behalf of the user.\n     * @dev This will pull in the user's funds and make the order available to be filled.\n     * @param order the ERC7683 compliant order.\n     * @param signature signature for the EIP-712 compliant order type.\n     * @param originFillerData Across-specific fillerData.\n     */\n    function openFor(\n        GaslessCrossChainOrder calldata order,\n        bytes calldata signature,\n        bytes calldata originFillerData\n    ) external {\n        (\n            ResolvedCrossChainOrder memory resolvedOrder,\n            AcrossOrderData memory acrossOrderData,\n            AcrossOriginFillerData memory acrossOriginFillerData\n        ) = _resolveFor(order, originFillerData);\n\n        // Verify Permit2 signature and pull user funds into this contract\n        _processPermit2Order(order, acrossOrderData, signature);\n\n        _callDeposit(\n            order.user,\n            acrossOrderData.recipient.toAddress(),\n            acrossOrderData.inputToken,\n            acrossOrderData.outputToken,\n            acrossOrderData.inputAmount,\n            acrossOrderData.outputAmount,\n            acrossOrderData.destinationChainId,\n            acrossOriginFillerData.exclusiveRelayer,\n            acrossOrderData.depositNonce,\n            // Note: simplifying assumption to avoid quote timestamps that cause orders to expire before the deadline.\n            SafeCast.toUint32(order.openDeadline - QUOTE_BEFORE_DEADLINE),\n            order.fillDeadline,\n            acrossOrderData.exclusivityPeriod,\n            acrossOrderData.message\n        );\n\n        emit Open(keccak256(resolvedOrder.fillInstructions[0].originData), resolvedOrder);\n    }\n\n    /**\n     * @notice Opens the order.\n     * @dev Unlike openFor, this method is callable by the user.\n     * @dev This will pull in the user's funds and make the order available to be filled.\n     * @param order the ERC7683 compliant order.\n     */\n    function open(OnchainCrossChainOrder calldata order) external {\n        (ResolvedCrossChainOrder memory resolvedOrder, AcrossOrderData memory acrossOrderData) = _resolve(order);\n\n        IERC20(acrossOrderData.inputToken).safeTransferFrom(msg.sender, address(this), acrossOrderData.inputAmount);\n\n        _callDeposit(\n            msg.sender,\n            acrossOrderData.recipient.toAddress(),\n            acrossOrderData.inputToken,\n            acrossOrderData.outputToken,\n            acrossOrderData.inputAmount,\n            acrossOrderData.outputAmount,\n            acrossOrderData.destinationChainId,\n            acrossOrderData.exclusiveRelayer,\n            acrossOrderData.depositNonce,\n            // Note: simplifying assumption to avoid the order type having to bake in the quote timestamp.\n            SafeCast.toUint32(block.timestamp),\n            order.fillDeadline,\n            acrossOrderData.exclusivityPeriod,\n            acrossOrderData.message\n        );\n\n        emit Open(keccak256(resolvedOrder.fillInstructions[0].originData), resolvedOrder);\n    }\n\n    /**\n     * @notice Constructs a ResolvedOrder from a GaslessCrossChainOrder and originFillerData.\n     * @param order the ERC-7683 compliant order.\n     * @param originFillerData Across-specific fillerData.\n     */\n    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData)\n        public\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder)\n    {\n        (resolvedOrder, , ) = _resolveFor(order, originFillerData);\n    }\n\n    /**\n     * @notice Constructs a ResolvedOrder from a CrossChainOrder.\n     * @param order the ERC7683 compliant order.\n     */\n    function resolve(OnchainCrossChainOrder calldata order)\n        public\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder)\n    {\n        (resolvedOrder, ) = _resolve(order);\n    }\n\n    /**\n     * @notice Decodes the Across specific orderData and fillerData into descriptive types.\n     * @param orderData the orderData field of the ERC7683 compliant order.\n     * @param fillerData Across-specific fillerData.\n     * @return acrossOrderData decoded AcrossOrderData.\n     * @return acrossOriginFillerData decoded AcrossOriginFillerData.\n     */\n    function decode(bytes memory orderData, bytes memory fillerData)\n        public\n        pure\n        returns (AcrossOrderData memory, AcrossOriginFillerData memory)\n    {\n        return (abi.decode(orderData, (AcrossOrderData)), abi.decode(fillerData, (AcrossOriginFillerData)));\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint32) {\n        return SafeCast.toUint32(block.timestamp); // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Convenience method to compute the Across depositId for orders sent through 7683.\n     * @dev if a 0 depositNonce is used, the depositId will not be deterministic (meaning it can change depending on\n     * when the open txn is mined), but you will be safe from collisions. See the unsafeDepositV3 method on SpokePool\n     * for more details on how to choose between deterministic and non-deterministic.\n     * @param depositNonce the depositNonce field in the order.\n     * @param depositor the sender or signer of the order.\n     * @return the resulting Across depositId.\n     */\n    function computeDepositId(uint256 depositNonce, address depositor) public view virtual returns (uint256);\n\n    function _resolveFor(GaslessCrossChainOrder calldata order, bytes calldata fillerData)\n        internal\n        view\n        returns (\n            ResolvedCrossChainOrder memory resolvedOrder,\n            AcrossOrderData memory acrossOrderData,\n            AcrossOriginFillerData memory acrossOriginFillerData\n        )\n    {\n        // Ensure that order was intended to be settled by Across.\n        if (order.originSettler != address(this)) {\n            revert WrongSettlementContract();\n        }\n\n        if (order.originChainId != block.chainid) {\n            revert WrongChainId();\n        }\n\n        if (order.orderDataType != ACROSS_ORDER_DATA_TYPE_HASH) {\n            revert WrongOrderDataType();\n        }\n\n        // Extract Across-specific params.\n        (acrossOrderData, acrossOriginFillerData) = decode(order.orderData, fillerData);\n\n        if (\n            acrossOrderData.exclusiveRelayer != address(0) &&\n            acrossOrderData.exclusiveRelayer != acrossOriginFillerData.exclusiveRelayer\n        ) {\n            revert WrongExclusiveRelayer();\n        }\n\n        Output[] memory maxSpent = new Output[](1);\n        maxSpent[0] = Output({\n            token: acrossOrderData.outputToken.toBytes32(),\n            amount: acrossOrderData.outputAmount,\n            recipient: acrossOrderData.recipient,\n            chainId: acrossOrderData.destinationChainId\n        });\n\n        // We assume that filler takes repayment on the origin chain in which case the filler output\n        // will always be equal to the input amount. If the filler requests repayment somewhere else then\n        // the filler output will be equal to the input amount less a fee based on the chain they request\n        // repayment on.\n        Output[] memory minReceived = new Output[](1);\n        minReceived[0] = Output({\n            token: acrossOrderData.inputToken.toBytes32(),\n            amount: acrossOrderData.inputAmount,\n            recipient: acrossOriginFillerData.exclusiveRelayer.toBytes32(),\n            chainId: block.chainid\n        });\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        V3SpokePoolInterface.V3RelayData memory relayData;\n        relayData.depositor = order.user.toBytes32();\n        relayData.recipient = acrossOrderData.recipient;\n        relayData.exclusiveRelayer = acrossOriginFillerData.exclusiveRelayer.toBytes32();\n        relayData.inputToken = acrossOrderData.inputToken.toBytes32();\n        relayData.outputToken = acrossOrderData.outputToken.toBytes32();\n        relayData.inputAmount = acrossOrderData.inputAmount;\n        relayData.outputAmount = acrossOrderData.outputAmount;\n        relayData.originChainId = block.chainid;\n        relayData.depositId = computeDepositId(acrossOrderData.depositNonce, order.user);\n        relayData.fillDeadline = order.fillDeadline;\n        relayData.exclusivityDeadline = acrossOrderData.exclusivityPeriod;\n        relayData.message = acrossOrderData.message;\n        fillInstructions[0] = FillInstruction({\n            destinationChainId: SafeCast.toUint64(acrossOrderData.destinationChainId),\n            destinationSettler: _destinationSettler(acrossOrderData.destinationChainId).toBytes32(),\n            originData: abi.encode(relayData)\n        });\n\n        resolvedOrder = ResolvedCrossChainOrder({\n            user: order.user,\n            originChainId: order.originChainId,\n            openDeadline: order.openDeadline,\n            fillDeadline: order.fillDeadline,\n            minReceived: minReceived,\n            maxSpent: maxSpent,\n            fillInstructions: fillInstructions,\n            orderId: keccak256(abi.encode(relayData, acrossOrderData.destinationChainId))\n        });\n    }\n\n    function _resolve(OnchainCrossChainOrder calldata order)\n        internal\n        view\n        returns (ResolvedCrossChainOrder memory resolvedOrder, AcrossOrderData memory acrossOrderData)\n    {\n        if (order.orderDataType != ACROSS_ORDER_DATA_TYPE_HASH) {\n            revert WrongOrderDataType();\n        }\n\n        // Extract Across-specific params.\n        acrossOrderData = abi.decode(order.orderData, (AcrossOrderData));\n\n        Output[] memory maxSpent = new Output[](1);\n        maxSpent[0] = Output({\n            token: acrossOrderData.outputToken.toBytes32(),\n            amount: acrossOrderData.outputAmount,\n            recipient: acrossOrderData.recipient,\n            chainId: acrossOrderData.destinationChainId\n        });\n\n        // We assume that filler takes repayment on the origin chain in which case the filler output\n        // will always be equal to the input amount. If the filler requests repayment somewhere else then\n        // the filler output will be equal to the input amount less a fee based on the chain they request\n        // repayment on.\n        Output[] memory minReceived = new Output[](1);\n        minReceived[0] = Output({\n            token: acrossOrderData.inputToken.toBytes32(),\n            amount: acrossOrderData.inputAmount,\n            recipient: acrossOrderData.exclusiveRelayer.toBytes32(),\n            chainId: block.chainid\n        });\n\n        FillInstruction[] memory fillInstructions = new FillInstruction[](1);\n        V3SpokePoolInterface.V3RelayData memory relayData;\n        relayData.depositor = msg.sender.toBytes32();\n        relayData.recipient = acrossOrderData.recipient;\n        relayData.exclusiveRelayer = acrossOrderData.exclusiveRelayer.toBytes32();\n        relayData.inputToken = acrossOrderData.inputToken.toBytes32();\n        relayData.outputToken = acrossOrderData.outputToken.toBytes32();\n        relayData.inputAmount = acrossOrderData.inputAmount;\n        relayData.outputAmount = acrossOrderData.outputAmount;\n        relayData.originChainId = block.chainid;\n        relayData.depositId = computeDepositId(acrossOrderData.depositNonce, msg.sender);\n        relayData.fillDeadline = order.fillDeadline;\n        relayData.exclusivityDeadline = acrossOrderData.exclusivityPeriod;\n        relayData.message = acrossOrderData.message;\n        fillInstructions[0] = FillInstruction({\n            destinationChainId: SafeCast.toUint64(acrossOrderData.destinationChainId),\n            destinationSettler: _destinationSettler(acrossOrderData.destinationChainId).toBytes32(),\n            originData: abi.encode(relayData)\n        });\n\n        resolvedOrder = ResolvedCrossChainOrder({\n            user: msg.sender,\n            originChainId: block.chainid,\n            openDeadline: type(uint32).max, // no deadline since the user is sending it\n            fillDeadline: order.fillDeadline,\n            minReceived: minReceived,\n            maxSpent: maxSpent,\n            fillInstructions: fillInstructions,\n            orderId: keccak256(abi.encode(relayData, acrossOrderData.destinationChainId))\n        });\n    }\n\n    function _processPermit2Order(\n        GaslessCrossChainOrder memory order,\n        AcrossOrderData memory acrossOrderData,\n        bytes memory signature\n    ) internal {\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\n            permitted: IPermit2.TokenPermissions({\n                token: acrossOrderData.inputToken,\n                amount: acrossOrderData.inputAmount\n            }),\n            nonce: order.nonce,\n            deadline: order.openDeadline\n        });\n\n        IPermit2.SignatureTransferDetails memory signatureTransferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: acrossOrderData.inputAmount\n        });\n\n        // Pull user funds.\n        PERMIT2.permitWitnessTransferFrom(\n            permit,\n            signatureTransferDetails,\n            order.user,\n            ERC7683Permit2Lib.hashOrder(order, ERC7683Permit2Lib.hashOrderData(acrossOrderData)), // witness data hash\n            ERC7683Permit2Lib.PERMIT2_ORDER_TYPE, // witness data type string\n            signature\n        );\n    }\n\n    function _callDeposit(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityPeriod,\n        bytes memory message\n    ) internal virtual;\n\n    function _destinationSettler(uint256 chainId) internal view virtual returns (address);\n}\n"
    },
    "contracts/erc7683/ERC7683OrderDepositorExternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC7683OrderDepositor } from \"./ERC7683OrderDepositor.sol\";\nimport \"../SpokePool.sol\";\nimport \"../external/interfaces/IPermit2.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\n\n/**\n * @notice ERC7683OrderDepositorExternal processes an external order type and translates it into an AcrossV3Deposit\n * that it sends to the SpokePool contract.\n * @custom:security-contact bugs@across.to\n */\ncontract ERC7683OrderDepositorExternal is ERC7683OrderDepositor, Ownable, MultiCaller {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n\n    event SetDestinationSettler(\n        uint256 indexed chainId,\n        address indexed prevDestinationSettler,\n        address indexed destinationSettler\n    );\n\n    SpokePool public immutable SPOKE_POOL;\n\n    // Mapping of chainIds to destination settler addresses.\n    mapping(uint256 => address) public destinationSettlers;\n\n    constructor(\n        SpokePool _spokePool,\n        IPermit2 _permit2,\n        uint256 _quoteBeforeDeadline\n    ) ERC7683OrderDepositor(_permit2, _quoteBeforeDeadline) {\n        SPOKE_POOL = _spokePool;\n    }\n\n    function setDestinationSettler(uint256 chainId, address destinationSettler) external onlyOwner {\n        address prevDestinationSettler = destinationSettlers[chainId];\n        destinationSettlers[chainId] = destinationSettler;\n        emit SetDestinationSettler(chainId, prevDestinationSettler, destinationSettler);\n    }\n\n    function _callDeposit(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes memory message\n    ) internal override {\n        IERC20(inputToken).forceApprove(address(SPOKE_POOL), inputAmount);\n\n        if (depositNonce == 0) {\n            SPOKE_POOL.depositV3(\n                depositor,\n                recipient,\n                inputToken,\n                outputToken,\n                inputAmount,\n                outputAmount,\n                destinationChainId,\n                exclusiveRelayer,\n                quoteTimestamp,\n                fillDeadline,\n                exclusivityDeadline,\n                message\n            );\n        } else {\n            SPOKE_POOL.unsafeDeposit(\n                depositor.toBytes32(),\n                recipient.toBytes32(),\n                inputToken.toBytes32(),\n                outputToken.toBytes32(),\n                inputAmount,\n                outputAmount,\n                destinationChainId,\n                exclusiveRelayer.toBytes32(),\n                depositNonce,\n                quoteTimestamp,\n                fillDeadline,\n                exclusivityDeadline,\n                message\n            );\n        }\n    }\n\n    function computeDepositId(uint256 depositNonce, address depositor) public view override returns (uint256) {\n        return\n            depositNonce == 0\n                ? SPOKE_POOL.numberOfDeposits()\n                : SPOKE_POOL.getUnsafeDepositId(address(this), depositor.toBytes32(), depositNonce);\n    }\n\n    function _destinationSettler(uint256 chainId) internal view override returns (address) {\n        if (destinationSettlers[chainId] == address(0)) revert NoDestinationSettlerForChain(chainId);\n        return destinationSettlers[chainId];\n    }\n}\n"
    },
    "contracts/erc7683/ERC7683Permit2Lib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../external/interfaces/IPermit2.sol\";\nimport { GaslessCrossChainOrder } from \"./ERC7683.sol\";\n\n// Data unique to every CrossChainOrder settled on Across\nstruct AcrossOrderData {\n    address inputToken;\n    uint256 inputAmount;\n    address outputToken;\n    uint256 outputAmount;\n    uint256 destinationChainId;\n    bytes32 recipient;\n    address exclusiveRelayer;\n    uint256 depositNonce;\n    uint32 exclusivityPeriod;\n    bytes message;\n}\n\nstruct AcrossOriginFillerData {\n    address exclusiveRelayer;\n}\n\nstruct AcrossDestinationFillerData {\n    uint256 repaymentChainId;\n}\n\nbytes constant ACROSS_ORDER_DATA_TYPE = abi.encodePacked(\n    \"AcrossOrderData(\",\n    \"address inputToken,\",\n    \"uint256 inputAmount,\",\n    \"address outputToken,\",\n    \"uint256 outputAmount,\",\n    \"uint256 destinationChainId,\",\n    \"bytes32 recipient,\",\n    \"address exclusiveRelayer,\"\n    \"uint256 depositNonce,\",\n    \"uint32 exclusivityPeriod,\",\n    \"bytes message)\"\n);\n\nbytes32 constant ACROSS_ORDER_DATA_TYPE_HASH = keccak256(ACROSS_ORDER_DATA_TYPE);\n\n/**\n * @notice ERC7683Permit2Lib knows how to process a particular type of external Permit2Order so that it can be used in Across.\n * @dev This library is responsible for definining the ERC712 type strings/hashes and performing hashes on the types.\n * @custom:security-contact bugs@across.to\n */\nlibrary ERC7683Permit2Lib {\n    bytes internal constant GASLESS_CROSS_CHAIN_ORDER_TYPE =\n        abi.encodePacked(\n            \"GaslessCrossChainOrder(\",\n            \"address originSettler,\",\n            \"address user,\",\n            \"uint256 nonce,\",\n            \"uint256 originChainId,\",\n            \"uint32 openDeadline,\",\n            \"uint32 fillDeadline,\",\n            \"bytes32 orderDataType,\",\n            \"AcrossOrderData orderData)\"\n        );\n\n    bytes internal constant GASLESS_CROSS_CHAIN_ORDER_EIP712_TYPE =\n        abi.encodePacked(GASLESS_CROSS_CHAIN_ORDER_TYPE, ACROSS_ORDER_DATA_TYPE);\n    bytes32 internal constant GASLESS_CROSS_CHAIN_ORDER_TYPE_HASH = keccak256(GASLESS_CROSS_CHAIN_ORDER_EIP712_TYPE);\n\n    string private constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n    string internal constant PERMIT2_ORDER_TYPE =\n        string(\n            abi.encodePacked(\n                \"GaslessCrossChainOrder witness)\",\n                ACROSS_ORDER_DATA_TYPE,\n                GASLESS_CROSS_CHAIN_ORDER_TYPE,\n                TOKEN_PERMISSIONS_TYPE\n            )\n        );\n\n    // Hashes an order to get an order hash. Needed for permit2.\n    function hashOrder(GaslessCrossChainOrder memory order, bytes32 orderDataHash) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    GASLESS_CROSS_CHAIN_ORDER_TYPE_HASH,\n                    order.originSettler,\n                    order.user,\n                    order.nonce,\n                    order.originChainId,\n                    order.openDeadline,\n                    order.fillDeadline,\n                    order.orderDataType,\n                    orderDataHash\n                )\n            );\n    }\n\n    function hashOrderData(AcrossOrderData memory orderData) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    ACROSS_ORDER_DATA_TYPE_HASH,\n                    orderData.inputToken,\n                    orderData.inputAmount,\n                    orderData.outputToken,\n                    orderData.outputAmount,\n                    orderData.destinationChainId,\n                    orderData.recipient,\n                    orderData.exclusiveRelayer,\n                    orderData.exclusivityPeriod,\n                    keccak256(orderData.message)\n                )\n            );\n    }\n}\n"
    },
    "contracts/Ethereum_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @notice Ethereum L1 specific SpokePool. Used on Ethereum L1 to facilitate L2->L1 transfers.\n * @custom:security-contact bugs@across.to\n */\ncontract Ethereum_SpokePool is SpokePool, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    ) SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer) {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Ethereum SpokePool.\n     * @dev crossDomainAdmin is unused on this contract.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(uint32 _initialDepositId, address _withdrawalRecipient) public initializer {\n        __Ownable_init();\n        __SpokePool_init(_initialDepositId, _withdrawalRecipient, _withdrawalRecipient);\n    }\n\n    /**************************************\n     *          INTERNAL FUNCTIONS           *\n     **************************************/\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        IERC20Upgradeable(l2TokenAddress).safeTransfer(withdrawalRecipient, amountToReturn);\n    }\n\n    // The SpokePool deployed to the same network as the HubPool must be owned by the HubPool.\n    // A core assumption of this contract system is that the HubPool is deployed on Ethereum.\n    function _requireAdminSender() internal override onlyOwner {}\n}\n"
    },
    "contracts/external/interfaces/CCTPInterfaces.sol": {
      "content": "/**\n * Copyright (C) 2015, 2016, 2017 Dapphub\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/**\n * Imported as-is from commit 139d8d0ce3b5531d3c7ec284f89d946dfb720016 of:\n *   * https://github.com/walkerq/evm-cctp-contracts/blob/139d8d0ce3b5531d3c7ec284f89d946dfb720016/src/TokenMessenger.sol\n * Changes applied post-import:\n *   * Removed a majority of code from this contract and converted the needed function signatures in this interface.\n */\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @return _nonce unique nonce reserved by message\n     */\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64 _nonce);\n\n    /**\n     * @notice Minter responsible for minting and burning tokens on the local domain\n     * @dev A TokenMessenger stores a TokenMinter contract which extends the TokenController contract.\n     * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMessenger.sol#L110\n     * @return minter Token Minter contract.\n     */\n    function localMinter() external view returns (ITokenMinter minter);\n}\n\n/**\n * A TokenMessenger stores a TokenMinter contract which extends the TokenController contract. The TokenController\n * contract has a burnLimitsPerMessage public mapping which can be queried to find the per-message burn limit\n * for a given token:\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMinter.sol#L33\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/roles/TokenController.sol#L69C40-L69C60\n *\n */\ninterface ITokenMinter {\n    /**\n     * @notice Supported burnable tokens on the local domain\n     * local token (address) => maximum burn amounts per message\n     * @param token address of token contract\n     * @return burnLimit maximum burn amount per message for token\n     */\n    function burnLimitsPerMessage(address token) external view returns (uint256);\n}\n\n/**\n * IMessageTransmitter in CCTP inherits IRelayer and IReceiver, but here we only import sendMessage from IRelayer:\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IMessageTransmitter.sol#L25\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IRelayer.sol#L23-L35\n */\ninterface IMessageTransmitter {\n    /**\n     * @notice Sends an outgoing message from the source domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external returns (uint64);\n}\n"
    },
    "contracts/external/interfaces/IOpUSDCBridgeAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * Imported from https://github.com/defi-wonderland/opUSDC\n * https://github.com/defi-wonderland/opUSDC/blob/ef22e5731f1655bf5249b2160452cce9aa06ff3f/src/interfaces/IOpUSDCBridgeAdapter.sol#L198C1-L204C84\n */\ninterface IOpUSDCBridgeAdapter {\n    /**\n     * @notice Send tokens to another chain through the linked adapter\n     * @param _to The target address on the destination chain\n     * @param _amount The amount of tokens to send\n     * @param _minGasLimit Minimum gas limit that the message can be executed with\n     */\n    function sendMessage(\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit\n    ) external;\n}\n"
    },
    "contracts/external/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPermit2 {\n    struct TokenPermissions {\n        address token;\n        uint256 amount;\n    }\n\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    struct SignatureTransferDetails {\n        address to;\n        uint256 requestedAmount;\n    }\n\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint160 amount,\n        address token\n    ) external;\n}\n"
    },
    "contracts/external/interfaces/IPolygonZkEVMBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Interface of Polygon zkEVM's Canonical Bridge\n * See https://github.com/0xPolygonHermez/zkevm-contracts/blob/53e95f3a236d8bea87c27cb8714a5d21496a3b20/contracts/interfaces/IPolygonZkEVMBridge.sol\n */\ninterface IPolygonZkEVMBridge {\n    /**\n     * @notice Deposit add a new leaf to the merkle tree\n     * @param destinationNetwork Network destination\n     * @param destinationAddress Address destination\n     * @param amount Amount of tokens\n     * @param token Token address, 0 address is reserved for ether\n     * @param forceUpdateGlobalExitRoot Indicates if the new global exit root is updated or not\n     * @param permitData Raw data of the call `permit` of the token\n     */\n    function bridgeAsset(\n        uint32 destinationNetwork,\n        address destinationAddress,\n        uint256 amount,\n        address token,\n        bool forceUpdateGlobalExitRoot,\n        bytes calldata permitData\n    ) external payable;\n\n    /**\n     * @notice Bridge message and send ETH value\n     * @param destinationNetwork Network destination\n     * @param destinationAddress Address destination\n     * @param forceUpdateGlobalExitRoot Indicates if the new global exit root is updated or not\n     * @param metadata Message metadata\n     */\n    function bridgeMessage(\n        uint32 destinationNetwork,\n        address destinationAddress,\n        bool forceUpdateGlobalExitRoot,\n        bytes calldata metadata\n    ) external payable;\n}\n"
    },
    "contracts/external/interfaces/SuccinctInterfaces.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// These interfaces are a subset of the Succinct interfaces here: https://github.com/succinctlabs/telepathy-contracts.\n\n// This interface should be implemented by any contract wanting to receive messages sent over the Succinct bridge.\ninterface ITelepathyHandler {\n    function handleTelepathy(\n        uint16 _sourceChainId,\n        address _senderAddress,\n        bytes memory _data\n    ) external returns (bytes4);\n}\n\n// This interface represents the contract that we call into to send messages over the Succinct AMB.\ninterface ITelepathyBroadcaster {\n    function send(\n        uint16 _recipientChainId,\n        address _recipientAddress,\n        bytes calldata _data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/external/interfaces/WETH9Interface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Interface for the WETH9 contract.\n */\ninterface WETH9Interface {\n    /**\n     * @notice Burn Wrapped Ether and receive native Ether.\n     * @param wad Amount of WETH to unwrap and send to caller.\n     */\n    function withdraw(uint256 wad) external;\n\n    /**\n     * @notice Lock native Ether and mint Wrapped Ether ERC20\n     * @dev msg.value is amount of Wrapped Ether to mint/Ether to lock.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Get balance of WETH held by `guy`.\n     * @param guy Address to get balance of.\n     * @return wad Amount of WETH held by `guy`.\n     */\n    function balanceOf(address guy) external view returns (uint256 wad);\n\n    /**\n     * @notice Transfer `wad` of WETH from caller to `guy`.\n     * @param guy Address to send WETH to.\n     * @param wad Amount of WETH to send.\n     * @return ok True if transfer succeeded.\n     */\n    function transfer(address guy, uint256 wad) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ArbitrumBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Staging ground for incoming and outgoing messages\n * @notice Unlike the standard Eth bridge, native token bridge escrows the custom ERC20 token which is\n * used as native currency on upper layer.\n * @dev Fees are paid in this token. There are certain restrictions on the native token:\n *       - The token can't be rebasing or have a transfer fee\n *       - The token must only be transferrable via a call to the token address itself\n *       - The token must only be able to set allowance via a call to the token address itself\n *       - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\n *       - The token must have a max of 2^256 - 1 wei total supply unscaled\n *       - The token must have a max of 2^256 - 1 wei total supply when scaled to 18 decimals\n */\ninterface ArbitrumERC20Bridge {\n    /**\n     * @notice Returns token that is escrowed in bridge on the lower layer and minted on the upper layer as native currency.\n     * @dev This function doesn't exist on the generic Bridge interface.\n     * @return address of the native token.\n     */\n    function nativeToken() external view returns (address);\n\n    /**\n     * @dev number of decimals used by the native token\n     *      This is set on bridge initialization using nativeToken.decimals()\n     *      If the token does not have decimals() method, we assume it have 0 decimals\n     */\n    function nativeTokenDecimals() external view returns (uint8);\n}\n\n/**\n * @title Inbox for user and contract originated messages\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\n * to await inclusion in the SequencerInbox\n */\ninterface ArbitrumInboxLike {\n    /**\n     * @dev we only use this function to check the native token used by the bridge, so we hardcode the interface\n     * to return an ArbitrumERC20Bridge instead of a more generic Bridge interface.\n     * @return address of the bridge.\n     */\n    function bridge() external view returns (ArbitrumERC20Bridge);\n\n    /**\n     * @notice Put a message in the inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @dev Caller must set msg.value equal to at least `maxSubmissionCost + maxGas * gasPriceBid`.\n     *      all msg.value will deposited to callValueRefundAddress on the upper layer\n     * @dev More details can be found here: https://developer.arbitrum.io/arbos/l1-to-l2-messaging\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's (upper layer) balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on (upper layer) balance\n     * @param callValueRefundAddress callvalue gets credited here on upper layer if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's upper layer balance to cover upper layer execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for upper layer execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the source chain inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed\n     * funds come from the deposit alone, rather than falling back on the user's balance\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\n     * createRetryableTicket method is the recommended standard.\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's source chain balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on source chain balance\n     * @param callValueRefundAddress callvalue gets credited here on source chain if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's balance to cover execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of the message\n     * @return unique message number of the retryable transaction\n     */\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n}\n\n/**\n * @notice Interface which extends ArbitrumInboxLike with functions used to interact with bridges that use a custom gas token.\n */\ninterface ArbitrumCustomGasTokenInbox is ArbitrumInboxLike {\n    /**\n     * @notice Put a message in the inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @notice Overloads the `createRetryableTicket` function but is not payable, and should only be called when paying\n     * for message using a custom gas token.\n     * @dev all tokenTotalFeeAmount will be deposited to callValueRefundAddress on upper layer\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @dev In case of native token having non-18 decimals: tokenTotalFeeAmount is denominated in native token's decimals. All other value params - callValue, maxSubmissionCost and maxFeePerGas are denominated in child chain's native 18 decimals.\n     * @param to destination contract address\n     * @param callValue call value for retryable message\n     * @param maxSubmissionCost Max gas deducted from user's upper layer balance to cover base submission fee\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost. In case this address is a contract, funds will be received in its alias on upper layer.\n     * @param callValueRefundAddress callvalue gets credited here on upper layer if retryable txn times out or gets cancelled. In case this address is a contract, funds will be received in its alias on upper layer.\n     * @param gasLimit Max gas deducted from user's balance to cover execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\n     * @param data ABI encoded data of message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 callValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 tokenTotalFeeAmount,\n        bytes calldata data\n    ) external returns (uint256);\n}\n\n/**\n * @notice Generic gateway contract for bridging standard ERC20s to/from Arbitrum-like networks.\n * @notice These function signatures are shared between the L1 and L2 gateway router contracts.\n */\ninterface ArbitrumL1ERC20GatewayLike {\n    /**\n     * @notice Deprecated in favor of outboundTransferCustomRefund but still used in custom bridges\n     * like the DAI bridge.\n     * @dev Refunded to aliased address of sender if sender has code on source chain, otherwise to to sender's EOA on destination chain.\n     * @param _sourceToken address of ERC20\n     * @param _to Account to be credited with the tokens at the destination (can be the user's account or a contract),\n     * not subject to aliasing. This account, or its alias if it has code in the source chain, will also be able to\n     * cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's balance to cover execution\n     * @param _gasPriceBid Gas price for execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransfer(\n        address _sourceToken,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    /**\n     * @notice get ERC20 gateway for token.\n     * @param _token ERC20 address.\n     * @return address of ERC20 gateway.\n     */\n    function getGateway(address _token) external view returns (address);\n\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum-like networks.\n     * @dev Upper layer address alias will not be applied to the following types of addresses on lower layer:\n     *      - an externally-owned account\n     *      - a contract in construction\n     *      - an address where a contract will be created\n     *      - an address where a contract lived, but was destroyed\n     * @param _sourceToken address of ERC20 on source chain.\n     * @param _refundTo Account, or its alias if it has code on the source chain, to be credited with excess gas refund at destination\n     * @param _to Account to be credited with the tokens in the L3 (can be the user's L3 account or a contract),\n     * not subject to aliasing. This account, or its alias if it has code on the source chain, will also be able to\n     * cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's balance to cover execution\n     * @param _gasPriceBid Gas price for execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransferCustomRefund(\n        address _sourceToken,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n\ninterface ArbitrumL2ERC20GatewayLike {\n    /**\n     * @notice Fetches the l2 token address from the gateway router for the input l1 token address\n     * @param _l1Erc20 address of the l1 token.\n     */\n    function calculateL2TokenAddress(address _l1Erc20) external view returns (address);\n\n    /**\n     * @notice Withdraws a specified amount of an l2 token to an l1 token.\n     * @param _l1Token address of the token to withdraw on L1.\n     * @param _to address on L1 which will receive the tokens upon withdrawal.\n     * @param _amount amount of the token to withdraw.\n     * @param _data encoded data to send to the gateway router.\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/HubPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Concise list of functions in HubPool implementation.\n */\ninterface HubPoolInterface {\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\n    struct PoolRebalanceLeaf {\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).\n        uint256 chainId;\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\n        uint256[] bundleLpFees;\n        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative\n        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This\n        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does\n        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous\n        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's\n        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.\n        int256[] netSendAmounts;\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1\n        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that\n        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.\n        int256[] runningBalances;\n        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.\n        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where\n        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under\n        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with\n        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one\n        // leaf for a specific chainId should have a groupIndex equal to 0.\n        uint256 groupIndex;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint8 leafId;\n        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel\n        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero\n        // relays on this chain in this bundle in the order of whitelisting.\n        address[] l1Tokens;\n    }\n\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves\n    // that can be executed later to:\n    // - Send funds from this contract to a SpokePool or vice versa\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \"slow\" relay\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\n    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\n    struct RootBundle {\n        // Contains leaves instructing this contract to send funds to SpokePools.\n        bytes32 poolRebalanceRoot;\n        // Relayer refund merkle root to be published to a SpokePool.\n        bytes32 relayerRefundRoot;\n        // Slow relay merkle root to be published to a SpokePool.\n        bytes32 slowRelayRoot;\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\n        uint256 claimedBitMap;\n        // Proposer of this root bundle.\n        address proposer;\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\n        // of leaves are executed, a new root bundle can be proposed\n        uint8 unclaimedPoolRebalanceLeafCount;\n        // When root bundle challenge period passes and this root bundle becomes executable.\n        uint32 challengePeriodEndTimestamp;\n    }\n\n    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the\n    // cumulative LP positions and if this token is enabled for deposits.\n    struct PooledToken {\n        // LP token given to LPs of a specific L1 token.\n        address lpToken;\n        // True if accepting new LP's.\n        bool isEnabled;\n        // Timestamp of last LP fee update.\n        uint32 lastLpFeeUpdate;\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\n        // back later.\n        int256 utilizedReserves;\n        // Number of LP funds held in contract less utilized reserves.\n        uint256 liquidReserves;\n        // Number of LP funds reserved to pay out to LPs as fees.\n        uint256 undistributedLpFees;\n    }\n\n    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\n    struct CrossChainContract {\n        address adapter;\n        address spokePool;\n    }\n\n    function setPaused(bool pause) external;\n\n    function emergencyDeleteProposal() external;\n\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\n\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\n\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\n\n    function setLiveness(uint32 newLiveness) external;\n\n    function setIdentifier(bytes32 newIdentifier) external;\n\n    function setCrossChainContracts(\n        uint256 l2ChainId,\n        address adapter,\n        address spokePool\n    ) external;\n\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\n\n    function removeLiquidity(\n        address l1Token,\n        uint256 lpTokenAmount,\n        bool sendEth\n    ) external;\n\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);\n\n    function sync(address l1Token) external;\n\n    function proposeRootBundle(\n        uint256[] memory bundleEvaluationBlockNumbers,\n        uint8 poolRebalanceLeafCount,\n        bytes32 poolRebalanceRoot,\n        bytes32 relayerRefundRoot,\n        bytes32 slowRelayRoot\n    ) external;\n\n    function executeRootBundle(\n        uint256 chainId,\n        uint256 groupIndex,\n        uint256[] memory bundleLpFees,\n        int256[] memory netSendAmounts,\n        int256[] memory runningBalances,\n        uint8 leafId,\n        address[] memory l1Tokens,\n        bytes32[] memory proof\n    ) external;\n\n    function disputeRootBundle() external;\n\n    function claimProtocolFeesCaptured(address l1Token) external;\n\n    function setPoolRebalanceRoute(\n        uint256 destinationChainId,\n        address l1Token,\n        address destinationToken\n    ) external;\n\n    function setDepositRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        bool depositsEnabled\n    ) external;\n\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\n        external\n        view\n        returns (address destinationToken);\n\n    function loadEthForL2Calls() external payable;\n}\n"
    },
    "contracts/interfaces/SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Contains common data structures and functions used by all SpokePool implementations.\n */\ninterface SpokePoolInterface {\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\n    struct RelayerRefundLeaf {\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that\n        // is negative. This is just the negative of this value.\n        uint256 amountToReturn;\n        // Used to verify that this is being executed on the correct destination chainId.\n        uint256 chainId;\n        // This array designates how much each of those addresses should be refunded.\n        uint256[] refundAmounts;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint32 leafId;\n        // The associated L2TokenAddress that these claims apply to.\n        address l2TokenAddress;\n        // Must be same length as refundAmounts and designates each address that must be refunded.\n        address[] refundAddresses;\n    }\n\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\n    // by \"data workers\" via inclusion proofs to execute leaves in the roots.\n    struct RootBundle {\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\n        bytes32 slowRelayRoot;\n        // Merkle root of relayer refunds for successful relays.\n        bytes32 relayerRefundRoot;\n        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of\n        // 256x(2^248) leaves per root.\n        mapping(uint256 => uint256) claimedBitmap;\n    }\n\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\n\n    function setWithdrawalRecipient(address newWithdrawalRecipient) external;\n\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enable\n    ) external;\n\n    function pauseDeposits(bool pause) external;\n\n    function pauseFills(bool pause) external;\n\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\n\n    function emergencyDeleteRootBundle(uint256 rootBundleId) external;\n\n    function depositDeprecated_5947912356(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 maxCount\n    ) external payable;\n\n    function depositFor(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 maxCount\n    ) external payable;\n\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) external payable;\n\n    function chainId() external view returns (uint256);\n\n    error NotEOA();\n    error InvalidDepositorSignature();\n    error InvalidRelayerFeePct();\n    error MaxTransferSizeExceeded();\n    error InvalidCrossDomainAdmin();\n    error InvalidWithdrawalRecipient();\n    error DepositsArePaused();\n    error FillsArePaused();\n}\n"
    },
    "contracts/interfaces/SpokePoolMessageHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// This interface is expected to be implemented by any contract that expects to receive messages from the SpokePool.\ninterface AcrossMessageHandler {\n    function handleV3AcrossMessage(\n        address tokenSent,\n        uint256 amount,\n        address relayer,\n        bytes memory message\n    ) external;\n}\n"
    },
    "contracts/interfaces/V3SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n// Contains structs and functions used by SpokePool contracts to facilitate universal settlement.\ninterface V3SpokePoolInterface {\n    /**************************************\n     *              ENUMS                 *\n     **************************************/\n\n    // Fill status tracks on-chain state of deposit, uniquely identified by relayHash.\n    enum FillStatus {\n        Unfilled,\n        RequestedSlowFill,\n        Filled\n    }\n    // Fill type is emitted in the FilledRelay event to assist Dataworker with determining which types of\n    // fills to refund (e.g. only fast fills) and whether a fast fill created a sow fill excess.\n    enum FillType {\n        FastFill,\n        // Fast fills are normal fills that do not replace a slow fill request.\n        ReplacedSlowFill,\n        // Replaced slow fills are fast fills that replace a slow fill request. This type is used by the Dataworker\n        // to know when to send excess funds from the SpokePool to the HubPool because they can no longer be used\n        // for a slow fill execution.\n        SlowFill\n    }\n    // Slow fills are requested via requestSlowFill and executed by executeSlowRelayLeaf after a bundle containing\n    // the slow fill is validated.\n\n    /**************************************\n     *              STRUCTS               *\n     **************************************/\n\n    // This struct represents the data to fully specify a **unique** relay submitted on this chain.\n    // This data is hashed with the chainId() and saved by the SpokePool to prevent collisions and protect against\n    // replay attacks on other chains. If any portion of this data differs, the relay is considered to be\n    // completely distinct.\n    struct V3RelayData {\n        // The bytes32 that made the deposit on the origin chain.\n        bytes32 depositor;\n        // The recipient bytes32 on the destination chain.\n        bytes32 recipient;\n        // This is the exclusive relayer who can fill the deposit before the exclusivity deadline.\n        bytes32 exclusiveRelayer;\n        // Token that is deposited on origin chain by depositor.\n        bytes32 inputToken;\n        // Token that is received on destination chain by recipient.\n        bytes32 outputToken;\n        // The amount of input token deposited by depositor.\n        uint256 inputAmount;\n        // The amount of output token to be received by recipient.\n        uint256 outputAmount;\n        // Origin chain id.\n        uint256 originChainId;\n        // The id uniquely identifying this deposit on the origin chain.\n        uint256 depositId;\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\n        uint32 fillDeadline;\n        // The timestamp on the destination chain after which any relayer can fill the deposit.\n        uint32 exclusivityDeadline;\n        // Data that is forwarded to the recipient.\n        bytes message;\n    }\n\n    // Same as V3RelayData but using addresses instead of bytes32 & depositId is uint32.\n    // Will be deprecated in favor of V3RelayData in the future.\n    struct V3RelayDataLegacy {\n        address depositor;\n        address recipient;\n        address exclusiveRelayer;\n        address inputToken;\n        address outputToken;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        uint256 originChainId;\n        uint32 depositId;\n        uint32 fillDeadline;\n        uint32 exclusivityDeadline;\n        bytes message;\n    }\n\n    // Contains parameters passed in by someone who wants to execute a slow relay leaf.\n    struct V3SlowFill {\n        V3RelayData relayData;\n        uint256 chainId;\n        uint256 updatedOutputAmount;\n    }\n\n    // Contains information about a relay to be sent along with additional information that is not unique to the\n    // relay itself but is required to know how to process the relay. For example, \"updatedX\" fields can be used\n    // by the relayer to modify fields of the relay with the depositor's permission, and \"repaymentChainId\" is specified\n    // by the relayer to determine where to take a relayer refund, but doesn't affect the uniqueness of the relay.\n    struct V3RelayExecutionParams {\n        V3RelayData relay;\n        bytes32 relayHash;\n        uint256 updatedOutputAmount;\n        bytes32 updatedRecipient;\n        bytes updatedMessage;\n        uint256 repaymentChainId;\n    }\n\n    // Packs together parameters emitted in FilledRelay because there are too many emitted otherwise.\n    // Similar to V3RelayExecutionParams, these parameters are not used to uniquely identify the deposit being\n    // filled so they don't have to be unpacked by all clients.\n    struct V3RelayExecutionEventInfo {\n        bytes32 updatedRecipient;\n        bytes32 updatedMessageHash;\n        uint256 updatedOutputAmount;\n        FillType fillType;\n    }\n\n    // Represents the parameters required for a V3 deposit operation in the SpokePool.\n    struct DepositV3Params {\n        bytes32 depositor;\n        bytes32 recipient;\n        bytes32 inputToken;\n        bytes32 outputToken;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        uint256 destinationChainId;\n        bytes32 exclusiveRelayer;\n        uint256 depositId;\n        uint32 quoteTimestamp;\n        uint32 fillDeadline;\n        uint32 exclusivityParameter;\n        bytes message;\n    }\n\n    /**************************************\n     *              EVENTS                *\n     **************************************/\n\n    event FundsDeposited(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed destinationChainId,\n        uint256 indexed depositId,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 indexed depositor,\n        bytes32 recipient,\n        bytes32 exclusiveRelayer,\n        bytes message\n    );\n\n    event RequestedSpeedUpDeposit(\n        uint256 updatedOutputAmount,\n        uint256 indexed depositId,\n        bytes32 indexed depositor,\n        bytes32 updatedRecipient,\n        bytes updatedMessage,\n        bytes depositorSignature\n    );\n\n    event FilledRelay(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 repaymentChainId,\n        uint256 indexed originChainId,\n        uint256 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 exclusiveRelayer,\n        bytes32 indexed relayer,\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 messageHash,\n        V3RelayExecutionEventInfo relayExecutionInfo\n    );\n\n    event RequestedSlowFill(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed originChainId,\n        uint256 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 exclusiveRelayer,\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 messageHash\n    );\n\n    event ClaimedRelayerRefund(\n        bytes32 indexed l2TokenAddress,\n        bytes32 indexed refundAddress,\n        uint256 amount,\n        address indexed caller\n    );\n\n    /**************************************\n     *              FUNCTIONS             *\n     **************************************/\n\n    function deposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositNow(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function unsafeDeposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable;\n\n    function speedUpDeposit(\n        bytes32 depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function speedUpV3Deposit(\n        address depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function fillRelay(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress\n    ) external;\n\n    function fillV3Relay(V3RelayDataLegacy calldata relayData, uint256 repaymentChainId) external;\n\n    function fillRelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function requestSlowFill(V3RelayData calldata relayData) external;\n\n    function executeSlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) external;\n\n    function claimRelayerRefund(bytes32 l2TokenAddress, bytes32 refundAddress) external;\n\n    /**************************************\n     *              ERRORS                *\n     **************************************/\n\n    error DisabledRoute();\n    error InvalidQuoteTimestamp();\n    error InvalidFillDeadline();\n    error InvalidExclusiveRelayer();\n    error MsgValueDoesNotMatchInputAmount();\n    error NotExclusiveRelayer();\n    error NoSlowFillsInExclusivityWindow();\n    error RelayFilled();\n    error InvalidSlowFillRequest();\n    error ExpiredFillDeadline();\n    error InvalidMerkleProof();\n    error InvalidChainId();\n    error InvalidMerkleLeaf();\n    error ClaimedMerkleLeaf();\n    error InvalidPayoutAdjustmentPct();\n    error WrongERC7683OrderId();\n    error LowLevelCallFailed(bytes data);\n    error InsufficientSpokePoolBalanceToExecuteLeaf();\n    error NoRelayerRefundToClaim();\n\n    /**************************************\n     *             LEGACY EVENTS          *\n     **************************************/\n\n    // Note: these events are unused, but included in the ABI for ease of migration.\n    event V3FundsDeposited(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed destinationChainId,\n        uint32 indexed depositId,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address indexed depositor,\n        address recipient,\n        address exclusiveRelayer,\n        bytes message\n    );\n\n    event RequestedSpeedUpV3Deposit(\n        uint256 updatedOutputAmount,\n        uint32 indexed depositId,\n        address indexed depositor,\n        address updatedRecipient,\n        bytes updatedMessage,\n        bytes depositorSignature\n    );\n\n    // Legacy struct only used to preserve the FilledV3Relay event definition.\n    struct LegacyV3RelayExecutionEventInfo {\n        address updatedRecipient;\n        bytes updatedMessage;\n        uint256 updatedOutputAmount;\n        FillType fillType;\n    }\n\n    event FilledV3Relay(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 repaymentChainId,\n        uint256 indexed originChainId,\n        uint32 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address exclusiveRelayer,\n        address indexed relayer,\n        address depositor,\n        address recipient,\n        bytes message,\n        LegacyV3RelayExecutionEventInfo relayExecutionInfo\n    );\n\n    event RequestedV3SlowFill(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed originChainId,\n        uint32 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address exclusiveRelayer,\n        address depositor,\n        address recipient,\n        bytes message\n    );\n}\n"
    },
    "contracts/Lens_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./ZkSync_SpokePool.sol\";\n\n/**\n * @notice Lens specific SpokePool. Wrapper around the ZkSync_SpokePool contract.\n * @dev Resources for compiling and deploying contracts with hardhat: https://era.zksync.io/docs/tools/hardhat/hardhat-zksync-solc.html\n * @custom:security-contact bugs@across.to\n */\ncontract Lens_SpokePool is ZkSync_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    ) ZkSync_SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer) {} // solhint-disable-line no-empty-blocks\n}\n"
    },
    "contracts/libraries/AddressConverters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary Bytes32ToAddress {\n    /**************************************\n     *              ERRORS                *\n     **************************************/\n    error InvalidBytes32();\n\n    function toAddress(bytes32 _bytes32) internal pure returns (address) {\n        checkAddress(_bytes32);\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    function toAddressUnchecked(bytes32 _bytes32) internal pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    function checkAddress(bytes32 _bytes32) internal pure {\n        if (uint256(_bytes32) >> 160 != 0) {\n            revert InvalidBytes32();\n        }\n    }\n}\n\nlibrary AddressToBytes32 {\n    function toBytes32(address _address) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n"
    },
    "contracts/libraries/CircleCCTPAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../external/interfaces/CCTPInterfaces.sol\";\nimport { AddressToBytes32 } from \"../libraries/AddressConverters.sol\";\n\nlibrary CircleDomainIds {\n    uint32 public constant Ethereum = 0;\n    uint32 public constant Optimism = 2;\n    uint32 public constant Arbitrum = 3;\n    uint32 public constant Solana = 5;\n    uint32 public constant Base = 6;\n    uint32 public constant Polygon = 7;\n    uint32 public constant DoctorWho = 10;\n    // Use this value for placeholder purposes only for adapters that extend this adapter but haven't yet been\n    // assigned a domain ID by Circle.\n    uint32 public constant UNINITIALIZED = type(uint32).max;\n}\n\n/**\n * @notice Facilitate bridging USDC via Circle's CCTP.\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\n * @custom:security-contact bugs@across.to\n */\nabstract contract CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n    /**\n     * @notice The domain ID that CCTP will transfer funds to.\n     * @dev This identifier is assigned by Circle and is not related to a chain ID.\n     * @dev Official domain list can be found here: https://developers.circle.com/stablecoins/docs/supported-domains\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n\n    uint32 public immutable recipientCircleDomainId;\n\n    /**\n     * @notice The official USDC contract address on this chain.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/usdc-on-main-networks\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IERC20 public immutable usdcToken;\n\n    /**\n     * @notice The official Circle CCTP token bridge contract endpoint.\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\n     */\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ITokenMessenger public immutable cctpTokenMessenger;\n\n    /**\n     * @notice intiailizes the CircleCCTPAdapter contract.\n     * @param _usdcToken USDC address on the current chain.\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP. If the zero address is passed, CCTP bridging will be disabled.\n     * @param _recipientCircleDomainId The domain ID that CCTP will transfer funds to.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        IERC20 _usdcToken,\n        ITokenMessenger _cctpTokenMessenger,\n        uint32 _recipientCircleDomainId\n    ) {\n        usdcToken = _usdcToken;\n        cctpTokenMessenger = _cctpTokenMessenger;\n        recipientCircleDomainId = _recipientCircleDomainId;\n    }\n\n    /**\n     * @notice Returns whether or not the CCTP bridge is enabled.\n     * @dev If the CCTPTokenMessenger is the zero address, CCTP bridging is disabled.\n     */\n    function _isCCTPEnabled() internal view returns (bool) {\n        return address(cctpTokenMessenger) != address(0);\n    }\n\n    /**\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\n     * @param to Address to receive USDC on the new domain.\n     * @param amount Amount of USDC to transfer.\n     */\n    function _transferUsdc(address to, uint256 amount) internal {\n        _transferUsdc(to.toBytes32(), amount);\n    }\n\n    /**\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\n     * @param to Address to receive USDC on the new domain represented as bytes32.\n     * @param amount Amount of USDC to transfer.\n     */\n    function _transferUsdc(bytes32 to, uint256 amount) internal {\n        // Only approve the exact amount to be transferred\n        usdcToken.safeIncreaseAllowance(address(cctpTokenMessenger), amount);\n        // Submit the amount to be transferred to bridged via the TokenMessenger.\n        // If the amount to send exceeds the burn limit per message, then split the message into smaller parts.\n        ITokenMinter cctpMinter = cctpTokenMessenger.localMinter();\n        uint256 burnLimit = cctpMinter.burnLimitsPerMessage(address(usdcToken));\n        uint256 remainingAmount = amount;\n        while (remainingAmount > 0) {\n            uint256 partAmount = remainingAmount > burnLimit ? burnLimit : remainingAmount;\n            cctpTokenMessenger.depositForBurn(partAmount, recipientCircleDomainId, to, address(usdcToken));\n            remainingAmount -= partAmount;\n        }\n    }\n}\n"
    },
    "contracts/libraries/CrossDomainAddressUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title AddressUtils\n * @notice This library contains internal functions for manipulating addresses.\n */\nlibrary CrossDomainAddressUtils {\n    // L1 addresses are transformed during l1->l2 calls.\n    // This cannot be pulled directly from Arbitrum contracts because their contracts are not 0.8.X compatible and\n    // this operation takes advantage of overflows, whose behavior changed in 0.8.0.\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + uint160(0x1111000000000000000000000000000000001111));\n        }\n    }\n}\n"
    },
    "contracts/Lockable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n * @dev The reason why we use this local contract instead of importing from uma/contracts is because of the addition\n * of the internal method `functionCallStackOriginatesFromOutsideThisContract` which doesn't exist in the one exported\n * by uma/contracts.\n * @custom:security-contact bugs@across.to\n */\ncontract Lockable {\n    bool internal _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a nonReentrant function from another nonReentrant function is not supported. It is possible to\n     * prevent this from happening by making the nonReentrant function external, and making it call a private\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a nonReentrant() state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is currently in a non-entered state, meaning that the origination of the call\n     * came from outside the contract. This is relevant with fallback/receive methods to see if the call came from ETH\n     * being dropped onto the contract externally or due to ETH dropped on the contract from within a method in this\n     * contract, such as unwrapping WETH to ETH within the contract.\n     */\n    function functionCallStackOriginatesFromOutsideThisContract() internal view returns (bool) {\n        return _notEntered;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every nonReentrant() method.\n    // On entry into a function, _preEntranceCheck() should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call _postEntranceSet(), perform its logic, and\n    // then call _postEntranceReset().\n    // View-only methods can simply call _preEntranceCheck() to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "contracts/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"./interfaces/HubPoolInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @notice Library to help with merkle roots, proofs, and claims.\n * @custom:security-contact bugs@across.to\n */\nlibrary MerkleLib {\n    /**\n     * @notice Verifies that a repayment is contained within a merkle root.\n     * @param root the merkle root.\n     * @param rebalance the rebalance struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the pool rebalance proof correctly shows inclusion of the rebalance within the tree.\n     */\n    function verifyPoolRebalance(\n        bytes32 root,\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));\n    }\n\n    /**\n     * @notice Verifies that a relayer refund is contained within a merkle root.\n     * @param root the merkle root.\n     * @param refund the refund struct.\n     * @param proof the merkle proof.\n     * @return bool to signal if the relayer refund proof correctly shows inclusion of the refund within the tree.\n     */\n    function verifyRelayerRefund(\n        bytes32 root,\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(refund)));\n    }\n\n    function verifyV3SlowRelayFulfillment(\n        bytes32 root,\n        V3SpokePoolInterface.V3SlowFill memory slowRelayFulfillment,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\n    }\n\n    // The following functions are primarily copied from\n    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.\n\n    /**\n     * @notice Tests whether a claim is contained within a claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to check in the bitmap.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to mark in the bitmap.\n     */\n    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    /**\n     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.\n     * @param index the index to check in the bitmap. Uint8 type enforces that index can't be > 255.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (bool) {\n        uint256 mask = (1 << index);\n        return claimedBitMap & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap. Uint8 type enforces that index\n     * can't be > 255.\n     * @param index the index to mark in the bitmap.\n     * @return uint256 representing the modified input claimedBitMap with the index set to true.\n     */\n    function setClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (uint256) {\n        return claimedBitMap | (1 << index);\n    }\n}\n"
    },
    "contracts/Ovm_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/crosschain/optimism/LibOptimismUpgradeable.sol\";\nimport \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\n\n// https://github.com/ethereum-optimism/optimism/blob/bf51c4935261634120f31827c3910aa631f6bf9c/packages/contracts-bedrock/contracts/L2/L2StandardBridge.sol\ninterface IL2ERC20Bridge {\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable;\n\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external;\n}\n\n/**\n * @notice OVM specific SpokePool. Uses OVM cross-domain-enabled logic to implement admin only access to functions. * Optimism, Base, and Boba each implement this spoke pool and set their chain specific contract addresses for l2Eth and l2Weth.\n * @custom:security-contact bugs@across.to\n */\ncontract Ovm_SpokePool is SpokePool, CircleCCTPAdapter {\n    using SafeERC20 for IERC20;\n    // \"l1Gas\" parameter used in call to bridge tokens from this contract back to L1 via IL2ERC20Bridge. Currently\n    // unused by bridge but included for future compatibility.\n    uint32 public l1Gas;\n\n    // ETH is an ERC20 on OVM.\n    address public l2Eth;\n\n    // Address of the Optimism L2 messenger.\n    address public constant MESSENGER = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n    // @dev This storage slot is reserved to replace the old messenger public variable that has now been\n    // replaced by the above constant.\n    address private __deprecated_messenger;\n\n    // Stores alternative token bridges to use for L2 tokens that don't go over the standard bridge. This is needed\n    // to support non-standard ERC20 tokens on Optimism, such as DAI which uses a custom bridge with the same\n    // interface as the standard bridge.\n    mapping(address => address) public tokenBridges;\n\n    // Stores mapping of L2 tokens to L1 equivalent tokens. If a mapping is defined for a given L2 token, then\n    // the mapped L1 token can be used in _bridgeTokensToHubPool which can then call bridgeERC20To, which\n    // requires specfiying an L1 token.\n    mapping(address => address) public remoteL1Tokens;\n\n    event SetL1Gas(uint32 indexed newL1Gas);\n    event SetL2TokenBridge(address indexed l2Token, address indexed tokenBridge);\n    event SetRemoteL1Token(address indexed l2Token, address indexed l1Token);\n\n    error NotCrossDomainAdmin();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the OVM SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     * @param _l2Eth Address of L2 ETH token. Usually should be Lib_PreeployAddresses.OVM_ETH but sometimes this can\n     * be different, like with Boba which flips the WETH and OVM_ETH addresses.\n     */\n    function __OvmSpokePool_init(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient,\n        address _l2Eth\n    ) public onlyInitializing {\n        l1Gas = 5_000_000;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        //slither-disable-next-line missing-zero-check\n        l2Eth = _l2Eth;\n    }\n\n    /*******************************************\n     *    OPTIMISM-SPECIFIC ADMIN FUNCTIONS    *\n     *******************************************/\n\n    /**\n     * @notice Change L1 gas limit. Callable only by admin.\n     * @param newl1Gas New L1 gas limit to set.\n     */\n    function setL1GasLimit(uint32 newl1Gas) public onlyAdmin nonReentrant {\n        l1Gas = newl1Gas;\n        emit SetL1Gas(newl1Gas);\n    }\n\n    function setRemoteL1Token(address l2Token, address l1Token) public onlyAdmin nonReentrant {\n        remoteL1Tokens[l2Token] = l1Token;\n        emit SetRemoteL1Token(l2Token, l1Token);\n    }\n\n    /**\n     * @notice Set bridge contract for L2 token used to withdraw back to L1.\n     * @dev If this mapping isn't set for an L2 token, then the standard bridge will be used to bridge this token.\n     * @param tokenBridge Address of token bridge\n     */\n    function setTokenBridge(address l2Token, address tokenBridge) public onlyAdmin nonReentrant {\n        tokenBridges[l2Token] = tokenBridge;\n        emit SetL2TokenBridge(l2Token, tokenBridge);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Wraps any ETH into WETH before executing leaves. This is necessary because SpokePool receives\n     * ETH over the canonical token bridge instead of WETH.\n     */\n    function _preExecuteLeafHook(address l2TokenAddress) internal override {\n        if (l2TokenAddress == address(wrappedNativeToken)) _depositEthToWeth();\n    }\n\n    // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is necessary because\n    // this SpokePool will receive ETH from the canonical token bridge instead of WETH. Its not sufficient to execute\n    // this logic inside a fallback method that executes when this contract receives ETH because ETH is an ERC20\n    // on the OVM.\n    function _depositEthToWeth() internal {\n        //slither-disable-next-line arbitrary-send-eth\n        if (address(this).balance > 0) wrappedNativeToken.deposit{ value: address(this).balance }();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual override {\n        // If the token being bridged is WETH then we need to first unwrap it to ETH and then send ETH over the\n        // canonical bridge. On Optimism, this is address 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n        if (l2TokenAddress == address(wrappedNativeToken)) {\n            WETH9Interface(l2TokenAddress).withdraw(amountToReturn); // Unwrap into ETH.\n            l2TokenAddress = l2Eth; // Set the l2TokenAddress to ETH.\n            IL2ERC20Bridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo{ value: amountToReturn }(\n                l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                amountToReturn, // _amount.\n                l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                \"\" // _data. We don't need to send any data for the bridging action.\n            );\n        }\n        // If the token is USDC && CCTP bridge is enabled, then bridge USDC via CCTP.\n        else if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        }\n        // Note we'll default to withdrawTo instead of bridgeERC20To unless the remoteL1Tokens mapping is set for\n        // the l2TokenAddress. withdrawTo should be used to bridge back non-native L2 tokens\n        // (i.e. non-native L2 tokens have a canonical L1 token). If we should bridge \"native L2\" tokens then\n        // we'd need to call bridgeERC20To and give allowance to the tokenBridge to spend l2Token from this contract.\n        // Therefore for native tokens we should set ensure that remoteL1Tokens is set for the l2TokenAddress.\n        else {\n            IL2ERC20Bridge tokenBridge = IL2ERC20Bridge(\n                tokenBridges[l2TokenAddress] == address(0)\n                    ? Lib_PredeployAddresses.L2_STANDARD_BRIDGE\n                    : tokenBridges[l2TokenAddress]\n            );\n            if (remoteL1Tokens[l2TokenAddress] != address(0)) {\n                // If there is a mapping for this L2 token to an L1 token, then use the L1 token address and\n                // call bridgeERC20To.\n                IERC20(l2TokenAddress).safeIncreaseAllowance(address(tokenBridge), amountToReturn);\n                address remoteL1Token = remoteL1Tokens[l2TokenAddress];\n                tokenBridge.bridgeERC20To(\n                    l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                    remoteL1Token, // Remote token to be received on L1 side. If the\n                    // remoteL1Token on the other chain does not recognize the local token as the correct\n                    // pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n                    // this chain.\n                    withdrawalRecipient, // _to\n                    amountToReturn, // _amount\n                    l1Gas, // _l1Gas\n                    \"\" // _data\n                );\n            } else {\n                tokenBridge.withdrawTo(\n                    l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n                    withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 pool contract.\n                    amountToReturn, // _amount.\n                    l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n                    \"\" // _data. We don't need to send any data for the bridging action.\n                );\n            }\n        }\n    }\n\n    // Apply OVM-specific transformation to cross domain admin address on L1.\n    function _requireAdminSender() internal view override {\n        if (LibOptimismUpgradeable.crossChainSender(MESSENGER) != crossDomainAdmin) revert NotCrossDomainAdmin();\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure its always at the end of storage.\n    uint256[999] private __gap;\n}\n"
    },
    "contracts/permit2-order/Permit2Depositor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Permit2OrderLib.sol\";\nimport \"../external/interfaces/IPermit2.sol\";\nimport \"../interfaces/V3SpokePoolInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AddressToBytes32 } from \"../libraries/AddressConverters.sol\";\n\n/**\n * @notice Permit2Depositor processes an external order type and translates it into an AcrossV3 deposit.\n */\ncontract Permit2Depositor {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n\n    // SpokePool that this contract can deposit to.\n    V3SpokePoolInterface public immutable SPOKE_POOL;\n\n    // Permit2 contract\n    IPermit2 public immutable PERMIT2;\n\n    // quoteBeforeDeadline is subtracted from the deadline to get the quote timestamp.\n    // This is a somewhat arbitrary conversion, but order creators need some way to precompute the quote timestamp.\n    uint256 public immutable QUOTE_BEFORE_DEADLINE;\n\n    /**\n     * @notice Construct the Permit2Depositor.\n     * @param _spokePool SpokePool that this contract can deposit to.\n     * @param _permit2 Permit2 contract\n     * @param _quoteBeforeDeadline quoteBeforeDeadline is subtracted from the deadline to get the quote timestamp.\n     */\n    constructor(\n        V3SpokePoolInterface _spokePool,\n        IPermit2 _permit2,\n        uint256 _quoteBeforeDeadline\n    ) {\n        SPOKE_POOL = _spokePool;\n        PERMIT2 = _permit2;\n        QUOTE_BEFORE_DEADLINE = _quoteBeforeDeadline;\n    }\n\n    /**\n     * @notice Uses a permit2 order to deposit to a SpokePool.\n     * @param signedOrder Signed external order type that is processed to produce the deposit. See Permit2OrderLib for details\n     * @param destinationChainFillerAddress Address of the filler on the destination chain. Specified by caller\n     * to avoid issue if destination and current network have different address derivation schemes.\n     */\n    function permit2Deposit(SignedOrder calldata signedOrder, address destinationChainFillerAddress) external {\n        CrossChainLimitOrder memory order = Permit2OrderLib._processPermit2Order(PERMIT2, signedOrder);\n        uint32 fillDeadline = SafeCast.toUint32(block.timestamp + order.info.fillPeriod);\n\n        // User input amount and filler collateral are added together to get the deposit amount.\n        // If the user gets filled correctly, the filler gets their collateral back.\n        // If the user is not filled or filled by someone else, the filler loses their collateral.\n        uint256 amountToDeposit = order.input.amount + order.fillerCollateral.amount;\n\n        IERC20(order.input.token).safeIncreaseAllowance(address(SPOKE_POOL), amountToDeposit);\n        SPOKE_POOL.deposit(\n            order.info.offerer.toBytes32(),\n            // Note: Permit2OrderLib checks that order only has a single output.\n            order.outputs[0].recipient.toBytes32(),\n            order.input.token.toBytes32(),\n            order.outputs[0].token.toBytes32(),\n            amountToDeposit,\n            order.outputs[0].amount,\n            order.outputs[0].chainId,\n            destinationChainFillerAddress.toBytes32(),\n            SafeCast.toUint32(order.info.initiateDeadline - QUOTE_BEFORE_DEADLINE),\n            fillDeadline,\n            // The entire fill period is exclusive.\n            fillDeadline,\n            \"\"\n        );\n    }\n}\n"
    },
    "contracts/permit2-order/Permit2Order.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// General Settlement Info.\nstruct SettlementInfo {\n    // The contract intended for settlement.\n    address settlerContract;\n    // User who created the order.\n    address offerer;\n    // The nonce of the order for replay protection.\n    uint256 nonce;\n    // Latest timestamp at which the order can be brought onchain.\n    uint256 initiateDeadline;\n    // Max delay between the order being brought onchain and the fill.\n    uint32 fillPeriod;\n    // The rest of the fields are unused in Across.\n    uint32 challengePeriod;\n    uint32 proofPeriod;\n    address settlementOracle;\n    address validationContract;\n    bytes validationData;\n}\n\n// Input token info.\nstruct InputToken {\n    address token;\n    uint256 amount;\n    uint256 maxAmount;\n}\n\n// Callateral token info.\nstruct CollateralToken {\n    address token;\n    uint256 amount;\n}\n\n// Output information.\nstruct OutputToken {\n    address recipient;\n    address token;\n    uint256 amount;\n    uint256 chainId;\n}\n\n// Full order struct that the user signs.\nstruct CrossChainLimitOrder {\n    // General order info.\n    SettlementInfo info;\n    // User's input token.\n    InputToken input;\n    // Filler's provided collateral.\n    CollateralToken fillerCollateral;\n    // Unused in Across.\n    CollateralToken challengerCollateral;\n    // Outputs. Today, Across only supports a single output.\n    OutputToken[] outputs;\n}\n\n// Encoded order + Permit2 signature.\nstruct SignedOrder {\n    bytes order;\n    bytes sig;\n}\n"
    },
    "contracts/permit2-order/Permit2OrderLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./Permit2Order.sol\";\nimport \"../external/interfaces/IPermit2.sol\";\n\n/**\n * @notice Permit2OrderLib knows how to process a particular type of external Permit2Order so that it can be used in Across.\n * @dev This library is responsible for validating the order and communicating with Permit2 to pull the tokens in.\n * This is a library to allow it to be pulled directly into the SpokePool in a future version.\n */\nlibrary Permit2OrderLib {\n    // Errors\n    error WrongSettlerContract();\n    error AfterDeadline();\n    error ValidationContractNotAllowed();\n    error MultipleOutputsNotAllowed();\n    error InputAndCollateralNotEqual();\n\n    // Type strings and hashes\n    bytes private constant OUTPUT_TOKEN_TYPE =\n        \"OutputToken(address recipient,address token,uint256 amount,uint256 chainId)\";\n    bytes32 private constant OUTPUT_TOKEN_TYPE_HASH = keccak256(OUTPUT_TOKEN_TYPE);\n\n    bytes internal constant ORDER_TYPE =\n        abi.encodePacked(\n            \"CrossChainLimitOrder(\",\n            \"address settlerContract,\",\n            \"address offerer,\",\n            \"uint256 nonce,\",\n            \"uint256 initiateDeadline,\",\n            \"uint32 fillPeriod\",\n            \"uint32 challengePeriod\",\n            \"uint32 proofPeriod\",\n            \"address settlementOracle\",\n            \"address validationContract,\",\n            \"bytes validationData,\",\n            \"address inputToken,\",\n            \"uint256 inputAmount,\",\n            \"address collateralToken,\",\n            \"uint256 collateralAmount,\",\n            \"address challengerCollateralToken,\",\n            \"uint256 challengerCollateralAmount,\",\n            \"OutputToken[] outputs)\",\n            OUTPUT_TOKEN_TYPE\n        );\n    bytes32 internal constant ORDER_TYPE_HASH = keccak256(ORDER_TYPE);\n    string private constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n    string internal constant PERMIT2_ORDER_TYPE =\n        string(abi.encodePacked(\"CrossChainLimitOrder witness)\", ORDER_TYPE, TOKEN_PERMISSIONS_TYPE));\n\n    // Hashes a single output.\n    function _hashOutput(OutputToken memory output) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(OUTPUT_TOKEN_TYPE_HASH, output.recipient, output.token, output.amount, output.chainId)\n            );\n    }\n\n    // Hashes the output array. Since we only allow a single output, it just grabs the first element.\n    function _hashOutputs(OutputToken[] memory outputs) internal pure returns (bytes32) {\n        // Across only allows a single output, so only hash\n        return keccak256(abi.encodePacked(_hashOutput(outputs[0])));\n    }\n\n    // Hashes an order to get an order hash. Needed for permit2.\n    function _hashOrder(CrossChainLimitOrder memory order) internal pure returns (bytes32) {\n        bytes memory part1 = abi.encode(\n            ORDER_TYPE_HASH,\n            order.info.settlerContract,\n            order.info.offerer,\n            order.info.nonce,\n            order.info.initiateDeadline,\n            order.info.fillPeriod,\n            order.info.challengePeriod,\n            order.info.proofPeriod,\n            order.info.settlementOracle,\n            order.info.validationContract,\n            keccak256(order.info.validationData),\n            order.input.token,\n            order.input.amount\n        );\n\n        // avoid stack too deep\n        bytes memory part2 = abi.encode(\n            order.fillerCollateral.token,\n            order.fillerCollateral.amount,\n            order.challengerCollateral.token,\n            order.challengerCollateral.amount,\n            _hashOutputs(order.outputs)\n        );\n\n        return keccak256(abi.encodePacked(part1, part2));\n    }\n\n    function _processPermit2Order(IPermit2 permit2, SignedOrder calldata signedOrder)\n        internal\n        returns (CrossChainLimitOrder memory)\n    {\n        CrossChainLimitOrder memory limitOrder = abi.decode(signedOrder.order, (CrossChainLimitOrder));\n\n        if (address(this) != limitOrder.info.settlerContract) revert WrongSettlerContract();\n        if (block.timestamp > limitOrder.info.initiateDeadline) revert AfterDeadline();\n        if (limitOrder.info.validationContract != address(0)) revert ValidationContractNotAllowed();\n        if (limitOrder.outputs.length != 1) revert MultipleOutputsNotAllowed();\n        if (limitOrder.fillerCollateral.token != limitOrder.input.token) revert InputAndCollateralNotEqual();\n\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\n            permitted: IPermit2.TokenPermissions({ token: limitOrder.input.token, amount: limitOrder.input.maxAmount }),\n            nonce: limitOrder.info.nonce,\n            deadline: limitOrder.info.initiateDeadline\n        });\n\n        IPermit2.SignatureTransferDetails memory signatureTransferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: limitOrder.input.amount\n        });\n\n        // Pull user funds.\n        permit2.permitWitnessTransferFrom(\n            permit,\n            signatureTransferDetails,\n            limitOrder.info.offerer,\n            _hashOrder(limitOrder),\n            PERMIT2_ORDER_TYPE,\n            signedOrder.sig\n        );\n\n        // Pull filler collateral.\n        permit2.transferFrom(\n            msg.sender,\n            address(this),\n            uint160(limitOrder.fillerCollateral.amount),\n            limitOrder.fillerCollateral.token\n        );\n\n        return limitOrder;\n    }\n}\n"
    },
    "contracts/Polygon_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./PolygonTokenBridger.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./libraries/CircleCCTPAdapter.sol\";\n\n/**\n * @notice IFxMessageProcessor represents interface to process messages.\n */\ninterface IFxMessageProcessor {\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @notice Polygon specific SpokePool.\n * @custom:security-contact bugs@across.to\n */\ncontract Polygon_SpokePool is IFxMessageProcessor, SpokePool, CircleCCTPAdapter {\n    using SafeERC20Upgradeable for PolygonIERC20Upgradeable;\n\n    // Address of FxChild which sends and receives messages to and from L1.\n    address public fxChild;\n\n    // Contract deployed on L1 and L2 processes all cross-chain transfers between this contract and the HubPool.\n    // Required because bridging tokens from Polygon to Ethereum has special constraints.\n    PolygonTokenBridger public polygonTokenBridger;\n\n    // Internal variable that only flips temporarily to true upon receiving messages from L1. Used to authenticate that\n    // the caller is the fxChild AND that the fxChild called processMessageFromRoot\n    bool private callValidated;\n\n    error MulticallExecuteLeaf();\n\n    event SetFxChild(address indexed newFxChild);\n    event SetPolygonTokenBridger(address indexed polygonTokenBridger);\n    event ReceivedMessageFromL1(address indexed caller, address indexed rootMessageSender);\n\n    error CallValidatedAlreadySet();\n    error CallValidatedNotSet();\n    error DelegateCallFailed();\n    error NotHubPool();\n    error NotFxChild();\n\n    // Note: validating calls this way ensures that strange calls coming from the fxChild won't be misinterpreted.\n    // Put differently, just checking that msg.sender == fxChild is not sufficient.\n    // All calls that have admin privileges must be fired from within the processMessageFromRoot method that's gone\n    // through validation where the sender is checked and the root (mainnet) sender is also validated.\n    // This modifier sets the callValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure callValidated is set to True only once at beginning of processMessageFromRoot, which prevents\n        // processMessageFromRoot from being re-entered.\n        if (callValidated) revert CallValidatedAlreadySet();\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed. See comment for `_requireAdminSender` for more details.\n        callValidated = true;\n\n        _;\n\n        // Reset callValidated to false to disallow admin calls after this method exits.\n        callValidated = false;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer,\n        IERC20 _l2Usdc,\n        ITokenMessenger _cctpTokenMessenger\n    )\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer)\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\n    {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Polygon SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _polygonTokenBridger Token routing contract that sends tokens from here to HubPool. Changeable by Admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     * @param _fxChild FxChild contract, changeable by Admin.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        PolygonTokenBridger _polygonTokenBridger,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient,\n        address _fxChild\n    ) public initializer {\n        callValidated = false;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setPolygonTokenBridger(payable(_polygonTokenBridger));\n        //slither-disable-next-line missing-zero-check\n        _setFxChild(_fxChild);\n    }\n\n    /********************************************************\n     *    POLYGON-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change FxChild address. Callable only by admin via processMessageFromRoot.\n     * @param newFxChild New FxChild.\n     */\n    function setFxChild(address newFxChild) public onlyAdmin nonReentrant {\n        _setFxChild(newFxChild);\n    }\n\n    /**\n     * @notice Change polygonTokenBridger address. Callable only by admin via processMessageFromRoot.\n     * @param newPolygonTokenBridger New Polygon Token Bridger contract.\n     */\n    function setPolygonTokenBridger(address payable newPolygonTokenBridger) public onlyAdmin nonReentrant {\n        _setPolygonTokenBridger(newPolygonTokenBridger);\n    }\n\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(\n        uint256, /*stateId*/\n        address rootMessageSender,\n        bytes calldata data\n    ) public validateInternalCalls {\n        // Validation logic.\n        if (msg.sender != fxChild) revert NotFxChild();\n        if (rootMessageSender != crossDomainAdmin) revert NotHubPool();\n\n        // This uses delegatecall to take the information in the message and process it as a function call on this contract.\n        /// This is a safe delegatecall because its made to address(this) so there is no risk of delegating to a\n        /// selfdestruct().\n        //slither-disable-start low-level-calls\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(data);\n        //slither-disable-end low-level-calls\n        if (!success) revert DelegateCallFailed();\n\n        emit ReceivedMessageFromL1(msg.sender, rootMessageSender);\n    }\n\n    /**\n     * @notice Allows the caller to trigger the wrapping of any unwrapped matic tokens.\n     * @dev Unlike other ERC20 transfers, Matic transfers from L1 -> L2 bridging don't result in an L2 call into\n     * the contract receiving the tokens, so wrapping must be done via a separate transaction. In other words,\n     * we can't rely upon a `fallback()` method being triggered to wrap MATIC upon receiving it.\n     */\n    function wrap() public nonReentrant {\n        _wrap();\n    }\n\n    /**\n     * @notice Override multicall so that it cannot include executeRelayerRefundLeaf\n     * as one of the calls combined with other public function calls.\n     * @dev Multicalling a single transaction will always succeed.\n     * @dev Multicalling execute functions without combining other public function calls will succeed.\n     * @dev Multicalling public function calls without combining execute functions will succeed.\n     */\n    function _validateMulticallData(bytes[] calldata data) internal pure override {\n        bool hasOtherPublicFunctionCall = false;\n        bool hasExecutedLeafCall = false;\n        for (uint256 i = 0; i < data.length; i++) {\n            bytes4 selector = bytes4(data[i][:4]);\n            if (selector == SpokePoolInterface.executeRelayerRefundLeaf.selector) {\n                if (hasOtherPublicFunctionCall) revert MulticallExecuteLeaf();\n                hasExecutedLeafCall = true;\n            } else {\n                if (hasExecutedLeafCall) revert MulticallExecuteLeaf();\n                hasOtherPublicFunctionCall = true;\n            }\n        }\n    }\n\n    /**\n     * @notice This function can send an L2 to L1 message so we are extra cautious about preventing a griefing vector\n     * whereby someone batches this call with a bunch of other calls and produces a very large L2 burn transaction.\n     * This might make the L2 -> L1 message fail due to exceeding the L1 calldata limit.\n     */\n\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable override {\n        // AddressLibUpgradeable.isContract isn't a sufficient check because it checks the contract code size of\n        // msg.sender which is 0 if called from a constructor function on msg.sender. This is why we check if\n        // msg.sender is equal to tx.origin which is fine as long as Polygon supports the tx.origin opcode.\n        // solhint-disable-next-line avoid-tx-origin\n        if (relayerRefundLeaf.amountToReturn > 0 && msg.sender != tx.origin) revert NotEOA();\n        super.executeRelayerRefundLeaf(rootBundleId, relayerRefundLeaf, proof);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _setFxChild(address _fxChild) internal {\n        //slither-disable-next-line missing-zero-check\n        fxChild = _fxChild;\n        emit SetFxChild(_fxChild);\n    }\n\n    function _setPolygonTokenBridger(address payable _polygonTokenBridger) internal {\n        polygonTokenBridger = PolygonTokenBridger(_polygonTokenBridger);\n        emit SetPolygonTokenBridger(address(_polygonTokenBridger));\n    }\n\n    function _preExecuteLeafHook(address) internal override {\n        // Wraps MATIC --> WMATIC before distributing tokens from this contract.\n        _wrap();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // If the token is USDC, we need to use the CCTP bridge to transfer it to the hub pool.\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\n            _transferUsdc(withdrawalRecipient, amountToReturn);\n        } else {\n            PolygonIERC20Upgradeable(l2TokenAddress).safeIncreaseAllowance(\n                address(polygonTokenBridger),\n                amountToReturn\n            );\n            // Note: WrappedNativeToken is WMATIC on matic, so this tells the tokenbridger that this is an unwrappable native token.\n            polygonTokenBridger.send(PolygonIERC20Upgradeable(l2TokenAddress), amountToReturn);\n        }\n    }\n\n    function _wrap() internal {\n        uint256 balance = address(this).balance;\n        //slither-disable-next-line arbitrary-send-eth\n        if (balance > 0) wrappedNativeToken.deposit{ value: balance }();\n    }\n\n    // @dev: This contract will trigger admin functions internally via the `processMessageFromRoot`, which is why\n    // the `callValidated` check is made below  and why we use the `validateInternalCalls` modifier on\n    // `processMessageFromRoot`. This prevents calling the admin functions from any other method besides\n    // `processMessageFromRoot`.\n    function _requireAdminSender() internal view override {\n        if (!callValidated) revert CallValidatedNotSet();\n    }\n}\n"
    },
    "contracts/PolygonTokenBridger.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Lockable.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n// Polygon Registry contract that stores their addresses.\ninterface PolygonRegistry {\n    function erc20Predicate() external returns (address);\n}\n\n// Polygon ERC20Predicate contract that handles Plasma exits (only used for Matic).\ninterface PolygonERC20Predicate {\n    function startExitWithBurntTokens(bytes calldata data) external;\n}\n\n// ERC20s (on polygon) compatible with polygon's bridge have a withdraw method.\ninterface PolygonIERC20Upgradeable is IERC20Upgradeable {\n    function withdraw(uint256 amount) external;\n}\n\ninterface MaticToken {\n    function withdraw(uint256 amount) external payable;\n}\n\n/**\n * @notice Contract deployed on Ethereum and Polygon to facilitate token transfers from Polygon to the HubPool and back.\n * @dev Because Polygon only allows withdrawals from a particular address to go to that same address on mainnet, we need to\n * have some sort of contract that can guarantee identical addresses on Polygon and Ethereum. This contract is intended\n * to be completely immutable, so it's guaranteed that the contract on each side is  configured identically as long as\n * it is created via create2. create2 is an alternative creation method that uses a different address determination\n * mechanism from normal create.\n * Normal create: address = hash(deployer_address, deployer_nonce)\n * create2:       address = hash(0xFF, sender, salt, bytecode)\n *  This ultimately allows create2 to generate deterministic addresses that don't depend on the transaction count of the\n * sender.\n * @custom:security-contact bugs@across.to\n */\ncontract PolygonTokenBridger is Lockable {\n    using SafeERC20Upgradeable for PolygonIERC20Upgradeable;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Gas token for Polygon.\n    MaticToken public constant MATIC = MaticToken(0x0000000000000000000000000000000000001010);\n\n    // Should be set to HubPool on Ethereum, or unused on Polygon.\n    address public immutable destination;\n\n    // Registry that stores L1 polygon addresses.\n    PolygonRegistry public immutable l1PolygonRegistry;\n\n    // WETH contract on Ethereum.\n    WETH9Interface public immutable l1Weth;\n\n    // Wrapped Matic on Polygon\n    address public immutable l2WrappedMatic;\n\n    // Chain id for the L1 that this contract is deployed on or communicates with.\n    // For example: if this contract were meant to facilitate transfers from polygon to mainnet, this value would be\n    // the mainnet chainId 1.\n    uint256 public immutable l1ChainId;\n\n    // Chain id for the L2 that this contract is deployed on or communicates with.\n    // For example: if this contract were meant to facilitate transfers from polygon to mainnet, this value would be\n    // the polygon chainId 137.\n    uint256 public immutable l2ChainId;\n\n    modifier onlyChainId(uint256 chainId) {\n        _requireChainId(chainId);\n        _;\n    }\n\n    /**\n     * @notice Constructs Token Bridger contract.\n     * @param _destination Where to send tokens to for this network.\n     * @param _l1PolygonRegistry L1 registry that stores updated addresses of polygon contracts. This should always be\n     * set to the L1 registry regardless if whether it's deployed on L2 or L1.\n     * @param _l1Weth L1 WETH address.\n     * @param _l2WrappedMatic L2 address of wrapped matic token.\n     * @param _l1ChainId the chain id for the L1 in this environment.\n     * @param _l2ChainId the chain id for the L2 in this environment.\n     */\n    constructor(\n        address _destination,\n        PolygonRegistry _l1PolygonRegistry,\n        WETH9Interface _l1Weth,\n        address _l2WrappedMatic,\n        uint256 _l1ChainId,\n        uint256 _l2ChainId\n    ) {\n        //slither-disable-next-line missing-zero-check\n        destination = _destination;\n        l1PolygonRegistry = _l1PolygonRegistry;\n        l1Weth = _l1Weth;\n        //slither-disable-next-line missing-zero-check\n        l2WrappedMatic = _l2WrappedMatic;\n        l1ChainId = _l1ChainId;\n        l2ChainId = _l2ChainId;\n    }\n\n    /**\n     * @notice Called by Polygon SpokePool to send tokens over bridge to contract with the same address as this.\n     * @notice The caller of this function must approve this contract to spend amount of token.\n     * @param token Token to bridge.\n     * @param amount Amount to bridge.\n     */\n    function send(PolygonIERC20Upgradeable token, uint256 amount) public nonReentrant onlyChainId(l2ChainId) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // In the wMatic case, this unwraps. For other ERC20s, this is the burn/send action.\n        token.withdraw(token.balanceOf(address(this)));\n\n        // This takes the token that was withdrawn and calls withdraw on the \"native\" ERC20.\n        if (address(token) == l2WrappedMatic) MATIC.withdraw{ value: address(this).balance }(address(this).balance);\n    }\n\n    /**\n     * @notice Called by someone to send tokens to the destination, which should be set to the HubPool.\n     * @param token Token to send to destination.\n     */\n    function retrieve(IERC20Upgradeable token) public nonReentrant onlyChainId(l1ChainId) {\n        if (address(token) == address(l1Weth)) {\n            // For WETH, there is a pre-deposit step to ensure any ETH that has been sent to the contract is captured.\n            //slither-disable-next-line arbitrary-send-eth\n            l1Weth.deposit{ value: address(this).balance }();\n        }\n        token.safeTransfer(destination, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Called to initiate an l1 exit (withdrawal) of matic tokens that have been sent over the plasma bridge.\n     * @param data the proof data to trigger the exit. Can be generated using the maticjs-plasma package.\n     */\n    function callExit(bytes memory data) public nonReentrant onlyChainId(l1ChainId) {\n        PolygonERC20Predicate erc20Predicate = PolygonERC20Predicate(l1PolygonRegistry.erc20Predicate());\n        erc20Predicate.startExitWithBurntTokens(data);\n    }\n\n    receive() external payable {\n        // This method is empty to avoid any gas expendatures that might cause transfers to fail.\n        // Note: the fact that there is _no_ code in this function means that matic can be erroneously transferred in\n        // to the contract on the polygon side. These tokens would be locked indefinitely since the receive function\n        // cannot be called on the polygon side. While this does have some downsides, the lack of any functionality\n        // in this function means that it has no chance of running out of gas on transfers, which is a much more\n        // important benefit. This just makes the matic token risk similar to that of ERC20s that are erroneously\n        // sent to the contract.\n    }\n\n    function _requireChainId(uint256 chainId) internal view {\n        require(block.chainid == chainId, \"Cannot run method on this chain\");\n    }\n}\n"
    },
    "contracts/PolygonZkEVM_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./external/interfaces/IPolygonZkEVMBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Define interface for PolygonZkEVM Bridge message receiver\n * See https://github.com/0xPolygonHermez/zkevm-contracts/blob/53e95f3a236d8bea87c27cb8714a5d21496a3b20/contracts/interfaces/IBridgeMessageReceiver.sol\n */\ninterface IBridgeMessageReceiver {\n    /**\n     * @notice This will be called by the Polygon zkEVM Bridge on L2 to relay a message sent from the HubPool.\n     * @param originAddress Address of the original message sender on L1.\n     * @param originNetwork Polygon zkEVM's internal network id of source chain.\n     * @param data Data to be received and executed on this contract.\n     */\n    function onMessageReceived(\n        address originAddress,\n        uint32 originNetwork,\n        bytes memory data\n    ) external payable;\n}\n\n/**\n * @notice Polygon zkEVM Spoke pool.\n * @custom:security-contact bugs@across.to\n */\ncontract PolygonZkEVM_SpokePool is SpokePool, IBridgeMessageReceiver {\n    using SafeERC20 for IERC20;\n\n    // Address of Polygon zkEVM's Canonical Bridge on L2.\n    IPolygonZkEVMBridge public l2PolygonZkEVMBridge;\n\n    // Polygon zkEVM's internal network id for L1.\n    uint32 public constant POLYGON_ZKEVM_L1_NETWORK_ID = 0;\n\n    // Warning: this variable should _never_ be touched outside of this contract. It is intentionally set to be\n    // private. Leaving it set to true can permanently disable admin calls.\n    bool private adminCallValidated;\n\n    /**************************************\n     *               ERRORS               *\n     **************************************/\n    error AdminCallValidatedAlreadySet();\n    error CallerNotBridge();\n    error OriginSenderNotCrossDomain();\n    error SourceChainNotHubChain();\n    error AdminCallNotValidated();\n\n    /**************************************\n     *               EVENTS               *\n     **************************************/\n    event SetPolygonZkEVMBridge(address indexed newPolygonZkEVMBridge, address indexed oldPolygonZkEVMBridge);\n    event ReceivedMessageFromL1(address indexed caller, address indexed originAddress);\n\n    // Note: validating calls this way ensures that strange calls coming from the onMessageReceived won't be\n    // misinterpreted. Put differently, just checking that originAddress == crossDomainAdmint is not sufficient.\n    // All calls that have admin privileges must be fired from within the onMessageReceived method that's gone\n    // through validation where the sender is checked and the sender from the other chain is also validated.\n    // This modifier sets the adminCallValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure adminCallValidated is set to True only once at beginning of onMessageReceived, which prevents\n        // onMessageReceived from being re-entered.\n        if (adminCallValidated) {\n            revert AdminCallValidatedAlreadySet();\n        }\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed.\n        adminCallValidated = true;\n\n        _;\n\n        // Reset adminCallValidated to false to disallow admin calls after this method exits.\n        adminCallValidated = false;\n    }\n\n    /**\n     * @notice Construct Polygon zkEVM specific SpokePool.\n     * @param _wrappedNativeTokenAddress Address of WETH on Polygon zkEVM.\n     * @param _depositQuoteTimeBuffer Quote timestamps can't be set more than this amount\n     * into the past from the block time of the deposit.\n     * @param _fillDeadlineBuffer Fill deadlines can't be set more than this amount\n     * into the future from the block time of the deposit.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    ) SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer) {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Polygon zkEVM SpokePool.\n     * @param _l2PolygonZkEVMBridge Address of Polygon zkEVM's canonical bridge contract on L2.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        IPolygonZkEVMBridge _l2PolygonZkEVMBridge,\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setL2PolygonZkEVMBridge(_l2PolygonZkEVMBridge);\n    }\n\n    /**\n     * @notice Admin can reset the Polygon zkEVM bridge contract address.\n     * @param _l2PolygonZkEVMBridge Address of the new canonical bridge.\n     */\n    function setL2PolygonZkEVMBridge(IPolygonZkEVMBridge _l2PolygonZkEVMBridge) external onlyAdmin {\n        _setL2PolygonZkEVMBridge(_l2PolygonZkEVMBridge);\n    }\n\n    /**\n     * @notice This will be called by the Polygon zkEVM Bridge on L2 to relay a message sent from the HubPool.\n     * @param _originAddress Address of the original message sender on L1.\n     * @param _originNetwork Polygon zkEVM's internal network id of source chain.\n     * @param _data Data to be received and executed on this contract.\n     */\n    function onMessageReceived(\n        address _originAddress,\n        uint32 _originNetwork,\n        bytes memory _data\n    ) external payable override validateInternalCalls {\n        if (msg.sender != address(l2PolygonZkEVMBridge)) {\n            revert CallerNotBridge();\n        }\n        if (_originAddress != crossDomainAdmin) {\n            revert OriginSenderNotCrossDomain();\n        }\n        if (_originNetwork != POLYGON_ZKEVM_L1_NETWORK_ID) {\n            revert SourceChainNotHubChain();\n        }\n\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(_data);\n        require(success, \"delegatecall failed\");\n\n        emit ReceivedMessageFromL1(msg.sender, _originAddress);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Wraps any ETH into WETH before executing base function. This is necessary because SpokePool receives\n     * ETH over the canonical token bridge instead of WETH.\n     */\n    function _preExecuteLeafHook(address l2TokenAddress) internal override {\n        if (l2TokenAddress == address(wrappedNativeToken)) _depositEthToWeth();\n    }\n\n    // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is necessary because\n    // this SpokePool will receive ETH from the canonical token bridge instead of WETH. This may not be neccessary\n    // if ETH on Polygon zkEVM is treated as ETH and the fallback() function is triggered when this contract receives\n    // ETH. We will have to test this but this function for now allows the contract to safely convert all of its\n    // held ETH into WETH at the cost of higher gas costs.\n    function _depositEthToWeth() internal {\n        //slither-disable-next-line arbitrary-send-eth\n        if (address(this).balance > 0) wrappedNativeToken.deposit{ value: address(this).balance }();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // SpokePool is expected to receive ETH from the L1 HubPool, then we need to first unwrap it to ETH and then\n        // send ETH directly via the native L2 bridge.\n        if (l2TokenAddress == address(wrappedNativeToken)) {\n            WETH9Interface(l2TokenAddress).withdraw(amountToReturn); // Unwrap into ETH.\n            l2PolygonZkEVMBridge.bridgeAsset{ value: amountToReturn }(\n                POLYGON_ZKEVM_L1_NETWORK_ID,\n                withdrawalRecipient,\n                amountToReturn,\n                address(0),\n                true, // Indicates if the new global exit root is updated or not, which is true for asset bridges\n                \"\"\n            );\n        } else {\n            IERC20(l2TokenAddress).safeIncreaseAllowance(address(l2PolygonZkEVMBridge), amountToReturn);\n            l2PolygonZkEVMBridge.bridgeAsset(\n                POLYGON_ZKEVM_L1_NETWORK_ID,\n                withdrawalRecipient,\n                amountToReturn,\n                l2TokenAddress,\n                true, // Indicates if the new global exit root is updated or not, which is true for asset bridges\n                \"\"\n            );\n        }\n    }\n\n    // Check that the onMessageReceived method has validated the method to ensure the sender is authenticated.\n    function _requireAdminSender() internal view override {\n        if (!adminCallValidated) {\n            revert AdminCallNotValidated();\n        }\n    }\n\n    function _setL2PolygonZkEVMBridge(IPolygonZkEVMBridge _newL2PolygonZkEVMBridge) internal {\n        address oldL2PolygonZkEVMBridge = address(l2PolygonZkEVMBridge);\n        l2PolygonZkEVMBridge = _newL2PolygonZkEVMBridge;\n        emit SetPolygonZkEVMBridge(address(_newL2PolygonZkEVMBridge), oldL2PolygonZkEVMBridge);\n    }\n}\n"
    },
    "contracts/SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./MerkleLib.sol\";\nimport \"./erc7683/ERC7683.sol\";\nimport \"./erc7683/ERC7683Permit2Lib.sol\";\nimport \"./external/interfaces/WETH9Interface.sol\";\nimport \"./interfaces/SpokePoolMessageHandler.sol\";\nimport \"./interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"./upgradeable/MultiCallerUpgradeable.sol\";\nimport \"./upgradeable/EIP712CrossChainUpgradeable.sol\";\nimport \"./upgradeable/AddressLibUpgradeable.sol\";\nimport \"./libraries/AddressConverters.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title SpokePool\n * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.\n * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a \"data worker\",\n * submits a proof that the relayer correctly submitted a relay on this SpokePool.\n * @custom:security-contact bugs@across.to\n */\nabstract contract SpokePool is\n    V3SpokePoolInterface,\n    SpokePoolInterface,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    MultiCallerUpgradeable,\n    EIP712CrossChainUpgradeable,\n    IDestinationSettler\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressLibUpgradeable for address;\n    using Bytes32ToAddress for bytes32;\n    using AddressToBytes32 for address;\n\n    // Address of the L1 contract that acts as the owner of this SpokePool. This should normally be set to the HubPool\n    // address. The crossDomainAdmin address is unused when the SpokePool is deployed to the same chain as the HubPool.\n    address public crossDomainAdmin;\n\n    // Address of the L1 contract that will send tokens to and receive tokens from this contract to fund relayer\n    // refunds and slow relays.\n    address public withdrawalRecipient;\n\n    // Note: The following two storage variables prefixed with DEPRECATED used to be variables that could be set by\n    // the cross-domain admin. Admins ended up not changing these in production, so to reduce\n    // gas in deposit/fill functions, we are converting them to private variables to maintain the contract\n    // storage layout and replacing them with immutable or constant variables, because retrieving a constant\n    // value is cheaper than retrieving a storage variable. Please see out the immutable/constant variable section.\n    WETH9Interface private DEPRECATED_wrappedNativeToken;\n    uint32 private DEPRECATED_depositQuoteTimeBuffer;\n\n    // `numberOfDeposits` acts as a counter to generate unique deposit identifiers for this spoke pool.\n    // It is a uint32 that increments with each `depositV3` call. In the `FundsDeposited` event, it is\n    // implicitly cast to uint256 by setting its most significant bits to 0, reducing the risk of ID collisions\n    // with unsafe deposits. However, this variable's name could be improved (e.g., `depositNonceCounter`)\n    // since it does not accurately reflect the total number of deposits, as `unsafeDeposit` can bypass this increment.\n    uint32 public numberOfDeposits;\n\n    // Whether deposits and fills are disabled.\n    bool public pausedFills;\n    bool public pausedDeposits;\n\n    // This contract can store as many root bundles as the HubPool chooses to publish here.\n    RootBundle[] public rootBundles;\n\n    // Origin token to destination token routings can be turned on or off, which can enable or disable deposits.\n    mapping(address => mapping(uint256 => bool)) public enabledDepositRoutes;\n\n    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay\n    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to\n    // relay, the fees, and the agents are all parameters included in the hash key.\n    mapping(bytes32 => uint256) private DEPRECATED_relayFills;\n\n    // Note: We will likely un-deprecate the fill and deposit counters to implement a better\n    // dynamic LP fee mechanism but for now we'll deprecate it to reduce bytecode\n    // in deposit/fill functions. These counters are designed to implement a fee mechanism that is based on a\n    // canonical history of deposit and fill events and how they update a virtual running balance of liabilities and\n    // assets, which then determines the LP fee charged to relays.\n\n    // This keeps track of the worst-case liabilities due to fills.\n    // It is never reset. Users should only rely on it to determine the worst-case increase in liabilities between\n    // two points. This is used to provide frontrunning protection to ensure the relayer's assumptions about the state\n    // upon which their expected repayments are based will not change before their transaction is mined.\n    mapping(address => uint256) private DEPRECATED_fillCounter;\n\n    // This keeps track of the total running deposits for each token. This allows depositors to protect themselves from\n    // frontrunning that might change their worst-case quote.\n    mapping(address => uint256) private DEPRECATED_depositCounter;\n\n    // This tracks the number of identical refunds that have been requested.\n    // The intention is to allow an off-chain system to know when this could be a duplicate and ensure that the other\n    // requests are known and accounted for.\n    mapping(bytes32 => uint256) private DEPRECATED_refundsRequested;\n\n    // Mapping of V3 relay hashes to fill statuses. Distinguished from relayFills\n    // to eliminate any chance of collision between pre and post V3 relay hashes.\n    mapping(bytes32 => uint256) public fillStatuses;\n\n    // Mapping of L2TokenAddress to relayer to outstanding refund amount. Used when a relayer repayment fails for some\n    // reason (eg blacklist) to track their outstanding liability, thereby letting them claim it later.\n    mapping(address => mapping(address => uint256)) public relayerRefund;\n\n    /**************************************************************\n     *                CONSTANT/IMMUTABLE VARIABLES                *\n     **************************************************************/\n    // Constant and immutable variables do not take up storage slots and are instead added to the contract bytecode\n    // at compile time. The difference between them is that constant variables must be declared inline, meaning\n    // that they cannot be changed in production without changing the contract code, while immutable variables\n    // can be set in the constructor. Therefore we use the immutable keyword for variables that we might want to be\n    // different for each child contract (one obvious example of this is the wrappedNativeToken) or that we might\n    // want to update in the future like depositQuoteTimeBuffer. Constants are unlikely to ever be changed.\n\n    // Address of wrappedNativeToken contract for this network. If an origin token matches this, then the caller can\n    // optionally instruct this contract to wrap native tokens when depositing (ie ETH->WETH or MATIC->WMATIC).\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    WETH9Interface public immutable wrappedNativeToken;\n\n    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces\n    // caller to use an approximately \"current\" realized fee.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable depositQuoteTimeBuffer;\n\n    // The fill deadline can only be set this far into the future from the timestamp of the deposit on this contract.\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint32 public immutable fillDeadlineBuffer;\n\n    uint256 public constant MAX_TRANSFER_SIZE = 1e36;\n\n    bytes32 public constant UPDATE_BYTES32_DEPOSIT_DETAILS_HASH =\n        keccak256(\n            \"UpdateDepositDetails(uint256 depositId,uint256 originChainId,uint256 updatedOutputAmount,bytes32 updatedRecipient,bytes updatedMessage)\"\n        );\n\n    bytes32 public constant UPDATE_ADDRESS_DEPOSIT_DETAILS_HASH =\n        keccak256(\n            \"UpdateDepositDetails(uint256 depositId,uint256 originChainId,uint256 updatedOutputAmount,address updatedRecipient,bytes updatedMessage)\"\n        );\n\n    // Default chain Id used to signify that no repayment is requested, for example when executing a slow fill.\n    uint256 public constant EMPTY_REPAYMENT_CHAIN_ID = 0;\n    // Default address used to signify that no relayer should be credited with a refund, for example\n    // when executing a slow fill.\n    bytes32 public constant EMPTY_RELAYER = bytes32(0);\n    // This is the magic value that signals to the off-chain validator\n    // that this deposit can never expire. A deposit with this fill deadline should always be eligible for a\n    // slow fill, meaning that its output token and input token must be \"equivalent\". Therefore, this value is only\n    // used as a fillDeadline in deposit(), a soon to be deprecated function that also hardcodes outputToken to\n    // the zero address, which forces the off-chain validator to replace the output token with the equivalent\n    // token for the input token. By using this magic value, off-chain validators do not have to keep\n    // this event in their lookback window when querying for expired deposits.\n    uint32 public constant INFINITE_FILL_DEADLINE = type(uint32).max;\n\n    // One year in seconds. If `exclusivityParameter` is set to a value less than this, then the emitted\n    // exclusivityDeadline in a deposit event will be set to the current time plus this value.\n    uint32 public constant MAX_EXCLUSIVITY_PERIOD_SECONDS = 31_536_000;\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n    event SetXDomainAdmin(address indexed newAdmin);\n    event SetWithdrawalRecipient(address indexed newWithdrawalRecipient);\n    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);\n    event RelayedRootBundle(\n        uint32 indexed rootBundleId,\n        bytes32 indexed relayerRefundRoot,\n        bytes32 indexed slowRelayRoot\n    );\n    event ExecutedRelayerRefundRoot(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint256[] refundAmounts,\n        uint32 indexed rootBundleId,\n        uint32 indexed leafId,\n        address l2TokenAddress,\n        address[] refundAddresses,\n        bool deferredRefunds,\n        address caller\n    );\n    event TokensBridged(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint32 indexed leafId,\n        bytes32 indexed l2TokenAddress,\n        address caller\n    );\n    event EmergencyDeletedRootBundle(uint256 indexed rootBundleId);\n    event PausedDeposits(bool isPaused);\n    event PausedFills(bool isPaused);\n\n    /**\n     * @notice Construct the SpokePool. Normally, logic contracts used in upgradeable proxies shouldn't\n     * have constructors since the following code will be executed within the logic contract's state, not the\n     * proxy contract's state. However, if we restrict the constructor to setting only immutable variables, then\n     * we are safe because immutable variables are included in the logic contract's bytecode rather than its storage.\n     * @dev Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be\n     * taken over by an attacker, which may impact the proxy. To prevent the implementation contract from being\n     * used, you should invoke the _disableInitializers function in the constructor to automatically lock it when\n     * it is deployed:\n     * @param _wrappedNativeTokenAddress wrappedNativeToken address for this network to set.\n     * @param _depositQuoteTimeBuffer depositQuoteTimeBuffer to set. Quote timestamps can't be set more than this amount\n     * into the past from the block time of the deposit.\n     * @param _fillDeadlineBuffer fillDeadlineBuffer to set. Fill deadlines can't be set more than this amount\n     * into the future from the block time of the deposit.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    ) {\n        wrappedNativeToken = WETH9Interface(_wrappedNativeTokenAddress);\n        depositQuoteTimeBuffer = _depositQuoteTimeBuffer;\n        fillDeadlineBuffer = _fillDeadlineBuffer;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Construct the base SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function __SpokePool_init(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public onlyInitializing {\n        numberOfDeposits = _initialDepositId;\n        __EIP712_init(\"ACROSS-V2\", \"1.0.0\");\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        _setCrossDomainAdmin(_crossDomainAdmin);\n        _setWithdrawalRecipient(_withdrawalRecipient);\n    }\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     * @dev This should be set to cross domain admin for specific SpokePool.\n     */\n    modifier onlyAdmin() {\n        _requireAdminSender();\n        _;\n    }\n\n    modifier unpausedDeposits() {\n        if (pausedDeposits) revert DepositsArePaused();\n        _;\n    }\n\n    modifier unpausedFills() {\n        if (pausedFills) revert FillsArePaused();\n        _;\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    // Allows cross domain admin to upgrade UUPS proxy implementation.\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {}\n\n    /**\n     * @notice Pauses deposit-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects `deposit()` but not `speedUpDeposit()`, so that existing deposits can be sped up and still\n     * relayed.\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseDeposits(bool pause) public override onlyAdmin nonReentrant {\n        pausedDeposits = pause;\n        emit PausedDeposits(pause);\n    }\n\n    /**\n     * @notice Pauses fill-related functions. This is intended to be used if this contract is deprecated or when\n     * something goes awry.\n     * @dev Affects fillRelayWithUpdatedDeposit() and fillRelay().\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\n     */\n    function pauseFills(bool pause) public override onlyAdmin nonReentrant {\n        pausedFills = pause;\n        emit PausedFills(pause);\n    }\n\n    /**\n     * @notice Change cross domain admin address. Callable by admin only.\n     * @param newCrossDomainAdmin New cross domain admin.\n     */\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyAdmin nonReentrant {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    /**\n     * @notice Change L1 withdrawal recipient address. Callable by admin only.\n     * @param newWithdrawalRecipient New withdrawal recipient address.\n     */\n    function setWithdrawalRecipient(address newWithdrawalRecipient) public override onlyAdmin nonReentrant {\n        _setWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    /**\n     * @notice Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only.\n     * @param originToken Token that depositor can deposit to this contract.\n     * @param destinationChainId Chain ID for where depositor wants to receive funds.\n     * @param enabled True to enable deposits, False otherwise.\n     */\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enabled\n    ) public override onlyAdmin nonReentrant {\n        enabledDepositRoutes[originToken][destinationChainId] = enabled;\n        emit EnabledDepositRoute(originToken, destinationChainId, enabled);\n    }\n\n    /**\n     * @notice This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill\n     * slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is\n     * designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\n     * @param relayerRefundRoot Merkle root containing relayer refund leaves that can be individually executed via\n     * executeRelayerRefundLeaf().\n     * @param slowRelayRoot Merkle root containing slow relay fulfillment leaves that can be individually executed via\n     * executeSlowRelayLeaf().\n     */\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) public override onlyAdmin nonReentrant {\n        uint32 rootBundleId = uint32(rootBundles.length);\n        RootBundle storage rootBundle = rootBundles.push();\n        rootBundle.relayerRefundRoot = relayerRefundRoot;\n        rootBundle.slowRelayRoot = slowRelayRoot;\n        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayRoot);\n    }\n\n    /**\n     * @notice This method is intended to only be used in emergencies where a bad root bundle has reached the\n     * SpokePool.\n     * @param rootBundleId Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256\n     * to ensure that a small input range doesn't limit which indices this method is able to reach.\n     */\n    function emergencyDeleteRootBundle(uint256 rootBundleId) public override onlyAdmin nonReentrant {\n        // Deleting a struct containing a mapping does not delete the mapping in Solidity, therefore the bitmap's\n        // data will still remain potentially leading to vulnerabilities down the line. The way around this would\n        // be to iterate through every key in the mapping and resetting the value to 0, but this seems expensive and\n        // would require a new list in storage to keep track of keys.\n        //slither-disable-next-line mapping-deletion\n        delete rootBundles[rootBundleId];\n        emit EmergencyDeletedRootBundle(rootBundleId);\n    }\n\n    /**************************************\n     *    LEGACY DEPOSITOR FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @dev DEPRECATION NOTICE: this function is deprecated and will be removed in the future.\n     *      Please use deposit (under DEPOSITOR FUNCTIONS below) or depositV3 instead.\n     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock\n     * tokens in this contract and receive a destination token on the destination chain. The origin => destination\n     * token mapping is stored on the L1 HubPool.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @dev Produces a FundsDeposited event with an infinite expiry, meaning that this deposit can never expire.\n     * Moreover, the event's outputToken is set to 0x0 meaning that this deposit can always be slow filled.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function depositDeprecated_5947912356(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable nonReentrant unpausedDeposits {\n        _deposit(\n            msg.sender,\n            recipient,\n            originToken,\n            amount,\n            destinationChainId,\n            relayerFeePct,\n            quoteTimestamp,\n            message\n        );\n    }\n\n    /**\n     * @dev DEPRECATION NOTICE: this function is deprecated and will be removed in the future.\n     *      Please use the other deposit or depositV3 instead.\n     * @notice The only difference between depositFor and deposit is that the depositor address stored\n     * in the relay hash can be overridden by the caller. This means that the passed in depositor\n     * can speed up the deposit, which is useful if the deposit is taken from the end user to a middle layer\n     * contract, like an aggregator or the SpokePoolVerifier, before calling deposit on this contract.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @param depositor Address who is credited for depositing funds on origin chain and can speed up the deposit.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     */\n    function depositFor(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message,\n        uint256 // maxCount. Deprecated.\n    ) public payable nonReentrant unpausedDeposits {\n        _deposit(depositor, recipient, originToken, amount, destinationChainId, relayerFeePct, quoteTimestamp, message);\n    }\n\n    /********************************************\n     *            DEPOSITOR FUNCTIONS           *\n     ********************************************/\n\n    /**\n     * @notice Previously, this function allowed the caller to specify the exclusivityDeadline, otherwise known as the\n     * as exact timestamp on the destination chain before which only the exclusiveRelayer could fill the deposit. Now,\n     * the caller is expected to pass in a number that will be interpreted either as an offset or a fixed\n     * timestamp depending on its value.\n     * @notice Request to bridge input token cross chain to a destination chain and receive a specified amount\n     * of output tokens. The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs,\n     * the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and the system fee that they'll be charged.\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, less a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp. This must be a valid, non-zero address if the exclusivity deadline is\n     * greater than the current block.timestamp. If the exclusivity deadline is < currentTime, then this must be\n     * address(0), and vice versa if this is address(0).\n     * @param quoteTimestamp The HubPool timestamp that is used to determine the system fee paid by the depositor.\n     *  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime]\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp,\n     * the fill will revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where\n     * currentTime is block.timestamp on this chain or this transaction will revert.\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\n     * event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address),\n     * can fill this deposit. There are three ways to use this parameter:\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\n     *        meaning that there is no exclusivity period.\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function deposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable override nonReentrant unpausedDeposits {\n        // Increment the `numberOfDeposits` counter to ensure a unique deposit ID for this spoke pool.\n        DepositV3Params memory params = DepositV3Params({\n            depositor: depositor,\n            recipient: recipient,\n            inputToken: inputToken,\n            outputToken: outputToken,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            destinationChainId: destinationChainId,\n            exclusiveRelayer: exclusiveRelayer,\n            depositId: numberOfDeposits++,\n            quoteTimestamp: quoteTimestamp,\n            fillDeadline: fillDeadline,\n            exclusivityParameter: exclusivityParameter,\n            message: message\n        });\n        _depositV3(params);\n    }\n\n    /**\n     * @notice A version of `deposit` that accepts `address` types for backward compatibility.\n     * This function allows bridging of input tokens cross-chain to a destination chain, receiving a specified amount of output tokens.\n     * The relayer is refunded in input tokens on a repayment chain of their choice, minus system fees, after an optimistic challenge\n     * window. The exclusivity period is specified as an offset from the current block timestamp.\n     *\n     * @dev This version mirrors the original `depositV3` function, but uses `address` types for `depositor`, `recipient`,\n     * `inputToken`, `outputToken`, and `exclusiveRelayer` for compatibility with contracts using the `address` type.\n     *\n     * The key functionality and logic remain identical, ensuring interoperability across both versions.\n     *\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to initiate the deposit.\n     * The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal\n     * to the wrapped native token, the caller can optionally pass in native token as msg.value, provided msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.\n     * @param inputAmount The amount of input tokens pulled from the caller's account and locked into this contract. This\n     * amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, less a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token as a valid\n     * deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer exclusively allowed to fill this deposit before the exclusivity deadline.\n     * @param quoteTimestamp The HubPool timestamp that determines the system fee paid by the depositor. This must be set\n     * between [currentTime - depositQuoteTimeBuffer, currentTime] where currentTime is block.timestamp on this chain.\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will\n     * revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where currentTime is block.timestamp\n     * on this chain.\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\n     * event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address),\n     * can fill this deposit. There are three ways to use this parameter:\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\n     *        meaning that there is no exclusivity period.\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract. If the\n     * message is not empty, the recipient contract must implement `handleV3AcrossMessage()` or the fill will revert.\n     */\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable override {\n        deposit(\n            depositor.toBytes32(),\n            recipient.toBytes32(),\n            inputToken.toBytes32(),\n            outputToken.toBytes32(),\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer.toBytes32(),\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice See deposit for details. This function is identical to deposit except that it does not use the\n     * global deposit ID counter as a deposit nonce, instead allowing the caller to pass in a deposit nonce. This\n     * function is designed to be used by anyone who wants to pre-compute their resultant relay data hash, which\n     * could be useful for filling a deposit faster and avoiding any risk of a relay hash unexpectedly changing\n     * due to another deposit front-running this one and incrementing the global deposit ID counter.\n     * @dev This is labeled \"unsafe\" because there is no guarantee that the depositId emitted in the resultant\n     * FundsDeposited event is unique which means that the\n     * corresponding fill might collide with an existing relay hash on the destination chain SpokePool,\n     * which would make this deposit unfillable. In this case, the depositor would subsequently receive a refund\n     * of `inputAmount` of `inputToken` on the origin chain after the fill deadline.\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\n     * @param depositNonce The nonce that uniquely identifies this deposit. This function will combine this parameter\n     * with the msg.sender address to create a unique uint256 depositNonce and ensure that the msg.sender cannot\n     * use this function to front-run another depositor's unsafe deposit. This function guarantees that the resultant\n     * deposit nonce will not collide with a safe uint256 deposit nonce whose 24 most significant bytes are always 0.\n     * @param depositor See identically named parameter in depositV3() comments.\n     * @param recipient See identically named parameter in depositV3() comments.\n     * @param inputToken See identically named parameter in depositV3() comments.\n     * @param outputToken See identically named parameter in depositV3() comments.\n     * @param inputAmount See identically named parameter in depositV3() comments.\n     * @param outputAmount See identically named parameter in depositV3() comments.\n     * @param destinationChainId See identically named parameter in depositV3() comments.\n     * @param exclusiveRelayer See identically named parameter in depositV3() comments.\n     * @param quoteTimestamp See identically named parameter in depositV3() comments.\n     * @param fillDeadline See identically named parameter in depositV3() comments.\n     * @param exclusivityParameter See identically named parameter in depositV3() comments.\n     * @param message See identically named parameter in depositV3() comments.\n     */\n    function unsafeDeposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) public payable nonReentrant unpausedDeposits {\n        // @dev Create the uint256 deposit ID by concatenating the msg.sender and depositor address with the inputted\n        // depositNonce parameter. The resultant 32 byte string will be hashed and then casted to an \"unsafe\"\n        // uint256 deposit ID. The probability that the resultant ID collides with a \"safe\" deposit ID is\n        // equal to the chance that the first 28 bytes of the hash are 0, which is too small for us to consider.\n\n        uint256 depositId = getUnsafeDepositId(msg.sender, depositor, depositNonce);\n        DepositV3Params memory params = DepositV3Params({\n            depositor: depositor,\n            recipient: recipient,\n            inputToken: inputToken,\n            outputToken: outputToken,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            destinationChainId: destinationChainId,\n            exclusiveRelayer: exclusiveRelayer,\n            depositId: depositId,\n            quoteTimestamp: quoteTimestamp,\n            fillDeadline: fillDeadline,\n            exclusivityParameter: exclusivityParameter,\n            message: message\n        });\n        _depositV3(params);\n    }\n\n    /**\n     * @notice Submits deposit and sets quoteTimestamp to current Time. Sets fill and exclusivity\n     * deadlines as offsets added to the current time. This function is designed to be called by users\n     * such as Multisig contracts who do not have certainty when their transaction will mine.\n     * @param depositor The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\n     * msg.value, as long as msg.value = inputTokenAmount.\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\n     * challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\n     * as a valid deposit route from this spoke pool or this transaction will revert.\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline, which is the deadline for the\n     * relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the\n     * destination chain.\n     * @param exclusivityParameter See identically named parameter in deposit() comments.\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\n     */\n    function depositNow(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable override {\n        deposit(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            uint32(getCurrentTime()),\n            uint32(getCurrentTime()) + fillDeadlineOffset,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice A version of `depositNow` that supports addresses as input types for backward compatibility.\n     * This function submits a deposit and sets `quoteTimestamp` to the current time. The `fill` and `exclusivity` deadlines\n     * are set as offsets added to the current time. It is designed to be called by users, including Multisig contracts, who may\n     * not have certainty when their transaction will be mined.\n     *\n     * @dev This version is identical to the original `depositV3Now` but uses `address` types for `depositor`, `recipient`,\n     * `inputToken`, `outputToken`, and `exclusiveRelayer` to support compatibility with older systems.\n     * It maintains the same logic and purpose, ensuring interoperability with both versions.\n     *\n     * @param depositor The account credited with the deposit, who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive the native token if\n     * an EOA or wrapped native token if a contract.\n     * @param inputToken The token pulled from the caller's account and locked into this contract to initiate the deposit.\n     * Equivalent tokens on the relayer's repayment chain will be sent as a refund. If this is the wrapped native token,\n     * msg.value must equal inputTokenAmount when passed.\n     * @param outputToken The token the relayer will send to the recipient on the destination chain. Must be an ERC20.\n     * @param inputAmount The amount of input tokens pulled from the caller's account and locked into this contract.\n     * This amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, plus a system fee.\n     * @param outputAmount The amount of output tokens the relayer will send to the recipient on the destination.\n     * @param destinationChainId The destination chain identifier. Must be enabled with the input token as a valid deposit route\n     * from this spoke pool, or the transaction will revert.\n     * @param exclusiveRelayer The relayer exclusively allowed to fill the deposit before the exclusivity deadline.\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline. After this timestamp, fills on the\n     * destination chain will revert.\n     * @param exclusivityParameter See identically named parameter in deposit() comments.\n     * @param message The message to send to the recipient on the destination chain. If the recipient is a contract, it must\n     * implement `handleV3AcrossMessage()` if the message is not empty, or the fill will revert.\n     */\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable override {\n        depositV3(\n            depositor,\n            recipient,\n            inputToken,\n            outputToken,\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            uint32(getCurrentTime()),\n            uint32(getCurrentTime()) + fillDeadlineOffset,\n            exclusivityParameter,\n            message\n        );\n    }\n\n    /**\n     * @notice Depositor can use this function to signal to relayer to use updated output amount, recipient,\n     * and/or message.\n     * @dev the depositor and depositId must match the params in a FundsDeposited event that the depositor\n     * wants to speed up. The relayer has the option but not the obligation to use this updated information\n     * when filling the deposit via fillRelayWithUpdatedDeposit().\n     * @param depositor Depositor that must sign the depositorSignature and was the original depositor.\n     * @param depositId Deposit ID to speed up.\n     * @param updatedOutputAmount New output amount to use for this deposit. Should be lower than previous value\n     * otherwise relayer has no incentive to use this updated value.\n     * @param updatedRecipient New recipient to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param updatedMessage New message to use for this deposit. Can be modified if the recipient is a contract\n     * that expects to receive a message from the relay and for some reason needs to be modified.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account. If depositor is a contract, then should implement EIP1271 to sign as a contract. See\n     * _verifyUpdateV3DepositMessage() for more details about how this signature should be constructed.\n     */\n    function speedUpDeposit(\n        bytes32 depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant {\n        _verifyUpdateV3DepositMessage(\n            depositor.toAddress(),\n            depositId,\n            chainId(),\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature,\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n        );\n\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\n        // from the following event to submit a fill with updated relay data.\n        emit RequestedSpeedUpDeposit(\n            updatedOutputAmount,\n            depositId,\n            depositor,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature\n        );\n    }\n\n    /**\n     * @notice A version of `speedUpDeposit` using `address` types for backward compatibility.\n     * This function allows the depositor to signal to the relayer to use updated output amount, recipient, and/or message\n     * when filling a deposit. This can be useful when the deposit needs to be modified after the original transaction has\n     * been mined.\n     *\n     * @dev The `depositor` and `depositId` must match the parameters in a `FundsDeposited` event that the depositor wants to speed up.\n     * The relayer is not obligated but has the option to use this updated information when filling the deposit using\n     * `fillRelayWithUpdatedDeposit()`. This version uses `address` types for compatibility with systems relying on\n     * `address`-based implementations.\n     *\n     * @param depositor The depositor that must sign the `depositorSignature` and was the original depositor.\n     * @param depositId The deposit ID to speed up.\n     * @param updatedOutputAmount The new output amount to use for this deposit. It should be lower than the previous value,\n     * otherwise the relayer has no incentive to use this updated value.\n     * @param updatedRecipient The new recipient for this deposit. Can be modified if the original recipient is a contract that\n     * expects to receive a message from the relay and needs to be changed.\n     * @param updatedMessage The new message for this deposit. Can be modified if the recipient is a contract that expects\n     * to receive a message from the relay and needs to be updated.\n     * @param depositorSignature The signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account.\n     * If the depositor is a contract, it should implement EIP1271 to sign as a contract. See `_verifyUpdateV3DepositMessage()`\n     * for more details on how the signature should be constructed.\n     */\n    function speedUpV3Deposit(\n        address depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public {\n        _verifyUpdateV3DepositMessage(\n            depositor,\n            depositId,\n            chainId(),\n            updatedOutputAmount,\n            updatedRecipient.toBytes32(),\n            updatedMessage,\n            depositorSignature,\n            UPDATE_ADDRESS_DEPOSIT_DETAILS_HASH\n        );\n\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\n        // from the following event to submit a fill with updated relay data.\n        emit RequestedSpeedUpDeposit(\n            updatedOutputAmount,\n            depositId,\n            depositor.toBytes32(),\n            updatedRecipient.toBytes32(),\n            updatedMessage,\n            depositorSignature\n        );\n    }\n\n    /**************************************\n     *         RELAYER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Fulfill request to bridge cross chain by sending specified output tokens to the recipient.\n     * @dev The fee paid to relayers and the system should be captured in the spread between output\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs, the\n     * relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\n     * window in the HubPool, and a system fee charged to relayers.\n     * @dev The hash of the relayData will be used to uniquely identify the deposit to fill, so\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\n     * all parameters passed to deposit() on the origin chain along with that chain's chainId(). This chain's\n     * chainId() must therefore match the destinationChainId passed into deposit.\n     * Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the\n     * origin SpokePool therefore the relayer should not modify any params in relayData.\n     * @dev Cannot fill more than once. Partial fills are not supported.\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. Should match\n     * all the same-named parameters emitted in the origin chain FundsDeposited event.\n     * - depositor: The account credited with the deposit who can request to \"speed up\" this deposit by modifying\n     * the output amount, recipient, and message.\n     * - recipient The account receiving funds on this chain. Can be an EOA or a contract. If\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\n     * an EOA or wrapped native token if a contract.\n     * - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this\n     * token on the repayment chain will be sent as a refund to the caller.\n     * - outputToken The token that the caller will send to the recipient on the destination chain. Must be an\n     * ERC20.\n     * - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund\n     * following an optimistic challenge window in the HubPool.\n     * - outputAmount: The amount of output tokens that the caller will send to the recipient.\n     * - originChainId: The origin chain identifier.\n     * - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\n     * exclusivity deadline timestamp.\n     * - fillDeadline The deadline for the caller to fill the deposit. After this timestamp,\n     * the fill will revert on the destination chain.\n     * - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this\n     * timestamp, anyone can fill this deposit. Note that if this value was set in deposit by adding an offset\n     * to the deposit's block.timestamp, there is re-org risk for the caller of this method because the event's\n     * block.timestamp can change. Read the comments in `deposit` about the `exclusivityParameter` for more details.\n     * - message The message to send to the recipient if the recipient is a contract that implements a\n     * handleV3AcrossMessage() public function\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain.\n     * @param repaymentAddress Address the relayer wants to be receive their refund at.\n     */\n    function fillRelay(\n        V3RelayData memory relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress\n    ) public override nonReentrant unpausedFills {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer.toAddress() != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: relayData.outputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: repaymentChainId\n        });\n\n        _fillRelayV3(relayExecution, repaymentAddress, false);\n    }\n\n    // Exposes the same function as fillRelay but with a legacy V3RelayData struct that takes in address types. Inner\n    // function fillV3Relay() applies reentrancy & non-paused checks.\n    function fillV3Relay(V3RelayDataLegacy calldata relayData, uint256 repaymentChainId) public override {\n        // Convert V3RelayDataLegacy to V3RelayData using the .toBytes32() method.\n        V3RelayData memory convertedRelayData = V3RelayData({\n            depositor: relayData.depositor.toBytes32(),\n            recipient: relayData.recipient.toBytes32(),\n            exclusiveRelayer: relayData.exclusiveRelayer.toBytes32(),\n            inputToken: relayData.inputToken.toBytes32(),\n            outputToken: relayData.outputToken.toBytes32(),\n            inputAmount: relayData.inputAmount,\n            outputAmount: relayData.outputAmount,\n            originChainId: relayData.originChainId,\n            depositId: relayData.depositId,\n            fillDeadline: relayData.fillDeadline,\n            exclusivityDeadline: relayData.exclusivityDeadline,\n            message: relayData.message\n        });\n\n        fillRelay(convertedRelayData, repaymentChainId, msg.sender.toBytes32());\n    }\n\n    /**\n     * @notice Identical to fillV3Relay except that the relayer wants to use a depositor's updated output amount,\n     * recipient, and/or message. The relayer should only use this function if they can supply a message signed\n     * by the depositor that contains the fill's matching deposit ID along with updated relay parameters.\n     * If the signature can be verified, then this function will emit a FilledV3Event that will be used by\n     * the system for refund verification purposes. In other words, this function is an alternative way to fill a\n     * a deposit than fillV3Relay.\n     * @dev Subject to same exclusivity deadline rules as fillV3Relay().\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. See fillV3Relay().\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\n     * passed. See fillV3Relay().\n     * @param repaymentAddress Address the relayer wants to be receive their refund at.\n     * @param updatedOutputAmount New output amount to use for this deposit.\n     * @param updatedRecipient New recipient to use for this deposit.\n     * @param updatedMessage New message to use for this deposit.\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\n     * account.\n     */\n    function fillRelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) public override nonReentrant unpausedFills {\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\n        // to fill the relay.\n        if (\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\n            relayData.exclusiveRelayer.toAddress() != msg.sender\n        ) {\n            revert NotExclusiveRelayer();\n        }\n\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: updatedOutputAmount,\n            updatedRecipient: updatedRecipient,\n            updatedMessage: updatedMessage,\n            repaymentChainId: repaymentChainId\n        });\n\n        _verifyUpdateV3DepositMessage(\n            relayData.depositor.toAddress(),\n            relayData.depositId,\n            relayData.originChainId,\n            updatedOutputAmount,\n            updatedRecipient,\n            updatedMessage,\n            depositorSignature,\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n        );\n\n        _fillRelayV3(relayExecution, repaymentAddress, false);\n    }\n\n    /**\n     * @notice Request Across to send LP funds to this contract to fulfill a slow fill relay\n     * for a deposit in the next bundle.\n     * @dev Slow fills are not possible unless the input and output tokens are \"equivalent\", i.e.\n     * they route to the same L1 token via PoolRebalanceRoutes.\n     * @dev Slow fills are created by inserting slow fill objects into a merkle tree that is included\n     * in the next HubPool \"root bundle\". Once the optimistic challenge window has passed, the HubPool\n     * will relay the slow root to this chain via relayRootBundle(). Once the slow root is relayed,\n     * the slow fill can be executed by anyone who calls executeSlowRelayLeaf().\n     * @dev Cannot request a slow fill if the fill deadline has passed.\n     * @dev Cannot request a slow fill if the relay has already been filled or a slow fill has already been requested.\n     * @param relayData struct containing all the data needed to identify the deposit that should be\n     * slow filled. If any of the params are missing or different from the origin chain deposit,\n     * then Across will not include a slow fill for the intended deposit.\n     */\n    function requestSlowFill(V3RelayData calldata relayData) public override nonReentrant unpausedFills {\n        uint32 currentTime = uint32(getCurrentTime());\n        // If a depositor has set an exclusivity deadline, then only the exclusive relayer should be able to\n        // fast fill within this deadline. Moreover, the depositor should expect to get *fast* filled within\n        // this deadline, not slow filled. As a simplifying assumption, we will not allow slow fills to be requested\n        // during this exclusivity period.\n        if (_fillIsExclusive(relayData.exclusivityDeadline, currentTime)) {\n            revert NoSlowFillsInExclusivityWindow();\n        }\n        if (relayData.fillDeadline < currentTime) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = getV3RelayHash(relayData);\n        if (fillStatuses[relayHash] != uint256(FillStatus.Unfilled)) revert InvalidSlowFillRequest();\n        fillStatuses[relayHash] = uint256(FillStatus.RequestedSlowFill);\n\n        emit RequestedSlowFill(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayData.depositor,\n            relayData.recipient,\n            _hashNonEmptyMessage(relayData.message)\n        );\n    }\n\n    /**\n     * @notice Fills a single leg of a particular order on the destination chain\n     * @dev ERC-7683 fill function.\n     * @param orderId Unique order identifier for this order\n     * @param originData Data emitted on the origin to parameterize the fill\n     * @param fillerData Data provided by the filler to inform the fill or express their preferences\n     */\n    function fill(\n        bytes32 orderId,\n        bytes calldata originData,\n        bytes calldata fillerData\n    ) external {\n        if (keccak256(abi.encode(originData, chainId())) != orderId) {\n            revert WrongERC7683OrderId();\n        }\n\n        // Ensure that the call is not malformed. If the call is malformed, abi.decode will fail.\n        V3SpokePoolInterface.V3RelayData memory relayData = abi.decode(originData, (V3SpokePoolInterface.V3RelayData));\n        AcrossDestinationFillerData memory destinationFillerData = abi.decode(\n            fillerData,\n            (AcrossDestinationFillerData)\n        );\n\n        // Must do a delegatecall because the function requires the inputs to be calldata.\n        (bool success, bytes memory data) = address(this).delegatecall(\n            abi.encodeCall(\n                V3SpokePoolInterface.fillRelay,\n                (relayData, destinationFillerData.repaymentChainId, msg.sender.toBytes32())\n            )\n        );\n        if (!success) {\n            revert LowLevelCallFailed(data);\n        }\n    }\n\n    /**************************************\n     *         DATA WORKER FUNCTIONS      *\n     **************************************/\n\n    /**\n     * @notice Executes a slow relay leaf stored as part of a root bundle relayed by the HubPool.\n     * @dev Executing a slow fill leaf is equivalent to filling the relayData so this function cannot be used to\n     * double fill a recipient. The relayData that is filled is included in the slowFillLeaf and is hashed\n     * like any other fill sent through a fill method.\n     * @dev There is no relayer credited with filling this relay since funds are sent directly out of this contract.\n     * @param slowFillLeaf Contains all data necessary to uniquely identify a relay for this chain. This struct is\n     * hashed and included in a merkle root that is relayed to all spoke pools.\n     * - relayData: struct containing all the data needed to identify the original deposit to be slow filled.\n     * - chainId: chain identifier where slow fill leaf should be executed. If this doesn't match this chain's\n     * chainId, then this function will revert.\n     * - updatedOutputAmount: Amount to be sent to recipient out of this contract's balance. Can be set differently\n     * from relayData.outputAmount to charge a different fee because this deposit was \"slow\" filled. Usually,\n     * this will be set higher to reimburse the recipient for waiting for the slow fill.\n     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.\n     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.\n     */\n    function executeSlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) public override nonReentrant {\n        V3RelayData memory relayData = slowFillLeaf.relayData;\n\n        _preExecuteLeafHook(relayData.outputToken.toAddress());\n\n        // @TODO In the future consider allowing way for slow fill leaf to be created with updated\n        // deposit params like outputAmount, message and recipient.\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\n            relay: relayData,\n            relayHash: getV3RelayHash(relayData),\n            updatedOutputAmount: slowFillLeaf.updatedOutputAmount,\n            updatedRecipient: relayData.recipient,\n            updatedMessage: relayData.message,\n            repaymentChainId: EMPTY_REPAYMENT_CHAIN_ID // Repayment not relevant for slow fills.\n        });\n\n        _verifyV3SlowFill(relayExecution, rootBundleId, proof);\n\n        // - No relayer to refund for slow fill executions.\n        _fillRelayV3(relayExecution, EMPTY_RELAYER, true);\n    }\n\n    /**\n     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they\n     * sent to the recipient plus a relayer fee.\n     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.\n     * @param relayerRefundLeaf Contains all data necessary to reconstruct leaf contained in root bundle and to\n     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.\n     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.\n     */\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public payable virtual override nonReentrant {\n        _preExecuteLeafHook(relayerRefundLeaf.l2TokenAddress);\n\n        if (relayerRefundLeaf.chainId != chainId()) revert InvalidChainId();\n\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Check that proof proves that relayerRefundLeaf is contained within the relayer refund root.\n        // Note: This should revert if the relayerRefundRoot is uninitialized.\n        if (!MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof)) {\n            revert InvalidMerkleProof();\n        }\n\n        _setClaimedLeaf(rootBundleId, relayerRefundLeaf.leafId);\n\n        bool deferredRefunds = _distributeRelayerRefunds(\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.refundAmounts,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses\n        );\n\n        emit ExecutedRelayerRefundRoot(\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.refundAmounts,\n            rootBundleId,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses,\n            deferredRefunds,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Enables a relayer to claim outstanding repayments. Should virtually never be used, unless for some reason\n     * relayer repayment transfer fails for reasons such as token transfer reverts due to blacklisting. In this case,\n     * the relayer can still call this method and claim the tokens to a new address.\n     * @param l2TokenAddress Address of the L2 token to claim refunds for.\n     * @param refundAddress Address to send the refund to.\n     */\n    function claimRelayerRefund(bytes32 l2TokenAddress, bytes32 refundAddress) external {\n        uint256 refund = relayerRefund[l2TokenAddress.toAddress()][msg.sender];\n        if (refund == 0) revert NoRelayerRefundToClaim();\n        relayerRefund[l2TokenAddress.toAddress()][msg.sender] = 0;\n        IERC20Upgradeable(l2TokenAddress.toAddress()).safeTransfer(refundAddress.toAddress(), refund);\n\n        emit ClaimedRelayerRefund(l2TokenAddress, refundAddress, refund, msg.sender);\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns chain ID for this network.\n     * @dev Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\n     */\n    function chainId() public view virtual override returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * @notice Gets the current time.\n     * @return uint for the current timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Returns the deposit ID for an unsafe deposit. This function is used to compute the deposit ID\n     * in unsafeDeposit and is provided as a convenience.\n     * @dev msgSender and depositor are both used as inputs to allow passthrough depositors to create unique\n     * deposit hash spaces for unique depositors.\n     * @param msgSender The caller of the transaction used as input to produce the deposit ID.\n     * @param depositor The depositor address used as input to produce the deposit ID.\n     * @param depositNonce The nonce used as input to produce the deposit ID.\n     * @return The deposit ID for the unsafe deposit.\n     */\n    function getUnsafeDepositId(\n        address msgSender,\n        bytes32 depositor,\n        uint256 depositNonce\n    ) public pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(msgSender, depositor, depositNonce)));\n    }\n\n    function getRelayerRefund(address l2TokenAddress, address refundAddress) public view returns (uint256) {\n        return relayerRefund[l2TokenAddress][refundAddress];\n    }\n\n    function getV3RelayHash(V3RelayData memory relayData) public view returns (bytes32) {\n        return keccak256(abi.encode(relayData, chainId()));\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    function _depositV3(DepositV3Params memory params) internal {\n        // Verify depositor is a valid EVM address.\n        params.depositor.checkAddress();\n\n        // Check that deposit route is enabled for the input token. There are no checks required for the output token\n        // which is pulled from the relayer at fill time and passed through this contract atomically to the recipient.\n        if (!enabledDepositRoutes[params.inputToken.toAddress()][params.destinationChainId]) revert DisabledRoute();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits/fills if this is undesirable.\n        // This will underflow if quoteTimestamp is more than depositQuoteTimeBuffer;\n        // this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        uint256 currentTime = getCurrentTime();\n        if (currentTime < params.quoteTimestamp || currentTime - params.quoteTimestamp > depositQuoteTimeBuffer)\n            revert InvalidQuoteTimestamp();\n\n        // fillDeadline is relative to the destination chain.\n        // Dont allow fillDeadline to be more than several bundles into the future.\n        // This limits the maximum required lookback for dataworker and relayer instances.\n        if (params.fillDeadline > currentTime + fillDeadlineBuffer) revert InvalidFillDeadline();\n\n        // There are three cases for setting the exclusivity deadline using the exclusivity parameter:\n        // 1. If this parameter is 0, then there is no exclusivity period and emit 0 for the deadline. This\n        //    means that fillers of this deposit do not have to worry about the block.timestamp of this event changing\n        //    due to re-orgs when filling this deposit.\n        // 2. If the exclusivity parameter is less than or equal to MAX_EXCLUSIVITY_PERIOD_SECONDS, then the exclusivity\n        //    deadline is set to the block.timestamp of this event plus the exclusivity parameter. This means that the\n        //    filler of this deposit assumes re-org risk when filling this deposit because the block.timestamp of this\n        //    event affects the exclusivity deadline.\n        // 3. Otherwise, interpret this parameter as a timestamp and emit it as the exclusivity deadline. This means\n        //    that the filler of this deposit will not assume re-org risk related to the block.timestamp of this\n        //    event changing.\n        uint32 exclusivityDeadline = params.exclusivityParameter;\n        if (exclusivityDeadline > 0) {\n            if (exclusivityDeadline <= MAX_EXCLUSIVITY_PERIOD_SECONDS) {\n                exclusivityDeadline += uint32(currentTime);\n            }\n\n            // As a safety measure, prevent caller from inadvertently locking funds during exclusivity period\n            //  by forcing them to specify an exclusive relayer.\n            if (params.exclusiveRelayer == bytes32(0)) revert InvalidExclusiveRelayer();\n        }\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending the native token. In this case, the native token should be\n        // wrapped.\n        if (params.inputToken == address(wrappedNativeToken).toBytes32() && msg.value > 0) {\n            if (msg.value != params.inputAmount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the caller as per normal.\n            // Note: this includes the case where the L2 caller has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else {\n            // msg.value should be 0 if input token isn't the wrapped native token.\n            if (msg.value != 0) revert MsgValueDoesNotMatchInputAmount();\n            IERC20Upgradeable(params.inputToken.toAddress()).safeTransferFrom(\n                msg.sender,\n                address(this),\n                params.inputAmount\n            );\n        }\n\n        emit FundsDeposited(\n            params.inputToken,\n            params.outputToken,\n            params.inputAmount,\n            params.outputAmount,\n            params.destinationChainId,\n            params.depositId,\n            params.quoteTimestamp,\n            params.fillDeadline,\n            exclusivityDeadline,\n            params.depositor,\n            params.recipient,\n            params.exclusiveRelayer,\n            params.message\n        );\n    }\n\n    function _deposit(\n        address depositor,\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        int64 relayerFeePct,\n        uint32 quoteTimestamp,\n        bytes memory message\n    ) internal {\n        // Check that deposit route is enabled.\n        if (!enabledDepositRoutes[originToken][destinationChainId]) revert DisabledRoute();\n\n        // We limit the relay fees to prevent the user spending all their funds on fees.\n        if (SignedMath.abs(relayerFeePct) >= 0.5e18) revert InvalidRelayerFeePct();\n        if (amount > MAX_TRANSFER_SIZE) revert MaxTransferSizeExceeded();\n\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\n        // within the configured buffer. The owner should pause deposits if this is undesirable. This will underflow if\n        // quoteTimestamp is more than depositQuoteTimeBuffer; this is safe but will throw an unintuitive error.\n\n        // slither-disable-next-line timestamp\n        if (getCurrentTime() - quoteTimestamp > depositQuoteTimeBuffer) revert InvalidQuoteTimestamp();\n\n        // Increment count of deposits so that deposit ID for this spoke pool is unique.\n        uint32 newDepositId = numberOfDeposits++;\n\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\n        // transaction then the user is sending ETH. In this case, the ETH should be deposited to wrappedNativeToken.\n        if (originToken == address(wrappedNativeToken) && msg.value > 0) {\n            if (msg.value != amount) revert MsgValueDoesNotMatchInputAmount();\n            wrappedNativeToken.deposit{ value: msg.value }();\n            // Else, it is a normal ERC20. In this case pull the token from the user's wallet as per normal.\n            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them.\n            // In this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n        } else {\n            IERC20Upgradeable(originToken).safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit FundsDeposited(\n            originToken.toBytes32(), // inputToken\n            bytes32(0), // outputToken. Setting this to 0x0 means that the outputToken should be assumed to be the\n            // canonical token for the destination chain matching the inputToken. Therefore, this deposit\n            // can always be slow filled.\n            // - setting token to 0x0 will signal to off-chain validator that the \"equivalent\"\n            // token as the inputToken for the destination chain should be replaced here.\n            amount, // inputAmount\n            _computeAmountPostFees(amount, relayerFeePct), // outputAmount\n            // - output amount will be the deposit amount less relayerFeePct, which should now be set\n            // equal to realizedLpFeePct + gasFeePct + capitalCostFeePct where (gasFeePct + capitalCostFeePct)\n            // is equal to the old usage of `relayerFeePct`.\n            destinationChainId,\n            newDepositId,\n            quoteTimestamp,\n            INFINITE_FILL_DEADLINE, // fillDeadline. Default to infinite expiry because\n            // expired deposits refunds could be a breaking change for existing users of this function.\n            0, // exclusivityDeadline. Setting this to 0 along with the exclusiveRelayer to 0x0 means that there\n            // is no exclusive deadline\n            depositor.toBytes32(),\n            recipient.toBytes32(),\n            bytes32(0), // exclusiveRelayer. Setting this to 0x0 will signal to off-chain validator that there\n            // is no exclusive relayer.\n            message\n        );\n    }\n\n    function _distributeRelayerRefunds(\n        uint256 _chainId,\n        uint256 amountToReturn,\n        uint256[] memory refundAmounts,\n        uint32 leafId,\n        address l2TokenAddress,\n        address[] memory refundAddresses\n    ) internal returns (bool deferredRefunds) {\n        uint256 numRefunds = refundAmounts.length;\n        if (refundAddresses.length != numRefunds) revert InvalidMerkleLeaf();\n\n        if (numRefunds > 0) {\n            uint256 spokeStartBalance = IERC20Upgradeable(l2TokenAddress).balanceOf(address(this));\n            uint256 totalRefundedAmount = 0; // Track the total amount refunded.\n\n            // Send each relayer refund address the associated refundAmount for the L2 token address.\n            // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.\n            for (uint256 i = 0; i < numRefunds; ++i) {\n                if (refundAmounts[i] > 0) {\n                    totalRefundedAmount += refundAmounts[i];\n\n                    // Only if the total refunded amount exceeds the spoke starting balance, should we revert. This\n                    // ensures that bundles are atomic, if we have sufficient balance to refund all relayers and\n                    // prevents can only re-pay some of the relayers.\n                    if (totalRefundedAmount > spokeStartBalance) revert InsufficientSpokePoolBalanceToExecuteLeaf();\n\n                    bool success = _noRevertTransfer(l2TokenAddress, refundAddresses[i], refundAmounts[i]);\n\n                    // If the transfer failed then track a deferred transfer for the relayer. Given this function would\n                    // have reverted if there was insufficient balance, this will only happen if the transfer call\n                    // reverts. This will only occur if the underlying transfer method on the l2Token reverts due to\n                    // recipient blacklisting or other related modifications to the l2Token.transfer method.\n                    if (!success) {\n                        relayerRefund[l2TokenAddress][refundAddresses[i]] += refundAmounts[i];\n                        deferredRefunds = true;\n                    }\n                }\n            }\n        }\n        // If leaf's amountToReturn is positive, then send L2 --> L1 message to bridge tokens back via\n        // chain-specific bridging method.\n        if (amountToReturn > 0) {\n            _bridgeTokensToHubPool(amountToReturn, l2TokenAddress);\n\n            emit TokensBridged(amountToReturn, _chainId, leafId, l2TokenAddress.toBytes32(), msg.sender);\n        }\n    }\n\n    // Re-implementation of OZ _callOptionalReturnBool to use private logic. Function executes a transfer and returns a\n    // bool indicating if the external call was successful, rather than reverting. Original method:\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/28aed34dc5e025e61ea0390c18cac875bfde1a78/contracts/token/ERC20/utils/SafeERC20.sol#L188\n    function _noRevertTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        bytes memory data = abi.encodeCall(IERC20Upgradeable.transfer, (to, amount));\n        assembly {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n\n    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {\n        if (newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\n        crossDomainAdmin = newCrossDomainAdmin;\n        emit SetXDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function _setWithdrawalRecipient(address newWithdrawalRecipient) internal {\n        if (newWithdrawalRecipient == address(0)) revert InvalidWithdrawalRecipient();\n        withdrawalRecipient = newWithdrawalRecipient;\n        emit SetWithdrawalRecipient(newWithdrawalRecipient);\n    }\n\n    function _preExecuteLeafHook(address) internal virtual {\n        // This method by default is a no-op. Different child spoke pools might want to execute functionality here\n        // such as wrapping any native tokens owned by the contract into wrapped tokens before proceeding with\n        // executing the leaf.\n    }\n\n    // Should be overriden by implementing contract depending on how L2 handles sending tokens to L1.\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual;\n\n    function _setClaimedLeaf(uint32 rootBundleId, uint32 leafId) internal {\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Verify the leafId in the leaf has not yet been claimed.\n        if (MerkleLib.isClaimed(rootBundle.claimedBitmap, leafId)) revert ClaimedMerkleLeaf();\n\n        // Set leaf as claimed in bitmap. This is passed by reference to the storage rootBundle.\n        MerkleLib.setClaimed(rootBundle.claimedBitmap, leafId);\n    }\n\n    function _verifyUpdateV3DepositMessage(\n        address depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature,\n        bytes32 hashType\n    ) internal view {\n        // A depositor can request to modify an un-relayed deposit by signing a hash containing the updated\n        // details and information uniquely identifying the deposit to relay. This information ensures\n        // that this signature cannot be re-used for other deposits.\n        bytes32 expectedTypedDataV4Hash = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    hashType,\n                    depositId,\n                    originChainId,\n                    updatedOutputAmount,\n                    updatedRecipient,\n                    keccak256(updatedMessage)\n                )\n            ),\n            originChainId\n        );\n        _verifyDepositorSignature(depositor, expectedTypedDataV4Hash, depositorSignature);\n    }\n\n    // This function is isolated and made virtual to allow different L2's to implement chain specific recovery of\n    // signers from signatures because some L2s might not support ecrecover. To be safe, consider always reverting\n    // this function for L2s where ecrecover is different from how it works on Ethereum, otherwise there is the\n    // potential to forge a signature from the depositor using a different private key than the original depositor's.\n    function _verifyDepositorSignature(\n        address depositor,\n        bytes32 ethSignedMessageHash,\n        bytes memory depositorSignature\n    ) internal view virtual {\n        // Note:\n        // - We don't need to worry about re-entrancy from a contract deployed at the depositor address since the method\n        //   `SignatureChecker.isValidSignatureNow` is a view method. Re-entrancy can happen, but it cannot affect state.\n        // - EIP-1271 signatures are supported. This means that a signature valid now, may not be valid later and vice-versa.\n        // - For an EIP-1271 signature to work, the depositor contract address must map to a deployed contract on the destination\n        //   chain that can validate the signature.\n        // - Regular signatures from an EOA are also supported.\n        bool isValid = SignatureChecker.isValidSignatureNow(depositor, ethSignedMessageHash, depositorSignature);\n        if (!isValid) revert InvalidDepositorSignature();\n    }\n\n    function _verifyV3SlowFill(\n        V3RelayExecutionParams memory relayExecution,\n        uint32 rootBundleId,\n        bytes32[] memory proof\n    ) internal view {\n        V3SlowFill memory slowFill = V3SlowFill({\n            relayData: relayExecution.relay,\n            chainId: chainId(),\n            updatedOutputAmount: relayExecution.updatedOutputAmount\n        });\n\n        if (!MerkleLib.verifyV3SlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, slowFill, proof)) {\n            revert InvalidMerkleProof();\n        }\n    }\n\n    function _computeAmountPostFees(uint256 amount, int256 feesPct) private pure returns (uint256) {\n        return (amount * uint256(int256(1e18) - feesPct)) / 1e18;\n    }\n\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends wrappedNativeToken.\n    function _unwrapwrappedNativeTokenTo(address payable to, uint256 amount) internal {\n        if (address(to).isContract()) {\n            IERC20Upgradeable(address(wrappedNativeToken)).safeTransfer(to, amount);\n        } else {\n            wrappedNativeToken.withdraw(amount);\n            AddressLibUpgradeable.sendValue(to, amount);\n        }\n    }\n\n    // @param relayer: relayer who is actually credited as filling this deposit. Can be different from\n    // exclusiveRelayer if passed exclusivityDeadline or if slow fill.\n    function _fillRelayV3(\n        V3RelayExecutionParams memory relayExecution,\n        bytes32 relayer,\n        bool isSlowFill\n    ) internal {\n        V3RelayData memory relayData = relayExecution.relay;\n\n        if (relayData.fillDeadline < getCurrentTime()) revert ExpiredFillDeadline();\n\n        bytes32 relayHash = relayExecution.relayHash;\n\n        // If a slow fill for this fill was requested then the relayFills value for this hash will be\n        // FillStatus.RequestedSlowFill. Therefore, if this is the status, then this fast fill\n        // will be replacing the slow fill. If this is a slow fill execution, then the following variable\n        // is trivially true. We'll emit this value in the FilledRelay\n        // event to assist the Dataworker in knowing when to return funds back to the HubPool that can no longer\n        // be used for a slow fill execution.\n        FillType fillType = isSlowFill\n            ? FillType.SlowFill // The following is true if this is a fast fill that was sent after a slow fill request.\n            : (\n                fillStatuses[relayExecution.relayHash] == uint256(FillStatus.RequestedSlowFill)\n                    ? FillType.ReplacedSlowFill\n                    : FillType.FastFill\n            );\n\n        // @dev This function doesn't support partial fills. Therefore, we associate the relay hash with\n        // an enum tracking its fill status. All filled relays, whether slow or fast fills, are set to the Filled\n        // status. However, we also use this slot to track whether this fill had a slow fill requested. Therefore\n        // we can include a bool in the FilledRelay event making it easy for the dataworker to compute if this\n        // fill was a fast fill that replaced a slow fill and therefore this SpokePool has excess funds that it\n        // needs to send back to the HubPool.\n        if (fillStatuses[relayHash] == uint256(FillStatus.Filled)) revert RelayFilled();\n        fillStatuses[relayHash] = uint256(FillStatus.Filled);\n\n        // @dev Before returning early, emit events to assist the dataworker in being able to know which fills were\n        // successful.\n        emit FilledRelay(\n            relayData.inputToken,\n            relayData.outputToken,\n            relayData.inputAmount,\n            relayData.outputAmount,\n            relayExecution.repaymentChainId,\n            relayData.originChainId,\n            relayData.depositId,\n            relayData.fillDeadline,\n            relayData.exclusivityDeadline,\n            relayData.exclusiveRelayer,\n            relayer,\n            relayData.depositor,\n            relayData.recipient,\n            _hashNonEmptyMessage(relayData.message),\n            V3RelayExecutionEventInfo({\n                updatedRecipient: relayExecution.updatedRecipient,\n                updatedMessageHash: _hashNonEmptyMessage(relayExecution.updatedMessage),\n                updatedOutputAmount: relayExecution.updatedOutputAmount,\n                fillType: fillType\n            })\n        );\n\n        address outputToken = relayData.outputToken.toAddress();\n        uint256 amountToSend = relayExecution.updatedOutputAmount;\n        address recipientToSend = relayExecution.updatedRecipient.toAddress();\n        // If relay token is wrappedNativeToken then unwrap and send native token.\n        // Stack too deep.\n        if (relayData.outputToken.toAddress() == address(wrappedNativeToken)) {\n            // Note: useContractFunds is True if we want to send funds to the recipient directly out of this contract,\n            // otherwise we expect the caller to send funds to the recipient. If useContractFunds is True and the\n            // recipient wants wrappedNativeToken, then we can assume that wrappedNativeToken is already in the\n            // contract, otherwise we'll need the user to send wrappedNativeToken to this contract. Regardless, we'll\n            // need to unwrap it to native token before sending to the user.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, address(this), amountToSend);\n            _unwrapwrappedNativeTokenTo(payable(recipientToSend), amountToSend);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else {\n            // Note: Similar to note above, send token directly from the contract to the user in the slow relay case.\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, recipientToSend, amountToSend);\n            else IERC20Upgradeable(outputToken).safeTransfer(recipientToSend, amountToSend);\n        }\n\n        bytes memory updatedMessage = relayExecution.updatedMessage;\n        if (updatedMessage.length > 0 && recipientToSend.isContract()) {\n            AcrossMessageHandler(recipientToSend).handleV3AcrossMessage(\n                outputToken,\n                amountToSend,\n                msg.sender,\n                updatedMessage\n            );\n        }\n    }\n\n    // Determine whether the exclusivityDeadline implies active exclusivity.\n    function _fillIsExclusive(uint32 exclusivityDeadline, uint32 currentTime) internal pure returns (bool) {\n        return exclusivityDeadline >= currentTime;\n    }\n\n    // Helper for emitting message hash. For easier easier human readability we return bytes32(0) for empty message.\n    function _hashNonEmptyMessage(bytes memory message) internal pure returns (bytes32) {\n        if (message.length == 0) return bytes32(0);\n        else return keccak256(message);\n    }\n\n    // Implementing contract needs to override this to ensure that only the appropriate cross chain admin can execute\n    // certain admin functions. For L2 contracts, the cross chain admin refers to some L1 address or contract, and for\n    // L1, this would just be the same admin of the HubPool.\n    function _requireAdminSender() internal virtual;\n\n    // Added to enable the this contract to receive native token (ETH). Used when unwrapping wrappedNativeToken.\n    receive() external payable {}\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[998] private __gap;\n}\n"
    },
    "contracts/Succinct_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./external/interfaces/SuccinctInterfaces.sol\";\n\n/**\n * @notice Succinct Spoke pool.\n */\ncontract Succinct_SpokePool is SpokePool, ITelepathyHandler {\n    // Address of the succinct AMB contract.\n    address public succinctTargetAmb;\n\n    // Chain where HubPool is deployed that is linked to this SpokePool.\n    uint16 public hubChainId;\n\n    // Warning: this variable should _never_ be touched outside of this contract. It is intentionally set to be\n    // private. Leaving it set to true can permanently disable admin calls.\n    bool private adminCallValidated;\n\n    event SetSuccinctTargetAmb(address indexed newSuccinctTargetAmb);\n    event ReceivedMessageFromL1(address indexed caller, address indexed rootMessageSender);\n\n    // Note: validating calls this way ensures that strange calls coming from the succinctTargetAmb won't be\n    // misinterpreted. Put differently, just checking that msg.sender == succinctTargetAmb is not sufficient.\n    // All calls that have admin privileges must be fired from within the handleTelepathy method that's gone\n    // through validation where the sender is checked and the sender from the other chain is also validated.\n    // This modifier sets the adminCallValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure adminCallValidated is set to True only once at beginning of processMessageFromRoot, which prevents\n        // processMessageFromRoot from being re-entered.\n        require(!adminCallValidated, \"adminCallValidated already set\");\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed.\n        adminCallValidated = true;\n\n        _;\n\n        // Reset adminCallValidated to false to disallow admin calls after this method exits.\n        adminCallValidated = false;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    ) SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer) {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the Succinct SpokePool.\n     * @param _hubChainId Chain ID of the chain where the HubPool is deployed.\n     * @param _succinctTargetAmb Address of the succinct AMB contract.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint16 _hubChainId,\n        address _succinctTargetAmb,\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        succinctTargetAmb = _succinctTargetAmb;\n        hubChainId = _hubChainId;\n    }\n\n    /**\n     * @notice Admin can reset the succinct contract address.\n     * @param _succinctTargetAmb Address of the succinct AMB contract.\n     */\n    function setSuccinctTargetAmb(address _succinctTargetAmb) external onlyAdmin {\n        succinctTargetAmb = _succinctTargetAmb;\n        emit SetSuccinctTargetAmb(_succinctTargetAmb);\n    }\n\n    /**\n     * @notice This will be called by Succinct AMB on this network to relay a message sent from the HubPool.\n     * @param _sourceChainId Chain ID of the chain where the message originated.\n     * @param _senderAddress Address of the sender on the chain where the message originated.\n     * @param _data Data to be received and executed on this contract.\n     */\n    function handleTelepathy(\n        uint16 _sourceChainId,\n        address _senderAddress,\n        bytes memory _data\n    ) external override validateInternalCalls returns (bytes4) {\n        // Validate msg.sender as succinct, the x-chain sender as being the hubPool (the admin) and the source chain as\n        // 1 (mainnet).\n        require(msg.sender == succinctTargetAmb, \"caller not succinct AMB\");\n        require(_senderAddress == crossDomainAdmin, \"sender not hubPool\");\n        require(_sourceChainId == hubChainId, \"source chain not hub chain\");\n\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(_data);\n        require(success, \"delegatecall failed\");\n\n        emit ReceivedMessageFromL1(msg.sender, _senderAddress);\n        return ITelepathyHandler.handleTelepathy.selector;\n    }\n\n    function _bridgeTokensToHubPool(uint256, address) internal override {\n        // This method is a no-op. If the chain intends to include bridging functionality, this must be overriden.\n        // If not, leaving this unimplemented means this method may be triggered, but the result will be that no\n        // balance is transferred.\n    }\n\n    // Check that the handleTelepathy method has validated the method to ensure the sender is authenticated.\n    function _requireAdminSender() internal view override {\n        require(adminCallValidated, \"Admin call not validated\");\n    }\n}\n"
    },
    "contracts/SwapAndBridge.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Lockable.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport \"./libraries/AddressConverters.sol\";\n\n/**\n * @title SwapAndBridgeBase\n * @notice Base contract for both variants of SwapAndBridge.\n * @custom:security-contact bugs@across.to\n */\nabstract contract SwapAndBridgeBase is Lockable, MultiCaller {\n    using SafeERC20 for IERC20;\n    using AddressToBytes32 for address;\n\n    // This contract performs a low level call with arbirary data to an external contract. This is a large attack\n    // surface and we should whitelist which function selectors are allowed to be called on the exchange.\n    mapping(bytes4 => bool) public allowedSelectors;\n\n    // Across SpokePool we'll submit deposits to with acrossInputToken as the input token.\n    V3SpokePoolInterface public immutable SPOKE_POOL;\n\n    // Exchange address or router where the swapping will happen.\n    address public immutable EXCHANGE;\n\n    // Params we'll need caller to pass in to specify an Across Deposit. The input token will be swapped into first\n    // before submitting a bridge deposit, which is why we don't include the input token amount as it is not known\n    // until after the swap.\n    struct DepositData {\n        // Token received on destination chain.\n        address outputToken;\n        // Amount of output token to be received by recipient.\n        uint256 outputAmount;\n        // The account credited with deposit who can submit speedups to the Across deposit.\n        address depositor;\n        // The account that will receive the output token on the destination chain. If the output token is\n        // wrapped native token, then if this is an EOA then they will receive native token on the destination\n        // chain and if this is a contract then they will receive an ERC20.\n        address recipient;\n        // The destination chain identifier.\n        uint256 destinationChainid;\n        // The account that can exclusively fill the deposit before the exclusivity deadline.\n        address exclusiveRelayer;\n        // Timestamp of the deposit used by system to charge fees. Must be within short window of time into the past\n        // relative to this chain's current time or deposit will revert.\n        uint32 quoteTimestamp;\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\n        uint32 fillDeadline;\n        // The timestamp on the destination chain after which anyone can fill the deposit.\n        uint32 exclusivityDeadline;\n        // Data that is forwarded to the recipient if the recipient is a contract.\n        bytes message;\n    }\n\n    event SwapBeforeBridge(\n        address exchange,\n        address indexed swapToken,\n        address indexed acrossInputToken,\n        uint256 swapTokenAmount,\n        uint256 acrossInputAmount,\n        address indexed acrossOutputToken,\n        uint256 acrossOutputAmount\n    );\n\n    /****************************************\n     *                ERRORS                *\n     ****************************************/\n    error MinimumExpectedInputAmount();\n    error LeftoverSrcTokens();\n    error InvalidFunctionSelector();\n\n    /**\n     * @notice Construct a new SwapAndBridgeBase contract.\n     * @param _spokePool Address of the SpokePool contract that we'll submit deposits to.\n     * @param _exchange Address of the exchange where tokens will be swapped.\n     * @param _allowedSelectors Function selectors that are allowed to be called on the exchange.\n     */\n    constructor(\n        V3SpokePoolInterface _spokePool,\n        address _exchange,\n        bytes4[] memory _allowedSelectors\n    ) {\n        SPOKE_POOL = _spokePool;\n        EXCHANGE = _exchange;\n        for (uint256 i = 0; i < _allowedSelectors.length; i++) {\n            allowedSelectors[_allowedSelectors[i]] = true;\n        }\n    }\n\n    // This contract supports two variants of swap and bridge, one that allows one token and another that allows the caller to pass them in.\n    function _swapAndBridge(\n        bytes calldata routerCalldata,\n        uint256 swapTokenAmount,\n        uint256 minExpectedInputTokenAmount,\n        DepositData calldata depositData,\n        IERC20 _swapToken,\n        IERC20 _acrossInputToken\n    ) internal {\n        // Note: this check should never be impactful, but is here out of an abundance of caution.\n        // For example, if the exchange address in the contract is also an ERC20 token that is approved by some\n        // user on this contract, a malicious actor could call transferFrom to steal the user's tokens.\n        if (!allowedSelectors[bytes4(routerCalldata)]) revert InvalidFunctionSelector();\n\n        // Pull tokens from caller into this contract.\n        _swapToken.safeTransferFrom(msg.sender, address(this), swapTokenAmount);\n        // Swap and run safety checks.\n        uint256 srcBalanceBefore = _swapToken.balanceOf(address(this));\n        uint256 dstBalanceBefore = _acrossInputToken.balanceOf(address(this));\n\n        _swapToken.safeIncreaseAllowance(EXCHANGE, swapTokenAmount);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory result) = EXCHANGE.call(routerCalldata);\n        require(success, string(result));\n\n        _checkSwapOutputAndDeposit(\n            swapTokenAmount,\n            srcBalanceBefore,\n            dstBalanceBefore,\n            minExpectedInputTokenAmount,\n            depositData,\n            _swapToken,\n            _acrossInputToken\n        );\n    }\n\n    /**\n     * @notice Check that the swap returned enough tokens to submit an Across deposit with and then submit the deposit.\n     * @param swapTokenAmount Amount of swapToken to swap for a minimum amount of acrossInputToken.\n     * @param swapTokenBalanceBefore Balance of swapToken before swap.\n     * @param inputTokenBalanceBefore Amount of Across input token we held before swap\n     * @param minExpectedInputTokenAmount Minimum amount of received acrossInputToken that we'll bridge\n     **/\n    function _checkSwapOutputAndDeposit(\n        uint256 swapTokenAmount,\n        uint256 swapTokenBalanceBefore,\n        uint256 inputTokenBalanceBefore,\n        uint256 minExpectedInputTokenAmount,\n        DepositData calldata depositData,\n        IERC20 _swapToken,\n        IERC20 _acrossInputToken\n    ) internal {\n        // Sanity check that we received as many tokens as we require:\n        uint256 returnAmount = _acrossInputToken.balanceOf(address(this)) - inputTokenBalanceBefore;\n        // Sanity check that received amount from swap is enough to submit Across deposit with.\n        if (returnAmount < minExpectedInputTokenAmount) revert MinimumExpectedInputAmount();\n        // Sanity check that we don't have any leftover swap tokens that would be locked in this contract (i.e. check\n        // that we weren't partial filled).\n        if (swapTokenBalanceBefore - _swapToken.balanceOf(address(this)) != swapTokenAmount) revert LeftoverSrcTokens();\n\n        emit SwapBeforeBridge(\n            EXCHANGE,\n            address(_swapToken),\n            address(_acrossInputToken),\n            swapTokenAmount,\n            returnAmount,\n            depositData.outputToken,\n            depositData.outputAmount\n        );\n        // Deposit the swapped tokens into Across and bridge them using remainder of input params.\n        _depositV3(_acrossInputToken, returnAmount, depositData);\n    }\n\n    /**\n     * @notice Approves the spoke pool and calls `depositV3` function with the specified input parameters.\n     * @param _acrossInputToken Token to deposit into the spoke pool.\n     * @param _acrossInputAmount Amount of the input token to deposit into the spoke pool.\n     * @param depositData Specifies the Across deposit params to use.\n     */\n    function _depositV3(\n        IERC20 _acrossInputToken,\n        uint256 _acrossInputAmount,\n        DepositData calldata depositData\n    ) internal {\n        _acrossInputToken.safeIncreaseAllowance(address(SPOKE_POOL), _acrossInputAmount);\n        SPOKE_POOL.deposit(\n            depositData.depositor.toBytes32(),\n            depositData.recipient.toBytes32(),\n            address(_acrossInputToken).toBytes32(), // input token\n            depositData.outputToken.toBytes32(), // output token\n            _acrossInputAmount, // input amount.\n            depositData.outputAmount, // output amount\n            depositData.destinationChainid,\n            depositData.exclusiveRelayer.toBytes32(),\n            depositData.quoteTimestamp,\n            depositData.fillDeadline,\n            depositData.exclusivityDeadline,\n            depositData.message\n        );\n    }\n}\n\n/**\n * @title SwapAndBridge\n * @notice Allows caller to swap between two pre-specified tokens on a chain before bridging the received token\n * via Across atomically. Provides safety checks post-swap and before-deposit.\n * @dev This variant primarily exists\n */\ncontract SwapAndBridge is SwapAndBridgeBase {\n    using SafeERC20 for IERC20;\n\n    // This contract simply enables the caller to swap a token on this chain for another specified one\n    // and bridge it as the input token via Across. This simplification is made to make the code\n    // easier to reason about and solve a specific use case for Across.\n    IERC20 public immutable SWAP_TOKEN;\n\n    // The token that will be bridged via Across as the inputToken.\n    IERC20 public immutable ACROSS_INPUT_TOKEN;\n\n    /**\n     * @notice Construct a new SwapAndBridge contract.\n     * @param _spokePool Address of the SpokePool contract that we'll submit deposits to.\n     * @param _exchange Address of the exchange where tokens will be swapped.\n     * @param _allowedSelectors Function selectors that are allowed to be called on the exchange.\n     * @param _swapToken Address of the token that will be swapped for acrossInputToken. Cannot be 0x0\n     * @param _acrossInputToken Address of the token that will be bridged via Across as the inputToken.\n     */\n    constructor(\n        V3SpokePoolInterface _spokePool,\n        address _exchange,\n        bytes4[] memory _allowedSelectors,\n        IERC20 _swapToken,\n        IERC20 _acrossInputToken\n    ) SwapAndBridgeBase(_spokePool, _exchange, _allowedSelectors) {\n        SWAP_TOKEN = _swapToken;\n        ACROSS_INPUT_TOKEN = _acrossInputToken;\n    }\n\n    /**\n     * @notice Swaps tokens on this chain via specified router before submitting Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev If swapToken or acrossInputToken are the native token for this chain then this function might fail.\n     * the assumption is that this function will handle only ERC20 tokens.\n     * @param routerCalldata ABI encoded function data to call on router. Should form a swap of swapToken for\n     * enough of acrossInputToken, otherwise this function will revert.\n     * @param swapTokenAmount Amount of swapToken to swap for a minimum amount of depositData.inputToken.\n     * @param minExpectedInputTokenAmount Minimum amount of received depositData.inputToken that we'll submit bridge\n     * deposit with.\n     * @param depositData Specifies the Across deposit params we'll send after the swap.\n     */\n    function swapAndBridge(\n        bytes calldata routerCalldata,\n        uint256 swapTokenAmount,\n        uint256 minExpectedInputTokenAmount,\n        DepositData calldata depositData\n    ) external nonReentrant {\n        _swapAndBridge(\n            routerCalldata,\n            swapTokenAmount,\n            minExpectedInputTokenAmount,\n            depositData,\n            SWAP_TOKEN,\n            ACROSS_INPUT_TOKEN\n        );\n    }\n}\n\n/**\n * @title UniversalSwapAndBridge\n * @notice Allows caller to swap between any two tokens specified at runtime on a chain before\n * bridging the received token via Across atomically. Provides safety checks post-swap and before-deposit.\n */\ncontract UniversalSwapAndBridge is SwapAndBridgeBase {\n    /**\n     * @notice Construct a new SwapAndBridgeBase contract.\n     * @param _spokePool Address of the SpokePool contract that we'll submit deposits to.\n     * @param _exchange Address of the exchange where tokens will be swapped.\n     * @param _allowedSelectors Function selectors that are allowed to be called on the exchange.\n     */\n    constructor(\n        V3SpokePoolInterface _spokePool,\n        address _exchange,\n        bytes4[] memory _allowedSelectors\n    ) SwapAndBridgeBase(_spokePool, _exchange, _allowedSelectors) {}\n\n    /**\n     * @notice Swaps tokens on this chain via specified router before submitting Across deposit atomically.\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\n     * @dev If swapToken or acrossInputToken are the native token for this chain then this function might fail.\n     * the assumption is that this function will handle only ERC20 tokens.\n     * @param swapToken Address of the token that will be swapped for acrossInputToken.\n     * @param acrossInputToken Address of the token that will be bridged via Across as the inputToken.\n     * @param routerCalldata ABI encoded function data to call on router. Should form a swap of swapToken for\n     * enough of acrossInputToken, otherwise this function will revert.\n     * @param swapTokenAmount Amount of swapToken to swap for a minimum amount of depositData.inputToken.\n     * @param minExpectedInputTokenAmount Minimum amount of received depositData.inputToken that we'll submit bridge\n     * deposit with.\n     * @param depositData Specifies the Across deposit params we'll send after the swap.\n     */\n    function swapAndBridge(\n        IERC20 swapToken,\n        IERC20 acrossInputToken,\n        bytes calldata routerCalldata,\n        uint256 swapTokenAmount,\n        uint256 minExpectedInputTokenAmount,\n        DepositData calldata depositData\n    ) external nonReentrant {\n        _swapAndBridge(\n            routerCalldata,\n            swapTokenAmount,\n            minExpectedInputTokenAmount,\n            depositData,\n            swapToken,\n            acrossInputToken\n        );\n    }\n}\n"
    },
    "contracts/test/AcrossMessageHandlerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../SpokePool.sol\";\nimport \"../interfaces/V3SpokePoolInterface.sol\";\n\ncontract AcrossMessageHandlerMock is AcrossMessageHandler {\n    function handleV3AcrossMessage(\n        address tokenSent,\n        uint256 amount,\n        address relayer,\n        bytes memory message\n    ) external override {}\n}\n"
    },
    "contracts/test/ExpandedERC20WithBlacklist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@uma/core/contracts/common/implementation/ExpandedERC20.sol\";\n\ncontract ExpandedERC20WithBlacklist is ExpandedERC20 {\n    mapping(address => bool) public isBlackListed;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ExpandedERC20(name, symbol, decimals) {}\n\n    function setBlacklistStatus(address account, bool status) external {\n        isBlackListed[account] = status;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(!isBlackListed[to], \"Recipient is blacklisted\");\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/test/interfaces/MockV2SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @notice Contains common data structures and functions used by all SpokePool implementations.\n */\ninterface MockV2SpokePoolInterface {\n    struct RelayData {\n        bytes32 depositor;\n        bytes32 recipient;\n        bytes32 destinationToken;\n        uint256 amount;\n        uint256 originChainId;\n        uint256 destinationChainId;\n        int64 realizedLpFeePct;\n        int64 relayerFeePct;\n        uint32 depositId;\n        bytes message;\n    }\n\n    struct RelayExecution {\n        RelayData relay;\n        bytes32 relayHash;\n        int64 updatedRelayerFeePct;\n        bytes32 updatedRecipient;\n        bytes updatedMessage;\n        uint256 repaymentChainId;\n        uint256 maxTokensToSend;\n        uint256 maxCount;\n        bool slowFill;\n        int256 payoutAdjustmentPct;\n    }\n\n    struct SlowFill {\n        RelayData relayData;\n        int256 payoutAdjustmentPct;\n    }\n}\n"
    },
    "contracts/test/MerkleLibTest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../MerkleLib.sol\";\nimport \"../interfaces/HubPoolInterface.sol\";\nimport \"../interfaces/SpokePoolInterface.sol\";\nimport \"./interfaces/MockV2SpokePoolInterface.sol\";\nimport \"./V2MerkleLib.sol\";\n\n/**\n * @notice Contract to test the MerkleLib.\n */\ncontract MerkleLibTest {\n    mapping(uint256 => uint256) public claimedBitMap;\n\n    uint256 public claimedBitMap1D;\n\n    function verifyPoolRebalance(\n        bytes32 root,\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifyPoolRebalance(root, rebalance, proof);\n    }\n\n    function verifyRelayerRefund(\n        bytes32 root,\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifyRelayerRefund(root, refund, proof);\n    }\n\n    function verifySlowRelayFulfillment(\n        bytes32 root,\n        MockV2SpokePoolInterface.SlowFill memory slowFill,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return V2MerkleLib.verifySlowRelayFulfillment(root, slowFill, proof);\n    }\n\n    function verifyV3SlowRelayFulfillment(\n        bytes32 root,\n        V3SpokePoolInterface.V3SlowFill memory slowFill,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifyV3SlowRelayFulfillment(root, slowFill, proof);\n    }\n\n    function isClaimed(uint256 index) public view returns (bool) {\n        return MerkleLib.isClaimed(claimedBitMap, index);\n    }\n\n    function setClaimed(uint256 index) public {\n        MerkleLib.setClaimed(claimedBitMap, index);\n    }\n\n    function isClaimed1D(uint8 index) public view returns (bool) {\n        return MerkleLib.isClaimed1D(claimedBitMap1D, index);\n    }\n\n    function setClaimed1D(uint8 index) public {\n        claimedBitMap1D = MerkleLib.setClaimed1D(claimedBitMap1D, index);\n    }\n}\n"
    },
    "contracts/test/MockBedrockStandardBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../Ovm_SpokePool.sol\";\n\n// Provides payable withdrawTo interface introduced on Bedrock\ncontract MockBedrockL2StandardBridge is IL2ERC20Bridge {\n    event ERC20WithdrawalInitiated(address indexed l2Token, address indexed to, uint256 amount);\n\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32,\n        bytes calldata\n    ) external payable {\n        emit ERC20WithdrawalInitiated(_l2Token, _to, _amount);\n    }\n\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32,\n        bytes calldata\n    ) external {\n        // Check that caller has approved this contract to pull funds, mirroring mainnet's behavior\n        IERC20(_localToken).transferFrom(msg.sender, address(this), _amount);\n        IERC20(_remoteToken).transfer(_to, _amount);\n    }\n}\n\ncontract MockBedrockL1StandardBridge {\n    event ETHDepositInitiated(address indexed to, uint256 amount);\n    event ERC20DepositInitiated(address indexed to, address l1Token, address l2Token, uint256 amount);\n\n    function depositERC20To(\n        address l1Token,\n        address l2Token,\n        address to,\n        uint256 amount,\n        uint32,\n        bytes calldata\n    ) external {\n        IERC20(l1Token).transferFrom(msg.sender, address(this), amount);\n        emit ERC20DepositInitiated(to, l1Token, l2Token, amount);\n    }\n\n    function depositETHTo(\n        address to,\n        uint32,\n        bytes calldata\n    ) external payable {\n        emit ETHDepositInitiated(to, msg.value);\n    }\n}\n\ncontract MockBedrockCrossDomainMessenger {\n    event MessageSent(address indexed target);\n\n    address private msgSender;\n\n    function sendMessage(\n        address target,\n        bytes calldata,\n        uint32\n    ) external {\n        emit MessageSent(target);\n    }\n\n    // Impersonates making a call on L2 from L1.\n    function impersonateCall(address target, bytes memory data) external payable returns (bytes memory) {\n        msgSender = msg.sender;\n        (bool success, bytes memory returnData) = target.call{ value: msg.value }(data);\n\n        // Revert if call reverted.\n        if (!success) {\n            assembly {\n                revert(add(32, returnData), mload(returnData))\n            }\n        }\n        return returnData;\n    }\n\n    function xDomainMessageSender() external view returns (address) {\n        return msgSender;\n    }\n}\n"
    },
    "contracts/test/MockCaller.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/SpokePoolInterface.sol\";\n\n// Used for calling SpokePool.sol functions from a contract instead of an EOA. Can be used to simulate aggregator\n// or pooled relayer behavior. Makes all calls from constructor to make sure SpokePool is not relying on checking the\n// caller's code size which is 0 at construction time.\n\ncontract MockCaller {\n    constructor(\n        address _spokePool,\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) {\n        require(_spokePool != address(this), \"spokePool not external\");\n        SpokePoolInterface(_spokePool).executeRelayerRefundLeaf(rootBundleId, relayerRefundLeaf, proof);\n    }\n}\n"
    },
    "contracts/test/MockOptimism_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../Ovm_SpokePool.sol\";\n\n/**\n * @notice Mock Optimism Spoke pool allowing deployer to override constructor params.\n */\ncontract MockOptimism_SpokePool is Ovm_SpokePool {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wrappedNativeTokenAddress)\n        Ovm_SpokePool(_wrappedNativeTokenAddress, 1 hours, 9 hours, IERC20(address(0)), ITokenMessenger(address(0)))\n    {} // solhint-disable-line no-empty-blocks\n\n    function initialize(\n        address l2Eth,\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _hubPool\n    ) public initializer {\n        __OvmSpokePool_init(_initialDepositId, _crossDomainAdmin, _hubPool, l2Eth);\n    }\n}\n"
    },
    "contracts/test/MockSpokePool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../SpokePool.sol\";\nimport \"./interfaces/MockV2SpokePoolInterface.sol\";\nimport \"./V2MerkleLib.sol\";\nimport { AddressToBytes32, Bytes32ToAddress } from \"../libraries/AddressConverters.sol\";\n\n/**\n * @title MockSpokePool\n * @notice Implements abstract contract for testing.\n */\ncontract MockSpokePool is SpokePool, MockV2SpokePoolInterface, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressToBytes32 for address;\n    using Bytes32ToAddress for bytes32;\n\n    uint256 private chainId_;\n    uint256 private currentTime;\n    mapping(bytes32 => uint256) private relayFills;\n\n    uint256 public constant SLOW_FILL_MAX_TOKENS_TO_SEND = 1e40;\n\n    bytes32 public constant UPDATE_DEPOSIT_DETAILS_HASH =\n        keccak256(\n            \"UpdateDepositDetails(uint256 depositId,uint256 originChainId,int64 updatedRelayerFeePct,address updatedRecipient,bytes updatedMessage)\"\n        );\n\n    event BridgedToHubPool(uint256 amount, address token);\n    event PreLeafExecuteHook(bytes32 token);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wrappedNativeTokenAddress) SpokePool(_wrappedNativeTokenAddress, 1 hours, 9 hours) {} // solhint-disable-line no-empty-blocks\n\n    function initialize(\n        uint32 _initialDepositId,\n        address _crossDomainAdmin,\n        address _hubPool\n    ) public initializer {\n        __Ownable_init();\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _hubPool);\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    function setCurrentTime(uint256 time) external {\n        currentTime = time;\n    }\n\n    function distributeRelayerRefunds(\n        uint256 _chainId,\n        uint256 amountToReturn,\n        uint256[] memory refundAmounts,\n        uint32 leafId,\n        address l2TokenAddress,\n        address[] memory refundAddresses\n    ) external {\n        _distributeRelayerRefunds(_chainId, amountToReturn, refundAmounts, leafId, l2TokenAddress, refundAddresses);\n    }\n\n    function _verifyUpdateDepositMessage(\n        address depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        int64 updatedRelayerFeePct,\n        bytes32 updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature\n    ) internal view {\n        bytes32 expectedTypedDataV4Hash = _hashTypedDataV4(\n            // EIP-712 compliant hash struct: https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct\n            keccak256(\n                abi.encode(\n                    UPDATE_DEPOSIT_DETAILS_HASH,\n                    depositId,\n                    originChainId,\n                    updatedRelayerFeePct,\n                    updatedRecipient,\n                    keccak256(updatedMessage)\n                )\n            ),\n            // By passing in the origin chain id, we enable the verification of the signature on a different chain\n            originChainId\n        );\n        _verifyDepositorSignature(depositor, expectedTypedDataV4Hash, depositorSignature);\n    }\n\n    function verifyUpdateV3DepositMessageBytes32(\n        bytes32 depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature\n    ) public view {\n        return\n            _verifyUpdateV3DepositMessage(\n                depositor.toAddress(),\n                depositId,\n                originChainId,\n                updatedOutputAmount,\n                updatedRecipient,\n                updatedMessage,\n                depositorSignature,\n                UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\n            );\n    }\n\n    function verifyUpdateV3DepositMessage(\n        address depositor,\n        uint256 depositId,\n        uint256 originChainId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes memory updatedMessage,\n        bytes memory depositorSignature\n    ) public view {\n        return\n            _verifyUpdateV3DepositMessage(\n                depositor,\n                depositId,\n                originChainId,\n                updatedOutputAmount,\n                updatedRecipient.toBytes32(),\n                updatedMessage,\n                depositorSignature,\n                UPDATE_ADDRESS_DEPOSIT_DETAILS_HASH\n            );\n    }\n\n    function fillRelayV3Internal(\n        V3RelayExecutionParams memory relayExecution,\n        bytes32 relayer,\n        bool isSlowFill\n    ) external {\n        _fillRelayV3(relayExecution, relayer, isSlowFill);\n    }\n\n    // This function is nonReentrant in order to allow caller to test whether a different function\n    // is reentrancy protected or not.\n    function callback(bytes memory data) external payable nonReentrant {\n        (bool success, bytes memory result) = address(this).call{ value: msg.value }(data);\n        require(success, string(result));\n    }\n\n    function setFillStatus(bytes32 relayHash, FillType fillType) external {\n        fillStatuses[relayHash] = uint256(fillType);\n    }\n\n    function getCurrentTime() public view override returns (uint256) {\n        return currentTime;\n    }\n\n    function _preExecuteLeafHook(address token) internal override {\n        emit PreLeafExecuteHook(token.toBytes32());\n    }\n\n    function _bridgeTokensToHubPool(uint256 amount, address token) internal override {\n        emit BridgedToHubPool(amount, token);\n    }\n\n    function _requireAdminSender() internal override onlyOwner {} // solhint-disable-line no-empty-blocks\n\n    function chainId() public view override(SpokePool) returns (uint256) {\n        // If chainId_ is set then return it, else do nothing and return the parent chainId().\n        return chainId_ == 0 ? super.chainId() : chainId_;\n    }\n\n    function setChainId(uint256 _chainId) public {\n        chainId_ = _chainId;\n    }\n\n    function _computeAmountPreFees(uint256 amount, int64 feesPct) private pure returns (uint256) {\n        return (1e18 * amount) / uint256((int256(1e18) - feesPct));\n    }\n\n    function __computeAmountPostFees(uint256 amount, int256 feesPct) private pure returns (uint256) {\n        return (amount * uint256(int256(1e18) - feesPct)) / 1e18;\n    }\n\n    function _getRelayHash(MockV2SpokePoolInterface.RelayData memory relayData) private pure returns (bytes32) {\n        return keccak256(abi.encode(relayData));\n    }\n\n    function _fillRelay(RelayExecution memory relayExecution) internal returns (uint256 fillAmountPreFees) {\n        MockV2SpokePoolInterface.RelayData memory relayData = relayExecution.relay;\n\n        require(relayFills[relayExecution.relayHash] < relayData.amount, \"relay filled\");\n\n        fillAmountPreFees = _computeAmountPreFees(\n            relayExecution.maxTokensToSend,\n            (relayData.realizedLpFeePct + relayExecution.updatedRelayerFeePct)\n        );\n        require(fillAmountPreFees > 0, \"fill amount pre fees is 0\");\n\n        uint256 amountRemainingInRelay = relayData.amount - relayFills[relayExecution.relayHash];\n        if (amountRemainingInRelay < fillAmountPreFees) {\n            fillAmountPreFees = amountRemainingInRelay;\n        }\n\n        uint256 amountToSend = __computeAmountPostFees(\n            fillAmountPreFees,\n            relayData.realizedLpFeePct + relayExecution.updatedRelayerFeePct\n        );\n\n        if (relayExecution.payoutAdjustmentPct != 0) {\n            require(relayExecution.payoutAdjustmentPct >= -1e18, \"payoutAdjustmentPct too small\");\n            require(relayExecution.payoutAdjustmentPct <= 100e18, \"payoutAdjustmentPct too large\");\n\n            amountToSend = __computeAmountPostFees(amountToSend, -relayExecution.payoutAdjustmentPct);\n            require(amountToSend <= relayExecution.maxTokensToSend, \"Somehow hit maxTokensToSend!\");\n        }\n\n        bool localRepayment = relayExecution.repaymentChainId == relayExecution.relay.destinationChainId;\n        require(\n            localRepayment || relayExecution.relay.amount == fillAmountPreFees || relayExecution.slowFill,\n            \"invalid repayment chain\"\n        );\n\n        relayFills[relayExecution.relayHash] += fillAmountPreFees;\n\n        if (msg.sender.toBytes32() == relayExecution.updatedRecipient && !relayExecution.slowFill) {\n            return fillAmountPreFees;\n        }\n\n        if (relayData.destinationToken == address(wrappedNativeToken).toBytes32()) {\n            if (!relayExecution.slowFill) {\n                IERC20Upgradeable(relayData.destinationToken.toAddress()).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amountToSend\n                );\n            }\n            _unwrapwrappedNativeTokenTo(payable(relayExecution.updatedRecipient.toAddress()), amountToSend);\n        } else {\n            if (!relayExecution.slowFill) {\n                IERC20Upgradeable(relayData.destinationToken.toAddress()).safeTransferFrom(\n                    msg.sender,\n                    relayExecution.updatedRecipient.toAddress(),\n                    amountToSend\n                );\n            } else {\n                IERC20Upgradeable(relayData.destinationToken.toAddress()).safeTransfer(\n                    relayExecution.updatedRecipient.toAddress(),\n                    amountToSend\n                );\n            }\n        }\n    }\n\n    function _verifySlowFill(\n        RelayExecution memory relayExecution,\n        uint32 rootBundleId,\n        bytes32[] memory proof\n    ) internal view {\n        SlowFill memory slowFill = SlowFill({\n            relayData: relayExecution.relay,\n            payoutAdjustmentPct: relayExecution.payoutAdjustmentPct\n        });\n\n        require(\n            V2MerkleLib.verifySlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, slowFill, proof),\n            \"Invalid slow relay proof\"\n        );\n    }\n}\n"
    },
    "contracts/test/MockSpokePoolV2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./MockSpokePool.sol\";\n\n/**\n * @title MockSpokePoolV2\n * @notice Upgrades MockSpokePool for no practical reason other than to demonstrate\n * upgradeability options\n */\ncontract MockSpokePoolV2 is MockSpokePool {\n    event NewEvent(bool value);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wrappedNativeTokenAddress) MockSpokePool(_wrappedNativeTokenAddress) {} // solhint-disable-line no-empty-blocks\n\n    // Demonstrative of how we could reset state variables in a V2 contract conveniently while initializing new\n    // modules. The `reinitializer` modifier is required to create new Initializable contracts.\n    function reinitialize(address _hubPool) public reinitializer(2) {\n        _setWithdrawalRecipient(_hubPool);\n    }\n\n    // Demonstrative new function we could add in a V2 contract.\n    function emitEvent() external {\n        emit NewEvent(true);\n    }\n}\n"
    },
    "contracts/test/V2MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/MockV2SpokePoolInterface.sol\";\n\n/**\n * @notice Library to help with merkle roots, proofs, and claims.\n */\nlibrary V2MerkleLib {\n    function verifySlowRelayFulfillment(\n        bytes32 root,\n        MockV2SpokePoolInterface.SlowFill memory slowRelayFulfillment,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\n    }\n}\n"
    },
    "contracts/upgradeable/AddressLibUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title AddressUpgradeable\n * @dev Collection of functions related to the address type\n * @notice Logic is 100% copied from \"@openzeppelin/contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\" but one\n * comment is added to clarify why we allow delegatecall() in this contract, which is typically unsafe for use in\n * upgradeable implementation contracts.\n * @dev See https://docs.openzeppelin.com/upgrades-plugins/1.x/faq#delegatecall-selfdestruct for more details.\n * @custom:security-contact bugs@across.to\n */\nlibrary AddressLibUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/upgradeable/EIP712CrossChainUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * This contract is based on OpenZeppelin's implementation:\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/cryptography/EIP712Upgradeable.sol\n *\n * NOTE: Modified version that allows to build a domain separator that relies on a different chain id than the chain this\n * contract is deployed to. An example use case we want to support is:\n * - User A signs a message on chain with id = 1\n * - User B executes a method by verifying user A's EIP-712 compliant signature on a chain with id != 1\n * @custom:security-contact bugs@across.to\n */\nabstract contract EIP712CrossChainUpgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator depending on the `originChainId`.\n     * @param originChainId Chain id of network where message originates from.\n     * @return bytes32 EIP-712-compliant domain separator.\n     */\n    function _domainSeparatorV4(uint256 originChainId) internal view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, originChainId));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 structHash = keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * ));\n     * bytes32 digest = _hashTypedDataV4(structHash, originChainId);\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     * @param structHash Hashed struct as defined in https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n     * @param originChainId Chain id of network where message originates from.\n     * @return bytes32 Hash digest that is recoverable via `EDCSA.recover`.\n     */\n    function _hashTypedDataV4(bytes32 structHash, uint256 originChainId) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(originChainId), structHash);\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/upgradeable/MultiCallerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title MultiCallerUpgradeable\n * @notice Logic is 100% copied from \"@uma/core/contracts/common/implementation/MultiCaller.sol\" but one\n * comment is added to clarify why we allow delegatecall() in this contract, which is typically unsafe for use in\n * upgradeable implementation contracts.\n * @dev See https://docs.openzeppelin.com/upgrades-plugins/1.x/faq#delegatecall-selfdestruct for more details.\n * @custom:security-contact bugs@across.to\n */\ncontract MultiCallerUpgradeable {\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function _validateMulticallData(bytes[] calldata data) internal virtual {\n        // no-op\n    }\n\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        _validateMulticallData(data);\n\n        uint256 dataLength = data.length;\n        results = new bytes[](dataLength);\n\n        //slither-disable-start calls-loop\n        for (uint256 i = 0; i < dataLength; ++i) {\n            // Typically, implementation contracts used in the upgradeable proxy pattern shouldn't call `delegatecall`\n            // because it could allow a malicious actor to call this implementation contract directly (rather than\n            // through a proxy contract) and then selfdestruct() the contract, thereby freezing the upgradeable\n            // proxy. However, since we're only delegatecall-ing into this contract, then we can consider this\n            // use of delegatecall() safe.\n\n            //slither-disable-start low-level-calls\n            /// @custom:oz-upgrades-unsafe-allow delegatecall\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n            //slither-disable-end low-level-calls\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                //slither-disable-next-line assembly\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n        //slither-disable-end calls-loop\n    }\n\n    function tryMulticall(bytes[] calldata data) external returns (Result[] memory results) {\n        _validateMulticallData(data);\n\n        uint256 dataLength = data.length;\n        results = new Result[](dataLength);\n\n        //slither-disable-start calls-loop\n        for (uint256 i = 0; i < dataLength; ++i) {\n            // The delegatecall here is safe for the same reasons outlined in the first multicall function.\n            Result memory result = results[i];\n            //slither-disable-start low-level-calls\n            /// @custom:oz-upgrades-unsafe-allow delegatecall\n            (result.success, result.returnData) = address(this).delegatecall(data[i]);\n            //slither-disable-end low-level-calls\n        }\n        //slither-disable-end calls-loop\n    }\n\n    // Reserve storage slots for future versions of this base contract to add state variables without\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\n    // are added. This is at bottom of contract to make sure its always at the end of storage.\n    uint256[1000] private __gap;\n}\n"
    },
    "contracts/ZkSync_SpokePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport { CrossDomainAddressUtils } from \"./libraries/CrossDomainAddressUtils.sol\";\n\n// https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/zksync/contracts/bridge/L2ERC20Bridge.sol#L104\ninterface ZkBridgeLike {\n    function withdraw(\n        address _l1Receiver,\n        address _l2Token,\n        uint256 _amount\n    ) external;\n}\n\ninterface IL2ETH {\n    function withdraw(address _l1Receiver) external payable;\n}\n\n/**\n * @notice ZkSync specific SpokePool, intended to be compiled with `@matterlabs/hardhat-zksync-solc`.\n * @dev Resources for compiling and deploying contracts with hardhat: https://era.zksync.io/docs/tools/hardhat/hardhat-zksync-solc.html\n * @custom:security-contact bugs@across.to\n */\ncontract ZkSync_SpokePool is SpokePool {\n    // On Ethereum, avoiding constructor parameters and putting them into constants reduces some of the gas cost\n    // upon contract deployment. On zkSync the opposite is true: deploying the same bytecode for contracts,\n    // while changing only constructor parameters can lead to substantial fee savings. So, the following params\n    // are all set by passing in constructor params where possible.\n\n    // ETH on ZkSync implements a subset of the ERC-20 interface, with additional built-in support to bridge to L1.\n    address public l2Eth;\n\n    // Bridge used to withdraw ERC20's to L1\n    ZkBridgeLike public zkErc20Bridge;\n\n    event SetZkBridge(address indexed erc20Bridge, address indexed oldErc20Bridge);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _wrappedNativeTokenAddress,\n        uint32 _depositQuoteTimeBuffer,\n        uint32 _fillDeadlineBuffer\n    ) SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer) {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Construct the ZkSync SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _zkErc20Bridge Address of L2 ERC20 gateway. Can be reset by admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\n     * likely be the hub pool.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        ZkBridgeLike _zkErc20Bridge,\n        address _crossDomainAdmin,\n        address _withdrawalRecipient\n    ) public initializer {\n        l2Eth = 0x000000000000000000000000000000000000800A;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\n        _setZkBridge(_zkErc20Bridge);\n    }\n\n    modifier onlyFromCrossDomainAdmin() {\n        require(msg.sender == CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin), \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /********************************************************\n     *      ZKSYNC-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change L2 token bridge addresses. Callable only by admin.\n     * @param _zkErc20Bridge New address of L2 ERC20 gateway.\n     */\n    function setZkBridge(ZkBridgeLike _zkErc20Bridge) public onlyAdmin nonReentrant {\n        _setZkBridge(_zkErc20Bridge);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Wraps any ETH into WETH before executing base function. This is necessary because SpokePool receives\n     * ETH over the canonical token bridge instead of WETH.\n     */\n    function _preExecuteLeafHook(address l2TokenAddress) internal override {\n        if (l2TokenAddress == address(wrappedNativeToken)) _depositEthToWeth();\n    }\n\n    // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is necessary because\n    // this SpokePool will receive ETH from the canonical token bridge instead of WETH. This may not be neccessary\n    // if ETH on ZkSync is treated as ETH and the fallback() function is triggered when this contract receives\n    // ETH. We will have to test this but this function for now allows the contract to safely convert all of its\n    // held ETH into WETH at the cost of higher gas costs.\n    function _depositEthToWeth() internal {\n        //slither-disable-next-line arbitrary-send-eth\n        if (address(this).balance > 0) wrappedNativeToken.deposit{ value: address(this).balance }();\n    }\n\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\n        // SpokePool is expected to receive ETH from the L1 HubPool and currently, withdrawing ETH directly\n        // over the ERC20 Bridge is blocked at the contract level. Therefore, we need to unwrap it before withdrawing.\n        if (l2TokenAddress == address(wrappedNativeToken)) {\n            WETH9Interface(l2TokenAddress).withdraw(amountToReturn); // Unwrap into ETH.\n            // To withdraw tokens, we actually call 'withdraw' on the L2 eth token itself.\n            IL2ETH(l2Eth).withdraw{ value: amountToReturn }(withdrawalRecipient);\n        } else {\n            zkErc20Bridge.withdraw(withdrawalRecipient, l2TokenAddress, amountToReturn);\n        }\n    }\n\n    function _setZkBridge(ZkBridgeLike _zkErc20Bridge) internal {\n        address oldErc20Bridge = address(zkErc20Bridge);\n        zkErc20Bridge = _zkErc20Bridge;\n        emit SetZkBridge(address(_zkErc20Bridge), oldErc20Bridge);\n    }\n\n    function _requireAdminSender() internal override onlyFromCrossDomainAdmin {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "viaIR": true,
    "debug": {
      "revertStrings": "strip"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}