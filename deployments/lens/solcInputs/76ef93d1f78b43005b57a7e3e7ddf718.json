{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/V3SpokePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contains structs and functions used by SpokePool contracts to facilitate universal settlement.\ninterface V3SpokePoolInterface {\n    /**************************************\n     *              ENUMS                 *\n     **************************************/\n\n    // Fill status tracks on-chain state of deposit, uniquely identified by relayHash.\n    enum FillStatus {\n        Unfilled,\n        RequestedSlowFill,\n        Filled\n    }\n    // Fill type is emitted in the FilledRelay event to assist Dataworker with determining which types of\n    // fills to refund (e.g. only fast fills) and whether a fast fill created a sow fill excess.\n    enum FillType {\n        FastFill,\n        // Fast fills are normal fills that do not replace a slow fill request.\n        ReplacedSlowFill,\n        // Replaced slow fills are fast fills that replace a slow fill request. This type is used by the Dataworker\n        // to know when to send excess funds from the SpokePool to the HubPool because they can no longer be used\n        // for a slow fill execution.\n        SlowFill\n    }\n    // Slow fills are requested via requestSlowFill and executed by executeSlowRelayLeaf after a bundle containing\n    // the slow fill is validated.\n\n    /**************************************\n     *              STRUCTS               *\n     **************************************/\n\n    // This struct represents the data to fully specify a **unique** relay submitted on this chain.\n    // This data is hashed with the chainId() and saved by the SpokePool to prevent collisions and protect against\n    // replay attacks on other chains. If any portion of this data differs, the relay is considered to be\n    // completely distinct.\n    struct V3RelayData {\n        // The bytes32 that made the deposit on the origin chain.\n        bytes32 depositor;\n        // The recipient bytes32 on the destination chain.\n        bytes32 recipient;\n        // This is the exclusive relayer who can fill the deposit before the exclusivity deadline.\n        bytes32 exclusiveRelayer;\n        // Token that is deposited on origin chain by depositor.\n        bytes32 inputToken;\n        // Token that is received on destination chain by recipient.\n        bytes32 outputToken;\n        // The amount of input token deposited by depositor.\n        uint256 inputAmount;\n        // The amount of output token to be received by recipient.\n        uint256 outputAmount;\n        // Origin chain id.\n        uint256 originChainId;\n        // The id uniquely identifying this deposit on the origin chain.\n        uint256 depositId;\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\n        uint32 fillDeadline;\n        // The timestamp on the destination chain after which any relayer can fill the deposit.\n        uint32 exclusivityDeadline;\n        // Data that is forwarded to the recipient.\n        bytes message;\n    }\n\n    // Same as V3RelayData but using addresses instead of bytes32 & depositId is uint32.\n    // Will be deprecated in favor of V3RelayData in the future.\n    struct V3RelayDataLegacy {\n        address depositor;\n        address recipient;\n        address exclusiveRelayer;\n        address inputToken;\n        address outputToken;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        uint256 originChainId;\n        uint32 depositId;\n        uint32 fillDeadline;\n        uint32 exclusivityDeadline;\n        bytes message;\n    }\n\n    // Contains parameters passed in by someone who wants to execute a slow relay leaf.\n    struct V3SlowFill {\n        V3RelayData relayData;\n        uint256 chainId;\n        uint256 updatedOutputAmount;\n    }\n\n    // Contains information about a relay to be sent along with additional information that is not unique to the\n    // relay itself but is required to know how to process the relay. For example, \"updatedX\" fields can be used\n    // by the relayer to modify fields of the relay with the depositor's permission, and \"repaymentChainId\" is specified\n    // by the relayer to determine where to take a relayer refund, but doesn't affect the uniqueness of the relay.\n    struct V3RelayExecutionParams {\n        V3RelayData relay;\n        bytes32 relayHash;\n        uint256 updatedOutputAmount;\n        bytes32 updatedRecipient;\n        bytes updatedMessage;\n        uint256 repaymentChainId;\n    }\n\n    // Packs together parameters emitted in FilledRelay because there are too many emitted otherwise.\n    // Similar to V3RelayExecutionParams, these parameters are not used to uniquely identify the deposit being\n    // filled so they don't have to be unpacked by all clients.\n    struct V3RelayExecutionEventInfo {\n        bytes32 updatedRecipient;\n        bytes32 updatedMessageHash;\n        uint256 updatedOutputAmount;\n        FillType fillType;\n    }\n\n    // Represents the parameters required for a V3 deposit operation in the SpokePool.\n    struct DepositV3Params {\n        bytes32 depositor;\n        bytes32 recipient;\n        bytes32 inputToken;\n        bytes32 outputToken;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        uint256 destinationChainId;\n        bytes32 exclusiveRelayer;\n        uint256 depositId;\n        uint32 quoteTimestamp;\n        uint32 fillDeadline;\n        uint32 exclusivityParameter;\n        bytes message;\n    }\n\n    /**************************************\n     *              EVENTS                *\n     **************************************/\n\n    event FundsDeposited(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed destinationChainId,\n        uint256 indexed depositId,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 indexed depositor,\n        bytes32 recipient,\n        bytes32 exclusiveRelayer,\n        bytes message\n    );\n\n    event RequestedSpeedUpDeposit(\n        uint256 updatedOutputAmount,\n        uint256 indexed depositId,\n        bytes32 indexed depositor,\n        bytes32 updatedRecipient,\n        bytes updatedMessage,\n        bytes depositorSignature\n    );\n\n    event FilledRelay(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 repaymentChainId,\n        uint256 indexed originChainId,\n        uint256 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 exclusiveRelayer,\n        bytes32 indexed relayer,\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 messageHash,\n        V3RelayExecutionEventInfo relayExecutionInfo\n    );\n\n    event RequestedSlowFill(\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed originChainId,\n        uint256 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes32 exclusiveRelayer,\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 messageHash\n    );\n\n    event ClaimedRelayerRefund(\n        bytes32 indexed l2TokenAddress,\n        bytes32 indexed refundAddress,\n        uint256 amount,\n        address indexed caller\n    );\n\n    /**************************************\n     *              FUNCTIONS             *\n     **************************************/\n\n    function deposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositV3(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositNow(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function depositV3Now(\n        address depositor,\n        address recipient,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        address exclusiveRelayer,\n        uint32 fillDeadlineOffset,\n        uint32 exclusivityDeadline,\n        bytes calldata message\n    ) external payable;\n\n    function unsafeDeposit(\n        bytes32 depositor,\n        bytes32 recipient,\n        bytes32 inputToken,\n        bytes32 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint256 depositNonce,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityParameter,\n        bytes calldata message\n    ) external payable;\n\n    function speedUpDeposit(\n        bytes32 depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function speedUpV3Deposit(\n        address depositor,\n        uint256 depositId,\n        uint256 updatedOutputAmount,\n        address updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function fillRelay(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress\n    ) external;\n\n    function fillV3Relay(V3RelayDataLegacy calldata relayData, uint256 repaymentChainId) external;\n\n    function fillRelayWithUpdatedDeposit(\n        V3RelayData calldata relayData,\n        uint256 repaymentChainId,\n        bytes32 repaymentAddress,\n        uint256 updatedOutputAmount,\n        bytes32 updatedRecipient,\n        bytes calldata updatedMessage,\n        bytes calldata depositorSignature\n    ) external;\n\n    function requestSlowFill(V3RelayData calldata relayData) external;\n\n    function executeSlowRelayLeaf(\n        V3SlowFill calldata slowFillLeaf,\n        uint32 rootBundleId,\n        bytes32[] calldata proof\n    ) external;\n\n    function claimRelayerRefund(bytes32 l2TokenAddress, bytes32 refundAddress) external;\n\n    /**************************************\n     *              ERRORS                *\n     **************************************/\n\n    error DisabledRoute();\n    error InvalidQuoteTimestamp();\n    error InvalidFillDeadline();\n    error InvalidExclusiveRelayer();\n    error MsgValueDoesNotMatchInputAmount();\n    error NotExclusiveRelayer();\n    error NoSlowFillsInExclusivityWindow();\n    error RelayFilled();\n    error InvalidSlowFillRequest();\n    error ExpiredFillDeadline();\n    error InvalidMerkleProof();\n    error InvalidChainId();\n    error InvalidMerkleLeaf();\n    error ClaimedMerkleLeaf();\n    error InvalidPayoutAdjustmentPct();\n    error WrongERC7683OrderId();\n    error LowLevelCallFailed(bytes data);\n    error InsufficientSpokePoolBalanceToExecuteLeaf();\n    error NoRelayerRefundToClaim();\n\n    /**************************************\n     *             LEGACY EVENTS          *\n     **************************************/\n\n    // Note: these events are unused, but included in the ABI for ease of migration.\n    event V3FundsDeposited(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed destinationChainId,\n        uint32 indexed depositId,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address indexed depositor,\n        address recipient,\n        address exclusiveRelayer,\n        bytes message\n    );\n\n    event RequestedSpeedUpV3Deposit(\n        uint256 updatedOutputAmount,\n        uint32 indexed depositId,\n        address indexed depositor,\n        address updatedRecipient,\n        bytes updatedMessage,\n        bytes depositorSignature\n    );\n\n    // Legacy struct only used to preserve the FilledV3Relay event definition.\n    struct LegacyV3RelayExecutionEventInfo {\n        address updatedRecipient;\n        bytes updatedMessage;\n        uint256 updatedOutputAmount;\n        FillType fillType;\n    }\n\n    event FilledV3Relay(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 repaymentChainId,\n        uint256 indexed originChainId,\n        uint32 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address exclusiveRelayer,\n        address indexed relayer,\n        address depositor,\n        address recipient,\n        bytes message,\n        LegacyV3RelayExecutionEventInfo relayExecutionInfo\n    );\n\n    event RequestedV3SlowFill(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 indexed originChainId,\n        uint32 indexed depositId,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        address exclusiveRelayer,\n        address depositor,\n        address recipient,\n        bytes message\n    );\n}\n"
    },
    "contracts/libraries/AddressConverters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary Bytes32ToAddress {\n    /**************************************\n     *              ERRORS                *\n     **************************************/\n    error InvalidBytes32();\n\n    function toAddress(bytes32 _bytes32) internal pure returns (address) {\n        checkAddress(_bytes32);\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    function toAddressUnchecked(bytes32 _bytes32) internal pure returns (address) {\n        return address(uint160(uint256(_bytes32)));\n    }\n\n    function checkAddress(bytes32 _bytes32) internal pure {\n        if (uint256(_bytes32) >> 160 != 0) {\n            revert InvalidBytes32();\n        }\n    }\n}\n\nlibrary AddressToBytes32 {\n    function toBytes32(address _address) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n}\n"
    },
    "contracts/SpokePoolVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/V3SpokePoolInterface.sol\";\nimport { AddressToBytes32 } from \"./libraries/AddressConverters.sol\";\n\n/**\n * @notice SpokePoolVerifier is a contract that verifies that the SpokePool exists on this chain before sending ETH to it.\n * @dev This contract must be deployed via Create2 to the same address on all chains. That way, an errant transaction sent\n * to the wrong chain will be blocked by this contract rather than hitting a dead address. This means that this contract\n * will not work to protect chains, like zkSync, where Create2 address derivations don't match other chains.\n * Source: https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html#create-create2\n * @custom:security-contact bugs@across.to\n */\ncontract SpokePoolVerifier {\n    using Address for address;\n    using AddressToBytes32 for address;\n\n    error InvalidMsgValue();\n    error InvalidSpokePool();\n\n    /**\n     * @notice Passthrough function to `deposit()` on the SpokePool contract.\n     * @dev Protects the caller from losing their ETH (or other native token) by reverting if the SpokePool address\n     * they intended to call does not exist on this chain. Because this contract can be deployed at the same address\n     * everywhere callers should be protected even if the transaction is submitted to an unintended network.\n     * This contract should only be used for native token deposits, as this problem only exists for native tokens.\n     * @param spokePool Address of the SpokePool contract that the user is intending to call.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param inputToken Token to lock into this contract to initiate deposit.\n     * @param inputAmount Amount of tokens to deposit.\n     * @param outputAmount Amount of tokens to receive on destination chain.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\n     * @param exclusiveRelayer Address of the relayer who has exclusive rights to fill this deposit. Can be set to\n     * 0x0 if no exclusivity period is desired. If so, then must set exclusivityDeadline to 0.\n     * @param exclusivityDeadline Timestamp after which any relayer can fill this deposit. Must set\n     * to 0 if exclusiveRelayer is set to 0x0, and vice versa.\n     * @param fillDeadline Timestamp after which this deposit can no longer be filled.\n     */\n    function deposit(\n        V3SpokePoolInterface spokePool,\n        bytes32 recipient,\n        bytes32 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 destinationChainId,\n        bytes32 exclusiveRelayer,\n        uint32 quoteTimestamp,\n        uint32 fillDeadline,\n        uint32 exclusivityDeadline,\n        bytes memory message\n    ) external payable {\n        if (msg.value != inputAmount) revert InvalidMsgValue();\n        if (!address(spokePool).isContract()) revert InvalidSpokePool();\n        // Set msg.sender as the depositor so that msg.sender can speed up the deposit.\n        spokePool.deposit{ value: msg.value }(\n            msg.sender.toBytes32(),\n            recipient,\n            inputToken,\n            // @dev Setting outputToken to 0x0 to instruct fillers to use the equivalent token\n            // as the originToken on the destination chain.\n            bytes32(0),\n            inputAmount,\n            outputAmount,\n            destinationChainId,\n            exclusiveRelayer,\n            quoteTimestamp,\n            fillDeadline,\n            exclusivityDeadline,\n            message\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "mode": "3"
    },
    "viaIR": true,
    "debug": {
      "revertStrings": "strip"
    },
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.methodIdentifiers", "metadata", "devdoc", "userdoc", "storageLayout"],
        "": ["ast"]
      }
    }
  }
}
