{
  "address": "0x5BE9F2a2f00475406f09e5bE82c06eFf206721d9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_wrappedNativeTokenAddress",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_depositQuoteTimeBuffer",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "_fillDeadlineBuffer",
          "type": "uint32"
        },
        {
          "internalType": "contract IERC20",
          "name": "_l2Usdc",
          "type": "address"
        },
        {
          "internalType": "contract ITokenMessenger",
          "name": "_cctpTokenMessenger",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ClaimedMerkleLeaf",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DepositsArePaused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DisabledRoute",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ExpiredFillDeadline",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FillsArePaused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientSpokePoolBalanceToExecuteLeaf",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBytes32",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidChainId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidCrossDomainAdmin",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidDepositorSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidExclusiveRelayer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFillDeadline",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidMerkleLeaf",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidMerkleProof",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPayoutAdjustmentPct",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidQuoteTimestamp",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidRelayerFeePct",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSlowFillRequest",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidWithdrawalRecipient",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "LowLevelCallFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MaxTransferSizeExceeded",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MsgValueDoesNotMatchInputAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoRelayerRefundToClaim",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoSlowFillsInExclusivityWindow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotEOA",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotExclusiveRelayer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RelayFilled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WrongERC7683OrderId",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previousAdmin",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "AdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "beacon",
          "type": "address"
        }
      ],
      "name": "BeaconUpgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "l2TokenAddress",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "refundAddress",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "ClaimedRelayerRefund",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "rootBundleId",
          "type": "uint256"
        }
      ],
      "name": "EmergencyDeletedRootBundle",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "originToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "enabled",
          "type": "bool"
        }
      ],
      "name": "EnabledDepositRoute",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountToReturn",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "refundAmounts",
          "type": "uint256[]"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "rootBundleId",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "leafId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "l2TokenAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "refundAddresses",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "deferredRefunds",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "ExecutedRelayerRefundRoot",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "inputToken",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "outputToken",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "repaymentChainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "depositId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "exclusivityDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "exclusiveRelayer",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "relayer",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "recipient",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "messageHash",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "updatedRecipient",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "updatedMessageHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "updatedOutputAmount",
              "type": "uint256"
            },
            {
              "internalType": "enum V3SpokePoolInterface.FillType",
              "name": "fillType",
              "type": "uint8"
            }
          ],
          "indexed": false,
          "internalType": "struct V3SpokePoolInterface.V3RelayExecutionEventInfo",
          "name": "relayExecutionInfo",
          "type": "tuple"
        }
      ],
      "name": "FilledRelay",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "inputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "outputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "repaymentChainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "exclusivityDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "exclusiveRelayer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "relayer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "updatedRecipient",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "updatedMessage",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "updatedOutputAmount",
              "type": "uint256"
            },
            {
              "internalType": "enum V3SpokePoolInterface.FillType",
              "name": "fillType",
              "type": "uint8"
            }
          ],
          "indexed": false,
          "internalType": "struct V3SpokePoolInterface.LegacyV3RelayExecutionEventInfo",
          "name": "relayExecutionInfo",
          "type": "tuple"
        }
      ],
      "name": "FilledV3Relay",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "inputToken",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "outputToken",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "depositId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "exclusivityDeadline",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "recipient",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "exclusiveRelayer",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "FundsDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isPaused",
          "type": "bool"
        }
      ],
      "name": "PausedDeposits",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isPaused",
          "type": "bool"
        }
      ],
      "name": "PausedFills",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "rootBundleId",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "relayerRefundRoot",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "slowRelayRoot",
          "type": "bytes32"
        }
      ],
      "name": "RelayedRootBundle",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "inputToken",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "outputToken",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "depositId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "exclusivityDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "exclusiveRelayer",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "recipient",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "messageHash",
          "type": "bytes32"
        }
      ],
      "name": "RequestedSlowFill",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "updatedOutputAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "depositId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "updatedRecipient",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "updatedMessage",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "depositorSignature",
          "type": "bytes"
        }
      ],
      "name": "RequestedSpeedUpDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "updatedOutputAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "updatedRecipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "updatedMessage",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "depositorSignature",
          "type": "bytes"
        }
      ],
      "name": "RequestedSpeedUpV3Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "inputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "outputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "exclusivityDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "exclusiveRelayer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "RequestedV3SlowFill",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newL2GatewayRouter",
          "type": "address"
        }
      ],
      "name": "SetL2GatewayRouter",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newWithdrawalRecipient",
          "type": "address"
        }
      ],
      "name": "SetWithdrawalRecipient",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "SetXDomainAdmin",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountToReturn",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "leafId",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "l2TokenAddress",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "TokensBridged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "inputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "outputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "exclusivityDeadline",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "exclusiveRelayer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "V3FundsDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "l2Token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "l1Token",
          "type": "address"
        }
      ],
      "name": "WhitelistedTokens",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "EMPTY_RELAYER",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "EMPTY_REPAYMENT_CHAIN_ID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "INFINITE_FILL_DEADLINE",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_EXCLUSIVITY_PERIOD_SECONDS",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_TRANSFER_SIZE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "UPDATE_ADDRESS_DEPOSIT_DETAILS_HASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "UPDATE_BYTES32_DEPOSIT_DETAILS_HASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_initialDepositId",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "_crossDomainAdmin",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_withdrawalRecipient",
          "type": "address"
        }
      ],
      "name": "__SpokePool_init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cctpTokenMessenger",
      "outputs": [
        {
          "internalType": "contract ITokenMessenger",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "chainId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "l2TokenAddress",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "refundAddress",
          "type": "bytes32"
        }
      ],
      "name": "claimRelayerRefund",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "crossDomainAdmin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "recipient",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "inputToken",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "outputToken",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "exclusiveRelayer",
          "type": "bytes32"
        },
        {
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "exclusivityParameter",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "originToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "int64",
          "name": "relayerFeePct",
          "type": "int64"
        },
        {
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "depositDeprecated_5947912356",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "originToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "int64",
          "name": "relayerFeePct",
          "type": "int64"
        },
        {
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "depositFor",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "recipient",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "inputToken",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "outputToken",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "exclusiveRelayer",
          "type": "bytes32"
        },
        {
          "internalType": "uint32",
          "name": "fillDeadlineOffset",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "exclusivityParameter",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "depositNow",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "depositQuoteTimeBuffer",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inputToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "outputToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "exclusiveRelayer",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "exclusivityParameter",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "depositV3",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inputToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "outputToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "exclusiveRelayer",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "fillDeadlineOffset",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "exclusivityParameter",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "depositV3Now",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "rootBundleId",
          "type": "uint256"
        }
      ],
      "name": "emergencyDeleteRootBundle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "enabledDepositRoutes",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "rootBundleId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "amountToReturn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "refundAmounts",
              "type": "uint256[]"
            },
            {
              "internalType": "uint32",
              "name": "leafId",
              "type": "uint32"
            },
            {
              "internalType": "address",
              "name": "l2TokenAddress",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "refundAddresses",
              "type": "address[]"
            }
          ],
          "internalType": "struct SpokePoolInterface.RelayerRefundLeaf",
          "name": "relayerRefundLeaf",
          "type": "tuple"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "executeRelayerRefundLeaf",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "bytes32",
                  "name": "depositor",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "recipient",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "exclusiveRelayer",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "inputToken",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "outputToken",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "inputAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outputAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "originChainId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "depositId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint32",
                  "name": "fillDeadline",
                  "type": "uint32"
                },
                {
                  "internalType": "uint32",
                  "name": "exclusivityDeadline",
                  "type": "uint32"
                },
                {
                  "internalType": "bytes",
                  "name": "message",
                  "type": "bytes"
                }
              ],
              "internalType": "struct V3SpokePoolInterface.V3RelayData",
              "name": "relayData",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "updatedOutputAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct V3SpokePoolInterface.V3SlowFill",
          "name": "slowFillLeaf",
          "type": "tuple"
        },
        {
          "internalType": "uint32",
          "name": "rootBundleId",
          "type": "uint32"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "executeSlowRelayLeaf",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "originData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "fillerData",
          "type": "bytes"
        }
      ],
      "name": "fill",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fillDeadlineBuffer",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "depositor",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "recipient",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "exclusiveRelayer",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "inputToken",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "outputToken",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "inputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "originChainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "depositId",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityDeadline",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct V3SpokePoolInterface.V3RelayData",
          "name": "relayData",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "repaymentChainId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "repaymentAddress",
          "type": "bytes32"
        }
      ],
      "name": "fillRelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "depositor",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "recipient",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "exclusiveRelayer",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "inputToken",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "outputToken",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "inputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "originChainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "depositId",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityDeadline",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct V3SpokePoolInterface.V3RelayData",
          "name": "relayData",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "repaymentChainId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "repaymentAddress",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "updatedOutputAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "updatedRecipient",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "updatedMessage",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "depositorSignature",
          "type": "bytes"
        }
      ],
      "name": "fillRelayWithUpdatedDeposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "fillStatuses",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "exclusiveRelayer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "inputToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "outputToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "inputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "originChainId",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "depositId",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityDeadline",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct V3SpokePoolInterface.V3RelayDataLegacy",
          "name": "relayData",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "repaymentChainId",
          "type": "uint256"
        }
      ],
      "name": "fillV3Relay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "l2TokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "refundAddress",
          "type": "address"
        }
      ],
      "name": "getRelayerRefund",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "msgSender",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "depositNonce",
          "type": "uint256"
        }
      ],
      "name": "getUnsafeDepositId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "depositor",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "recipient",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "exclusiveRelayer",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "inputToken",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "outputToken",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "inputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "originChainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "depositId",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityDeadline",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct V3SpokePoolInterface.V3RelayData",
          "name": "relayData",
          "type": "tuple"
        }
      ],
      "name": "getV3RelayHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_initialDepositId",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "_l2GatewayRouter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_crossDomainAdmin",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_withdrawalRecipient",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "l2GatewayRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "numberOfDeposits",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "pause",
          "type": "bool"
        }
      ],
      "name": "pauseDeposits",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "pause",
          "type": "bool"
        }
      ],
      "name": "pauseFills",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pausedDeposits",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pausedFills",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxiableUUID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "recipientCircleDomainId",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "relayerRefundRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "slowRelayRoot",
          "type": "bytes32"
        }
      ],
      "name": "relayRootBundle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "relayerRefund",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "depositor",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "recipient",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "exclusiveRelayer",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "inputToken",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "outputToken",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "inputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "originChainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "depositId",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityDeadline",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct V3SpokePoolInterface.V3RelayData",
          "name": "relayData",
          "type": "tuple"
        }
      ],
      "name": "requestSlowFill",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "rootBundles",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "slowRelayRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "relayerRefundRoot",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newCrossDomainAdmin",
          "type": "address"
        }
      ],
      "name": "setCrossDomainAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "originToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "enabled",
          "type": "bool"
        }
      ],
      "name": "setEnableRoute",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newL2GatewayRouter",
          "type": "address"
        }
      ],
      "name": "setL2GatewayRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newWithdrawalRecipient",
          "type": "address"
        }
      ],
      "name": "setWithdrawalRecipient",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "depositId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "updatedOutputAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "updatedRecipient",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "updatedMessage",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "depositorSignature",
          "type": "bytes"
        }
      ],
      "name": "speedUpDeposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "depositId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "updatedOutputAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "updatedRecipient",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "updatedMessage",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "depositorSignature",
          "type": "bytes"
        }
      ],
      "name": "speedUpV3Deposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "tryMulticall",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            },
            {
              "internalType": "bytes",
              "name": "returnData",
              "type": "bytes"
            }
          ],
          "internalType": "struct MultiCallerUpgradeable.Result[]",
          "name": "results",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "depositor",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "recipient",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "inputToken",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "outputToken",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "exclusiveRelayer",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "depositNonce",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "exclusivityParameter",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "unsafeDeposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "usdcToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "l2Token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "l1Token",
          "type": "address"
        }
      ],
      "name": "whitelistToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "whitelistedTokens",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawalRecipient",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wrappedNativeToken",
      "outputs": [
        {
          "internalType": "contract WETH9Interface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "numDeployments": 4,
  "solcInputHash": "79f521c5c02b08116b0da91c514961c5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrappedNativeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_depositQuoteTimeBuffer\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_fillDeadlineBuffer\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC20\",\"name\":\"_l2Usdc\",\"type\":\"address\"},{\"internalType\":\"contract ITokenMessenger\",\"name\":\"_cctpTokenMessenger\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ClaimedMerkleLeaf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositsArePaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DisabledRoute\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpiredFillDeadline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FillsArePaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientSpokePoolBalanceToExecuteLeaf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBytes32\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCrossDomainAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDepositorSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidExclusiveRelayer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFillDeadline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMerkleLeaf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMerkleProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPayoutAdjustmentPct\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQuoteTimestamp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRelayerFeePct\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSlowFillRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWithdrawalRecipient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LowLevelCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxTransferSizeExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MsgValueDoesNotMatchInputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRelayerRefundToClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSlowFillsInExclusivityWindow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEOA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotExclusiveRelayer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongERC7683OrderId\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"l2TokenAddress\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ClaimedRelayerRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rootBundleId\",\"type\":\"uint256\"}],\"name\":\"EmergencyDeletedRootBundle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"EnabledDepositRoute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToReturn\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"refundAmounts\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"rootBundleId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"leafId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"l2TokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"refundAddresses\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"deferredRefunds\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ExecutedRelayerRefundRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repaymentChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"relayer\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"updatedRecipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"updatedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"updatedOutputAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum V3SpokePoolInterface.FillType\",\"name\":\"fillType\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct V3SpokePoolInterface.V3RelayExecutionEventInfo\",\"name\":\"relayExecutionInfo\",\"type\":\"tuple\"}],\"name\":\"FilledRelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repaymentChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"updatedRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"updatedMessage\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"updatedOutputAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum V3SpokePoolInterface.FillType\",\"name\":\"fillType\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct V3SpokePoolInterface.LegacyV3RelayExecutionEventInfo\",\"name\":\"relayExecutionInfo\",\"type\":\"tuple\"}],\"name\":\"FilledV3Relay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"FundsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PausedDeposits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PausedFills\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"rootBundleId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"relayerRefundRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"slowRelayRoot\",\"type\":\"bytes32\"}],\"name\":\"RelayedRootBundle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"name\":\"RequestedSlowFill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedOutputAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"updatedRecipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"updatedMessage\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"depositorSignature\",\"type\":\"bytes\"}],\"name\":\"RequestedSpeedUpDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedOutputAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"updatedRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"updatedMessage\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"depositorSignature\",\"type\":\"bytes\"}],\"name\":\"RequestedSpeedUpV3Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"RequestedV3SlowFill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newL2GatewayRouter\",\"type\":\"address\"}],\"name\":\"SetL2GatewayRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWithdrawalRecipient\",\"type\":\"address\"}],\"name\":\"SetWithdrawalRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"SetXDomainAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToReturn\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"leafId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"l2TokenAddress\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"TokensBridged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"V3FundsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"}],\"name\":\"WhitelistedTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EMPTY_RELAYER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMPTY_REPAYMENT_CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INFINITE_FILL_DEADLINE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EXCLUSIVITY_PERIOD_SECONDS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TRANSFER_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPDATE_ADDRESS_DEPOSIT_DETAILS_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_initialDepositId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_crossDomainAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_withdrawalRecipient\",\"type\":\"address\"}],\"name\":\"__SpokePool_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cctpTokenMessenger\",\"outputs\":[{\"internalType\":\"contract ITokenMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"l2TokenAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"}],\"name\":\"claimRelayerRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crossDomainAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"int64\",\"name\":\"relayerFeePct\",\"type\":\"int64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositDeprecated_5947912356\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"int64\",\"name\":\"relayerFeePct\",\"type\":\"int64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadlineOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"depositNow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositQuoteTimeBuffer\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"depositV3\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadlineOffset\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"depositV3Now\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rootBundleId\",\"type\":\"uint256\"}],\"name\":\"emergencyDeleteRootBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"enabledDepositRoutes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"rootBundleId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountToReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"refundAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32\",\"name\":\"leafId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"l2TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"refundAddresses\",\"type\":\"address[]\"}],\"internalType\":\"struct SpokePoolInterface.RelayerRefundLeaf\",\"name\":\"relayerRefundLeaf\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"executeRelayerRefundLeaf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct V3SpokePoolInterface.V3RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedOutputAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct V3SpokePoolInterface.V3SlowFill\",\"name\":\"slowFillLeaf\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"rootBundleId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"executeSlowRelayLeaf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"originData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"fillerData\",\"type\":\"bytes\"}],\"name\":\"fill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fillDeadlineBuffer\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct V3SpokePoolInterface.V3RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"repaymentChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"repaymentAddress\",\"type\":\"bytes32\"}],\"name\":\"fillRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct V3SpokePoolInterface.V3RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"repaymentChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"repaymentAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"updatedOutputAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"updatedRecipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"updatedMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"depositorSignature\",\"type\":\"bytes\"}],\"name\":\"fillRelayWithUpdatedDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fillStatuses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct V3SpokePoolInterface.V3RelayDataLegacy\",\"name\":\"relayData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"repaymentChainId\",\"type\":\"uint256\"}],\"name\":\"fillV3Relay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l2TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"getRelayerRefund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"depositNonce\",\"type\":\"uint256\"}],\"name\":\"getUnsafeDepositId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct V3SpokePoolInterface.V3RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"}],\"name\":\"getV3RelayHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_initialDepositId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_l2GatewayRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_crossDomainAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_withdrawalRecipient\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2GatewayRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfDeposits\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"pause\",\"type\":\"bool\"}],\"name\":\"pauseDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"pause\",\"type\":\"bool\"}],\"name\":\"pauseFills\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedDeposits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedFills\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipientCircleDomainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"relayerRefundRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slowRelayRoot\",\"type\":\"bytes32\"}],\"name\":\"relayRootBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayerRefund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityDeadline\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct V3SpokePoolInterface.V3RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"}],\"name\":\"requestSlowFill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rootBundles\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"slowRelayRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"relayerRefundRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCrossDomainAdmin\",\"type\":\"address\"}],\"name\":\"setCrossDomainAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setEnableRoute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newL2GatewayRouter\",\"type\":\"address\"}],\"name\":\"setL2GatewayRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWithdrawalRecipient\",\"type\":\"address\"}],\"name\":\"setWithdrawalRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedOutputAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"updatedRecipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"updatedMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"depositorSignature\",\"type\":\"bytes\"}],\"name\":\"speedUpDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedOutputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"updatedRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"updatedMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"depositorSignature\",\"type\":\"bytes\"}],\"name\":\"speedUpV3Deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"tryMulticall\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCallerUpgradeable.Result[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"depositor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"inputToken\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"outputToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"exclusiveRelayer\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"depositNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"unsafeDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"}],\"name\":\"whitelistToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedNativeToken\",\"outputs\":[{\"internalType\":\"contract WETH9Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"custom:security-contact\":\"bugs@across.to\",\"events\":{\"AdminChanged(address,address)\":{\"details\":\"Emitted when the admin account has changed.\"},\"BeaconUpgraded(address)\":{\"details\":\"Emitted when the beacon is changed.\"},\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"Upgraded(address)\":{\"details\":\"Emitted when the implementation is upgraded.\"}},\"kind\":\"dev\",\"methods\":{\"__SpokePool_init(uint32,address,address)\":{\"params\":{\"_crossDomainAdmin\":\"Cross domain admin to set. Can be changed by admin.\",\"_initialDepositId\":\"Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate relay hash collisions.\",\"_withdrawalRecipient\":\"Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will likely be the hub pool.\"}},\"chainId()\":{\"details\":\"Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\"},\"claimRelayerRefund(bytes32,bytes32)\":{\"params\":{\"l2TokenAddress\":\"Address of the L2 token to claim refunds for.\",\"refundAddress\":\"Address to send the refund to.\"}},\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\"},\"deposit(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint32,uint32,uint32,bytes)\":{\"details\":\"On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so modifying any params in it will result in a different hash and a different deposit. The hash will comprise all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by this contract.\",\"params\":{\"depositor\":\"The account credited with the deposit who can request to \\\"speed up\\\" this deposit by modifying the output amount, recipient, and message.\",\"destinationChainId\":\"The destination chain identifier. Must be enabled along with the input token as a valid deposit route from this spoke pool or this transaction will revert.\",\"exclusiveRelayer\":\"The relayer that will be exclusively allowed to fill this deposit before the exclusivity deadline timestamp. This must be a valid, non-zero address if the exclusivity deadline is greater than the current block.timestamp. If the exclusivity deadline is < currentTime, then this must be address(0), and vice versa if this is address(0).\",\"exclusivityParameter\":\"This value is used to set the exclusivity deadline timestamp in the emitted deposit event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address), can fill this deposit. There are three ways to use this parameter:     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,        meaning that there is no exclusivity period.     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed        due to a chain-reorg, which would also change the exclusivity timestamp.     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp. which is the deadline for the exclusiveRelayer to fill the deposit.\",\"fillDeadline\":\"The deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where currentTime is block.timestamp on this chain or this transaction will revert.\",\"inputAmount\":\"The amount of input tokens to pull from the caller's account and lock into this contract. This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic challenge window in the HubPool, less a system fee.\",\"inputToken\":\"The token pulled from the caller's account and locked into this contract to initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as msg.value, as long as msg.value = inputTokenAmount.\",\"message\":\"The message to send to the recipient on the destination chain if the recipient is a contract. If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\",\"outputAmount\":\"The amount of output tokens that the relayer will send to the recipient on the destination.\",\"outputToken\":\"The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.\",\"quoteTimestamp\":\"The HubPool timestamp that is used to determine the system fee paid by the depositor.  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime] where currentTime is block.timestamp on this chain or this transaction will revert.\",\"recipient\":\"The account receiving funds on the destination chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive native token if an EOA or wrapped native token if a contract.\"}},\"depositDeprecated_5947912356(address,address,uint256,uint256,int64,uint32,bytes,uint256)\":{\"details\":\"DEPRECATION NOTICE: this function is deprecated and will be removed in the future.      Please use deposit (under DEPOSITOR FUNCTIONS below) or depositV3 instead.Produces a FundsDeposited event with an infinite expiry, meaning that this deposit can never expire. Moreover, the event's outputToken is set to 0x0 meaning that this deposit can always be slow filled.\",\"params\":{\"amount\":\"Amount of tokens to deposit. Will be amount of tokens to receive less fees.\",\"destinationChainId\":\"Denotes network where user will receive funds from SpokePool by a relayer.\",\"message\":\"Arbitrary data that can be used to pass additional information to the recipient along with the tokens. Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\",\"originToken\":\"Token to lock into this contract to initiate deposit.\",\"quoteTimestamp\":\"Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.\",\"recipient\":\"Address to receive funds at on destination chain.\",\"relayerFeePct\":\"% of deposit amount taken out to incentivize a fast relayer.\"}},\"depositFor(address,address,address,uint256,uint256,int64,uint32,bytes,uint256)\":{\"details\":\"DEPRECATION NOTICE: this function is deprecated and will be removed in the future.      Please use the other deposit or depositV3 instead.\",\"params\":{\"amount\":\"Amount of tokens to deposit. Will be amount of tokens to receive less fees.\",\"depositor\":\"Address who is credited for depositing funds on origin chain and can speed up the deposit.\",\"destinationChainId\":\"Denotes network where user will receive funds from SpokePool by a relayer.\",\"message\":\"Arbitrary data that can be used to pass additional information to the recipient along with the tokens. Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\",\"originToken\":\"Token to lock into this contract to initiate deposit.\",\"quoteTimestamp\":\"Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.\",\"recipient\":\"Address to receive funds at on destination chain.\",\"relayerFeePct\":\"% of deposit amount taken out to incentivize a fast relayer.\"}},\"depositNow(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint32,uint32,bytes)\":{\"params\":{\"depositor\":\"The account credited with the deposit who can request to \\\"speed up\\\" this deposit by modifying the output amount, recipient, and message.\",\"destinationChainId\":\"The destination chain identifier. Must be enabled along with the input token as a valid deposit route from this spoke pool or this transaction will revert.\",\"exclusiveRelayer\":\"The relayer that will be exclusively allowed to fill this deposit before the exclusivity deadline timestamp.\",\"exclusivityParameter\":\"See identically named parameter in deposit() comments.\",\"fillDeadlineOffset\":\"Added to the current time to set the fill deadline, which is the deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the destination chain.\",\"inputAmount\":\"The amount of input tokens to pull from the caller's account and lock into this contract. This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic challenge window in the HubPool, plus a system fee.\",\"inputToken\":\"The token pulled from the caller's account and locked into this contract to initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as msg.value, as long as msg.value = inputTokenAmount.\",\"message\":\"The message to send to the recipient on the destination chain if the recipient is a contract. If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\",\"outputAmount\":\"The amount of output tokens that the relayer will send to the recipient on the destination.\",\"outputToken\":\"The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.\",\"recipient\":\"The account receiving funds on the destination chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive native token if an EOA or wrapped native token if a contract.\"}},\"depositV3(address,address,address,address,uint256,uint256,uint256,address,uint32,uint32,uint32,bytes)\":{\"details\":\"This version mirrors the original `depositV3` function, but uses `address` types for `depositor`, `recipient`, `inputToken`, `outputToken`, and `exclusiveRelayer` for compatibility with contracts using the `address` type. The key functionality and logic remain identical, ensuring interoperability across both versions.\",\"params\":{\"depositor\":\"The account credited with the deposit who can request to \\\"speed up\\\" this deposit by modifying the output amount, recipient, and message.\",\"destinationChainId\":\"The destination chain identifier. Must be enabled along with the input token as a valid deposit route from this spoke pool or this transaction will revert.\",\"exclusiveRelayer\":\"The relayer exclusively allowed to fill this deposit before the exclusivity deadline.\",\"exclusivityParameter\":\"This value is used to set the exclusivity deadline timestamp in the emitted deposit event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address), can fill this deposit. There are three ways to use this parameter:     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,        meaning that there is no exclusivity period.     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed        due to a chain-reorg, which would also change the exclusivity timestamp.     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp. which is the deadline for the exclusiveRelayer to fill the deposit.\",\"fillDeadline\":\"The deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where currentTime is block.timestamp on this chain.\",\"inputAmount\":\"The amount of input tokens pulled from the caller's account and locked into this contract. This amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, less a system fee.\",\"inputToken\":\"The token pulled from the caller's account and locked into this contract to initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal to the wrapped native token, the caller can optionally pass in native token as msg.value, provided msg.value = inputTokenAmount.\",\"message\":\"The message to send to the recipient on the destination chain if the recipient is a contract. If the message is not empty, the recipient contract must implement `handleV3AcrossMessage()` or the fill will revert.\",\"outputAmount\":\"The amount of output tokens that the relayer will send to the recipient on the destination.\",\"outputToken\":\"The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.\",\"quoteTimestamp\":\"The HubPool timestamp that determines the system fee paid by the depositor. This must be set between [currentTime - depositQuoteTimeBuffer, currentTime] where currentTime is block.timestamp on this chain.\",\"recipient\":\"The account receiving funds on the destination chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive native token if an EOA or wrapped native token if a contract.\"}},\"depositV3Now(address,address,address,address,uint256,uint256,uint256,address,uint32,uint32,bytes)\":{\"details\":\"This version is identical to the original `depositV3Now` but uses `address` types for `depositor`, `recipient`, `inputToken`, `outputToken`, and `exclusiveRelayer` to support compatibility with older systems. It maintains the same logic and purpose, ensuring interoperability with both versions.\",\"params\":{\"depositor\":\"The account credited with the deposit, who can request to \\\"speed up\\\" this deposit by modifying the output amount, recipient, and message.\",\"destinationChainId\":\"The destination chain identifier. Must be enabled with the input token as a valid deposit route from this spoke pool, or the transaction will revert.\",\"exclusiveRelayer\":\"The relayer exclusively allowed to fill the deposit before the exclusivity deadline.\",\"exclusivityParameter\":\"See identically named parameter in deposit() comments.\",\"fillDeadlineOffset\":\"Added to the current time to set the fill deadline. After this timestamp, fills on the destination chain will revert.\",\"inputAmount\":\"The amount of input tokens pulled from the caller's account and locked into this contract. This amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, plus a system fee.\",\"inputToken\":\"The token pulled from the caller's account and locked into this contract to initiate the deposit. Equivalent tokens on the relayer's repayment chain will be sent as a refund. If this is the wrapped native token, msg.value must equal inputTokenAmount when passed.\",\"message\":\"The message to send to the recipient on the destination chain. If the recipient is a contract, it must implement `handleV3AcrossMessage()` if the message is not empty, or the fill will revert.\",\"outputAmount\":\"The amount of output tokens the relayer will send to the recipient on the destination.\",\"outputToken\":\"The token the relayer will send to the recipient on the destination chain. Must be an ERC20.\",\"recipient\":\"The account receiving funds on the destination chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive the native token if an EOA or wrapped native token if a contract.\"}},\"emergencyDeleteRootBundle(uint256)\":{\"params\":{\"rootBundleId\":\"Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256 to ensure that a small input range doesn't limit which indices this method is able to reach.\"}},\"executeRelayerRefundLeaf(uint32,(uint256,uint256,uint256[],uint32,address,address[]),bytes32[])\":{\"params\":{\"proof\":\"Inclusion proof for this leaf in relayer refund root in root bundle.\",\"relayerRefundLeaf\":\"Contains all data necessary to reconstruct leaf contained in root bundle and to refund relayer. This data structure is explained in detail in the SpokePoolInterface.\",\"rootBundleId\":\"Unique ID of root bundle containing relayer refund root that this leaf is contained in.\"}},\"executeSlowRelayLeaf(((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,uint256),uint32,bytes32[])\":{\"details\":\"Executing a slow fill leaf is equivalent to filling the relayData so this function cannot be used to double fill a recipient. The relayData that is filled is included in the slowFillLeaf and is hashed like any other fill sent through a fill method.There is no relayer credited with filling this relay since funds are sent directly out of this contract.\",\"params\":{\"proof\":\"Inclusion proof for this leaf in slow relay root in root bundle.\",\"rootBundleId\":\"Unique ID of root bundle containing slow relay root that this leaf is contained in.\",\"slowFillLeaf\":\"Contains all data necessary to uniquely identify a relay for this chain. This struct is hashed and included in a merkle root that is relayed to all spoke pools. - relayData: struct containing all the data needed to identify the original deposit to be slow filled. - chainId: chain identifier where slow fill leaf should be executed. If this doesn't match this chain's chainId, then this function will revert. - updatedOutputAmount: Amount to be sent to recipient out of this contract's balance. Can be set differently from relayData.outputAmount to charge a different fee because this deposit was \\\"slow\\\" filled. Usually, this will be set higher to reimburse the recipient for waiting for the slow fill.\"}},\"fill(bytes32,bytes,bytes)\":{\"details\":\"ERC-7683 fill function.\",\"params\":{\"fillerData\":\"Data provided by the filler to inform the fill or express their preferences\",\"orderId\":\"Unique order identifier for this order\",\"originData\":\"Data emitted on the origin to parameterize the fill\"}},\"fillRelay((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,bytes32)\":{\"details\":\"The fee paid to relayers and the system should be captured in the spread between output amount and input amount when adjusted to be denominated in the input token. A relayer on the destination chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment chain of their choice. Therefore, the fee should account for destination fee transaction costs, the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge window in the HubPool, and a system fee charged to relayers.The hash of the relayData will be used to uniquely identify the deposit to fill, so modifying any params in it will result in a different hash and a different deposit. The hash will comprise all parameters passed to deposit() on the origin chain along with that chain's chainId(). This chain's chainId() must therefore match the destinationChainId passed into deposit. Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the origin SpokePool therefore the relayer should not modify any params in relayData.Cannot fill more than once. Partial fills are not supported.\",\"params\":{\"relayData\":\"struct containing all the data needed to identify the deposit to be filled. Should match all the same-named parameters emitted in the origin chain FundsDeposited event. - depositor: The account credited with the deposit who can request to \\\"speed up\\\" this deposit by modifying the output amount, recipient, and message. - recipient The account receiving funds on this chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive native token if an EOA or wrapped native token if a contract. - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this token on the repayment chain will be sent as a refund to the caller. - outputToken The token that the caller will send to the recipient on the destination chain. Must be an ERC20. - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund following an optimistic challenge window in the HubPool. - outputAmount: The amount of output tokens that the caller will send to the recipient. - originChainId: The origin chain identifier. - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the exclusivity deadline timestamp. - fillDeadline The deadline for the caller to fill the deposit. After this timestamp, the fill will revert on the destination chain. - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this timestamp, anyone can fill this deposit. Note that if this value was set in deposit by adding an offset to the deposit's block.timestamp, there is re-org risk for the caller of this method because the event's block.timestamp can change. Read the comments in `deposit` about the `exclusivityParameter` for more details. - message The message to send to the recipient if the recipient is a contract that implements a handleV3AcrossMessage() public function\",\"repaymentAddress\":\"Address the relayer wants to be receive their refund at.\",\"repaymentChainId\":\"Chain of SpokePool where relayer wants to be refunded after the challenge window has passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain.\"}},\"fillRelayWithUpdatedDeposit((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,bytes32,uint256,bytes32,bytes,bytes)\":{\"details\":\"Subject to same exclusivity deadline rules as fillV3Relay().\",\"params\":{\"depositorSignature\":\"Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account.\",\"relayData\":\"struct containing all the data needed to identify the deposit to be filled. See fillV3Relay().\",\"repaymentAddress\":\"Address the relayer wants to be receive their refund at.\",\"repaymentChainId\":\"Chain of SpokePool where relayer wants to be refunded after the challenge window has passed. See fillV3Relay().\",\"updatedMessage\":\"New message to use for this deposit.\",\"updatedOutputAmount\":\"New output amount to use for this deposit.\",\"updatedRecipient\":\"New recipient to use for this deposit.\"}},\"getCurrentTime()\":{\"returns\":{\"_0\":\"uint for the current timestamp.\"}},\"getUnsafeDepositId(address,bytes32,uint256)\":{\"details\":\"msgSender and depositor are both used as inputs to allow passthrough depositors to create unique deposit hash spaces for unique depositors.\",\"params\":{\"depositNonce\":\"The nonce used as input to produce the deposit ID.\",\"depositor\":\"The depositor address used as input to produce the deposit ID.\",\"msgSender\":\"The caller of the transaction used as input to produce the deposit ID.\"},\"returns\":{\"_0\":\"The deposit ID for the unsafe deposit.\"}},\"initialize(uint32,address,address,address)\":{\"params\":{\"_crossDomainAdmin\":\"Cross domain admin to set. Can be changed by admin.\",\"_initialDepositId\":\"Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate relay hash collisions.\",\"_l2GatewayRouter\":\"Address of L2 token gateway. Can be reset by admin.\",\"_withdrawalRecipient\":\"Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will likely be the hub pool.\"}},\"pauseDeposits(bool)\":{\"details\":\"Affects `deposit()` but not `speedUpDeposit()`, so that existing deposits can be sped up and still relayed.\",\"params\":{\"pause\":\"true if the call is meant to pause the system, false if the call is meant to unpause it.\"}},\"pauseFills(bool)\":{\"details\":\"Affects fillRelayWithUpdatedDeposit() and fillRelay().\",\"params\":{\"pause\":\"true if the call is meant to pause the system, false if the call is meant to unpause it.\"}},\"proxiableUUID()\":{\"details\":\"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\"},\"relayRootBundle(bytes32,bytes32)\":{\"params\":{\"relayerRefundRoot\":\"Merkle root containing relayer refund leaves that can be individually executed via executeRelayerRefundLeaf().\",\"slowRelayRoot\":\"Merkle root containing slow relay fulfillment leaves that can be individually executed via executeSlowRelayLeaf().\"}},\"requestSlowFill((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes))\":{\"details\":\"Slow fills are not possible unless the input and output tokens are \\\"equivalent\\\", i.e. they route to the same L1 token via PoolRebalanceRoutes.Slow fills are created by inserting slow fill objects into a merkle tree that is included in the next HubPool \\\"root bundle\\\". Once the optimistic challenge window has passed, the HubPool will relay the slow root to this chain via relayRootBundle(). Once the slow root is relayed, the slow fill can be executed by anyone who calls executeSlowRelayLeaf().Cannot request a slow fill if the fill deadline has passed.Cannot request a slow fill if the relay has already been filled or a slow fill has already been requested.\",\"params\":{\"relayData\":\"struct containing all the data needed to identify the deposit that should be slow filled. If any of the params are missing or different from the origin chain deposit, then Across will not include a slow fill for the intended deposit.\"}},\"setCrossDomainAdmin(address)\":{\"params\":{\"newCrossDomainAdmin\":\"New cross domain admin.\"}},\"setEnableRoute(address,uint256,bool)\":{\"params\":{\"destinationChainId\":\"Chain ID for where depositor wants to receive funds.\",\"enabled\":\"True to enable deposits, False otherwise.\",\"originToken\":\"Token that depositor can deposit to this contract.\"}},\"setL2GatewayRouter(address)\":{\"params\":{\"newL2GatewayRouter\":\"New L2 gateway router.\"}},\"setWithdrawalRecipient(address)\":{\"params\":{\"newWithdrawalRecipient\":\"New withdrawal recipient address.\"}},\"speedUpDeposit(bytes32,uint256,uint256,bytes32,bytes,bytes)\":{\"details\":\"the depositor and depositId must match the params in a FundsDeposited event that the depositor wants to speed up. The relayer has the option but not the obligation to use this updated information when filling the deposit via fillRelayWithUpdatedDeposit().\",\"params\":{\"depositId\":\"Deposit ID to speed up.\",\"depositor\":\"Depositor that must sign the depositorSignature and was the original depositor.\",\"depositorSignature\":\"Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account. If depositor is a contract, then should implement EIP1271 to sign as a contract. See _verifyUpdateV3DepositMessage() for more details about how this signature should be constructed.\",\"updatedMessage\":\"New message to use for this deposit. Can be modified if the recipient is a contract that expects to receive a message from the relay and for some reason needs to be modified.\",\"updatedOutputAmount\":\"New output amount to use for this deposit. Should be lower than previous value otherwise relayer has no incentive to use this updated value.\",\"updatedRecipient\":\"New recipient to use for this deposit. Can be modified if the recipient is a contract that expects to receive a message from the relay and for some reason needs to be modified.\"}},\"speedUpV3Deposit(address,uint256,uint256,address,bytes,bytes)\":{\"details\":\"The `depositor` and `depositId` must match the parameters in a `FundsDeposited` event that the depositor wants to speed up. The relayer is not obligated but has the option to use this updated information when filling the deposit using `fillRelayWithUpdatedDeposit()`. This version uses `address` types for compatibility with systems relying on `address`-based implementations.\",\"params\":{\"depositId\":\"The deposit ID to speed up.\",\"depositor\":\"The depositor that must sign the `depositorSignature` and was the original depositor.\",\"depositorSignature\":\"The signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account. If the depositor is a contract, it should implement EIP1271 to sign as a contract. See `_verifyUpdateV3DepositMessage()` for more details on how the signature should be constructed.\",\"updatedMessage\":\"The new message for this deposit. Can be modified if the recipient is a contract that expects to receive a message from the relay and needs to be updated.\",\"updatedOutputAmount\":\"The new output amount to use for this deposit. It should be lower than the previous value, otherwise the relayer has no incentive to use this updated value.\",\"updatedRecipient\":\"The new recipient for this deposit. Can be modified if the original recipient is a contract that expects to receive a message from the relay and needs to be changed.\"}},\"unsafeDeposit(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint256,uint32,uint32,uint32,bytes)\":{\"details\":\"This is labeled \\\"unsafe\\\" because there is no guarantee that the depositId emitted in the resultant FundsDeposited event is unique which means that the corresponding fill might collide with an existing relay hash on the destination chain SpokePool, which would make this deposit unfillable. In this case, the depositor would subsequently receive a refund of `inputAmount` of `inputToken` on the origin chain after the fill deadline.On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so modifying any params in it will result in a different hash and a different deposit. The hash will comprise all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by this contract.\",\"params\":{\"depositNonce\":\"The nonce that uniquely identifies this deposit. This function will combine this parameter with the msg.sender address to create a unique uint256 depositNonce and ensure that the msg.sender cannot use this function to front-run another depositor's unsafe deposit. This function guarantees that the resultant deposit nonce will not collide with a safe uint256 deposit nonce whose 24 most significant bytes are always 0.\",\"depositor\":\"See identically named parameter in depositV3() comments.\",\"destinationChainId\":\"See identically named parameter in depositV3() comments.\",\"exclusiveRelayer\":\"See identically named parameter in depositV3() comments.\",\"exclusivityParameter\":\"See identically named parameter in depositV3() comments.\",\"fillDeadline\":\"See identically named parameter in depositV3() comments.\",\"inputAmount\":\"See identically named parameter in depositV3() comments.\",\"inputToken\":\"See identically named parameter in depositV3() comments.\",\"message\":\"See identically named parameter in depositV3() comments.\",\"outputAmount\":\"See identically named parameter in depositV3() comments.\",\"outputToken\":\"See identically named parameter in depositV3() comments.\",\"quoteTimestamp\":\"See identically named parameter in depositV3() comments.\",\"recipient\":\"See identically named parameter in depositV3() comments.\"}},\"upgradeTo(address)\":{\"custom:oz-upgrades-unsafe-allow-reachable\":\"delegatecall\",\"details\":\"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"},\"upgradeToAndCall(address,bytes)\":{\"custom:oz-upgrades-unsafe-allow-reachable\":\"delegatecall\",\"details\":\"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"},\"whitelistToken(address,address)\":{\"params\":{\"l1Token\":\"Ethereum version of l2Token.\",\"l2Token\":\"Arbitrum token.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"__SpokePool_init(uint32,address,address)\":{\"notice\":\"Construct the base SpokePool.\"},\"chainId()\":{\"notice\":\"Returns chain ID for this network.\"},\"claimRelayerRefund(bytes32,bytes32)\":{\"notice\":\"Enables a relayer to claim outstanding repayments. Should virtually never be used, unless for some reason relayer repayment transfer fails for reasons such as token transfer reverts due to blacklisting. In this case, the relayer can still call this method and claim the tokens to a new address.\"},\"deposit(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint32,uint32,uint32,bytes)\":{\"notice\":\"Previously, this function allowed the caller to specify the exclusivityDeadline, otherwise known as the as exact timestamp on the destination chain before which only the exclusiveRelayer could fill the deposit. Now, the caller is expected to pass in a number that will be interpreted either as an offset or a fixed timestamp depending on its value.Request to bridge input token cross chain to a destination chain and receive a specified amount of output tokens. The fee paid to relayers and the system should be captured in the spread between output amount and input amount when adjusted to be denominated in the input token. A relayer on the destination chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment chain of their choice. Therefore, the fee should account for destination fee transaction costs, the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge window in the HubPool, and the system fee that they'll be charged.\"},\"depositDeprecated_5947912356(address,address,uint256,uint256,int64,uint32,bytes,uint256)\":{\"notice\":\"Called by user to bridge funds from origin to destination chain. Depositor will effectively lock tokens in this contract and receive a destination token on the destination chain. The origin => destination token mapping is stored on the L1 HubPool.The caller must first approve this contract to spend amount of originToken.The originToken => destinationChainId must be enabled.This method is payable because the caller is able to deposit native token if the originToken is wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\"},\"depositFor(address,address,address,uint256,uint256,int64,uint32,bytes,uint256)\":{\"notice\":\"The only difference between depositFor and deposit is that the depositor address stored in the relay hash can be overridden by the caller. This means that the passed in depositor can speed up the deposit, which is useful if the deposit is taken from the end user to a middle layer contract, like an aggregator or the SpokePoolVerifier, before calling deposit on this contract.The caller must first approve this contract to spend amount of originToken.The originToken => destinationChainId must be enabled.This method is payable because the caller is able to deposit native token if the originToken is wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\"},\"depositNow(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint32,uint32,bytes)\":{\"notice\":\"Submits deposit and sets quoteTimestamp to current Time. Sets fill and exclusivity deadlines as offsets added to the current time. This function is designed to be called by users such as Multisig contracts who do not have certainty when their transaction will mine.\"},\"depositV3(address,address,address,address,uint256,uint256,uint256,address,uint32,uint32,uint32,bytes)\":{\"notice\":\"A version of `deposit` that accepts `address` types for backward compatibility. This function allows bridging of input tokens cross-chain to a destination chain, receiving a specified amount of output tokens. The relayer is refunded in input tokens on a repayment chain of their choice, minus system fees, after an optimistic challenge window. The exclusivity period is specified as an offset from the current block timestamp.\"},\"depositV3Now(address,address,address,address,uint256,uint256,uint256,address,uint32,uint32,bytes)\":{\"notice\":\"A version of `depositNow` that supports addresses as input types for backward compatibility. This function submits a deposit and sets `quoteTimestamp` to the current time. The `fill` and `exclusivity` deadlines are set as offsets added to the current time. It is designed to be called by users, including Multisig contracts, who may not have certainty when their transaction will be mined.\"},\"emergencyDeleteRootBundle(uint256)\":{\"notice\":\"This method is intended to only be used in emergencies where a bad root bundle has reached the SpokePool.\"},\"executeRelayerRefundLeaf(uint32,(uint256,uint256,uint256[],uint32,address,address[]),bytes32[])\":{\"notice\":\"Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they sent to the recipient plus a relayer fee.\"},\"executeSlowRelayLeaf(((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,uint256),uint32,bytes32[])\":{\"notice\":\"Executes a slow relay leaf stored as part of a root bundle relayed by the HubPool.\"},\"fill(bytes32,bytes,bytes)\":{\"notice\":\"Fills a single leg of a particular order on the destination chain\"},\"fillRelay((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,bytes32)\":{\"notice\":\"Fulfill request to bridge cross chain by sending specified output tokens to the recipient.\"},\"fillRelayWithUpdatedDeposit((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,bytes32,uint256,bytes32,bytes,bytes)\":{\"notice\":\"Identical to fillV3Relay except that the relayer wants to use a depositor's updated output amount, recipient, and/or message. The relayer should only use this function if they can supply a message signed by the depositor that contains the fill's matching deposit ID along with updated relay parameters. If the signature can be verified, then this function will emit a FilledV3Event that will be used by the system for refund verification purposes. In other words, this function is an alternative way to fill a a deposit than fillV3Relay.\"},\"getCurrentTime()\":{\"notice\":\"Gets the current time.\"},\"getUnsafeDepositId(address,bytes32,uint256)\":{\"notice\":\"Returns the deposit ID for an unsafe deposit. This function is used to compute the deposit ID in unsafeDeposit and is provided as a convenience.\"},\"initialize(uint32,address,address,address)\":{\"notice\":\"Construct the AVM SpokePool.\"},\"pauseDeposits(bool)\":{\"notice\":\"Pauses deposit-related functions. This is intended to be used if this contract is deprecated or when something goes awry.\"},\"pauseFills(bool)\":{\"notice\":\"Pauses fill-related functions. This is intended to be used if this contract is deprecated or when something goes awry.\"},\"relayRootBundle(bytes32,bytes32)\":{\"notice\":\"This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\"},\"requestSlowFill((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes))\":{\"notice\":\"Request Across to send LP funds to this contract to fulfill a slow fill relay for a deposit in the next bundle.\"},\"setCrossDomainAdmin(address)\":{\"notice\":\"Change cross domain admin address. Callable by admin only.\"},\"setEnableRoute(address,uint256,bool)\":{\"notice\":\"Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only.\"},\"setL2GatewayRouter(address)\":{\"notice\":\"Change L2 gateway router. Callable only by admin.\"},\"setWithdrawalRecipient(address)\":{\"notice\":\"Change L1 withdrawal recipient address. Callable by admin only.\"},\"speedUpDeposit(bytes32,uint256,uint256,bytes32,bytes,bytes)\":{\"notice\":\"Depositor can use this function to signal to relayer to use updated output amount, recipient, and/or message.\"},\"speedUpV3Deposit(address,uint256,uint256,address,bytes,bytes)\":{\"notice\":\"A version of `speedUpDeposit` using `address` types for backward compatibility. This function allows the depositor to signal to the relayer to use updated output amount, recipient, and/or message when filling a deposit. This can be useful when the deposit needs to be modified after the original transaction has been mined.\"},\"unsafeDeposit(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint256,uint32,uint32,uint32,bytes)\":{\"notice\":\"See deposit for details. This function is identical to deposit except that it does not use the global deposit ID counter as a deposit nonce, instead allowing the caller to pass in a deposit nonce. This function is designed to be used by anyone who wants to pre-compute their resultant relay data hash, which could be useful for filling a deposit faster and avoiding any risk of a relay hash unexpectedly changing due to another deposit front-running this one and incrementing the global deposit ID counter.\"},\"whitelistToken(address,address)\":{\"notice\":\"Add L2 -> L1 token mapping. Callable only by admin.\"}},\"notice\":\"AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/AlephZero_SpokePool.sol\":\"AlephZero_SpokePool\"},\"debug\":{\"revertStrings\":\"strip\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0x47d6e06872b12e72c79d1b5eb55842f860b5fb1207b2317c2358d2766b950a7b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x77c89f893e403efc6929ba842b7ccf6534d4ffe03afe31670b4a528c0ad78c0f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x7795808e3899c805254e3ae58074b20f799b466e3f43e057e47bedee5fb771f8\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x24b86ac8c005b8c654fbf6ac34a5a4f61580d7273541e83e013e89d66fbf0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xefb41f5c1a00249b7a99f0782f8c557865605426a3fb6e5fe9ae334293ae4f33\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x2025ccf05f6f1f2fd4e078e552836f525a1864e3854ed555047cd732320ab29b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x07e881de3b9f6d2c07909f193f24b96c7fe4ea60013260f3f25aecd8bab3c2f8\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x23b997be73d3dd46885262704f0f8cfc7273fdadfe303d37969a9561373972b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x07ac95acad040f1fb1f6120dd0aa5f702db69446e95f82613721879d30de0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\nimport \\\"./math/SignedMathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMathUpgradeable.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0xb96dc79b65b7c37937919dcdb356a969ce0aa2e8338322bf4dc027a3c9c9a7eb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0xa014f65d84b02827055d99993ccdbfb4b56b2c9e91eb278d82a93330659d06e4\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2bc0007987c229ae7624eb29be6a9b84f6a6a5872f76248b15208b131ea41c4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMathUpgradeable {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x88f6b7bba3ee33eeb741f9a0f5bc98b6e6e352d0fe4905377bb328590f84095a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x0705a4b1b86d7b0bd8432118f226ba139c44b9dcaba0a6eafba2dd7d0639c544\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf688741f79f4838d5301dcf72d0af9eff11bbab6ab0bb112ad144c7fb672dac\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\",\"keccak256\":\"0x3af3ca86df39aac39a0514c84459d691434a108d2151c8ce9d69f32e315cab80\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/AlephZero_SpokePool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\n// Arbitrum only supports v0.8.19\\n// See https://docs.arbitrum.io/for-devs/concepts/differences-between-arbitrum-ethereum/solidity-support#differences-from-solidity-on-ethereum\\npragma solidity ^0.8.19;\\n\\nimport \\\"./Arbitrum_SpokePool.sol\\\";\\n\\n/**\\n * @notice AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract AlephZero_SpokePool is Arbitrum_SpokePool {\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(\\n        address _wrappedNativeTokenAddress,\\n        uint32 _depositQuoteTimeBuffer,\\n        uint32 _fillDeadlineBuffer,\\n        IERC20 _l2Usdc,\\n        ITokenMessenger _cctpTokenMessenger\\n    )\\n        Arbitrum_SpokePool(\\n            _wrappedNativeTokenAddress,\\n            _depositQuoteTimeBuffer,\\n            _fillDeadlineBuffer,\\n            _l2Usdc,\\n            _cctpTokenMessenger\\n        )\\n    {} // solhint-disable-line no-empty-blocks\\n}\\n\",\"keccak256\":\"0x242ee91b3054911bd5b1c2bc2d0744c90bb8d673752eed2292fd70f4814e68d5\",\"license\":\"BUSL-1.1\"},\"contracts/Arbitrum_SpokePool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SpokePool.sol\\\";\\nimport \\\"./libraries/CircleCCTPAdapter.sol\\\";\\nimport { CrossDomainAddressUtils } from \\\"./libraries/CrossDomainAddressUtils.sol\\\";\\nimport { ArbitrumL2ERC20GatewayLike } from \\\"./interfaces/ArbitrumBridge.sol\\\";\\n\\n/**\\n * @notice AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract Arbitrum_SpokePool is SpokePool, CircleCCTPAdapter {\\n    // Address of the Arbitrum L2 token gateway to send funds to L1.\\n    address public l2GatewayRouter;\\n\\n    // Admin controlled mapping of arbitrum tokens to L1 counterpart. L1 counterpart addresses\\n    // are necessary params used when bridging tokens to L1.\\n    mapping(address => address) public whitelistedTokens;\\n\\n    event SetL2GatewayRouter(address indexed newL2GatewayRouter);\\n    event WhitelistedTokens(address indexed l2Token, address indexed l1Token);\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(\\n        address _wrappedNativeTokenAddress,\\n        uint32 _depositQuoteTimeBuffer,\\n        uint32 _fillDeadlineBuffer,\\n        IERC20 _l2Usdc,\\n        ITokenMessenger _cctpTokenMessenger\\n    )\\n        SpokePool(_wrappedNativeTokenAddress, _depositQuoteTimeBuffer, _fillDeadlineBuffer)\\n        CircleCCTPAdapter(_l2Usdc, _cctpTokenMessenger, CircleDomainIds.Ethereum)\\n    {} // solhint-disable-line no-empty-blocks\\n\\n    /**\\n     * @notice Construct the AVM SpokePool.\\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\\n     * relay hash collisions.\\n     * @param _l2GatewayRouter Address of L2 token gateway. Can be reset by admin.\\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\\n     * likely be the hub pool.\\n     */\\n    function initialize(\\n        uint32 _initialDepositId,\\n        address _l2GatewayRouter,\\n        address _crossDomainAdmin,\\n        address _withdrawalRecipient\\n    ) public initializer {\\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _withdrawalRecipient);\\n        _setL2GatewayRouter(_l2GatewayRouter);\\n    }\\n\\n    modifier onlyFromCrossDomainAdmin() {\\n        require(msg.sender == CrossDomainAddressUtils.applyL1ToL2Alias(crossDomainAdmin), \\\"ONLY_COUNTERPART_GATEWAY\\\");\\n        _;\\n    }\\n\\n    /********************************************************\\n     *    ARBITRUM-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\\n     ********************************************************/\\n\\n    /**\\n     * @notice Change L2 gateway router. Callable only by admin.\\n     * @param newL2GatewayRouter New L2 gateway router.\\n     */\\n    function setL2GatewayRouter(address newL2GatewayRouter) public onlyAdmin nonReentrant {\\n        _setL2GatewayRouter(newL2GatewayRouter);\\n    }\\n\\n    /**\\n     * @notice Add L2 -> L1 token mapping. Callable only by admin.\\n     * @param l2Token Arbitrum token.\\n     * @param l1Token Ethereum version of l2Token.\\n     */\\n    function whitelistToken(address l2Token, address l1Token) public onlyAdmin nonReentrant {\\n        _whitelistToken(l2Token, l1Token);\\n    }\\n\\n    /**************************************\\n     *        INTERNAL FUNCTIONS          *\\n     **************************************/\\n\\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal override {\\n        // If the l2TokenAddress is UDSC, we need to use the CCTP bridge.\\n        if (_isCCTPEnabled() && l2TokenAddress == address(usdcToken)) {\\n            _transferUsdc(withdrawalRecipient, amountToReturn);\\n        } else {\\n            // Check that the Ethereum counterpart of the L2 token is stored on this contract.\\n            address ethereumTokenToBridge = whitelistedTokens[l2TokenAddress];\\n            require(ethereumTokenToBridge != address(0), \\\"Uninitialized mainnet token\\\");\\n            //slither-disable-next-line unused-return\\n            ArbitrumL2ERC20GatewayLike(l2GatewayRouter).outboundTransfer(\\n                ethereumTokenToBridge, // _l1Token. Address of the L1 token to bridge over.\\n                withdrawalRecipient, // _to. Withdraw, over the bridge, to the l1 hub pool contract.\\n                amountToReturn, // _amount.\\n                \\\"\\\" // _data. We don't need to send any data for the bridging action.\\n            );\\n        }\\n    }\\n\\n    function _setL2GatewayRouter(address _l2GatewayRouter) internal {\\n        l2GatewayRouter = _l2GatewayRouter;\\n        emit SetL2GatewayRouter(l2GatewayRouter);\\n    }\\n\\n    function _whitelistToken(address _l2Token, address _l1Token) internal {\\n        whitelistedTokens[_l2Token] = _l1Token;\\n        emit WhitelistedTokens(_l2Token, _l1Token);\\n    }\\n\\n    // Apply AVM-specific transformation to cross domain admin address on L1.\\n    function _requireAdminSender() internal override onlyFromCrossDomainAdmin {}\\n}\\n\",\"keccak256\":\"0x1db889db6ba958d74ab8f64afc2e48d5e84fadc7f8ac546bcc202976ee321d5a\",\"license\":\"BUSL-1.1\"},\"contracts/MerkleLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/SpokePoolInterface.sol\\\";\\nimport \\\"./interfaces/V3SpokePoolInterface.sol\\\";\\nimport \\\"./interfaces/HubPoolInterface.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\n/**\\n * @notice Library to help with merkle roots, proofs, and claims.\\n * @custom:security-contact bugs@across.to\\n */\\nlibrary MerkleLib {\\n    /**\\n     * @notice Verifies that a repayment is contained within a merkle root.\\n     * @param root the merkle root.\\n     * @param rebalance the rebalance struct.\\n     * @param proof the merkle proof.\\n     * @return bool to signal if the pool rebalance proof correctly shows inclusion of the rebalance within the tree.\\n     */\\n    function verifyPoolRebalance(\\n        bytes32 root,\\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\\n        bytes32[] memory proof\\n    ) internal pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));\\n    }\\n\\n    /**\\n     * @notice Verifies that a relayer refund is contained within a merkle root.\\n     * @param root the merkle root.\\n     * @param refund the refund struct.\\n     * @param proof the merkle proof.\\n     * @return bool to signal if the relayer refund proof correctly shows inclusion of the refund within the tree.\\n     */\\n    function verifyRelayerRefund(\\n        bytes32 root,\\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\\n        bytes32[] memory proof\\n    ) internal pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(refund)));\\n    }\\n\\n    function verifyV3SlowRelayFulfillment(\\n        bytes32 root,\\n        V3SpokePoolInterface.V3SlowFill memory slowRelayFulfillment,\\n        bytes32[] memory proof\\n    ) internal pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\\n    }\\n\\n    // The following functions are primarily copied from\\n    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.\\n\\n    /**\\n     * @notice Tests whether a claim is contained within a claimedBitMap mapping.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\\n     * @param index the index to check in the bitmap.\\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\\n     */\\n    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal view returns (bool) {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\\n        uint256 mask = (1 << claimedBitIndex);\\n        return claimedWord & mask == mask;\\n    }\\n\\n    /**\\n     * @notice Marks an index in a claimedBitMap as claimed.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\\n     * @param index the index to mark in the bitmap.\\n     */\\n    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\\n    }\\n\\n    /**\\n     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.\\n     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.\\n     * @param index the index to check in the bitmap. Uint8 type enforces that index can't be > 255.\\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\\n     */\\n    function isClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (bool) {\\n        uint256 mask = (1 << index);\\n        return claimedBitMap & mask == mask;\\n    }\\n\\n    /**\\n     * @notice Marks an index in a claimedBitMap as claimed.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap. Uint8 type enforces that index\\n     * can't be > 255.\\n     * @param index the index to mark in the bitmap.\\n     * @return uint256 representing the modified input claimedBitMap with the index set to true.\\n     */\\n    function setClaimed1D(uint256 claimedBitMap, uint8 index) internal pure returns (uint256) {\\n        return claimedBitMap | (1 << index);\\n    }\\n}\\n\",\"keccak256\":\"0xdaf19fdc82593b79a608af8f691aec89a3c0e47b210770deabbe66ece7c35bb1\",\"license\":\"BUSL-1.1\"},\"contracts/SpokePool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./MerkleLib.sol\\\";\\nimport \\\"./erc7683/ERC7683.sol\\\";\\nimport \\\"./erc7683/ERC7683Permit2Lib.sol\\\";\\nimport \\\"./external/interfaces/WETH9Interface.sol\\\";\\nimport \\\"./interfaces/SpokePoolMessageHandler.sol\\\";\\nimport \\\"./interfaces/SpokePoolInterface.sol\\\";\\nimport \\\"./interfaces/V3SpokePoolInterface.sol\\\";\\nimport \\\"./upgradeable/MultiCallerUpgradeable.sol\\\";\\nimport \\\"./upgradeable/EIP712CrossChainUpgradeable.sol\\\";\\nimport \\\"./upgradeable/AddressLibUpgradeable.sol\\\";\\nimport \\\"./libraries/AddressConverters.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\n\\n/**\\n * @title SpokePool\\n * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to\\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.\\n * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a \\\"data worker\\\",\\n * submits a proof that the relayer correctly submitted a relay on this SpokePool.\\n * @custom:security-contact bugs@across.to\\n */\\nabstract contract SpokePool is\\n    V3SpokePoolInterface,\\n    SpokePoolInterface,\\n    UUPSUpgradeable,\\n    ReentrancyGuardUpgradeable,\\n    MultiCallerUpgradeable,\\n    EIP712CrossChainUpgradeable,\\n    IDestinationSettler\\n{\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n    using AddressLibUpgradeable for address;\\n    using Bytes32ToAddress for bytes32;\\n    using AddressToBytes32 for address;\\n\\n    // Address of the L1 contract that acts as the owner of this SpokePool. This should normally be set to the HubPool\\n    // address. The crossDomainAdmin address is unused when the SpokePool is deployed to the same chain as the HubPool.\\n    address public crossDomainAdmin;\\n\\n    // Address of the L1 contract that will send tokens to and receive tokens from this contract to fund relayer\\n    // refunds and slow relays.\\n    address public withdrawalRecipient;\\n\\n    // Note: The following two storage variables prefixed with DEPRECATED used to be variables that could be set by\\n    // the cross-domain admin. Admins ended up not changing these in production, so to reduce\\n    // gas in deposit/fill functions, we are converting them to private variables to maintain the contract\\n    // storage layout and replacing them with immutable or constant variables, because retrieving a constant\\n    // value is cheaper than retrieving a storage variable. Please see out the immutable/constant variable section.\\n    WETH9Interface private DEPRECATED_wrappedNativeToken;\\n    uint32 private DEPRECATED_depositQuoteTimeBuffer;\\n\\n    // `numberOfDeposits` acts as a counter to generate unique deposit identifiers for this spoke pool.\\n    // It is a uint32 that increments with each `depositV3` call. In the `FundsDeposited` event, it is\\n    // implicitly cast to uint256 by setting its most significant bits to 0, reducing the risk of ID collisions\\n    // with unsafe deposits. However, this variable's name could be improved (e.g., `depositNonceCounter`)\\n    // since it does not accurately reflect the total number of deposits, as `unsafeDeposit` can bypass this increment.\\n    uint32 public numberOfDeposits;\\n\\n    // Whether deposits and fills are disabled.\\n    bool public pausedFills;\\n    bool public pausedDeposits;\\n\\n    // This contract can store as many root bundles as the HubPool chooses to publish here.\\n    RootBundle[] public rootBundles;\\n\\n    // Origin token to destination token routings can be turned on or off, which can enable or disable deposits.\\n    mapping(address => mapping(uint256 => bool)) public enabledDepositRoutes;\\n\\n    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay\\n    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to\\n    // relay, the fees, and the agents are all parameters included in the hash key.\\n    mapping(bytes32 => uint256) private DEPRECATED_relayFills;\\n\\n    // Note: We will likely un-deprecate the fill and deposit counters to implement a better\\n    // dynamic LP fee mechanism but for now we'll deprecate it to reduce bytecode\\n    // in deposit/fill functions. These counters are designed to implement a fee mechanism that is based on a\\n    // canonical history of deposit and fill events and how they update a virtual running balance of liabilities and\\n    // assets, which then determines the LP fee charged to relays.\\n\\n    // This keeps track of the worst-case liabilities due to fills.\\n    // It is never reset. Users should only rely on it to determine the worst-case increase in liabilities between\\n    // two points. This is used to provide frontrunning protection to ensure the relayer's assumptions about the state\\n    // upon which their expected repayments are based will not change before their transaction is mined.\\n    mapping(address => uint256) private DEPRECATED_fillCounter;\\n\\n    // This keeps track of the total running deposits for each token. This allows depositors to protect themselves from\\n    // frontrunning that might change their worst-case quote.\\n    mapping(address => uint256) private DEPRECATED_depositCounter;\\n\\n    // This tracks the number of identical refunds that have been requested.\\n    // The intention is to allow an off-chain system to know when this could be a duplicate and ensure that the other\\n    // requests are known and accounted for.\\n    mapping(bytes32 => uint256) private DEPRECATED_refundsRequested;\\n\\n    // Mapping of V3 relay hashes to fill statuses. Distinguished from relayFills\\n    // to eliminate any chance of collision between pre and post V3 relay hashes.\\n    mapping(bytes32 => uint256) public fillStatuses;\\n\\n    // Mapping of L2TokenAddress to relayer to outstanding refund amount. Used when a relayer repayment fails for some\\n    // reason (eg blacklist) to track their outstanding liability, thereby letting them claim it later.\\n    mapping(address => mapping(address => uint256)) public relayerRefund;\\n\\n    /**************************************************************\\n     *                CONSTANT/IMMUTABLE VARIABLES                *\\n     **************************************************************/\\n    // Constant and immutable variables do not take up storage slots and are instead added to the contract bytecode\\n    // at compile time. The difference between them is that constant variables must be declared inline, meaning\\n    // that they cannot be changed in production without changing the contract code, while immutable variables\\n    // can be set in the constructor. Therefore we use the immutable keyword for variables that we might want to be\\n    // different for each child contract (one obvious example of this is the wrappedNativeToken) or that we might\\n    // want to update in the future like depositQuoteTimeBuffer. Constants are unlikely to ever be changed.\\n\\n    // Address of wrappedNativeToken contract for this network. If an origin token matches this, then the caller can\\n    // optionally instruct this contract to wrap native tokens when depositing (ie ETH->WETH or MATIC->WMATIC).\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    WETH9Interface public immutable wrappedNativeToken;\\n\\n    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces\\n    // caller to use an approximately \\\"current\\\" realized fee.\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    uint32 public immutable depositQuoteTimeBuffer;\\n\\n    // The fill deadline can only be set this far into the future from the timestamp of the deposit on this contract.\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    uint32 public immutable fillDeadlineBuffer;\\n\\n    uint256 public constant MAX_TRANSFER_SIZE = 1e36;\\n\\n    bytes32 public constant UPDATE_BYTES32_DEPOSIT_DETAILS_HASH =\\n        keccak256(\\n            \\\"UpdateDepositDetails(uint256 depositId,uint256 originChainId,uint256 updatedOutputAmount,bytes32 updatedRecipient,bytes updatedMessage)\\\"\\n        );\\n\\n    bytes32 public constant UPDATE_ADDRESS_DEPOSIT_DETAILS_HASH =\\n        keccak256(\\n            \\\"UpdateDepositDetails(uint256 depositId,uint256 originChainId,uint256 updatedOutputAmount,address updatedRecipient,bytes updatedMessage)\\\"\\n        );\\n\\n    // Default chain Id used to signify that no repayment is requested, for example when executing a slow fill.\\n    uint256 public constant EMPTY_REPAYMENT_CHAIN_ID = 0;\\n    // Default address used to signify that no relayer should be credited with a refund, for example\\n    // when executing a slow fill.\\n    bytes32 public constant EMPTY_RELAYER = bytes32(0);\\n    // This is the magic value that signals to the off-chain validator\\n    // that this deposit can never expire. A deposit with this fill deadline should always be eligible for a\\n    // slow fill, meaning that its output token and input token must be \\\"equivalent\\\". Therefore, this value is only\\n    // used as a fillDeadline in deposit(), a soon to be deprecated function that also hardcodes outputToken to\\n    // the zero address, which forces the off-chain validator to replace the output token with the equivalent\\n    // token for the input token. By using this magic value, off-chain validators do not have to keep\\n    // this event in their lookback window when querying for expired deposits.\\n    uint32 public constant INFINITE_FILL_DEADLINE = type(uint32).max;\\n\\n    // One year in seconds. If `exclusivityParameter` is set to a value less than this, then the emitted\\n    // exclusivityDeadline in a deposit event will be set to the current time plus this value.\\n    uint32 public constant MAX_EXCLUSIVITY_PERIOD_SECONDS = 31_536_000;\\n    /****************************************\\n     *                EVENTS                *\\n     ****************************************/\\n    event SetXDomainAdmin(address indexed newAdmin);\\n    event SetWithdrawalRecipient(address indexed newWithdrawalRecipient);\\n    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);\\n    event RelayedRootBundle(\\n        uint32 indexed rootBundleId,\\n        bytes32 indexed relayerRefundRoot,\\n        bytes32 indexed slowRelayRoot\\n    );\\n    event ExecutedRelayerRefundRoot(\\n        uint256 amountToReturn,\\n        uint256 indexed chainId,\\n        uint256[] refundAmounts,\\n        uint32 indexed rootBundleId,\\n        uint32 indexed leafId,\\n        address l2TokenAddress,\\n        address[] refundAddresses,\\n        bool deferredRefunds,\\n        address caller\\n    );\\n    event TokensBridged(\\n        uint256 amountToReturn,\\n        uint256 indexed chainId,\\n        uint32 indexed leafId,\\n        bytes32 indexed l2TokenAddress,\\n        address caller\\n    );\\n    event EmergencyDeletedRootBundle(uint256 indexed rootBundleId);\\n    event PausedDeposits(bool isPaused);\\n    event PausedFills(bool isPaused);\\n\\n    /**\\n     * @notice Construct the SpokePool. Normally, logic contracts used in upgradeable proxies shouldn't\\n     * have constructors since the following code will be executed within the logic contract's state, not the\\n     * proxy contract's state. However, if we restrict the constructor to setting only immutable variables, then\\n     * we are safe because immutable variables are included in the logic contract's bytecode rather than its storage.\\n     * @dev Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be\\n     * taken over by an attacker, which may impact the proxy. To prevent the implementation contract from being\\n     * used, you should invoke the _disableInitializers function in the constructor to automatically lock it when\\n     * it is deployed:\\n     * @param _wrappedNativeTokenAddress wrappedNativeToken address for this network to set.\\n     * @param _depositQuoteTimeBuffer depositQuoteTimeBuffer to set. Quote timestamps can't be set more than this amount\\n     * into the past from the block time of the deposit.\\n     * @param _fillDeadlineBuffer fillDeadlineBuffer to set. Fill deadlines can't be set more than this amount\\n     * into the future from the block time of the deposit.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(\\n        address _wrappedNativeTokenAddress,\\n        uint32 _depositQuoteTimeBuffer,\\n        uint32 _fillDeadlineBuffer\\n    ) {\\n        wrappedNativeToken = WETH9Interface(_wrappedNativeTokenAddress);\\n        depositQuoteTimeBuffer = _depositQuoteTimeBuffer;\\n        fillDeadlineBuffer = _fillDeadlineBuffer;\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Construct the base SpokePool.\\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\\n     * relay hash collisions.\\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\\n     * @param _withdrawalRecipient Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will\\n     * likely be the hub pool.\\n     */\\n    function __SpokePool_init(\\n        uint32 _initialDepositId,\\n        address _crossDomainAdmin,\\n        address _withdrawalRecipient\\n    ) public onlyInitializing {\\n        numberOfDeposits = _initialDepositId;\\n        __EIP712_init(\\\"ACROSS-V2\\\", \\\"1.0.0\\\");\\n        __UUPSUpgradeable_init();\\n        __ReentrancyGuard_init();\\n        _setCrossDomainAdmin(_crossDomainAdmin);\\n        _setWithdrawalRecipient(_withdrawalRecipient);\\n    }\\n\\n    /****************************************\\n     *               MODIFIERS              *\\n     ****************************************/\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     * @dev This should be set to cross domain admin for specific SpokePool.\\n     */\\n    modifier onlyAdmin() {\\n        _requireAdminSender();\\n        _;\\n    }\\n\\n    modifier unpausedDeposits() {\\n        if (pausedDeposits) revert DepositsArePaused();\\n        _;\\n    }\\n\\n    modifier unpausedFills() {\\n        if (pausedFills) revert FillsArePaused();\\n        _;\\n    }\\n\\n    /**************************************\\n     *          ADMIN FUNCTIONS           *\\n     **************************************/\\n\\n    // Allows cross domain admin to upgrade UUPS proxy implementation.\\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {}\\n\\n    /**\\n     * @notice Pauses deposit-related functions. This is intended to be used if this contract is deprecated or when\\n     * something goes awry.\\n     * @dev Affects `deposit()` but not `speedUpDeposit()`, so that existing deposits can be sped up and still\\n     * relayed.\\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\\n     */\\n    function pauseDeposits(bool pause) public override onlyAdmin nonReentrant {\\n        pausedDeposits = pause;\\n        emit PausedDeposits(pause);\\n    }\\n\\n    /**\\n     * @notice Pauses fill-related functions. This is intended to be used if this contract is deprecated or when\\n     * something goes awry.\\n     * @dev Affects fillRelayWithUpdatedDeposit() and fillRelay().\\n     * @param pause true if the call is meant to pause the system, false if the call is meant to unpause it.\\n     */\\n    function pauseFills(bool pause) public override onlyAdmin nonReentrant {\\n        pausedFills = pause;\\n        emit PausedFills(pause);\\n    }\\n\\n    /**\\n     * @notice Change cross domain admin address. Callable by admin only.\\n     * @param newCrossDomainAdmin New cross domain admin.\\n     */\\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyAdmin nonReentrant {\\n        _setCrossDomainAdmin(newCrossDomainAdmin);\\n    }\\n\\n    /**\\n     * @notice Change L1 withdrawal recipient address. Callable by admin only.\\n     * @param newWithdrawalRecipient New withdrawal recipient address.\\n     */\\n    function setWithdrawalRecipient(address newWithdrawalRecipient) public override onlyAdmin nonReentrant {\\n        _setWithdrawalRecipient(newWithdrawalRecipient);\\n    }\\n\\n    /**\\n     * @notice Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only.\\n     * @param originToken Token that depositor can deposit to this contract.\\n     * @param destinationChainId Chain ID for where depositor wants to receive funds.\\n     * @param enabled True to enable deposits, False otherwise.\\n     */\\n    function setEnableRoute(\\n        address originToken,\\n        uint256 destinationChainId,\\n        bool enabled\\n    ) public override onlyAdmin nonReentrant {\\n        enabledDepositRoutes[originToken][destinationChainId] = enabled;\\n        emit EnabledDepositRoute(originToken, destinationChainId, enabled);\\n    }\\n\\n    /**\\n     * @notice This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill\\n     * slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is\\n     * designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\\n     * @param relayerRefundRoot Merkle root containing relayer refund leaves that can be individually executed via\\n     * executeRelayerRefundLeaf().\\n     * @param slowRelayRoot Merkle root containing slow relay fulfillment leaves that can be individually executed via\\n     * executeSlowRelayLeaf().\\n     */\\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) public override onlyAdmin nonReentrant {\\n        uint32 rootBundleId = uint32(rootBundles.length);\\n        RootBundle storage rootBundle = rootBundles.push();\\n        rootBundle.relayerRefundRoot = relayerRefundRoot;\\n        rootBundle.slowRelayRoot = slowRelayRoot;\\n        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayRoot);\\n    }\\n\\n    /**\\n     * @notice This method is intended to only be used in emergencies where a bad root bundle has reached the\\n     * SpokePool.\\n     * @param rootBundleId Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256\\n     * to ensure that a small input range doesn't limit which indices this method is able to reach.\\n     */\\n    function emergencyDeleteRootBundle(uint256 rootBundleId) public override onlyAdmin nonReentrant {\\n        // Deleting a struct containing a mapping does not delete the mapping in Solidity, therefore the bitmap's\\n        // data will still remain potentially leading to vulnerabilities down the line. The way around this would\\n        // be to iterate through every key in the mapping and resetting the value to 0, but this seems expensive and\\n        // would require a new list in storage to keep track of keys.\\n        //slither-disable-next-line mapping-deletion\\n        delete rootBundles[rootBundleId];\\n        emit EmergencyDeletedRootBundle(rootBundleId);\\n    }\\n\\n    /**************************************\\n     *    LEGACY DEPOSITOR FUNCTIONS      *\\n     **************************************/\\n\\n    /**\\n     * @dev DEPRECATION NOTICE: this function is deprecated and will be removed in the future.\\n     *      Please use deposit (under DEPOSITOR FUNCTIONS below) or depositV3 instead.\\n     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock\\n     * tokens in this contract and receive a destination token on the destination chain. The origin => destination\\n     * token mapping is stored on the L1 HubPool.\\n     * @notice The caller must first approve this contract to spend amount of originToken.\\n     * @notice The originToken => destinationChainId must be enabled.\\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\\n     * @dev Produces a FundsDeposited event with an infinite expiry, meaning that this deposit can never expire.\\n     * Moreover, the event's outputToken is set to 0x0 meaning that this deposit can always be slow filled.\\n     * @param recipient Address to receive funds at on destination chain.\\n     * @param originToken Token to lock into this contract to initiate deposit.\\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\\n     * to LP pool on HubPool.\\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\\n     */\\n    function depositDeprecated_5947912356(\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 // maxCount. Deprecated.\\n    ) public payable nonReentrant unpausedDeposits {\\n        _deposit(\\n            msg.sender,\\n            recipient,\\n            originToken,\\n            amount,\\n            destinationChainId,\\n            relayerFeePct,\\n            quoteTimestamp,\\n            message\\n        );\\n    }\\n\\n    /**\\n     * @dev DEPRECATION NOTICE: this function is deprecated and will be removed in the future.\\n     *      Please use the other deposit or depositV3 instead.\\n     * @notice The only difference between depositFor and deposit is that the depositor address stored\\n     * in the relay hash can be overridden by the caller. This means that the passed in depositor\\n     * can speed up the deposit, which is useful if the deposit is taken from the end user to a middle layer\\n     * contract, like an aggregator or the SpokePoolVerifier, before calling deposit on this contract.\\n     * @notice The caller must first approve this contract to spend amount of originToken.\\n     * @notice The originToken => destinationChainId must be enabled.\\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\\n     * @param depositor Address who is credited for depositing funds on origin chain and can speed up the deposit.\\n     * @param recipient Address to receive funds at on destination chain.\\n     * @param originToken Token to lock into this contract to initiate deposit.\\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\\n     * to LP pool on HubPool.\\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\\n     */\\n    function depositFor(\\n        address depositor,\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 // maxCount. Deprecated.\\n    ) public payable nonReentrant unpausedDeposits {\\n        _deposit(depositor, recipient, originToken, amount, destinationChainId, relayerFeePct, quoteTimestamp, message);\\n    }\\n\\n    /********************************************\\n     *            DEPOSITOR FUNCTIONS           *\\n     ********************************************/\\n\\n    /**\\n     * @notice Previously, this function allowed the caller to specify the exclusivityDeadline, otherwise known as the\\n     * as exact timestamp on the destination chain before which only the exclusiveRelayer could fill the deposit. Now,\\n     * the caller is expected to pass in a number that will be interpreted either as an offset or a fixed\\n     * timestamp depending on its value.\\n     * @notice Request to bridge input token cross chain to a destination chain and receive a specified amount\\n     * of output tokens. The fee paid to relayers and the system should be captured in the spread between output\\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs,\\n     * the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\\n     * window in the HubPool, and the system fee that they'll be charged.\\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\\n     * @param depositor The account credited with the deposit who can request to \\\"speed up\\\" this deposit by modifying\\n     * the output amount, recipient, and message.\\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\\n     * an EOA or wrapped native token if a contract.\\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\\n     * msg.value, as long as msg.value = inputTokenAmount.\\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\\n     * ERC20.\\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\\n     * challenge window in the HubPool, less a system fee.\\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\\n     * as a valid deposit route from this spoke pool or this transaction will revert.\\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\\n     * exclusivity deadline timestamp. This must be a valid, non-zero address if the exclusivity deadline is\\n     * greater than the current block.timestamp. If the exclusivity deadline is < currentTime, then this must be\\n     * address(0), and vice versa if this is address(0).\\n     * @param quoteTimestamp The HubPool timestamp that is used to determine the system fee paid by the depositor.\\n     *  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime]\\n     * where currentTime is block.timestamp on this chain or this transaction will revert.\\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp,\\n     * the fill will revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where\\n     * currentTime is block.timestamp on this chain or this transaction will revert.\\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\\n     * event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address),\\n     * can fill this deposit. There are three ways to use this parameter:\\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\\n     *        meaning that there is no exclusivity period.\\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\\n     */\\n    function deposit(\\n        bytes32 depositor,\\n        bytes32 recipient,\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        bytes32 exclusiveRelayer,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityParameter,\\n        bytes calldata message\\n    ) public payable override nonReentrant unpausedDeposits {\\n        // Increment the `numberOfDeposits` counter to ensure a unique deposit ID for this spoke pool.\\n        DepositV3Params memory params = DepositV3Params({\\n            depositor: depositor,\\n            recipient: recipient,\\n            inputToken: inputToken,\\n            outputToken: outputToken,\\n            inputAmount: inputAmount,\\n            outputAmount: outputAmount,\\n            destinationChainId: destinationChainId,\\n            exclusiveRelayer: exclusiveRelayer,\\n            depositId: numberOfDeposits++,\\n            quoteTimestamp: quoteTimestamp,\\n            fillDeadline: fillDeadline,\\n            exclusivityParameter: exclusivityParameter,\\n            message: message\\n        });\\n        _depositV3(params);\\n    }\\n\\n    /**\\n     * @notice A version of `deposit` that accepts `address` types for backward compatibility.\\n     * This function allows bridging of input tokens cross-chain to a destination chain, receiving a specified amount of output tokens.\\n     * The relayer is refunded in input tokens on a repayment chain of their choice, minus system fees, after an optimistic challenge\\n     * window. The exclusivity period is specified as an offset from the current block timestamp.\\n     *\\n     * @dev This version mirrors the original `depositV3` function, but uses `address` types for `depositor`, `recipient`,\\n     * `inputToken`, `outputToken`, and `exclusiveRelayer` for compatibility with contracts using the `address` type.\\n     *\\n     * The key functionality and logic remain identical, ensuring interoperability across both versions.\\n     *\\n     * @param depositor The account credited with the deposit who can request to \\\"speed up\\\" this deposit by modifying\\n     * the output amount, recipient, and message.\\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\\n     * an EOA or wrapped native token if a contract.\\n     * @param inputToken The token pulled from the caller's account and locked into this contract to initiate the deposit.\\n     * The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal\\n     * to the wrapped native token, the caller can optionally pass in native token as msg.value, provided msg.value = inputTokenAmount.\\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.\\n     * @param inputAmount The amount of input tokens pulled from the caller's account and locked into this contract. This\\n     * amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, less a system fee.\\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token as a valid\\n     * deposit route from this spoke pool or this transaction will revert.\\n     * @param exclusiveRelayer The relayer exclusively allowed to fill this deposit before the exclusivity deadline.\\n     * @param quoteTimestamp The HubPool timestamp that determines the system fee paid by the depositor. This must be set\\n     * between [currentTime - depositQuoteTimeBuffer, currentTime] where currentTime is block.timestamp on this chain.\\n     * @param fillDeadline The deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will\\n     * revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where currentTime is block.timestamp\\n     * on this chain.\\n     * @param exclusivityParameter This value is used to set the exclusivity deadline timestamp in the emitted deposit\\n     * event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address),\\n     * can fill this deposit. There are three ways to use this parameter:\\n     *     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,\\n     *        meaning that there is no exclusivity period.\\n     *     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to\\n     *        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way\\n     *        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed\\n     *        due to a chain-reorg, which would also change the exclusivity timestamp.\\n     *     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp.\\n     * which is the deadline for the exclusiveRelayer to fill the deposit.\\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract. If the\\n     * message is not empty, the recipient contract must implement `handleV3AcrossMessage()` or the fill will revert.\\n     */\\n    function depositV3(\\n        address depositor,\\n        address recipient,\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        address exclusiveRelayer,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityParameter,\\n        bytes calldata message\\n    ) public payable override {\\n        deposit(\\n            depositor.toBytes32(),\\n            recipient.toBytes32(),\\n            inputToken.toBytes32(),\\n            outputToken.toBytes32(),\\n            inputAmount,\\n            outputAmount,\\n            destinationChainId,\\n            exclusiveRelayer.toBytes32(),\\n            quoteTimestamp,\\n            fillDeadline,\\n            exclusivityParameter,\\n            message\\n        );\\n    }\\n\\n    /**\\n     * @notice See deposit for details. This function is identical to deposit except that it does not use the\\n     * global deposit ID counter as a deposit nonce, instead allowing the caller to pass in a deposit nonce. This\\n     * function is designed to be used by anyone who wants to pre-compute their resultant relay data hash, which\\n     * could be useful for filling a deposit faster and avoiding any risk of a relay hash unexpectedly changing\\n     * due to another deposit front-running this one and incrementing the global deposit ID counter.\\n     * @dev This is labeled \\\"unsafe\\\" because there is no guarantee that the depositId emitted in the resultant\\n     * FundsDeposited event is unique which means that the\\n     * corresponding fill might collide with an existing relay hash on the destination chain SpokePool,\\n     * which would make this deposit unfillable. In this case, the depositor would subsequently receive a refund\\n     * of `inputAmount` of `inputToken` on the origin chain after the fill deadline.\\n     * @dev On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so\\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\\n     * all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling\\n     * deposits with deposit hashes that map exactly to the one emitted by this contract.\\n     * @param depositNonce The nonce that uniquely identifies this deposit. This function will combine this parameter\\n     * with the msg.sender address to create a unique uint256 depositNonce and ensure that the msg.sender cannot\\n     * use this function to front-run another depositor's unsafe deposit. This function guarantees that the resultant\\n     * deposit nonce will not collide with a safe uint256 deposit nonce whose 24 most significant bytes are always 0.\\n     * @param depositor See identically named parameter in depositV3() comments.\\n     * @param recipient See identically named parameter in depositV3() comments.\\n     * @param inputToken See identically named parameter in depositV3() comments.\\n     * @param outputToken See identically named parameter in depositV3() comments.\\n     * @param inputAmount See identically named parameter in depositV3() comments.\\n     * @param outputAmount See identically named parameter in depositV3() comments.\\n     * @param destinationChainId See identically named parameter in depositV3() comments.\\n     * @param exclusiveRelayer See identically named parameter in depositV3() comments.\\n     * @param quoteTimestamp See identically named parameter in depositV3() comments.\\n     * @param fillDeadline See identically named parameter in depositV3() comments.\\n     * @param exclusivityParameter See identically named parameter in depositV3() comments.\\n     * @param message See identically named parameter in depositV3() comments.\\n     */\\n    function unsafeDeposit(\\n        bytes32 depositor,\\n        bytes32 recipient,\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        bytes32 exclusiveRelayer,\\n        uint256 depositNonce,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityParameter,\\n        bytes calldata message\\n    ) public payable nonReentrant unpausedDeposits {\\n        // @dev Create the uint256 deposit ID by concatenating the msg.sender and depositor address with the inputted\\n        // depositNonce parameter. The resultant 32 byte string will be hashed and then casted to an \\\"unsafe\\\"\\n        // uint256 deposit ID. The probability that the resultant ID collides with a \\\"safe\\\" deposit ID is\\n        // equal to the chance that the first 28 bytes of the hash are 0, which is too small for us to consider.\\n\\n        uint256 depositId = getUnsafeDepositId(msg.sender, depositor, depositNonce);\\n        DepositV3Params memory params = DepositV3Params({\\n            depositor: depositor,\\n            recipient: recipient,\\n            inputToken: inputToken,\\n            outputToken: outputToken,\\n            inputAmount: inputAmount,\\n            outputAmount: outputAmount,\\n            destinationChainId: destinationChainId,\\n            exclusiveRelayer: exclusiveRelayer,\\n            depositId: depositId,\\n            quoteTimestamp: quoteTimestamp,\\n            fillDeadline: fillDeadline,\\n            exclusivityParameter: exclusivityParameter,\\n            message: message\\n        });\\n        _depositV3(params);\\n    }\\n\\n    /**\\n     * @notice Submits deposit and sets quoteTimestamp to current Time. Sets fill and exclusivity\\n     * deadlines as offsets added to the current time. This function is designed to be called by users\\n     * such as Multisig contracts who do not have certainty when their transaction will mine.\\n     * @param depositor The account credited with the deposit who can request to \\\"speed up\\\" this deposit by modifying\\n     * the output amount, recipient, and message.\\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\\n     * an EOA or wrapped native token if a contract.\\n     * @param inputToken The token pulled from the caller's account and locked into this contract to\\n     * initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent\\n     * as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as\\n     * msg.value, as long as msg.value = inputTokenAmount.\\n     * @param outputToken The token that the relayer will send to the recipient on the destination chain. Must be an\\n     * ERC20.\\n     * @param inputAmount The amount of input tokens to pull from the caller's account and lock into this contract.\\n     * This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic\\n     * challenge window in the HubPool, plus a system fee.\\n     * @param outputAmount The amount of output tokens that the relayer will send to the recipient on the destination.\\n     * @param destinationChainId The destination chain identifier. Must be enabled along with the input token\\n     * as a valid deposit route from this spoke pool or this transaction will revert.\\n     * @param exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\\n     * exclusivity deadline timestamp.\\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline, which is the deadline for the\\n     * relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the\\n     * destination chain.\\n     * @param exclusivityParameter See identically named parameter in deposit() comments.\\n     * @param message The message to send to the recipient on the destination chain if the recipient is a contract.\\n     * If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.\\n     */\\n    function depositNow(\\n        bytes32 depositor,\\n        bytes32 recipient,\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        bytes32 exclusiveRelayer,\\n        uint32 fillDeadlineOffset,\\n        uint32 exclusivityParameter,\\n        bytes calldata message\\n    ) external payable override {\\n        deposit(\\n            depositor,\\n            recipient,\\n            inputToken,\\n            outputToken,\\n            inputAmount,\\n            outputAmount,\\n            destinationChainId,\\n            exclusiveRelayer,\\n            uint32(getCurrentTime()),\\n            uint32(getCurrentTime()) + fillDeadlineOffset,\\n            exclusivityParameter,\\n            message\\n        );\\n    }\\n\\n    /**\\n     * @notice A version of `depositNow` that supports addresses as input types for backward compatibility.\\n     * This function submits a deposit and sets `quoteTimestamp` to the current time. The `fill` and `exclusivity` deadlines\\n     * are set as offsets added to the current time. It is designed to be called by users, including Multisig contracts, who may\\n     * not have certainty when their transaction will be mined.\\n     *\\n     * @dev This version is identical to the original `depositV3Now` but uses `address` types for `depositor`, `recipient`,\\n     * `inputToken`, `outputToken`, and `exclusiveRelayer` to support compatibility with older systems.\\n     * It maintains the same logic and purpose, ensuring interoperability with both versions.\\n     *\\n     * @param depositor The account credited with the deposit, who can request to \\\"speed up\\\" this deposit by modifying\\n     * the output amount, recipient, and message.\\n     * @param recipient The account receiving funds on the destination chain. Can be an EOA or a contract. If\\n     * the output token is the wrapped native token for the chain, then the recipient will receive the native token if\\n     * an EOA or wrapped native token if a contract.\\n     * @param inputToken The token pulled from the caller's account and locked into this contract to initiate the deposit.\\n     * Equivalent tokens on the relayer's repayment chain will be sent as a refund. If this is the wrapped native token,\\n     * msg.value must equal inputTokenAmount when passed.\\n     * @param outputToken The token the relayer will send to the recipient on the destination chain. Must be an ERC20.\\n     * @param inputAmount The amount of input tokens pulled from the caller's account and locked into this contract.\\n     * This amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, plus a system fee.\\n     * @param outputAmount The amount of output tokens the relayer will send to the recipient on the destination.\\n     * @param destinationChainId The destination chain identifier. Must be enabled with the input token as a valid deposit route\\n     * from this spoke pool, or the transaction will revert.\\n     * @param exclusiveRelayer The relayer exclusively allowed to fill the deposit before the exclusivity deadline.\\n     * @param fillDeadlineOffset Added to the current time to set the fill deadline. After this timestamp, fills on the\\n     * destination chain will revert.\\n     * @param exclusivityParameter See identically named parameter in deposit() comments.\\n     * @param message The message to send to the recipient on the destination chain. If the recipient is a contract, it must\\n     * implement `handleV3AcrossMessage()` if the message is not empty, or the fill will revert.\\n     */\\n    function depositV3Now(\\n        address depositor,\\n        address recipient,\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        address exclusiveRelayer,\\n        uint32 fillDeadlineOffset,\\n        uint32 exclusivityParameter,\\n        bytes calldata message\\n    ) external payable override {\\n        depositV3(\\n            depositor,\\n            recipient,\\n            inputToken,\\n            outputToken,\\n            inputAmount,\\n            outputAmount,\\n            destinationChainId,\\n            exclusiveRelayer,\\n            uint32(getCurrentTime()),\\n            uint32(getCurrentTime()) + fillDeadlineOffset,\\n            exclusivityParameter,\\n            message\\n        );\\n    }\\n\\n    /**\\n     * @notice Depositor can use this function to signal to relayer to use updated output amount, recipient,\\n     * and/or message.\\n     * @dev the depositor and depositId must match the params in a FundsDeposited event that the depositor\\n     * wants to speed up. The relayer has the option but not the obligation to use this updated information\\n     * when filling the deposit via fillRelayWithUpdatedDeposit().\\n     * @param depositor Depositor that must sign the depositorSignature and was the original depositor.\\n     * @param depositId Deposit ID to speed up.\\n     * @param updatedOutputAmount New output amount to use for this deposit. Should be lower than previous value\\n     * otherwise relayer has no incentive to use this updated value.\\n     * @param updatedRecipient New recipient to use for this deposit. Can be modified if the recipient is a contract\\n     * that expects to receive a message from the relay and for some reason needs to be modified.\\n     * @param updatedMessage New message to use for this deposit. Can be modified if the recipient is a contract\\n     * that expects to receive a message from the relay and for some reason needs to be modified.\\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\\n     * account. If depositor is a contract, then should implement EIP1271 to sign as a contract. See\\n     * _verifyUpdateV3DepositMessage() for more details about how this signature should be constructed.\\n     */\\n    function speedUpDeposit(\\n        bytes32 depositor,\\n        uint256 depositId,\\n        uint256 updatedOutputAmount,\\n        bytes32 updatedRecipient,\\n        bytes calldata updatedMessage,\\n        bytes calldata depositorSignature\\n    ) public override nonReentrant {\\n        _verifyUpdateV3DepositMessage(\\n            depositor.toAddress(),\\n            depositId,\\n            chainId(),\\n            updatedOutputAmount,\\n            updatedRecipient,\\n            updatedMessage,\\n            depositorSignature,\\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\\n        );\\n\\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\\n        // from the following event to submit a fill with updated relay data.\\n        emit RequestedSpeedUpDeposit(\\n            updatedOutputAmount,\\n            depositId,\\n            depositor,\\n            updatedRecipient,\\n            updatedMessage,\\n            depositorSignature\\n        );\\n    }\\n\\n    /**\\n     * @notice A version of `speedUpDeposit` using `address` types for backward compatibility.\\n     * This function allows the depositor to signal to the relayer to use updated output amount, recipient, and/or message\\n     * when filling a deposit. This can be useful when the deposit needs to be modified after the original transaction has\\n     * been mined.\\n     *\\n     * @dev The `depositor` and `depositId` must match the parameters in a `FundsDeposited` event that the depositor wants to speed up.\\n     * The relayer is not obligated but has the option to use this updated information when filling the deposit using\\n     * `fillRelayWithUpdatedDeposit()`. This version uses `address` types for compatibility with systems relying on\\n     * `address`-based implementations.\\n     *\\n     * @param depositor The depositor that must sign the `depositorSignature` and was the original depositor.\\n     * @param depositId The deposit ID to speed up.\\n     * @param updatedOutputAmount The new output amount to use for this deposit. It should be lower than the previous value,\\n     * otherwise the relayer has no incentive to use this updated value.\\n     * @param updatedRecipient The new recipient for this deposit. Can be modified if the original recipient is a contract that\\n     * expects to receive a message from the relay and needs to be changed.\\n     * @param updatedMessage The new message for this deposit. Can be modified if the recipient is a contract that expects\\n     * to receive a message from the relay and needs to be updated.\\n     * @param depositorSignature The signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account.\\n     * If the depositor is a contract, it should implement EIP1271 to sign as a contract. See `_verifyUpdateV3DepositMessage()`\\n     * for more details on how the signature should be constructed.\\n     */\\n    function speedUpV3Deposit(\\n        address depositor,\\n        uint256 depositId,\\n        uint256 updatedOutputAmount,\\n        address updatedRecipient,\\n        bytes calldata updatedMessage,\\n        bytes calldata depositorSignature\\n    ) public {\\n        _verifyUpdateV3DepositMessage(\\n            depositor,\\n            depositId,\\n            chainId(),\\n            updatedOutputAmount,\\n            updatedRecipient.toBytes32(),\\n            updatedMessage,\\n            depositorSignature,\\n            UPDATE_ADDRESS_DEPOSIT_DETAILS_HASH\\n        );\\n\\n        // Assuming the above checks passed, a relayer can take the signature and the updated deposit information\\n        // from the following event to submit a fill with updated relay data.\\n        emit RequestedSpeedUpDeposit(\\n            updatedOutputAmount,\\n            depositId,\\n            depositor.toBytes32(),\\n            updatedRecipient.toBytes32(),\\n            updatedMessage,\\n            depositorSignature\\n        );\\n    }\\n\\n    /**************************************\\n     *         RELAYER FUNCTIONS          *\\n     **************************************/\\n\\n    /**\\n     * @notice Fulfill request to bridge cross chain by sending specified output tokens to the recipient.\\n     * @dev The fee paid to relayers and the system should be captured in the spread between output\\n     * amount and input amount when adjusted to be denominated in the input token. A relayer on the destination\\n     * chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment\\n     * chain of their choice. Therefore, the fee should account for destination fee transaction costs, the\\n     * relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge\\n     * window in the HubPool, and a system fee charged to relayers.\\n     * @dev The hash of the relayData will be used to uniquely identify the deposit to fill, so\\n     * modifying any params in it will result in a different hash and a different deposit. The hash will comprise\\n     * all parameters passed to deposit() on the origin chain along with that chain's chainId(). This chain's\\n     * chainId() must therefore match the destinationChainId passed into deposit.\\n     * Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the\\n     * origin SpokePool therefore the relayer should not modify any params in relayData.\\n     * @dev Cannot fill more than once. Partial fills are not supported.\\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. Should match\\n     * all the same-named parameters emitted in the origin chain FundsDeposited event.\\n     * - depositor: The account credited with the deposit who can request to \\\"speed up\\\" this deposit by modifying\\n     * the output amount, recipient, and message.\\n     * - recipient The account receiving funds on this chain. Can be an EOA or a contract. If\\n     * the output token is the wrapped native token for the chain, then the recipient will receive native token if\\n     * an EOA or wrapped native token if a contract.\\n     * - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this\\n     * token on the repayment chain will be sent as a refund to the caller.\\n     * - outputToken The token that the caller will send to the recipient on the destination chain. Must be an\\n     * ERC20.\\n     * - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund\\n     * following an optimistic challenge window in the HubPool.\\n     * - outputAmount: The amount of output tokens that the caller will send to the recipient.\\n     * - originChainId: The origin chain identifier.\\n     * - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the\\n     * exclusivity deadline timestamp.\\n     * - fillDeadline The deadline for the caller to fill the deposit. After this timestamp,\\n     * the fill will revert on the destination chain.\\n     * - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this\\n     * timestamp, anyone can fill this deposit. Note that if this value was set in deposit by adding an offset\\n     * to the deposit's block.timestamp, there is re-org risk for the caller of this method because the event's\\n     * block.timestamp can change. Read the comments in `deposit` about the `exclusivityParameter` for more details.\\n     * - message The message to send to the recipient if the recipient is a contract that implements a\\n     * handleV3AcrossMessage() public function\\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\\n     * passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain.\\n     * @param repaymentAddress Address the relayer wants to be receive their refund at.\\n     */\\n    function fillRelay(\\n        V3RelayData memory relayData,\\n        uint256 repaymentChainId,\\n        bytes32 repaymentAddress\\n    ) public override nonReentrant unpausedFills {\\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\\n        // to fill the relay.\\n        if (\\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\\n            relayData.exclusiveRelayer.toAddress() != msg.sender\\n        ) {\\n            revert NotExclusiveRelayer();\\n        }\\n\\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\\n            relay: relayData,\\n            relayHash: getV3RelayHash(relayData),\\n            updatedOutputAmount: relayData.outputAmount,\\n            updatedRecipient: relayData.recipient,\\n            updatedMessage: relayData.message,\\n            repaymentChainId: repaymentChainId\\n        });\\n\\n        _fillRelayV3(relayExecution, repaymentAddress, false);\\n    }\\n\\n    // Exposes the same function as fillRelay but with a legacy V3RelayData struct that takes in address types. Inner\\n    // function fillV3Relay() applies reentrancy & non-paused checks.\\n    function fillV3Relay(V3RelayDataLegacy calldata relayData, uint256 repaymentChainId) public override {\\n        // Convert V3RelayDataLegacy to V3RelayData using the .toBytes32() method.\\n        V3RelayData memory convertedRelayData = V3RelayData({\\n            depositor: relayData.depositor.toBytes32(),\\n            recipient: relayData.recipient.toBytes32(),\\n            exclusiveRelayer: relayData.exclusiveRelayer.toBytes32(),\\n            inputToken: relayData.inputToken.toBytes32(),\\n            outputToken: relayData.outputToken.toBytes32(),\\n            inputAmount: relayData.inputAmount,\\n            outputAmount: relayData.outputAmount,\\n            originChainId: relayData.originChainId,\\n            depositId: relayData.depositId,\\n            fillDeadline: relayData.fillDeadline,\\n            exclusivityDeadline: relayData.exclusivityDeadline,\\n            message: relayData.message\\n        });\\n\\n        fillRelay(convertedRelayData, repaymentChainId, msg.sender.toBytes32());\\n    }\\n\\n    /**\\n     * @notice Identical to fillV3Relay except that the relayer wants to use a depositor's updated output amount,\\n     * recipient, and/or message. The relayer should only use this function if they can supply a message signed\\n     * by the depositor that contains the fill's matching deposit ID along with updated relay parameters.\\n     * If the signature can be verified, then this function will emit a FilledV3Event that will be used by\\n     * the system for refund verification purposes. In other words, this function is an alternative way to fill a\\n     * a deposit than fillV3Relay.\\n     * @dev Subject to same exclusivity deadline rules as fillV3Relay().\\n     * @param relayData struct containing all the data needed to identify the deposit to be filled. See fillV3Relay().\\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\\n     * passed. See fillV3Relay().\\n     * @param repaymentAddress Address the relayer wants to be receive their refund at.\\n     * @param updatedOutputAmount New output amount to use for this deposit.\\n     * @param updatedRecipient New recipient to use for this deposit.\\n     * @param updatedMessage New message to use for this deposit.\\n     * @param depositorSignature Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor\\n     * account.\\n     */\\n    function fillRelayWithUpdatedDeposit(\\n        V3RelayData calldata relayData,\\n        uint256 repaymentChainId,\\n        bytes32 repaymentAddress,\\n        uint256 updatedOutputAmount,\\n        bytes32 updatedRecipient,\\n        bytes calldata updatedMessage,\\n        bytes calldata depositorSignature\\n    ) public override nonReentrant unpausedFills {\\n        // Exclusivity deadline is inclusive and is the latest timestamp that the exclusive relayer has sole right\\n        // to fill the relay.\\n        if (\\n            _fillIsExclusive(relayData.exclusivityDeadline, uint32(getCurrentTime())) &&\\n            relayData.exclusiveRelayer.toAddress() != msg.sender\\n        ) {\\n            revert NotExclusiveRelayer();\\n        }\\n\\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\\n            relay: relayData,\\n            relayHash: getV3RelayHash(relayData),\\n            updatedOutputAmount: updatedOutputAmount,\\n            updatedRecipient: updatedRecipient,\\n            updatedMessage: updatedMessage,\\n            repaymentChainId: repaymentChainId\\n        });\\n\\n        _verifyUpdateV3DepositMessage(\\n            relayData.depositor.toAddress(),\\n            relayData.depositId,\\n            relayData.originChainId,\\n            updatedOutputAmount,\\n            updatedRecipient,\\n            updatedMessage,\\n            depositorSignature,\\n            UPDATE_BYTES32_DEPOSIT_DETAILS_HASH\\n        );\\n\\n        _fillRelayV3(relayExecution, repaymentAddress, false);\\n    }\\n\\n    /**\\n     * @notice Request Across to send LP funds to this contract to fulfill a slow fill relay\\n     * for a deposit in the next bundle.\\n     * @dev Slow fills are not possible unless the input and output tokens are \\\"equivalent\\\", i.e.\\n     * they route to the same L1 token via PoolRebalanceRoutes.\\n     * @dev Slow fills are created by inserting slow fill objects into a merkle tree that is included\\n     * in the next HubPool \\\"root bundle\\\". Once the optimistic challenge window has passed, the HubPool\\n     * will relay the slow root to this chain via relayRootBundle(). Once the slow root is relayed,\\n     * the slow fill can be executed by anyone who calls executeSlowRelayLeaf().\\n     * @dev Cannot request a slow fill if the fill deadline has passed.\\n     * @dev Cannot request a slow fill if the relay has already been filled or a slow fill has already been requested.\\n     * @param relayData struct containing all the data needed to identify the deposit that should be\\n     * slow filled. If any of the params are missing or different from the origin chain deposit,\\n     * then Across will not include a slow fill for the intended deposit.\\n     */\\n    function requestSlowFill(V3RelayData calldata relayData) public override nonReentrant unpausedFills {\\n        uint32 currentTime = uint32(getCurrentTime());\\n        // If a depositor has set an exclusivity deadline, then only the exclusive relayer should be able to\\n        // fast fill within this deadline. Moreover, the depositor should expect to get *fast* filled within\\n        // this deadline, not slow filled. As a simplifying assumption, we will not allow slow fills to be requested\\n        // during this exclusivity period.\\n        if (_fillIsExclusive(relayData.exclusivityDeadline, currentTime)) {\\n            revert NoSlowFillsInExclusivityWindow();\\n        }\\n        if (relayData.fillDeadline < currentTime) revert ExpiredFillDeadline();\\n\\n        bytes32 relayHash = getV3RelayHash(relayData);\\n        if (fillStatuses[relayHash] != uint256(FillStatus.Unfilled)) revert InvalidSlowFillRequest();\\n        fillStatuses[relayHash] = uint256(FillStatus.RequestedSlowFill);\\n\\n        emit RequestedSlowFill(\\n            relayData.inputToken,\\n            relayData.outputToken,\\n            relayData.inputAmount,\\n            relayData.outputAmount,\\n            relayData.originChainId,\\n            relayData.depositId,\\n            relayData.fillDeadline,\\n            relayData.exclusivityDeadline,\\n            relayData.exclusiveRelayer,\\n            relayData.depositor,\\n            relayData.recipient,\\n            _hashNonEmptyMessage(relayData.message)\\n        );\\n    }\\n\\n    /**\\n     * @notice Fills a single leg of a particular order on the destination chain\\n     * @dev ERC-7683 fill function.\\n     * @param orderId Unique order identifier for this order\\n     * @param originData Data emitted on the origin to parameterize the fill\\n     * @param fillerData Data provided by the filler to inform the fill or express their preferences\\n     */\\n    function fill(\\n        bytes32 orderId,\\n        bytes calldata originData,\\n        bytes calldata fillerData\\n    ) external {\\n        if (keccak256(abi.encode(originData, chainId())) != orderId) {\\n            revert WrongERC7683OrderId();\\n        }\\n\\n        // Ensure that the call is not malformed. If the call is malformed, abi.decode will fail.\\n        V3SpokePoolInterface.V3RelayData memory relayData = abi.decode(originData, (V3SpokePoolInterface.V3RelayData));\\n        AcrossDestinationFillerData memory destinationFillerData = abi.decode(\\n            fillerData,\\n            (AcrossDestinationFillerData)\\n        );\\n\\n        // Must do a delegatecall because the function requires the inputs to be calldata.\\n        (bool success, bytes memory data) = address(this).delegatecall(\\n            abi.encodeCall(\\n                V3SpokePoolInterface.fillRelay,\\n                (relayData, destinationFillerData.repaymentChainId, msg.sender.toBytes32())\\n            )\\n        );\\n        if (!success) {\\n            revert LowLevelCallFailed(data);\\n        }\\n    }\\n\\n    /**************************************\\n     *         DATA WORKER FUNCTIONS      *\\n     **************************************/\\n\\n    /**\\n     * @notice Executes a slow relay leaf stored as part of a root bundle relayed by the HubPool.\\n     * @dev Executing a slow fill leaf is equivalent to filling the relayData so this function cannot be used to\\n     * double fill a recipient. The relayData that is filled is included in the slowFillLeaf and is hashed\\n     * like any other fill sent through a fill method.\\n     * @dev There is no relayer credited with filling this relay since funds are sent directly out of this contract.\\n     * @param slowFillLeaf Contains all data necessary to uniquely identify a relay for this chain. This struct is\\n     * hashed and included in a merkle root that is relayed to all spoke pools.\\n     * - relayData: struct containing all the data needed to identify the original deposit to be slow filled.\\n     * - chainId: chain identifier where slow fill leaf should be executed. If this doesn't match this chain's\\n     * chainId, then this function will revert.\\n     * - updatedOutputAmount: Amount to be sent to recipient out of this contract's balance. Can be set differently\\n     * from relayData.outputAmount to charge a different fee because this deposit was \\\"slow\\\" filled. Usually,\\n     * this will be set higher to reimburse the recipient for waiting for the slow fill.\\n     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.\\n     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.\\n     */\\n    function executeSlowRelayLeaf(\\n        V3SlowFill calldata slowFillLeaf,\\n        uint32 rootBundleId,\\n        bytes32[] calldata proof\\n    ) public override nonReentrant {\\n        V3RelayData memory relayData = slowFillLeaf.relayData;\\n\\n        _preExecuteLeafHook(relayData.outputToken.toAddress());\\n\\n        // @TODO In the future consider allowing way for slow fill leaf to be created with updated\\n        // deposit params like outputAmount, message and recipient.\\n        V3RelayExecutionParams memory relayExecution = V3RelayExecutionParams({\\n            relay: relayData,\\n            relayHash: getV3RelayHash(relayData),\\n            updatedOutputAmount: slowFillLeaf.updatedOutputAmount,\\n            updatedRecipient: relayData.recipient,\\n            updatedMessage: relayData.message,\\n            repaymentChainId: EMPTY_REPAYMENT_CHAIN_ID // Repayment not relevant for slow fills.\\n        });\\n\\n        _verifyV3SlowFill(relayExecution, rootBundleId, proof);\\n\\n        // - No relayer to refund for slow fill executions.\\n        _fillRelayV3(relayExecution, EMPTY_RELAYER, true);\\n    }\\n\\n    /**\\n     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they\\n     * sent to the recipient plus a relayer fee.\\n     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.\\n     * @param relayerRefundLeaf Contains all data necessary to reconstruct leaf contained in root bundle and to\\n     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.\\n     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.\\n     */\\n    function executeRelayerRefundLeaf(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) public payable virtual override nonReentrant {\\n        _preExecuteLeafHook(relayerRefundLeaf.l2TokenAddress);\\n\\n        if (relayerRefundLeaf.chainId != chainId()) revert InvalidChainId();\\n\\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\\n\\n        // Check that proof proves that relayerRefundLeaf is contained within the relayer refund root.\\n        // Note: This should revert if the relayerRefundRoot is uninitialized.\\n        if (!MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof)) {\\n            revert InvalidMerkleProof();\\n        }\\n\\n        _setClaimedLeaf(rootBundleId, relayerRefundLeaf.leafId);\\n\\n        bool deferredRefunds = _distributeRelayerRefunds(\\n            relayerRefundLeaf.chainId,\\n            relayerRefundLeaf.amountToReturn,\\n            relayerRefundLeaf.refundAmounts,\\n            relayerRefundLeaf.leafId,\\n            relayerRefundLeaf.l2TokenAddress,\\n            relayerRefundLeaf.refundAddresses\\n        );\\n\\n        emit ExecutedRelayerRefundRoot(\\n            relayerRefundLeaf.amountToReturn,\\n            relayerRefundLeaf.chainId,\\n            relayerRefundLeaf.refundAmounts,\\n            rootBundleId,\\n            relayerRefundLeaf.leafId,\\n            relayerRefundLeaf.l2TokenAddress,\\n            relayerRefundLeaf.refundAddresses,\\n            deferredRefunds,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @notice Enables a relayer to claim outstanding repayments. Should virtually never be used, unless for some reason\\n     * relayer repayment transfer fails for reasons such as token transfer reverts due to blacklisting. In this case,\\n     * the relayer can still call this method and claim the tokens to a new address.\\n     * @param l2TokenAddress Address of the L2 token to claim refunds for.\\n     * @param refundAddress Address to send the refund to.\\n     */\\n    function claimRelayerRefund(bytes32 l2TokenAddress, bytes32 refundAddress) external {\\n        uint256 refund = relayerRefund[l2TokenAddress.toAddress()][msg.sender];\\n        if (refund == 0) revert NoRelayerRefundToClaim();\\n        relayerRefund[l2TokenAddress.toAddress()][msg.sender] = 0;\\n        IERC20Upgradeable(l2TokenAddress.toAddress()).safeTransfer(refundAddress.toAddress(), refund);\\n\\n        emit ClaimedRelayerRefund(l2TokenAddress, refundAddress, refund, msg.sender);\\n    }\\n\\n    /**************************************\\n     *           VIEW FUNCTIONS           *\\n     **************************************/\\n\\n    /**\\n     * @notice Returns chain ID for this network.\\n     * @dev Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\\n     */\\n    function chainId() public view virtual override returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    /**\\n     * @notice Gets the current time.\\n     * @return uint for the current timestamp.\\n     */\\n    function getCurrentTime() public view virtual returns (uint256) {\\n        return block.timestamp; // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /**\\n     * @notice Returns the deposit ID for an unsafe deposit. This function is used to compute the deposit ID\\n     * in unsafeDeposit and is provided as a convenience.\\n     * @dev msgSender and depositor are both used as inputs to allow passthrough depositors to create unique\\n     * deposit hash spaces for unique depositors.\\n     * @param msgSender The caller of the transaction used as input to produce the deposit ID.\\n     * @param depositor The depositor address used as input to produce the deposit ID.\\n     * @param depositNonce The nonce used as input to produce the deposit ID.\\n     * @return The deposit ID for the unsafe deposit.\\n     */\\n    function getUnsafeDepositId(\\n        address msgSender,\\n        bytes32 depositor,\\n        uint256 depositNonce\\n    ) public pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(msgSender, depositor, depositNonce)));\\n    }\\n\\n    function getRelayerRefund(address l2TokenAddress, address refundAddress) public view returns (uint256) {\\n        return relayerRefund[l2TokenAddress][refundAddress];\\n    }\\n\\n    function getV3RelayHash(V3RelayData memory relayData) public view returns (bytes32) {\\n        return keccak256(abi.encode(relayData, chainId()));\\n    }\\n\\n    /**************************************\\n     *         INTERNAL FUNCTIONS         *\\n     **************************************/\\n\\n    function _depositV3(DepositV3Params memory params) internal {\\n        // Verify depositor is a valid EVM address.\\n        params.depositor.checkAddress();\\n\\n        // Check that deposit route is enabled for the input token. There are no checks required for the output token\\n        // which is pulled from the relayer at fill time and passed through this contract atomically to the recipient.\\n        if (!enabledDepositRoutes[params.inputToken.toAddress()][params.destinationChainId]) revert DisabledRoute();\\n\\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\\n        // within the configured buffer. The owner should pause deposits/fills if this is undesirable.\\n        // This will underflow if quoteTimestamp is more than depositQuoteTimeBuffer;\\n        // this is safe but will throw an unintuitive error.\\n\\n        // slither-disable-next-line timestamp\\n        uint256 currentTime = getCurrentTime();\\n        if (currentTime < params.quoteTimestamp || currentTime - params.quoteTimestamp > depositQuoteTimeBuffer)\\n            revert InvalidQuoteTimestamp();\\n\\n        // fillDeadline is relative to the destination chain.\\n        // Don\\u2019t allow fillDeadline to be more than several bundles into the future.\\n        // This limits the maximum required lookback for dataworker and relayer instances.\\n        if (params.fillDeadline > currentTime + fillDeadlineBuffer) revert InvalidFillDeadline();\\n\\n        // There are three cases for setting the exclusivity deadline using the exclusivity parameter:\\n        // 1. If this parameter is 0, then there is no exclusivity period and emit 0 for the deadline. This\\n        //    means that fillers of this deposit do not have to worry about the block.timestamp of this event changing\\n        //    due to re-orgs when filling this deposit.\\n        // 2. If the exclusivity parameter is less than or equal to MAX_EXCLUSIVITY_PERIOD_SECONDS, then the exclusivity\\n        //    deadline is set to the block.timestamp of this event plus the exclusivity parameter. This means that the\\n        //    filler of this deposit assumes re-org risk when filling this deposit because the block.timestamp of this\\n        //    event affects the exclusivity deadline.\\n        // 3. Otherwise, interpret this parameter as a timestamp and emit it as the exclusivity deadline. This means\\n        //    that the filler of this deposit will not assume re-org risk related to the block.timestamp of this\\n        //    event changing.\\n        uint32 exclusivityDeadline = params.exclusivityParameter;\\n        if (exclusivityDeadline > 0) {\\n            if (exclusivityDeadline <= MAX_EXCLUSIVITY_PERIOD_SECONDS) {\\n                exclusivityDeadline += uint32(currentTime);\\n            }\\n\\n            // As a safety measure, prevent caller from inadvertently locking funds during exclusivity period\\n            //  by forcing them to specify an exclusive relayer.\\n            if (params.exclusiveRelayer == bytes32(0)) revert InvalidExclusiveRelayer();\\n        }\\n\\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\\n        // transaction then the user is sending the native token. In this case, the native token should be\\n        // wrapped.\\n        if (params.inputToken == address(wrappedNativeToken).toBytes32() && msg.value > 0) {\\n            if (msg.value != params.inputAmount) revert MsgValueDoesNotMatchInputAmount();\\n            wrappedNativeToken.deposit{ value: msg.value }();\\n            // Else, it is a normal ERC20. In this case pull the token from the caller as per normal.\\n            // Note: this includes the case where the L2 caller has WETH (already wrapped ETH) and wants to bridge them.\\n            // In this case the msg.value will be set to 0, indicating a \\\"normal\\\" ERC20 bridging action.\\n        } else {\\n            // msg.value should be 0 if input token isn't the wrapped native token.\\n            if (msg.value != 0) revert MsgValueDoesNotMatchInputAmount();\\n            IERC20Upgradeable(params.inputToken.toAddress()).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                params.inputAmount\\n            );\\n        }\\n\\n        emit FundsDeposited(\\n            params.inputToken,\\n            params.outputToken,\\n            params.inputAmount,\\n            params.outputAmount,\\n            params.destinationChainId,\\n            params.depositId,\\n            params.quoteTimestamp,\\n            params.fillDeadline,\\n            exclusivityDeadline,\\n            params.depositor,\\n            params.recipient,\\n            params.exclusiveRelayer,\\n            params.message\\n        );\\n    }\\n\\n    function _deposit(\\n        address depositor,\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message\\n    ) internal {\\n        // Check that deposit route is enabled.\\n        if (!enabledDepositRoutes[originToken][destinationChainId]) revert DisabledRoute();\\n\\n        // We limit the relay fees to prevent the user spending all their funds on fees.\\n        if (SignedMath.abs(relayerFeePct) >= 0.5e18) revert InvalidRelayerFeePct();\\n        if (amount > MAX_TRANSFER_SIZE) revert MaxTransferSizeExceeded();\\n\\n        // Require that quoteTimestamp has a maximum age so that depositors pay an LP fee based on recent HubPool usage.\\n        // It is assumed that cross-chain timestamps are normally loosely in-sync, but clock drift can occur. If the\\n        // SpokePool time stalls or lags significantly, it is still possible to make deposits by setting quoteTimestamp\\n        // within the configured buffer. The owner should pause deposits if this is undesirable. This will underflow if\\n        // quoteTimestamp is more than depositQuoteTimeBuffer; this is safe but will throw an unintuitive error.\\n\\n        // slither-disable-next-line timestamp\\n        if (getCurrentTime() - quoteTimestamp > depositQuoteTimeBuffer) revert InvalidQuoteTimestamp();\\n\\n        // Increment count of deposits so that deposit ID for this spoke pool is unique.\\n        uint32 newDepositId = numberOfDeposits++;\\n\\n        // If the address of the origin token is a wrappedNativeToken contract and there is a msg.value with the\\n        // transaction then the user is sending ETH. In this case, the ETH should be deposited to wrappedNativeToken.\\n        if (originToken == address(wrappedNativeToken) && msg.value > 0) {\\n            if (msg.value != amount) revert MsgValueDoesNotMatchInputAmount();\\n            wrappedNativeToken.deposit{ value: msg.value }();\\n            // Else, it is a normal ERC20. In this case pull the token from the user's wallet as per normal.\\n            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them.\\n            // In this case the msg.value will be set to 0, indicating a \\\"normal\\\" ERC20 bridging action.\\n        } else {\\n            IERC20Upgradeable(originToken).safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n\\n        emit FundsDeposited(\\n            originToken.toBytes32(), // inputToken\\n            bytes32(0), // outputToken. Setting this to 0x0 means that the outputToken should be assumed to be the\\n            // canonical token for the destination chain matching the inputToken. Therefore, this deposit\\n            // can always be slow filled.\\n            // - setting token to 0x0 will signal to off-chain validator that the \\\"equivalent\\\"\\n            // token as the inputToken for the destination chain should be replaced here.\\n            amount, // inputAmount\\n            _computeAmountPostFees(amount, relayerFeePct), // outputAmount\\n            // - output amount will be the deposit amount less relayerFeePct, which should now be set\\n            // equal to realizedLpFeePct + gasFeePct + capitalCostFeePct where (gasFeePct + capitalCostFeePct)\\n            // is equal to the old usage of `relayerFeePct`.\\n            destinationChainId,\\n            newDepositId,\\n            quoteTimestamp,\\n            INFINITE_FILL_DEADLINE, // fillDeadline. Default to infinite expiry because\\n            // expired deposits refunds could be a breaking change for existing users of this function.\\n            0, // exclusivityDeadline. Setting this to 0 along with the exclusiveRelayer to 0x0 means that there\\n            // is no exclusive deadline\\n            depositor.toBytes32(),\\n            recipient.toBytes32(),\\n            bytes32(0), // exclusiveRelayer. Setting this to 0x0 will signal to off-chain validator that there\\n            // is no exclusive relayer.\\n            message\\n        );\\n    }\\n\\n    function _distributeRelayerRefunds(\\n        uint256 _chainId,\\n        uint256 amountToReturn,\\n        uint256[] memory refundAmounts,\\n        uint32 leafId,\\n        address l2TokenAddress,\\n        address[] memory refundAddresses\\n    ) internal returns (bool deferredRefunds) {\\n        uint256 numRefunds = refundAmounts.length;\\n        if (refundAddresses.length != numRefunds) revert InvalidMerkleLeaf();\\n\\n        if (numRefunds > 0) {\\n            uint256 spokeStartBalance = IERC20Upgradeable(l2TokenAddress).balanceOf(address(this));\\n            uint256 totalRefundedAmount = 0; // Track the total amount refunded.\\n\\n            // Send each relayer refund address the associated refundAmount for the L2 token address.\\n            // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.\\n            for (uint256 i = 0; i < numRefunds; ++i) {\\n                if (refundAmounts[i] > 0) {\\n                    totalRefundedAmount += refundAmounts[i];\\n\\n                    // Only if the total refunded amount exceeds the spoke starting balance, should we revert. This\\n                    // ensures that bundles are atomic, if we have sufficient balance to refund all relayers and\\n                    // prevents can only re-pay some of the relayers.\\n                    if (totalRefundedAmount > spokeStartBalance) revert InsufficientSpokePoolBalanceToExecuteLeaf();\\n\\n                    bool success = _noRevertTransfer(l2TokenAddress, refundAddresses[i], refundAmounts[i]);\\n\\n                    // If the transfer failed then track a deferred transfer for the relayer. Given this function would\\n                    // have reverted if there was insufficient balance, this will only happen if the transfer call\\n                    // reverts. This will only occur if the underlying transfer method on the l2Token reverts due to\\n                    // recipient blacklisting or other related modifications to the l2Token.transfer method.\\n                    if (!success) {\\n                        relayerRefund[l2TokenAddress][refundAddresses[i]] += refundAmounts[i];\\n                        deferredRefunds = true;\\n                    }\\n                }\\n            }\\n        }\\n        // If leaf's amountToReturn is positive, then send L2 --> L1 message to bridge tokens back via\\n        // chain-specific bridging method.\\n        if (amountToReturn > 0) {\\n            _bridgeTokensToHubPool(amountToReturn, l2TokenAddress);\\n\\n            emit TokensBridged(amountToReturn, _chainId, leafId, l2TokenAddress.toBytes32(), msg.sender);\\n        }\\n    }\\n\\n    // Re-implementation of OZ _callOptionalReturnBool to use private logic. Function executes a transfer and returns a\\n    // bool indicating if the external call was successful, rather than reverting. Original method:\\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/28aed34dc5e025e61ea0390c18cac875bfde1a78/contracts/token/ERC20/utils/SafeERC20.sol#L188\\n    function _noRevertTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        bytes memory data = abi.encodeCall(IERC20Upgradeable.transfer, (to, amount));\\n        assembly {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\\n    }\\n\\n    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {\\n        if (newCrossDomainAdmin == address(0)) revert InvalidCrossDomainAdmin();\\n        crossDomainAdmin = newCrossDomainAdmin;\\n        emit SetXDomainAdmin(newCrossDomainAdmin);\\n    }\\n\\n    function _setWithdrawalRecipient(address newWithdrawalRecipient) internal {\\n        if (newWithdrawalRecipient == address(0)) revert InvalidWithdrawalRecipient();\\n        withdrawalRecipient = newWithdrawalRecipient;\\n        emit SetWithdrawalRecipient(newWithdrawalRecipient);\\n    }\\n\\n    function _preExecuteLeafHook(address) internal virtual {\\n        // This method by default is a no-op. Different child spoke pools might want to execute functionality here\\n        // such as wrapping any native tokens owned by the contract into wrapped tokens before proceeding with\\n        // executing the leaf.\\n    }\\n\\n    // Should be overriden by implementing contract depending on how L2 handles sending tokens to L1.\\n    function _bridgeTokensToHubPool(uint256 amountToReturn, address l2TokenAddress) internal virtual;\\n\\n    function _setClaimedLeaf(uint32 rootBundleId, uint32 leafId) internal {\\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\\n\\n        // Verify the leafId in the leaf has not yet been claimed.\\n        if (MerkleLib.isClaimed(rootBundle.claimedBitmap, leafId)) revert ClaimedMerkleLeaf();\\n\\n        // Set leaf as claimed in bitmap. This is passed by reference to the storage rootBundle.\\n        MerkleLib.setClaimed(rootBundle.claimedBitmap, leafId);\\n    }\\n\\n    function _verifyUpdateV3DepositMessage(\\n        address depositor,\\n        uint256 depositId,\\n        uint256 originChainId,\\n        uint256 updatedOutputAmount,\\n        bytes32 updatedRecipient,\\n        bytes memory updatedMessage,\\n        bytes memory depositorSignature,\\n        bytes32 hashType\\n    ) internal view {\\n        // A depositor can request to modify an un-relayed deposit by signing a hash containing the updated\\n        // details and information uniquely identifying the deposit to relay. This information ensures\\n        // that this signature cannot be re-used for other deposits.\\n        bytes32 expectedTypedDataV4Hash = _hashTypedDataV4(\\n            keccak256(\\n                abi.encode(\\n                    hashType,\\n                    depositId,\\n                    originChainId,\\n                    updatedOutputAmount,\\n                    updatedRecipient,\\n                    keccak256(updatedMessage)\\n                )\\n            ),\\n            originChainId\\n        );\\n        _verifyDepositorSignature(depositor, expectedTypedDataV4Hash, depositorSignature);\\n    }\\n\\n    // This function is isolated and made virtual to allow different L2's to implement chain specific recovery of\\n    // signers from signatures because some L2s might not support ecrecover. To be safe, consider always reverting\\n    // this function for L2s where ecrecover is different from how it works on Ethereum, otherwise there is the\\n    // potential to forge a signature from the depositor using a different private key than the original depositor's.\\n    function _verifyDepositorSignature(\\n        address depositor,\\n        bytes32 ethSignedMessageHash,\\n        bytes memory depositorSignature\\n    ) internal view virtual {\\n        // Note:\\n        // - We don't need to worry about re-entrancy from a contract deployed at the depositor address since the method\\n        //   `SignatureChecker.isValidSignatureNow` is a view method. Re-entrancy can happen, but it cannot affect state.\\n        // - EIP-1271 signatures are supported. This means that a signature valid now, may not be valid later and vice-versa.\\n        // - For an EIP-1271 signature to work, the depositor contract address must map to a deployed contract on the destination\\n        //   chain that can validate the signature.\\n        // - Regular signatures from an EOA are also supported.\\n        bool isValid = SignatureChecker.isValidSignatureNow(depositor, ethSignedMessageHash, depositorSignature);\\n        if (!isValid) revert InvalidDepositorSignature();\\n    }\\n\\n    function _verifyV3SlowFill(\\n        V3RelayExecutionParams memory relayExecution,\\n        uint32 rootBundleId,\\n        bytes32[] memory proof\\n    ) internal view {\\n        V3SlowFill memory slowFill = V3SlowFill({\\n            relayData: relayExecution.relay,\\n            chainId: chainId(),\\n            updatedOutputAmount: relayExecution.updatedOutputAmount\\n        });\\n\\n        if (!MerkleLib.verifyV3SlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, slowFill, proof)) {\\n            revert InvalidMerkleProof();\\n        }\\n    }\\n\\n    function _computeAmountPostFees(uint256 amount, int256 feesPct) private pure returns (uint256) {\\n        return (amount * uint256(int256(1e18) - feesPct)) / 1e18;\\n    }\\n\\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends wrappedNativeToken.\\n    function _unwrapwrappedNativeTokenTo(address payable to, uint256 amount) internal {\\n        if (address(to).isContract()) {\\n            IERC20Upgradeable(address(wrappedNativeToken)).safeTransfer(to, amount);\\n        } else {\\n            wrappedNativeToken.withdraw(amount);\\n            AddressLibUpgradeable.sendValue(to, amount);\\n        }\\n    }\\n\\n    // @param relayer: relayer who is actually credited as filling this deposit. Can be different from\\n    // exclusiveRelayer if passed exclusivityDeadline or if slow fill.\\n    function _fillRelayV3(\\n        V3RelayExecutionParams memory relayExecution,\\n        bytes32 relayer,\\n        bool isSlowFill\\n    ) internal {\\n        V3RelayData memory relayData = relayExecution.relay;\\n\\n        if (relayData.fillDeadline < getCurrentTime()) revert ExpiredFillDeadline();\\n\\n        bytes32 relayHash = relayExecution.relayHash;\\n\\n        // If a slow fill for this fill was requested then the relayFills value for this hash will be\\n        // FillStatus.RequestedSlowFill. Therefore, if this is the status, then this fast fill\\n        // will be replacing the slow fill. If this is a slow fill execution, then the following variable\\n        // is trivially true. We'll emit this value in the FilledRelay\\n        // event to assist the Dataworker in knowing when to return funds back to the HubPool that can no longer\\n        // be used for a slow fill execution.\\n        FillType fillType = isSlowFill\\n            ? FillType.SlowFill // The following is true if this is a fast fill that was sent after a slow fill request.\\n            : (\\n                fillStatuses[relayExecution.relayHash] == uint256(FillStatus.RequestedSlowFill)\\n                    ? FillType.ReplacedSlowFill\\n                    : FillType.FastFill\\n            );\\n\\n        // @dev This function doesn't support partial fills. Therefore, we associate the relay hash with\\n        // an enum tracking its fill status. All filled relays, whether slow or fast fills, are set to the Filled\\n        // status. However, we also use this slot to track whether this fill had a slow fill requested. Therefore\\n        // we can include a bool in the FilledRelay event making it easy for the dataworker to compute if this\\n        // fill was a fast fill that replaced a slow fill and therefore this SpokePool has excess funds that it\\n        // needs to send back to the HubPool.\\n        if (fillStatuses[relayHash] == uint256(FillStatus.Filled)) revert RelayFilled();\\n        fillStatuses[relayHash] = uint256(FillStatus.Filled);\\n\\n        // @dev Before returning early, emit events to assist the dataworker in being able to know which fills were\\n        // successful.\\n        emit FilledRelay(\\n            relayData.inputToken,\\n            relayData.outputToken,\\n            relayData.inputAmount,\\n            relayData.outputAmount,\\n            relayExecution.repaymentChainId,\\n            relayData.originChainId,\\n            relayData.depositId,\\n            relayData.fillDeadline,\\n            relayData.exclusivityDeadline,\\n            relayData.exclusiveRelayer,\\n            relayer,\\n            relayData.depositor,\\n            relayData.recipient,\\n            _hashNonEmptyMessage(relayData.message),\\n            V3RelayExecutionEventInfo({\\n                updatedRecipient: relayExecution.updatedRecipient,\\n                updatedMessageHash: _hashNonEmptyMessage(relayExecution.updatedMessage),\\n                updatedOutputAmount: relayExecution.updatedOutputAmount,\\n                fillType: fillType\\n            })\\n        );\\n\\n        address outputToken = relayData.outputToken.toAddress();\\n        uint256 amountToSend = relayExecution.updatedOutputAmount;\\n        address recipientToSend = relayExecution.updatedRecipient.toAddress();\\n        // If relay token is wrappedNativeToken then unwrap and send native token.\\n        // Stack too deep.\\n        if (relayData.outputToken.toAddress() == address(wrappedNativeToken)) {\\n            // Note: useContractFunds is True if we want to send funds to the recipient directly out of this contract,\\n            // otherwise we expect the caller to send funds to the recipient. If useContractFunds is True and the\\n            // recipient wants wrappedNativeToken, then we can assume that wrappedNativeToken is already in the\\n            // contract, otherwise we'll need the user to send wrappedNativeToken to this contract. Regardless, we'll\\n            // need to unwrap it to native token before sending to the user.\\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, address(this), amountToSend);\\n            _unwrapwrappedNativeTokenTo(payable(recipientToSend), amountToSend);\\n            // Else, this is a normal ERC20 token. Send to recipient.\\n        } else {\\n            // Note: Similar to note above, send token directly from the contract to the user in the slow relay case.\\n            if (!isSlowFill) IERC20Upgradeable(outputToken).safeTransferFrom(msg.sender, recipientToSend, amountToSend);\\n            else IERC20Upgradeable(outputToken).safeTransfer(recipientToSend, amountToSend);\\n        }\\n\\n        bytes memory updatedMessage = relayExecution.updatedMessage;\\n        if (updatedMessage.length > 0 && recipientToSend.isContract()) {\\n            AcrossMessageHandler(recipientToSend).handleV3AcrossMessage(\\n                outputToken,\\n                amountToSend,\\n                msg.sender,\\n                updatedMessage\\n            );\\n        }\\n    }\\n\\n    // Determine whether the exclusivityDeadline implies active exclusivity.\\n    function _fillIsExclusive(uint32 exclusivityDeadline, uint32 currentTime) internal pure returns (bool) {\\n        return exclusivityDeadline >= currentTime;\\n    }\\n\\n    // Helper for emitting message hash. For easier easier human readability we return bytes32(0) for empty message.\\n    function _hashNonEmptyMessage(bytes memory message) internal pure returns (bytes32) {\\n        if (message.length == 0) return bytes32(0);\\n        else return keccak256(message);\\n    }\\n\\n    // Implementing contract needs to override this to ensure that only the appropriate cross chain admin can execute\\n    // certain admin functions. For L2 contracts, the cross chain admin refers to some L1 address or contract, and for\\n    // L1, this would just be the same admin of the HubPool.\\n    function _requireAdminSender() internal virtual;\\n\\n    // Added to enable the this contract to receive native token (ETH). Used when unwrapping wrappedNativeToken.\\n    receive() external payable {}\\n\\n    // Reserve storage slots for future versions of this base contract to add state variables without\\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\\n    uint256[998] private __gap;\\n}\\n\",\"keccak256\":\"0x62c641e112f07f831e4141dcb6b2f5dade3e60b2c85ebb72d553e036742126fd\",\"license\":\"BUSL-1.1\"},\"contracts/erc7683/ERC7683.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title GaslessCrossChainOrder CrossChainOrder type\\n/// @notice Standard order struct to be signed by users, disseminated to fillers, and submitted to origin settler contracts\\nstruct GaslessCrossChainOrder {\\n    /// @dev The contract address that the order is meant to be settled by.\\n    /// Fillers send this order to this contract address on the origin chain\\n    address originSettler;\\n    /// @dev The address of the user who is initiating the swap,\\n    /// whose input tokens will be taken and escrowed\\n    address user;\\n    /// @dev Nonce to be used as replay protection for the order\\n    uint256 nonce;\\n    /// @dev The chainId of the origin chain\\n    uint256 originChainId;\\n    /// @dev The timestamp by which the order must be opened\\n    uint32 openDeadline;\\n    /// @dev The timestamp by which the order must be filled on the destination chain\\n    uint32 fillDeadline;\\n    /// @dev Type identifier for the order data. This is an EIP-712 typehash.\\n    bytes32 orderDataType;\\n    /// @dev Arbitrary implementation-specific data\\n    /// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,\\n    /// or any other order-type specific information\\n    bytes orderData;\\n}\\n\\n/// @title OnchainCrossChainOrder CrossChainOrder type\\n/// @notice Standard order struct for user-opened orders, where the user is the msg.sender.\\nstruct OnchainCrossChainOrder {\\n    /// @dev The timestamp by which the order must be filled on the destination chain\\n    uint32 fillDeadline;\\n    /// @dev Type identifier for the order data. This is an EIP-712 typehash.\\n    bytes32 orderDataType;\\n    /// @dev Arbitrary implementation-specific data\\n    /// Can be used to define tokens, amounts, destination chains, fees, settlement parameters,\\n    /// or any other order-type specific information\\n    bytes orderData;\\n}\\n\\n/// @title ResolvedCrossChainOrder type\\n/// @notice An implementation-generic representation of an order intended for filler consumption\\n/// @dev Defines all requirements for filling an order by unbundling the implementation-specific orderData.\\n/// @dev Intended to improve integration generalization by allowing fillers to compute the exact input and output information of any order\\nstruct ResolvedCrossChainOrder {\\n    /// @dev The address of the user who is initiating the transfer\\n    address user;\\n    /// @dev The chainId of the origin chain\\n    uint256 originChainId;\\n    /// @dev The timestamp by which the order must be opened\\n    uint32 openDeadline;\\n    /// @dev The timestamp by which the order must be filled on the destination chain(s)\\n    uint32 fillDeadline;\\n    /// @dev The unique identifier for this order within this settlement system\\n    bytes32 orderId;\\n    /// @dev The max outputs that the filler will send. It's possible the actual amount depends on the state of the destination\\n    ///      chain (destination dutch auction, for instance), so these outputs should be considered a cap on filler liabilities.\\n    Output[] maxSpent;\\n    /// @dev The minimum outputs that must to be given to the filler as part of order settlement. Similar to maxSpent, it's possible\\n    ///      that special order types may not be able to guarantee the exact amount at open time, so this should be considered\\n    ///      a floor on filler receipts.\\n    Output[] minReceived;\\n    /// @dev Each instruction in this array is parameterizes a single leg of the fill. This provides the filler with the information\\n    ///      necessary to perform the fill on the destination(s).\\n    FillInstruction[] fillInstructions;\\n}\\n\\n/// @notice Tokens that must be receive for a valid order fulfillment\\nstruct Output {\\n    /// @dev The address of the ERC20 token on the destination chain\\n    /// @dev address(0) used as a sentinel for the native token\\n    bytes32 token;\\n    /// @dev The amount of the token to be sent\\n    uint256 amount;\\n    /// @dev The address to receive the output tokens\\n    bytes32 recipient;\\n    /// @dev The destination chain for this output\\n    uint256 chainId;\\n}\\n\\n/// @title FillInstruction type\\n/// @notice Instructions to parameterize each leg of the fill\\n/// @dev Provides all the origin-generated information required to produce a valid fill leg\\nstruct FillInstruction {\\n    /// @dev The contract address that the order is meant to be settled by\\n    uint64 destinationChainId;\\n    /// @dev The contract address that the order is meant to be filled on\\n    bytes32 destinationSettler;\\n    /// @dev The data generated on the origin chain needed by the destinationSettler to process the fill\\n    bytes originData;\\n}\\n\\n/// @title IOriginSettler\\n/// @notice Standard interface for settlement contracts on the origin chain\\ninterface IOriginSettler {\\n    /// @notice Signals that an order has been opened\\n    /// @param orderId a unique order identifier within this settlement system\\n    /// @param resolvedOrder resolved order that would be returned by resolve if called instead of Open\\n    event Open(bytes32 indexed orderId, ResolvedCrossChainOrder resolvedOrder);\\n\\n    /// @notice Opens a gasless cross-chain order on behalf of a user.\\n    /// @dev To be called by the filler.\\n    /// @dev This method must emit the Open event\\n    /// @param order The GaslessCrossChainOrder definition\\n    /// @param signature The user's signature over the order\\n    /// @param originFillerData Any filler-defined data required by the settler\\n    function openFor(\\n        GaslessCrossChainOrder calldata order,\\n        bytes calldata signature,\\n        bytes calldata originFillerData\\n    ) external;\\n\\n    /// @notice Opens a cross-chain order\\n    /// @dev To be called by the user\\n    /// @dev This method must emit the Open event\\n    /// @param order The OnchainCrossChainOrder definition\\n    function open(OnchainCrossChainOrder calldata order) external;\\n\\n    /// @notice Resolves a specific GaslessCrossChainOrder into a generic ResolvedCrossChainOrder\\n    /// @dev Intended to improve standardized integration of various order types and settlement contracts\\n    /// @param order The GaslessCrossChainOrder definition\\n    /// @param originFillerData Any filler-defined data required by the settler\\n    /// @return ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order\\n    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData)\\n        external\\n        view\\n        returns (ResolvedCrossChainOrder memory);\\n\\n    /// @notice Resolves a specific OnchainCrossChainOrder into a generic ResolvedCrossChainOrder\\n    /// @dev Intended to improve standardized integration of various order types and settlement contracts\\n    /// @param order The OnchainCrossChainOrder definition\\n    /// @return ResolvedCrossChainOrder hydrated order data including the inputs and outputs of the order\\n    function resolve(OnchainCrossChainOrder calldata order) external view returns (ResolvedCrossChainOrder memory);\\n}\\n\\n/// @title IDestinationSettler\\n/// @notice Standard interface for settlement contracts on the destination chain\\ninterface IDestinationSettler {\\n    /// @notice Fills a single leg of a particular order on the destination chain\\n    /// @param orderId Unique order identifier for this order\\n    /// @param originData Data emitted on the origin to parameterize the fill\\n    /// @param fillerData Data provided by the filler to inform the fill or express their preferences\\n    function fill(\\n        bytes32 orderId,\\n        bytes calldata originData,\\n        bytes calldata fillerData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x726d0426b0f3a11ff59d3a5bbe433c182c0feac9ea2c8c75377fcc2693eccded\",\"license\":\"GPL-3.0-or-later\"},\"contracts/erc7683/ERC7683Permit2Lib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../external/interfaces/IPermit2.sol\\\";\\nimport { GaslessCrossChainOrder } from \\\"./ERC7683.sol\\\";\\n\\n// Data unique to every CrossChainOrder settled on Across\\nstruct AcrossOrderData {\\n    address inputToken;\\n    uint256 inputAmount;\\n    address outputToken;\\n    uint256 outputAmount;\\n    uint256 destinationChainId;\\n    bytes32 recipient;\\n    address exclusiveRelayer;\\n    uint256 depositNonce;\\n    uint32 exclusivityPeriod;\\n    bytes message;\\n}\\n\\nstruct AcrossOriginFillerData {\\n    address exclusiveRelayer;\\n}\\n\\nstruct AcrossDestinationFillerData {\\n    uint256 repaymentChainId;\\n}\\n\\nbytes constant ACROSS_ORDER_DATA_TYPE = abi.encodePacked(\\n    \\\"AcrossOrderData(\\\",\\n    \\\"address inputToken,\\\",\\n    \\\"uint256 inputAmount,\\\",\\n    \\\"address outputToken,\\\",\\n    \\\"uint256 outputAmount,\\\",\\n    \\\"uint256 destinationChainId,\\\",\\n    \\\"bytes32 recipient,\\\",\\n    \\\"address exclusiveRelayer,\\\"\\n    \\\"uint256 depositNonce,\\\",\\n    \\\"uint32 exclusivityPeriod,\\\",\\n    \\\"bytes message)\\\"\\n);\\n\\nbytes32 constant ACROSS_ORDER_DATA_TYPE_HASH = keccak256(ACROSS_ORDER_DATA_TYPE);\\n\\n/**\\n * @notice ERC7683Permit2Lib knows how to process a particular type of external Permit2Order so that it can be used in Across.\\n * @dev This library is responsible for definining the ERC712 type strings/hashes and performing hashes on the types.\\n * @custom:security-contact bugs@across.to\\n */\\nlibrary ERC7683Permit2Lib {\\n    bytes internal constant GASLESS_CROSS_CHAIN_ORDER_TYPE =\\n        abi.encodePacked(\\n            \\\"GaslessCrossChainOrder(\\\",\\n            \\\"address originSettler,\\\",\\n            \\\"address user,\\\",\\n            \\\"uint256 nonce,\\\",\\n            \\\"uint256 originChainId,\\\",\\n            \\\"uint32 openDeadline,\\\",\\n            \\\"uint32 fillDeadline,\\\",\\n            \\\"bytes32 orderDataType,\\\",\\n            \\\"AcrossOrderData orderData)\\\"\\n        );\\n\\n    bytes internal constant GASLESS_CROSS_CHAIN_ORDER_EIP712_TYPE =\\n        abi.encodePacked(GASLESS_CROSS_CHAIN_ORDER_TYPE, ACROSS_ORDER_DATA_TYPE);\\n    bytes32 internal constant GASLESS_CROSS_CHAIN_ORDER_TYPE_HASH = keccak256(GASLESS_CROSS_CHAIN_ORDER_EIP712_TYPE);\\n\\n    string private constant TOKEN_PERMISSIONS_TYPE = \\\"TokenPermissions(address token,uint256 amount)\\\";\\n    string internal constant PERMIT2_ORDER_TYPE =\\n        string(\\n            abi.encodePacked(\\n                \\\"GaslessCrossChainOrder witness)\\\",\\n                ACROSS_ORDER_DATA_TYPE,\\n                GASLESS_CROSS_CHAIN_ORDER_TYPE,\\n                TOKEN_PERMISSIONS_TYPE\\n            )\\n        );\\n\\n    // Hashes an order to get an order hash. Needed for permit2.\\n    function hashOrder(GaslessCrossChainOrder memory order, bytes32 orderDataHash) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    GASLESS_CROSS_CHAIN_ORDER_TYPE_HASH,\\n                    order.originSettler,\\n                    order.user,\\n                    order.nonce,\\n                    order.originChainId,\\n                    order.openDeadline,\\n                    order.fillDeadline,\\n                    order.orderDataType,\\n                    orderDataHash\\n                )\\n            );\\n    }\\n\\n    function hashOrderData(AcrossOrderData memory orderData) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    ACROSS_ORDER_DATA_TYPE_HASH,\\n                    orderData.inputToken,\\n                    orderData.inputAmount,\\n                    orderData.outputToken,\\n                    orderData.outputAmount,\\n                    orderData.destinationChainId,\\n                    orderData.recipient,\\n                    orderData.exclusiveRelayer,\\n                    orderData.exclusivityPeriod,\\n                    keccak256(orderData.message)\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x12d0e6dd7e394b75067157ccbe3e8756db138b8f48b3c69494da2e2f294d582f\",\"license\":\"UNLICENSED\"},\"contracts/external/interfaces/CCTPInterfaces.sol\":{\"content\":\"/**\\n * Copyright (C) 2015, 2016, 2017 Dapphub\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/**\\n * Imported as-is from commit 139d8d0ce3b5531d3c7ec284f89d946dfb720016 of:\\n *   * https://github.com/walkerq/evm-cctp-contracts/blob/139d8d0ce3b5531d3c7ec284f89d946dfb720016/src/TokenMessenger.sol\\n * Changes applied post-import:\\n *   * Removed a majority of code from this contract and converted the needed function signatures in this interface.\\n */\\ninterface ITokenMessenger {\\n    /**\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\\n     * Emits a `DepositForBurn` event.\\n     * @dev reverts if:\\n     * - given burnToken is not supported\\n     * - given destinationDomain has no TokenMessenger registered\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\n     * to this contract is less than `amount`.\\n     * - burn() reverts. For example, if `amount` is 0.\\n     * - MessageTransmitter returns false or reverts.\\n     * @param amount amount of tokens to burn\\n     * @param destinationDomain destination domain\\n     * @param mintRecipient address of mint recipient on destination domain\\n     * @param burnToken address of contract to burn deposited tokens, on local domain\\n     * @return _nonce unique nonce reserved by message\\n     */\\n    function depositForBurn(\\n        uint256 amount,\\n        uint32 destinationDomain,\\n        bytes32 mintRecipient,\\n        address burnToken\\n    ) external returns (uint64 _nonce);\\n\\n    /**\\n     * @notice Minter responsible for minting and burning tokens on the local domain\\n     * @dev A TokenMessenger stores a TokenMinter contract which extends the TokenController contract.\\n     * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMessenger.sol#L110\\n     * @return minter Token Minter contract.\\n     */\\n    function localMinter() external view returns (ITokenMinter minter);\\n}\\n\\n/**\\n * A TokenMessenger stores a TokenMinter contract which extends the TokenController contract. The TokenController\\n * contract has a burnLimitsPerMessage public mapping which can be queried to find the per-message burn limit\\n * for a given token:\\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/TokenMinter.sol#L33\\n * https://github.com/circlefin/evm-cctp-contracts/blob/817397db0a12963accc08ff86065491577bbc0e5/src/roles/TokenController.sol#L69C40-L69C60\\n *\\n */\\ninterface ITokenMinter {\\n    /**\\n     * @notice Supported burnable tokens on the local domain\\n     * local token (address) => maximum burn amounts per message\\n     * @param token address of token contract\\n     * @return burnLimit maximum burn amount per message for token\\n     */\\n    function burnLimitsPerMessage(address token) external view returns (uint256);\\n}\\n\\n/**\\n * IMessageTransmitter in CCTP inherits IRelayer and IReceiver, but here we only import sendMessage from IRelayer:\\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IMessageTransmitter.sol#L25\\n * https://github.com/circlefin/evm-cctp-contracts/blob/377c9bd813fb86a42d900ae4003599d82aef635a/src/interfaces/IRelayer.sol#L23-L35\\n */\\ninterface IMessageTransmitter {\\n    /**\\n     * @notice Sends an outgoing message from the source domain.\\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\\n     * @param destinationDomain Domain of destination chain\\n     * @param recipient Address of message recipient on destination domain as bytes32\\n     * @param messageBody Raw bytes content of message\\n     * @return nonce reserved by message\\n     */\\n    function sendMessage(\\n        uint32 destinationDomain,\\n        bytes32 recipient,\\n        bytes calldata messageBody\\n    ) external returns (uint64);\\n}\\n\",\"keccak256\":\"0xd9d9ecaf4617ec19f7c30f6ed94d15f656d8fc59eb7c757aca406331ba20424c\",\"license\":\"GPL-3.0-or-later\"},\"contracts/external/interfaces/IPermit2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPermit2 {\\n    struct TokenPermissions {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    struct PermitTransferFrom {\\n        TokenPermissions permitted;\\n        uint256 nonce;\\n        uint256 deadline;\\n    }\\n\\n    struct SignatureTransferDetails {\\n        address to;\\n        uint256 requestedAmount;\\n    }\\n\\n    function permitWitnessTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint160 amount,\\n        address token\\n    ) external;\\n}\\n\",\"keccak256\":\"0x68f40961ee44fbc71eff2037f2c88ba9bfbccf35b9b1eae5a527b71d19bf3a71\",\"license\":\"MIT\"},\"contracts/external/interfaces/WETH9Interface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for the WETH9 contract.\\n */\\ninterface WETH9Interface {\\n    /**\\n     * @notice Burn Wrapped Ether and receive native Ether.\\n     * @param wad Amount of WETH to unwrap and send to caller.\\n     */\\n    function withdraw(uint256 wad) external;\\n\\n    /**\\n     * @notice Lock native Ether and mint Wrapped Ether ERC20\\n     * @dev msg.value is amount of Wrapped Ether to mint/Ether to lock.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice Get balance of WETH held by `guy`.\\n     * @param guy Address to get balance of.\\n     * @return wad Amount of WETH held by `guy`.\\n     */\\n    function balanceOf(address guy) external view returns (uint256 wad);\\n\\n    /**\\n     * @notice Transfer `wad` of WETH from caller to `guy`.\\n     * @param guy Address to send WETH to.\\n     * @param wad Amount of WETH to send.\\n     * @return ok True if transfer succeeded.\\n     */\\n    function transfer(address guy, uint256 wad) external returns (bool);\\n}\\n\",\"keccak256\":\"0x3f7892554ec7f54681fdd3cc18a41346c246c9c1afba016c52990ef77741f718\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ArbitrumBridge.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Staging ground for incoming and outgoing messages\\n * @notice Unlike the standard Eth bridge, native token bridge escrows the custom ERC20 token which is\\n * used as native currency on upper layer.\\n * @dev Fees are paid in this token. There are certain restrictions on the native token:\\n *       - The token can't be rebasing or have a transfer fee\\n *       - The token must only be transferrable via a call to the token address itself\\n *       - The token must only be able to set allowance via a call to the token address itself\\n *       - The token must not have a callback on transfer, and more generally a user must not be able to make a transfer to themselves revert\\n *       - The token must have a max of 2^256 - 1 wei total supply unscaled\\n *       - The token must have a max of 2^256 - 1 wei total supply when scaled to 18 decimals\\n */\\ninterface ArbitrumERC20Bridge {\\n    /**\\n     * @notice Returns token that is escrowed in bridge on the lower layer and minted on the upper layer as native currency.\\n     * @dev This function doesn't exist on the generic Bridge interface.\\n     * @return address of the native token.\\n     */\\n    function nativeToken() external view returns (address);\\n\\n    /**\\n     * @dev number of decimals used by the native token\\n     *      This is set on bridge initialization using nativeToken.decimals()\\n     *      If the token does not have decimals() method, we assume it have 0 decimals\\n     */\\n    function nativeTokenDecimals() external view returns (uint8);\\n}\\n\\n/**\\n * @title Inbox for user and contract originated messages\\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\\n * to await inclusion in the SequencerInbox\\n */\\ninterface ArbitrumInboxLike {\\n    /**\\n     * @dev we only use this function to check the native token used by the bridge, so we hardcode the interface\\n     * to return an ArbitrumERC20Bridge instead of a more generic Bridge interface.\\n     * @return address of the bridge.\\n     */\\n    function bridge() external view returns (ArbitrumERC20Bridge);\\n\\n    /**\\n     * @notice Put a message in the inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @dev Caller must set msg.value equal to at least `maxSubmissionCost + maxGas * gasPriceBid`.\\n     *      all msg.value will deposited to callValueRefundAddress on the upper layer\\n     * @dev More details can be found here: https://developer.arbitrum.io/arbos/l1-to-l2-messaging\\n     * @param to destination contract address\\n     * @param callValue call value for retryable message\\n     * @param maxSubmissionCost Max gas deducted from user's (upper layer) balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on (upper layer) balance\\n     * @param callValueRefundAddress callvalue gets credited here on upper layer if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's upper layer balance to cover upper layer execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for upper layer execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function createRetryableTicket(\\n        address to,\\n        uint256 callValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Put a message in the source chain inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed\\n     * funds come from the deposit alone, rather than falling back on the user's balance\\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\\n     * createRetryableTicket method is the recommended standard.\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination contract address\\n     * @param callValue call value for retryable message\\n     * @param maxSubmissionCost Max gas deducted from user's source chain balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on source chain balance\\n     * @param callValueRefundAddress callvalue gets credited here on source chain if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's balance to cover execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of the message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 callValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n}\\n\\n/**\\n * @notice Interface which extends ArbitrumInboxLike with functions used to interact with bridges that use a custom gas token.\\n */\\ninterface ArbitrumCustomGasTokenInbox is ArbitrumInboxLike {\\n    /**\\n     * @notice Put a message in the inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @notice Overloads the `createRetryableTicket` function but is not payable, and should only be called when paying\\n     * for message using a custom gas token.\\n     * @dev all tokenTotalFeeAmount will be deposited to callValueRefundAddress on upper layer\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @dev In case of native token having non-18 decimals: tokenTotalFeeAmount is denominated in native token's decimals. All other value params - callValue, maxSubmissionCost and maxFeePerGas are denominated in child chain's native 18 decimals.\\n     * @param to destination contract address\\n     * @param callValue call value for retryable message\\n     * @param maxSubmissionCost Max gas deducted from user's upper layer balance to cover base submission fee\\n     * @param excessFeeRefundAddress the address which receives the difference between execution fee paid and the actual execution cost. In case this address is a contract, funds will be received in its alias on upper layer.\\n     * @param callValueRefundAddress callvalue gets credited here on upper layer if retryable txn times out or gets cancelled. In case this address is a contract, funds will be received in its alias on upper layer.\\n     * @param gasLimit Max gas deducted from user's balance to cover execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param tokenTotalFeeAmount amount of fees to be deposited in native token to cover for retryable ticket cost\\n     * @param data ABI encoded data of message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function createRetryableTicket(\\n        address to,\\n        uint256 callValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 tokenTotalFeeAmount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n}\\n\\n/**\\n * @notice Generic gateway contract for bridging standard ERC20s to/from Arbitrum-like networks.\\n * @notice These function signatures are shared between the L1 and L2 gateway router contracts.\\n */\\ninterface ArbitrumL1ERC20GatewayLike {\\n    /**\\n     * @notice Deprecated in favor of outboundTransferCustomRefund but still used in custom bridges\\n     * like the DAI bridge.\\n     * @dev Refunded to aliased address of sender if sender has code on source chain, otherwise to to sender's EOA on destination chain.\\n     * @param _sourceToken address of ERC20\\n     * @param _to Account to be credited with the tokens at the destination (can be the user's account or a contract),\\n     * not subject to aliasing. This account, or its alias if it has code in the source chain, will also be able to\\n     * cancel the retryable ticket and receive callvalue refund\\n     * @param _amount Token Amount\\n     * @param _maxGas Max gas deducted from user's balance to cover execution\\n     * @param _gasPriceBid Gas price for execution\\n     * @param _data encoded data from router and user\\n     * @return res abi encoded inbox sequence number\\n     */\\n    function outboundTransfer(\\n        address _sourceToken,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n\\n    /**\\n     * @notice get ERC20 gateway for token.\\n     * @param _token ERC20 address.\\n     * @return address of ERC20 gateway.\\n     */\\n    function getGateway(address _token) external view returns (address);\\n\\n    /**\\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum-like networks.\\n     * @dev Upper layer address alias will not be applied to the following types of addresses on lower layer:\\n     *      - an externally-owned account\\n     *      - a contract in construction\\n     *      - an address where a contract will be created\\n     *      - an address where a contract lived, but was destroyed\\n     * @param _sourceToken address of ERC20 on source chain.\\n     * @param _refundTo Account, or its alias if it has code on the source chain, to be credited with excess gas refund at destination\\n     * @param _to Account to be credited with the tokens in the L3 (can be the user's L3 account or a contract),\\n     * not subject to aliasing. This account, or its alias if it has code on the source chain, will also be able to\\n     * cancel the retryable ticket and receive callvalue refund\\n     * @param _amount Token Amount\\n     * @param _maxGas Max gas deducted from user's balance to cover execution\\n     * @param _gasPriceBid Gas price for execution\\n     * @param _data encoded data from router and user\\n     * @return res abi encoded inbox sequence number\\n     */\\n    function outboundTransferCustomRefund(\\n        address _sourceToken,\\n        address _refundTo,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n}\\n\\ninterface ArbitrumL2ERC20GatewayLike {\\n    /**\\n     * @notice Fetches the l2 token address from the gateway router for the input l1 token address\\n     * @param _l1Erc20 address of the l1 token.\\n     */\\n    function calculateL2TokenAddress(address _l1Erc20) external view returns (address);\\n\\n    /**\\n     * @notice Withdraws a specified amount of an l2 token to an l1 token.\\n     * @param _l1Token address of the token to withdraw on L1.\\n     * @param _to address on L1 which will receive the tokens upon withdrawal.\\n     * @param _amount amount of the token to withdraw.\\n     * @param _data encoded data to send to the gateway router.\\n     */\\n    function outboundTransfer(\\n        address _l1Token,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x9ef6db1c1bee70688b3b9756855b1fa14b0bb45b0a53a43992ffb0272153a927\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/HubPoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @notice Concise list of functions in HubPool implementation.\\n */\\ninterface HubPoolInterface {\\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\\n    struct PoolRebalanceLeaf {\\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to send to).\\n        uint256 chainId;\\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\\n        uint256[] bundleLpFees;\\n        // Represents the amount to push to or pull from the SpokePool. If +, the pool pays the SpokePool. If negative\\n        // the SpokePool pays the HubPool. There can be arbitrarily complex rebalancing rules defined offchain. This\\n        // number is only nonzero when the rules indicate that a rebalancing action should occur. When a rebalance does\\n        // occur, runningBalances must be set to zero for this token and netSendAmounts should be set to the previous\\n        // runningBalances + relays - deposits in this bundle. If non-zero then it must be set on the SpokePool's\\n        // RelayerRefundLeaf amountToReturn as -1 * this value to show if funds are being sent from or to the SpokePool.\\n        int256[] netSendAmounts;\\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1\\n        // pool. A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that\\n        // the SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts.\\n        int256[] runningBalances;\\n        // Used by data worker to mark which leaves should relay roots to SpokePools, and to otherwise organize leaves.\\n        // For example, each leaf should contain all the rebalance information for a single chain, but in the case where\\n        // the list of l1Tokens is very large such that they all can't fit into a single leaf that can be executed under\\n        // the block gas limit, then the data worker can use this groupIndex to organize them. Any leaves with\\n        // a groupIndex equal to 0 will relay roots to the SpokePool, so the data worker should ensure that only one\\n        // leaf for a specific chainId should have a groupIndex equal to 0.\\n        uint256 groupIndex;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint8 leafId;\\n        // The bundleLpFees, netSendAmounts, and runningBalances are required to be the same length. They are parallel\\n        // arrays for the given chainId and should be ordered by the l1Tokens field. All whitelisted tokens with nonzero\\n        // relays on this chain in this bundle in the order of whitelisting.\\n        address[] l1Tokens;\\n    }\\n\\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all contain valid leaves\\n    // that can be executed later to:\\n    // - Send funds from this contract to a SpokePool or vice versa\\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \\\"slow\\\" relay\\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\\n    // challengePeriodEndTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\\n    struct RootBundle {\\n        // Contains leaves instructing this contract to send funds to SpokePools.\\n        bytes32 poolRebalanceRoot;\\n        // Relayer refund merkle root to be published to a SpokePool.\\n        bytes32 relayerRefundRoot;\\n        // Slow relay merkle root to be published to a SpokePool.\\n        bytes32 slowRelayRoot;\\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\\n        uint256 claimedBitMap;\\n        // Proposer of this root bundle.\\n        address proposer;\\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\\n        // of leaves are executed, a new root bundle can be proposed\\n        uint8 unclaimedPoolRebalanceLeafCount;\\n        // When root bundle challenge period passes and this root bundle becomes executable.\\n        uint32 challengePeriodEndTimestamp;\\n    }\\n\\n    // Each whitelisted L1 token has an associated pooledToken struct that contains all information used to track the\\n    // cumulative LP positions and if this token is enabled for deposits.\\n    struct PooledToken {\\n        // LP token given to LPs of a specific L1 token.\\n        address lpToken;\\n        // True if accepting new LP's.\\n        bool isEnabled;\\n        // Timestamp of last LP fee update.\\n        uint32 lastLpFeeUpdate;\\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\\n        // back later.\\n        int256 utilizedReserves;\\n        // Number of LP funds held in contract less utilized reserves.\\n        uint256 liquidReserves;\\n        // Number of LP funds reserved to pay out to LPs as fees.\\n        uint256 undistributedLpFees;\\n    }\\n\\n    // Helper contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\\n    struct CrossChainContract {\\n        address adapter;\\n        address spokePool;\\n    }\\n\\n    function setPaused(bool pause) external;\\n\\n    function emergencyDeleteProposal() external;\\n\\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\\n\\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\\n\\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\\n\\n    function setLiveness(uint32 newLiveness) external;\\n\\n    function setIdentifier(bytes32 newIdentifier) external;\\n\\n    function setCrossChainContracts(\\n        uint256 l2ChainId,\\n        address adapter,\\n        address spokePool\\n    ) external;\\n\\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\\n\\n    function removeLiquidity(\\n        address l1Token,\\n        uint256 lpTokenAmount,\\n        bool sendEth\\n    ) external;\\n\\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount) external returns (uint256);\\n\\n    function sync(address l1Token) external;\\n\\n    function proposeRootBundle(\\n        uint256[] memory bundleEvaluationBlockNumbers,\\n        uint8 poolRebalanceLeafCount,\\n        bytes32 poolRebalanceRoot,\\n        bytes32 relayerRefundRoot,\\n        bytes32 slowRelayRoot\\n    ) external;\\n\\n    function executeRootBundle(\\n        uint256 chainId,\\n        uint256 groupIndex,\\n        uint256[] memory bundleLpFees,\\n        int256[] memory netSendAmounts,\\n        int256[] memory runningBalances,\\n        uint8 leafId,\\n        address[] memory l1Tokens,\\n        bytes32[] memory proof\\n    ) external;\\n\\n    function disputeRootBundle() external;\\n\\n    function claimProtocolFeesCaptured(address l1Token) external;\\n\\n    function setPoolRebalanceRoute(\\n        uint256 destinationChainId,\\n        address l1Token,\\n        address destinationToken\\n    ) external;\\n\\n    function setDepositRoute(\\n        uint256 originChainId,\\n        uint256 destinationChainId,\\n        address originToken,\\n        bool depositsEnabled\\n    ) external;\\n\\n    function poolRebalanceRoute(uint256 destinationChainId, address l1Token)\\n        external\\n        view\\n        returns (address destinationToken);\\n\\n    function loadEthForL2Calls() external payable;\\n}\\n\",\"keccak256\":\"0xefd509ab379b94004b5767d67971e5c0bda4ca1e9f376b5aea75a0297b5d7bd6\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/SpokePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Contains common data structures and functions used by all SpokePool implementations.\\n */\\ninterface SpokePoolInterface {\\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\\n    struct RelayerRefundLeaf {\\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that\\n        // is negative. This is just the negative of this value.\\n        uint256 amountToReturn;\\n        // Used to verify that this is being executed on the correct destination chainId.\\n        uint256 chainId;\\n        // This array designates how much each of those addresses should be refunded.\\n        uint256[] refundAmounts;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint32 leafId;\\n        // The associated L2TokenAddress that these claims apply to.\\n        address l2TokenAddress;\\n        // Must be same length as refundAmounts and designates each address that must be refunded.\\n        address[] refundAddresses;\\n    }\\n\\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\\n    // by \\\"data workers\\\" via inclusion proofs to execute leaves in the roots.\\n    struct RootBundle {\\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\\n        bytes32 slowRelayRoot;\\n        // Merkle root of relayer refunds for successful relays.\\n        bytes32 relayerRefundRoot;\\n        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of\\n        // 256x(2^248) leaves per root.\\n        mapping(uint256 => uint256) claimedBitmap;\\n    }\\n\\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\\n\\n    function setWithdrawalRecipient(address newWithdrawalRecipient) external;\\n\\n    function setEnableRoute(\\n        address originToken,\\n        uint256 destinationChainId,\\n        bool enable\\n    ) external;\\n\\n    function pauseDeposits(bool pause) external;\\n\\n    function pauseFills(bool pause) external;\\n\\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\\n\\n    function emergencyDeleteRootBundle(uint256 rootBundleId) external;\\n\\n    function depositDeprecated_5947912356(\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external payable;\\n\\n    function depositFor(\\n        address depositor,\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external payable;\\n\\n    function executeRelayerRefundLeaf(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) external payable;\\n\\n    function chainId() external view returns (uint256);\\n\\n    error NotEOA();\\n    error InvalidDepositorSignature();\\n    error InvalidRelayerFeePct();\\n    error MaxTransferSizeExceeded();\\n    error InvalidCrossDomainAdmin();\\n    error InvalidWithdrawalRecipient();\\n    error DepositsArePaused();\\n    error FillsArePaused();\\n}\\n\",\"keccak256\":\"0x4fefc97b3446f957f2679869ee7d8e8cc319a189f3fe47584b8203256a0d703b\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/SpokePoolMessageHandler.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// This interface is expected to be implemented by any contract that expects to receive messages from the SpokePool.\\ninterface AcrossMessageHandler {\\n    function handleV3AcrossMessage(\\n        address tokenSent,\\n        uint256 amount,\\n        address relayer,\\n        bytes memory message\\n    ) external;\\n}\\n\",\"keccak256\":\"0xef7377f05d40e665eb346fb1647e1341558ce5fd1e03768d81a41a579365ff47\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/V3SpokePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// Contains structs and functions used by SpokePool contracts to facilitate universal settlement.\\ninterface V3SpokePoolInterface {\\n    /**************************************\\n     *              ENUMS                 *\\n     **************************************/\\n\\n    // Fill status tracks on-chain state of deposit, uniquely identified by relayHash.\\n    enum FillStatus {\\n        Unfilled,\\n        RequestedSlowFill,\\n        Filled\\n    }\\n    // Fill type is emitted in the FilledRelay event to assist Dataworker with determining which types of\\n    // fills to refund (e.g. only fast fills) and whether a fast fill created a sow fill excess.\\n    enum FillType {\\n        FastFill,\\n        // Fast fills are normal fills that do not replace a slow fill request.\\n        ReplacedSlowFill,\\n        // Replaced slow fills are fast fills that replace a slow fill request. This type is used by the Dataworker\\n        // to know when to send excess funds from the SpokePool to the HubPool because they can no longer be used\\n        // for a slow fill execution.\\n        SlowFill\\n    }\\n    // Slow fills are requested via requestSlowFill and executed by executeSlowRelayLeaf after a bundle containing\\n    // the slow fill is validated.\\n\\n    /**************************************\\n     *              STRUCTS               *\\n     **************************************/\\n\\n    // This struct represents the data to fully specify a **unique** relay submitted on this chain.\\n    // This data is hashed with the chainId() and saved by the SpokePool to prevent collisions and protect against\\n    // replay attacks on other chains. If any portion of this data differs, the relay is considered to be\\n    // completely distinct.\\n    struct V3RelayData {\\n        // The bytes32 that made the deposit on the origin chain.\\n        bytes32 depositor;\\n        // The recipient bytes32 on the destination chain.\\n        bytes32 recipient;\\n        // This is the exclusive relayer who can fill the deposit before the exclusivity deadline.\\n        bytes32 exclusiveRelayer;\\n        // Token that is deposited on origin chain by depositor.\\n        bytes32 inputToken;\\n        // Token that is received on destination chain by recipient.\\n        bytes32 outputToken;\\n        // The amount of input token deposited by depositor.\\n        uint256 inputAmount;\\n        // The amount of output token to be received by recipient.\\n        uint256 outputAmount;\\n        // Origin chain id.\\n        uint256 originChainId;\\n        // The id uniquely identifying this deposit on the origin chain.\\n        uint256 depositId;\\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\\n        uint32 fillDeadline;\\n        // The timestamp on the destination chain after which any relayer can fill the deposit.\\n        uint32 exclusivityDeadline;\\n        // Data that is forwarded to the recipient.\\n        bytes message;\\n    }\\n\\n    // Same as V3RelayData but using addresses instead of bytes32 & depositId is uint32.\\n    // Will be deprecated in favor of V3RelayData in the future.\\n    struct V3RelayDataLegacy {\\n        address depositor;\\n        address recipient;\\n        address exclusiveRelayer;\\n        address inputToken;\\n        address outputToken;\\n        uint256 inputAmount;\\n        uint256 outputAmount;\\n        uint256 originChainId;\\n        uint32 depositId;\\n        uint32 fillDeadline;\\n        uint32 exclusivityDeadline;\\n        bytes message;\\n    }\\n\\n    // Contains parameters passed in by someone who wants to execute a slow relay leaf.\\n    struct V3SlowFill {\\n        V3RelayData relayData;\\n        uint256 chainId;\\n        uint256 updatedOutputAmount;\\n    }\\n\\n    // Contains information about a relay to be sent along with additional information that is not unique to the\\n    // relay itself but is required to know how to process the relay. For example, \\\"updatedX\\\" fields can be used\\n    // by the relayer to modify fields of the relay with the depositor's permission, and \\\"repaymentChainId\\\" is specified\\n    // by the relayer to determine where to take a relayer refund, but doesn't affect the uniqueness of the relay.\\n    struct V3RelayExecutionParams {\\n        V3RelayData relay;\\n        bytes32 relayHash;\\n        uint256 updatedOutputAmount;\\n        bytes32 updatedRecipient;\\n        bytes updatedMessage;\\n        uint256 repaymentChainId;\\n    }\\n\\n    // Packs together parameters emitted in FilledRelay because there are too many emitted otherwise.\\n    // Similar to V3RelayExecutionParams, these parameters are not used to uniquely identify the deposit being\\n    // filled so they don't have to be unpacked by all clients.\\n    struct V3RelayExecutionEventInfo {\\n        bytes32 updatedRecipient;\\n        bytes32 updatedMessageHash;\\n        uint256 updatedOutputAmount;\\n        FillType fillType;\\n    }\\n\\n    // Represents the parameters required for a V3 deposit operation in the SpokePool.\\n    struct DepositV3Params {\\n        bytes32 depositor;\\n        bytes32 recipient;\\n        bytes32 inputToken;\\n        bytes32 outputToken;\\n        uint256 inputAmount;\\n        uint256 outputAmount;\\n        uint256 destinationChainId;\\n        bytes32 exclusiveRelayer;\\n        uint256 depositId;\\n        uint32 quoteTimestamp;\\n        uint32 fillDeadline;\\n        uint32 exclusivityParameter;\\n        bytes message;\\n    }\\n\\n    /**************************************\\n     *              EVENTS                *\\n     **************************************/\\n\\n    event FundsDeposited(\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 indexed destinationChainId,\\n        uint256 indexed depositId,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        bytes32 indexed depositor,\\n        bytes32 recipient,\\n        bytes32 exclusiveRelayer,\\n        bytes message\\n    );\\n\\n    event RequestedSpeedUpDeposit(\\n        uint256 updatedOutputAmount,\\n        uint256 indexed depositId,\\n        bytes32 indexed depositor,\\n        bytes32 updatedRecipient,\\n        bytes updatedMessage,\\n        bytes depositorSignature\\n    );\\n\\n    event FilledRelay(\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 repaymentChainId,\\n        uint256 indexed originChainId,\\n        uint256 indexed depositId,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        bytes32 exclusiveRelayer,\\n        bytes32 indexed relayer,\\n        bytes32 depositor,\\n        bytes32 recipient,\\n        bytes32 messageHash,\\n        V3RelayExecutionEventInfo relayExecutionInfo\\n    );\\n\\n    event RequestedSlowFill(\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 indexed originChainId,\\n        uint256 indexed depositId,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        bytes32 exclusiveRelayer,\\n        bytes32 depositor,\\n        bytes32 recipient,\\n        bytes32 messageHash\\n    );\\n\\n    event ClaimedRelayerRefund(\\n        bytes32 indexed l2TokenAddress,\\n        bytes32 indexed refundAddress,\\n        uint256 amount,\\n        address indexed caller\\n    );\\n\\n    /**************************************\\n     *              FUNCTIONS             *\\n     **************************************/\\n\\n    function deposit(\\n        bytes32 depositor,\\n        bytes32 recipient,\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        bytes32 exclusiveRelayer,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        bytes calldata message\\n    ) external payable;\\n\\n    function depositV3(\\n        address depositor,\\n        address recipient,\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        address exclusiveRelayer,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        bytes calldata message\\n    ) external payable;\\n\\n    function depositNow(\\n        bytes32 depositor,\\n        bytes32 recipient,\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        bytes32 exclusiveRelayer,\\n        uint32 fillDeadlineOffset,\\n        uint32 exclusivityDeadline,\\n        bytes calldata message\\n    ) external payable;\\n\\n    function depositV3Now(\\n        address depositor,\\n        address recipient,\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        address exclusiveRelayer,\\n        uint32 fillDeadlineOffset,\\n        uint32 exclusivityDeadline,\\n        bytes calldata message\\n    ) external payable;\\n\\n    function unsafeDeposit(\\n        bytes32 depositor,\\n        bytes32 recipient,\\n        bytes32 inputToken,\\n        bytes32 outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        bytes32 exclusiveRelayer,\\n        uint256 depositNonce,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityParameter,\\n        bytes calldata message\\n    ) external payable;\\n\\n    function speedUpDeposit(\\n        bytes32 depositor,\\n        uint256 depositId,\\n        uint256 updatedOutputAmount,\\n        bytes32 updatedRecipient,\\n        bytes calldata updatedMessage,\\n        bytes calldata depositorSignature\\n    ) external;\\n\\n    function speedUpV3Deposit(\\n        address depositor,\\n        uint256 depositId,\\n        uint256 updatedOutputAmount,\\n        address updatedRecipient,\\n        bytes calldata updatedMessage,\\n        bytes calldata depositorSignature\\n    ) external;\\n\\n    function fillRelay(\\n        V3RelayData calldata relayData,\\n        uint256 repaymentChainId,\\n        bytes32 repaymentAddress\\n    ) external;\\n\\n    function fillV3Relay(V3RelayDataLegacy calldata relayData, uint256 repaymentChainId) external;\\n\\n    function fillRelayWithUpdatedDeposit(\\n        V3RelayData calldata relayData,\\n        uint256 repaymentChainId,\\n        bytes32 repaymentAddress,\\n        uint256 updatedOutputAmount,\\n        bytes32 updatedRecipient,\\n        bytes calldata updatedMessage,\\n        bytes calldata depositorSignature\\n    ) external;\\n\\n    function requestSlowFill(V3RelayData calldata relayData) external;\\n\\n    function executeSlowRelayLeaf(\\n        V3SlowFill calldata slowFillLeaf,\\n        uint32 rootBundleId,\\n        bytes32[] calldata proof\\n    ) external;\\n\\n    function claimRelayerRefund(bytes32 l2TokenAddress, bytes32 refundAddress) external;\\n\\n    /**************************************\\n     *              ERRORS                *\\n     **************************************/\\n\\n    error DisabledRoute();\\n    error InvalidQuoteTimestamp();\\n    error InvalidFillDeadline();\\n    error InvalidExclusiveRelayer();\\n    error MsgValueDoesNotMatchInputAmount();\\n    error NotExclusiveRelayer();\\n    error NoSlowFillsInExclusivityWindow();\\n    error RelayFilled();\\n    error InvalidSlowFillRequest();\\n    error ExpiredFillDeadline();\\n    error InvalidMerkleProof();\\n    error InvalidChainId();\\n    error InvalidMerkleLeaf();\\n    error ClaimedMerkleLeaf();\\n    error InvalidPayoutAdjustmentPct();\\n    error WrongERC7683OrderId();\\n    error LowLevelCallFailed(bytes data);\\n    error InsufficientSpokePoolBalanceToExecuteLeaf();\\n    error NoRelayerRefundToClaim();\\n\\n    /**************************************\\n     *             LEGACY EVENTS          *\\n     **************************************/\\n\\n    // Note: these events are unused, but included in the ABI for ease of migration.\\n    event V3FundsDeposited(\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 indexed destinationChainId,\\n        uint32 indexed depositId,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        address indexed depositor,\\n        address recipient,\\n        address exclusiveRelayer,\\n        bytes message\\n    );\\n\\n    event RequestedSpeedUpV3Deposit(\\n        uint256 updatedOutputAmount,\\n        uint32 indexed depositId,\\n        address indexed depositor,\\n        address updatedRecipient,\\n        bytes updatedMessage,\\n        bytes depositorSignature\\n    );\\n\\n    // Legacy struct only used to preserve the FilledV3Relay event definition.\\n    struct LegacyV3RelayExecutionEventInfo {\\n        address updatedRecipient;\\n        bytes updatedMessage;\\n        uint256 updatedOutputAmount;\\n        FillType fillType;\\n    }\\n\\n    event FilledV3Relay(\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 repaymentChainId,\\n        uint256 indexed originChainId,\\n        uint32 indexed depositId,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        address exclusiveRelayer,\\n        address indexed relayer,\\n        address depositor,\\n        address recipient,\\n        bytes message,\\n        LegacyV3RelayExecutionEventInfo relayExecutionInfo\\n    );\\n\\n    event RequestedV3SlowFill(\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 indexed originChainId,\\n        uint32 indexed depositId,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        address exclusiveRelayer,\\n        address depositor,\\n        address recipient,\\n        bytes message\\n    );\\n}\\n\",\"keccak256\":\"0x28d33b34690ea41eea70c5cce5db8c5f1066d74b59a23e28c7b4d9afddef7608\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/AddressConverters.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary Bytes32ToAddress {\\n    /**************************************\\n     *              ERRORS                *\\n     **************************************/\\n    error InvalidBytes32();\\n\\n    function toAddress(bytes32 _bytes32) internal pure returns (address) {\\n        checkAddress(_bytes32);\\n        return address(uint160(uint256(_bytes32)));\\n    }\\n\\n    function toAddressUnchecked(bytes32 _bytes32) internal pure returns (address) {\\n        return address(uint160(uint256(_bytes32)));\\n    }\\n\\n    function checkAddress(bytes32 _bytes32) internal pure {\\n        if (uint256(_bytes32) >> 160 != 0) {\\n            revert InvalidBytes32();\\n        }\\n    }\\n}\\n\\nlibrary AddressToBytes32 {\\n    function toBytes32(address _address) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_address)));\\n    }\\n}\\n\",\"keccak256\":\"0x378f28bb4a17a5c47457cb9341086b2140f7faf6c048f702d3528166f0d74453\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/CircleCCTPAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../external/interfaces/CCTPInterfaces.sol\\\";\\nimport { AddressToBytes32 } from \\\"../libraries/AddressConverters.sol\\\";\\n\\nlibrary CircleDomainIds {\\n    uint32 public constant Ethereum = 0;\\n    uint32 public constant Optimism = 2;\\n    uint32 public constant Arbitrum = 3;\\n    uint32 public constant Solana = 5;\\n    uint32 public constant Base = 6;\\n    uint32 public constant Polygon = 7;\\n    uint32 public constant DoctorWho = 10;\\n    // Use this value for placeholder purposes only for adapters that extend this adapter but haven't yet been\\n    // assigned a domain ID by Circle.\\n    uint32 public constant UNINITIALIZED = type(uint32).max;\\n}\\n\\n/**\\n * @notice Facilitate bridging USDC via Circle's CCTP.\\n * @dev This contract is intended to be inherited by other chain-specific adapters and spoke pools.\\n * @custom:security-contact bugs@across.to\\n */\\nabstract contract CircleCCTPAdapter {\\n    using SafeERC20 for IERC20;\\n    using AddressToBytes32 for address;\\n    /**\\n     * @notice The domain ID that CCTP will transfer funds to.\\n     * @dev This identifier is assigned by Circle and is not related to a chain ID.\\n     * @dev Official domain list can be found here: https://developers.circle.com/stablecoins/docs/supported-domains\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n\\n    uint32 public immutable recipientCircleDomainId;\\n\\n    /**\\n     * @notice The official USDC contract address on this chain.\\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/usdc-on-main-networks\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    IERC20 public immutable usdcToken;\\n\\n    /**\\n     * @notice The official Circle CCTP token bridge contract endpoint.\\n     * @dev Posted officially here: https://developers.circle.com/stablecoins/docs/evm-smart-contracts\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    ITokenMessenger public immutable cctpTokenMessenger;\\n\\n    /**\\n     * @notice intiailizes the CircleCCTPAdapter contract.\\n     * @param _usdcToken USDC address on the current chain.\\n     * @param _cctpTokenMessenger TokenMessenger contract to bridge via CCTP. If the zero address is passed, CCTP bridging will be disabled.\\n     * @param _recipientCircleDomainId The domain ID that CCTP will transfer funds to.\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(\\n        IERC20 _usdcToken,\\n        ITokenMessenger _cctpTokenMessenger,\\n        uint32 _recipientCircleDomainId\\n    ) {\\n        usdcToken = _usdcToken;\\n        cctpTokenMessenger = _cctpTokenMessenger;\\n        recipientCircleDomainId = _recipientCircleDomainId;\\n    }\\n\\n    /**\\n     * @notice Returns whether or not the CCTP bridge is enabled.\\n     * @dev If the CCTPTokenMessenger is the zero address, CCTP bridging is disabled.\\n     */\\n    function _isCCTPEnabled() internal view returns (bool) {\\n        return address(cctpTokenMessenger) != address(0);\\n    }\\n\\n    /**\\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\\n     * @param to Address to receive USDC on the new domain.\\n     * @param amount Amount of USDC to transfer.\\n     */\\n    function _transferUsdc(address to, uint256 amount) internal {\\n        _transferUsdc(to.toBytes32(), amount);\\n    }\\n\\n    /**\\n     * @notice Transfers USDC from the current domain to the given address on the new domain.\\n     * @dev This function will revert if the CCTP bridge is disabled. I.e. if the zero address is passed to the constructor for the cctpTokenMessenger.\\n     * @param to Address to receive USDC on the new domain represented as bytes32.\\n     * @param amount Amount of USDC to transfer.\\n     */\\n    function _transferUsdc(bytes32 to, uint256 amount) internal {\\n        // Only approve the exact amount to be transferred\\n        usdcToken.safeIncreaseAllowance(address(cctpTokenMessenger), amount);\\n        // Submit the amount to be transferred to bridged via the TokenMessenger.\\n        // If the amount to send exceeds the burn limit per message, then split the message into smaller parts.\\n        ITokenMinter cctpMinter = cctpTokenMessenger.localMinter();\\n        uint256 burnLimit = cctpMinter.burnLimitsPerMessage(address(usdcToken));\\n        uint256 remainingAmount = amount;\\n        while (remainingAmount > 0) {\\n            uint256 partAmount = remainingAmount > burnLimit ? burnLimit : remainingAmount;\\n            cctpTokenMessenger.depositForBurn(partAmount, recipientCircleDomainId, to, address(usdcToken));\\n            remainingAmount -= partAmount;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf2d4f9d84b80259be516be7e543ea9a504ed665070d8105fbd7c84e7f79f8a32\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/CrossDomainAddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title AddressUtils\\n * @notice This library contains internal functions for manipulating addresses.\\n */\\nlibrary CrossDomainAddressUtils {\\n    // L1 addresses are transformed during l1->l2 calls.\\n    // This cannot be pulled directly from Arbitrum contracts because their contracts are not 0.8.X compatible and\\n    // this operation takes advantage of overflows, whose behavior changed in 0.8.0.\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + uint160(0x1111000000000000000000000000000000001111));\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8cc6314539c233645e25cd87dca634ff334560227047e041da84be6079250f59\",\"license\":\"BUSL-1.1\"},\"contracts/upgradeable/AddressLibUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title AddressUpgradeable\\n * @dev Collection of functions related to the address type\\n * @notice Logic is 100% copied from \\\"@openzeppelin/contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\\\" but one\\n * comment is added to clarify why we allow delegatecall() in this contract, which is typically unsafe for use in\\n * upgradeable implementation contracts.\\n * @dev See https://docs.openzeppelin.com/upgrades-plugins/1.x/faq#delegatecall-selfdestruct for more details.\\n * @custom:security-contact bugs@across.to\\n */\\nlibrary AddressLibUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x655040da45a857cf609d7176c7b0647bf76d36e73e856af79d511014c7e8ef81\",\"license\":\"MIT\"},\"contracts/upgradeable/EIP712CrossChainUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * This contract is based on OpenZeppelin's implementation:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/cryptography/EIP712Upgradeable.sol\\n *\\n * NOTE: Modified version that allows to build a domain separator that relies on a different chain id than the chain this\\n * contract is deployed to. An example use case we want to support is:\\n * - User A signs a message on chain with id = 1\\n * - User B executes a method by verifying user A's EIP-712 compliant signature on a chain with id != 1\\n * @custom:security-contact bugs@across.to\\n */\\nabstract contract EIP712CrossChainUpgradeable is Initializable {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private _HASHED_NAME;\\n    bytes32 private _HASHED_VERSION;\\n    bytes32 private constant _TYPE_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId)\\\");\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\\n        __EIP712_init_unchained(name, version);\\n    }\\n\\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator depending on the `originChainId`.\\n     * @param originChainId Chain id of network where message originates from.\\n     * @return bytes32 EIP-712-compliant domain separator.\\n     */\\n    function _domainSeparatorV4(uint256 originChainId) internal view returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, originChainId));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 structHash = keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * ));\\n     * bytes32 digest = _hashTypedDataV4(structHash, originChainId);\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     * @param structHash Hashed struct as defined in https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\\n     * @param originChainId Chain id of network where message originates from.\\n     * @return bytes32 Hash digest that is recoverable via `EDCSA.recover`.\\n     */\\n    function _hashTypedDataV4(bytes32 structHash, uint256 originChainId) internal view virtual returns (bytes32) {\\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(originChainId), structHash);\\n    }\\n\\n    // Reserve storage slots for future versions of this base contract to add state variables without\\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\\n    // are added. This is at bottom of contract to make sure it's always at the end of storage.\\n    uint256[1000] private __gap;\\n}\\n\",\"keccak256\":\"0xff617722706d1c0a6d346e56e4598cc5f60adea99b4ac1d2347dcd69270a14f6\",\"license\":\"BUSL-1.1\"},\"contracts/upgradeable/MultiCallerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title MultiCallerUpgradeable\\n * @notice Logic is 100% copied from \\\"@uma/core/contracts/common/implementation/MultiCaller.sol\\\" but one\\n * comment is added to clarify why we allow delegatecall() in this contract, which is typically unsafe for use in\\n * upgradeable implementation contracts.\\n * @dev See https://docs.openzeppelin.com/upgrades-plugins/1.x/faq#delegatecall-selfdestruct for more details.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract MultiCallerUpgradeable {\\n    struct Result {\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    function _validateMulticallData(bytes[] calldata data) internal virtual {\\n        // no-op\\n    }\\n\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\\n        _validateMulticallData(data);\\n\\n        uint256 dataLength = data.length;\\n        results = new bytes[](dataLength);\\n\\n        //slither-disable-start calls-loop\\n        for (uint256 i = 0; i < dataLength; ++i) {\\n            // Typically, implementation contracts used in the upgradeable proxy pattern shouldn't call `delegatecall`\\n            // because it could allow a malicious actor to call this implementation contract directly (rather than\\n            // through a proxy contract) and then selfdestruct() the contract, thereby freezing the upgradeable\\n            // proxy. However, since we're only delegatecall-ing into this contract, then we can consider this\\n            // use of delegatecall() safe.\\n\\n            //slither-disable-start low-level-calls\\n            /// @custom:oz-upgrades-unsafe-allow delegatecall\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n            //slither-disable-end low-level-calls\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                //slither-disable-next-line assembly\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n        //slither-disable-end calls-loop\\n    }\\n\\n    function tryMulticall(bytes[] calldata data) external returns (Result[] memory results) {\\n        _validateMulticallData(data);\\n\\n        uint256 dataLength = data.length;\\n        results = new Result[](dataLength);\\n\\n        //slither-disable-start calls-loop\\n        for (uint256 i = 0; i < dataLength; ++i) {\\n            // The delegatecall here is safe for the same reasons outlined in the first multicall function.\\n            Result memory result = results[i];\\n            //slither-disable-start low-level-calls\\n            /// @custom:oz-upgrades-unsafe-allow delegatecall\\n            (result.success, result.returnData) = address(this).delegatecall(data[i]);\\n            //slither-disable-end low-level-calls\\n        }\\n        //slither-disable-end calls-loop\\n    }\\n\\n    // Reserve storage slots for future versions of this base contract to add state variables without\\n    // affecting the storage layout of child contracts. Decrement the size of __gap whenever state variables\\n    // are added. This is at bottom of contract to make sure its always at the end of storage.\\n    uint256[1000] private __gap;\\n}\\n\",\"keccak256\":\"0xc1378a7d63785d9381b8fb6e42962499ab26a243292e20981c2792511a4697f3\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x61016034620001c657601f620067f538819003918201601f19168301916001600160401b03831184841017620001ca5780849260a094604052833981010312620001c65780516001600160a01b03919082811690819003620001c6576200006960208301620001de565b6200007760408401620001de565b916060840151938585168503620001c657608001519485168503620001c6573060805260a05260c05260e0525f5460ff8160081c16620001c65760ff808216036200018b575b50610120908152610140918252610100915f8352604051916166049384620001f185396080518481816113b4015281816118750152611a01015260a0518481816108ae0152818161439501528181614ca401528181614f8c0152818161560501528181615e790152615ea0015260c051848181611d500152818161433c0152615885015260e05184818161043c01526155a6015251838181611e4a015261627c01525182818161080801528181615df501526161740152518181816124ab01528181615c5f01526161970152f35b60ff90811916175f557f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498602060405160ff8152a15f620000bd565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b519063ffffffff82168203620001c65756fe6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c8063079bd2c7146103ef5780631186ec33146103ea57806311eac855146103e557806315348e441461036d57806317fcb39b146103e05780631b3d5559146103db5780631fab657c146103d6578063272751c7146103d157806329cb924d146103cc5780632e378115146103c75780632e63e59a146103c257806333a84ff0146103bd578063364f01a6146103b85780633659cfe6146103b3578063437b9116146103ae578063490e49ef146103a9578063493a4f84146103a45780634e3485c81461039f5780634f1ef2861461039a5780635249fef1146103955780635285e0581461039057806352d1902d1461038b578063541f4f1414610386578063577f51f81461038157806357f6dcb81461037c5780636068d6cb14610377578063670fa8ac146103725780636bbbcd2e1461036d5780636e40098314610368578063738b62e5146103635780637aef642c1461035e5780637b939232146103595780637ef413e11461035457806382e2c43f1461034f5780638a7860ce1461034a5780638b15788e146103455780639748cf7c1461034057806397943aa91461033b578063979f2bc21461033657806399cc2968146103315780639a8a05921461032c578063a1244c6714610327578063a18a096e14610322578063ac9650d81461031d578063ad5425c614610318578063adb5a6a6146102d2578063b370b7f514610313578063babb6aac1461030e578063c35c83fc14610309578063c835685914610304578063ceb4c987146102ff578063d7e1583a146102fa578063daf9c210146102f5578063dda52113146102f0578063ddd224f1146102eb578063de7eba78146102e6578063deff4b24146102e1578063ea86bd46146102dc578063ee2a53f8146102d7578063f79f29ed146102d2578063fb6bf74c146102cd5763fc8a584f0361000e5761361f565b61349e565b612c88565b613442565b613308565b6131b8565b613139565b6130f2565b6130ae565b613044565b612ff0565b612ed8565b612e86565b612e3d565b612d3b565b612ce9565b612b01565b612a61565b612865565b612820565b6127e8565b6126eb565b61256d565b6124cf565b612461565b6123c5565b6122e6565b612145565b6120f0565b61202a565b611f6c565b611e6e565b611e10565b61082c565b611db8565b611d74565b611d16565b611b32565b611a51565b6119bc565b61196a565b6118f1565b611807565b611783565b6116ad565b611671565b611586565b611361565b6112a9565b61120e565b610f91565b610dd2565b610d8b565b610c84565b610b44565b610a1d565b610864565b6107be565b6106e7565b610402565b5f9103126103fe57565b5f80fd5b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b73ffffffffffffffffffffffffffffffffffffffff8116036103fe57565b359061048982610460565b565b63ffffffff8116036103fe57565b61014435906104898261048b565b35906104898261048b565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6040810190811067ffffffffffffffff8211176104fb57604052565b6104b2565b6101a0810190811067ffffffffffffffff8211176104fb57604052565b67ffffffffffffffff81116104fb57604052565b6060810190811067ffffffffffffffff8211176104fb57604052565b6080810190811067ffffffffffffffff8211176104fb57604052565b6020810190811067ffffffffffffffff8211176104fb57604052565b60e0810190811067ffffffffffffffff8211176104fb57604052565b60a0810190811067ffffffffffffffff8211176104fb57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176104fb57604052565b6040519060c0820182811067ffffffffffffffff8211176104fb57604052565b60405190610180820182811067ffffffffffffffff8211176104fb57604052565b6040519061048982610500565b604051906104898261054d565b67ffffffffffffffff81116104fb57601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b92919261069f82610659565b916106ad60405193846105bd565b8294818452818301116103fe578281602093845f960137010152565b9080601f830112156103fe578160206106e493359101610693565b90565b6101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561071e81610460565b60243561072a81610460565b6084358060070b81036103fe5760a435906107448261048b565b60c43567ffffffffffffffff81116103fe576107649036906004016106c9565b9261076d614228565b60ff61086b5460e81c166107945761078d946064359160443591336142a3565b6001606555005b60046040517f5a65d188000000000000000000000000000000000000000000000000000000008152fd5b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040515f8152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b67ffffffffffffffff81116104fb5760051b60200190565b9080601f830112156103fe576020908235610904816108d2565b9361091260405195866105bd565b81855260208086019260051b8201019283116103fe57602001905b82821061093b575050505090565b8135815290830190830161092d565b9080601f830112156103fe576020908235610964816108d2565b9361097260405195866105bd565b81855260208086019260051b8201019283116103fe57602001905b82821061099b575050505090565b83809183356109a981610460565b81520191019061098d565b92916109bf826108d2565b916109cd60405193846105bd565b829481845260208094019160051b81019283116103fe57905b8282106109f35750505050565b813581529083019083016109e6565b9080601f830112156103fe578160206106e4933591016109b4565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc6060813601126103fe57600435610a548161048b565b60243567ffffffffffffffff928382116103fe5760c09082360301126103fe57610a7c6105fe565b90806004013582526024810135602083015260448101358481116103fe57610aaa90600436918401016108ea565b6040830152610abb606482016104a7565b6060830152610acc6084820161047e565b608083015260a4810135908482116103fe576004610aed923692010161094a565b60a08201526044359283116103fe57610b0d610018933690600401610a02565b9161369e565b9181601f840112156103fe5782359167ffffffffffffffff83116103fe576020808501948460051b0101116103fe57565b346103fe577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc6060813601126103fe5760043567ffffffffffffffff8082116103fe576060823603938401126103fe5760243590610ba18261048b565b6044359081116103fe57610bb9903690600401610b13565b919093610bc4614228565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe7d846004013591018112156103fe57610c7094610c6b93610c0e610c649360043691890101612f14565b95610c1c6080880151614972565b50610c2687614010565b9060446020890151916101608a015193610c3e6105fe565b9a8b5260208b015201356040890152606088015260808701525f60a087015236916109b4565b9083614995565b614b2a565b6100186001606555565b801515036103fe57565b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435610cbf81610460565b6024359060443590610cd082610c7a565b73ffffffffffffffffffffffffffffffffffffffff9081731111000000000000000000000000000000001111816108695416011633036103fe577f0a21fdd43d0ad0c62689ee7230a47309a050755bcc52eba00310add65297692a91602091610d37614228565b1692835f5261086d825260405f20855f52825260405f20901515907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0081541660ff8316179055604051908152a36001606555005b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576020604051428152f35b90816101809103126103fe5790565b346103fe5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043567ffffffffffffffff81116103fe57610e21903690600401610dc3565b610e2a816138ed565b73ffffffffffffffffffffffffffffffffffffffff1690610e4d602082016138ed565b73ffffffffffffffffffffffffffffffffffffffff1691610e70604083016138ed565b73ffffffffffffffffffffffffffffffffffffffff16610e92606084016138ed565b73ffffffffffffffffffffffffffffffffffffffff1692610eb5608082016138ed565b73ffffffffffffffffffffffffffffffffffffffff1690610100610eda8183016138f7565b9061012090610eea8483016138f7565b9261014094858101610efb906138f7565b966101609a8b8301610f0d9084613901565b9a909b610f1861061e565b9e8f91825260208201526040015260608d015260808c015260a081013560a08c015260c081013560c08c015260e0013560e08b015263ffffffff1690890152870190610f69919063ffffffff169052565b63ffffffff909116908501523690610f8092610693565b90820152336024356100189261405f565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004803567ffffffffffffffff81116103fe57610fe09036908301610dc3565b610fe8614228565b60ff61086b5460e01c166111e55763ffffffff8042169261014083019361102181611012876138f7565b63ffffffff9182169116101590565b6111bc57610120840192611034846138f7565b16106111945761104c6110473685612f14565b614010565b90611060825f5261087260205260405f2090565b5461116c57506110af7f3cee3e290f36226751cd0b3321b213890fe9c768e922f267fa6111836ce05c32926110aa6110a46110b5945f5261087260205260405f2090565b60019055565b6138f7565b936138f7565b6110d56110d06110c9610160860186613901565b3691610693565b61507b565b9061115f6040519283926101008701359760e08801359760208101359281359260408301359260c08101359060a081013590606060808201359101358b9693909a999895919261012098959361014089019c895260208901526040880152606087015263ffffffff80921660808701521660a085015260c084015260e08301526101008201520152565b0390a36100186001606555565b6040517f012f9e44000000000000000000000000000000000000000000000000000000008152fd5b6040517fd642b7d9000000000000000000000000000000000000000000000000000000008152fd5b506040517f09deb9ec000000000000000000000000000000000000000000000000000000008152fd5b506040517f7b21f8aa000000000000000000000000000000000000000000000000000000008152fd5b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040517f9c6dfd61d811b9950a4f2b9adf46357b717c816d22c420d0bde8f2360148f7cd8152f35b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60409101126103fe5760043561129c81610460565b906024356106e481610460565b346103fe576112b736611266565b9073ffffffffffffffffffffffffffffffffffffffff9081731111000000000000000000000000000000001111816108695416011633036103fe5781906112fc614228565b1690815f52610c5b60205260405f20921691827fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557f8d7f294eaa476236fe8cb5629376a12cd37dace3d21e6a7b98f1641c4ed5f09e5f80a36001606555005b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561139c81610460565b73ffffffffffffffffffffffffffffffffffffffff807f0000000000000000000000000000000000000000000000000000000000000000168030146103fe57817f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416036103fe57731111000000000000000000000000000000001111816108695416011633036103fe576040516100189161143782610569565b5f8252615090565b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126103fe576004359067ffffffffffffffff82116103fe5761148891600401610b13565b9091565b5f5b83811061149d5750505f910152565b818101518382015260200161148e565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f6020936114e98151809281875287808801910161148c565b0116010190565b6020808201908083528351809252604092604081018260408560051b8401019601945f925b858410611526575050505050505090565b909192939495968580611575837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0866001960301885286838d51805115158452015191818582015201906114ad565b990194019401929594939190611515565b346103fe576115943661143f565b61159d816108d2565b9160406115ad60405194856105bd565b8284527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06115da846108d2565b015f5b81811061164e5750505f5b83811061160157604051806115fd87826114f0565b0390f35b8061164861161160019388613995565b515f8061161f858a8a6139a9565b9061162e8951809381936139c0565b0390305af49061163c6139cd565b60208201529015159052565b016115e8565b602090835161165c816104df565b5f8152826060818301528289010152016115dd565b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040516301e133808152f35b346103fe5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356024359073ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe57611723614228565b61086c8054680100000000000000008110156104fb5763ffffffff916001820190558361174f82613403565b5084600182015555167fc86ba04c55bc5eb2f2876b91c438849a296dbec7b08751c3074d92e04f0a77af5f80a46001606555005b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356117be81610460565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5761078d90611802614228565b61533c565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561183d81610460565b60243567ffffffffffffffff81116103fe5761185d9036906004016106c9565b73ffffffffffffffffffffffffffffffffffffffff807f0000000000000000000000000000000000000000000000000000000000000000168030146103fe57817f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416036103fe57731111000000000000000000000000000000001111816108695416011633036103fe5761001891615223565b346103fe5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5773ffffffffffffffffffffffffffffffffffffffff60043561194181610460565b165f5261086d60205260405f206024355f52602052602060ff60405f2054166040519015158152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602073ffffffffffffffffffffffffffffffffffffffff6108695416604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036103fe5760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b6101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435611a8881610460565b60243590611a9582610460565b60443591611aa283610460565b60a4358060070b81036103fe5760c43591611abc8361048b565b60e43567ffffffffffffffff81116103fe57611adc9036906004016106c9565b93611ae5614228565b60ff61086b5460e81c166107945761078d9560843592606435926142a3565b9181601f840112156103fe5782359167ffffffffffffffff83116103fe57602083818601950101116103fe57565b346103fe5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435611b6d81610460565b60243560443591606435611b8081610460565b67ffffffffffffffff916084358381116103fe57611ba2903690600401611b04565b60a4949194359182116103fe577f45e04bc8f121ba11466985789ca2822a91109f31bb8ac85504a37b7eaf873c2694611be2611d11933690600401611b04565b92909173ffffffffffffffffffffffffffffffffffffffff8097168a611d05611c0c368686610693565b60428d611c1a368b8b610693565b92602081519101209460409586519160208301937f9c6dfd61d811b9950a4f2b9adf46357b717c816d22c420d0bde8f2360148f7cd85528884015246606084015260808301528760a083015260c082015260c08152611c7881610585565b51902061047f546104805486519060208201927fc2f8787176b8ac6bf7215b4adcc1e069bf4ab82d9ab1df05a57a91d425935b6e845288830152606082015246608082015260808152611cca816105a1565b519020908551917f1901000000000000000000000000000000000000000000000000000000000000835260028301526022820152208a615fa0565b51978897169a87613a3a565b0390a3005b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060ff61086b5460e81c166040519015158152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040517f8d1994e2bbbd77564cdca06dd819e7ee2a5efa06c80dcb59a4a7b6e39edc538f8152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435611ea981610c7a565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5760207fe88463c2f254e2b070013a2dc7ee1e099f9bc00534cbdf03af551dc26ae4921991611f0d614228565b151561086b80547fffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7dff00000000000000000000000000000000000000000000000000000000008460e81b169116179055604051908152a16001606555005b6101607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435611fa381610460565b60243590611fb082610460565b604435611fbc81610460565b60643590611fc982610460565b60e435611fd581610460565b6101043590611fe38261048b565b6101243592611ff18461048b565b610144359667ffffffffffffffff88116103fe57612016610018983690600401611b04565b97909660c4359360a4359360843593613ab7565b6101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561206181610460565b6024359061206e82610460565b60443561207a81610460565b6064359061208782610460565b60e43561209381610460565b610104356120a08161048b565b61012435916120ae8361048b565b6120b6610499565b93610164359767ffffffffffffffff89116103fe576120dc610018993690600401611b04565b98909760c4359360a4359360843593613ad9565b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602061213d60043561213081610460565b6044359060243590613c62565b604051908152f35b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5767ffffffffffffffff6024358181116103fe57612195903690600401611b04565b916044359081116103fe576121ae903690600401611b04565b90604051936020850194806121c54684888a613cb0565b03956121f77fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0978881018452836105bd565b60043591519020036122bc575f946122266122619361221d8761226d958a990190612fca565b95810190613ccd565b519360405193849160208301967fdeff4b24000000000000000000000000000000000000000000000000000000008852339160248501613d95565b039081018352826105bd565b5190305af461227a6139cd565b901561228257005b6122b8906040519182917fb8fe37a700000000000000000000000000000000000000000000000000000000835260048301613db7565b0390fd5b60046040517f1e191e8e000000000000000000000000000000000000000000000000000000008152fd5b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043573ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe57612358614228565b61236181613403565b612399576001815f80935501557f7c1af0646963afc3343245b103731965735a893347bfa0d58a5dc77a77ae691c5f80a26001606555005b7f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b6101a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57610124356123fd8161048b565b6101443561240a8161048b565b61016435916124188361048b565b610184359267ffffffffffffffff84116103fe5761243d610018943690600401611b04565b9390926101043560e43560c43560a435608435606435604435602435600435613dc8565b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346103fe5760e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5767ffffffffffffffff6004358181116103fe5761251f903690600401610dc3565b60a4358281116103fe57612537903690600401611b04565b60c4929192359384116103fe57612555610018943690600401611b04565b93909260843590606435906044359060243590613e40565b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356125a88161048b565b602435906125b582610460565b604435906125c282610460565b60ff5f5460081c16156103fe576126239061086b907fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff7bffffffff00000000000000000000000000000000000000000000000083549260c01b169116179055565b60405161262f816104df565b6009815260208101927f4143524f53532d5632000000000000000000000000000000000000000000000084527f312e302e30000000000000000000000000000000000000000000000000000000602060405161268a816104df565b60058152015260ff5f5460081c16156103fe57610018936126e69251902061047f557f06c015bd22b4c69690933c1058878ebdfef31f9aaae40bbe86d8a09fe1b2972c610480556126d96158d5565b6126e16158e4565b6158f8565b61598f565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561272681610c7a565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5760207f2d5b62420992e5a4afce0e77742636ca2608ef58289fd2e1baa5161ef6e7e41e9161278a614228565b151561086b80547fffffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffff7cff000000000000000000000000000000000000000000000000000000008460e01b169116179055604051908152a16001606555005b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576020604051468152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602063ffffffff61086b5460c01c16604051908152f35b346103fe5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356024356128a382615e1e565b73ffffffffffffffffffffffffffffffffffffffff82165f526108736020526128ec60405f203373ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b549182156129b6575f61294d3361292a61290585614972565b73ffffffffffffffffffffffffffffffffffffffff165f5261087360205260405f2090565b9073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b556129868361297761295e84614972565b73ffffffffffffffffffffffffffffffffffffffff1690565b61298085614972565b90615a26565b60405192835233927f6c172ea51018fb2eb2118f3f8a507c4df71eb519b8c0052834dc3c920182fef490602090a4005b60046040517fd950afdc000000000000000000000000000000000000000000000000000000008152fd5b6020808201906020835283518092526040830192602060408460051b8301019501935f915b848310612a155750505050505090565b9091929394958480612a51837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc086600196030187528a516114ad565b9801930193019194939290612a05565b346103fe57612a6f3661143f565b90612a7982613f36565b915f5b818110612a9157604051806115fd86826129e0565b5f80612a9e8385876139a9565b90612aae604051809381936139c0565b0390305af4612abb6139cd565b9015612ae15790600191612acf8287613995565b52612ada8186613995565b5001612a7c565b60448151106103fe578060046103fe920151602480918301019101613f9c565b610180807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5761010435612b3a8161048b565b6101243591612b488361048b565b6101443592612b568461048b565b6101643567ffffffffffffffff81116103fe57612b77903690600401611b04565b612b7f614228565b61086b549260ff8460e81c1661079457610c7096612c716110c992612c6363ffffffff612c7f9860c01c1699612c07612bb78c613ffb565b61086b907fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff7bffffffff00000000000000000000000000000000000000000000000083549260c01b169116179055565b612c0f61063f565b9a6004358c5260243560208d015260443560408d015260643560608d015260843560808d015260a43560a08d015260c43560c08d015260e43560e08d01526101008c01526101208b019063ffffffff169052565b63ffffffff16610140890152565b63ffffffff16610160870152565b908201526154f0565b346103fe576020612ce073ffffffffffffffffffffffffffffffffffffffff612cb036611266565b91165f52610873835260405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b54604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602073ffffffffffffffffffffffffffffffffffffffff61086a5416604051908152f35b346103fe5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043560243567ffffffffffffffff6064356044356084358381116103fe57612d97903690600401611b04565b60a4949194359182116103fe577f45e04bc8f121ba11466985789ca2822a91109f31bb8ac85504a37b7eaf873c2694612dd7612e33933690600401611b04565b929091612de2614228565b612deb8a615e1e565b612e27898b8989612dfd368888610693565b92612e09368b8b610693565b9473ffffffffffffffffffffffffffffffffffffffff4692166153a3565b60405196879687613a3a565b0390a36001606555005b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004355f52610872602052602060405f2054604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602073ffffffffffffffffffffffffffffffffffffffff610c5a5416604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405163ffffffff8152f35b9190610180838203126103fe57612f2961061e565b92803584526020810135602085015260408101356040850152606081013560608501526080810135608085015260a081013560a085015260c081013560c085015260e081013560e08501526101008082013590850152610120612f8d8183016104a7565b90850152610140612f9f8183016104a7565b90850152610160918282013567ffffffffffffffff81116103fe57612fc492016106c9565b90830152565b906020828203126103fe57813567ffffffffffffffff81116103fe576106e49201612f14565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043567ffffffffffffffff81116103fe5761213d6110476020923690600401612f14565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060043561308181610460565b73ffffffffffffffffffffffffffffffffffffffff8091165f52610c5b825260405f205416604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060ff61086b5460e01c166040519015158152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040516ec097ce7bc90715b34b9f10000000008152f35b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561317481610460565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5761078d906126e1614228565b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043567ffffffffffffffff81116103fe57613207903690600401612f14565b61320f614228565b60ff61086b5460e01c166132de5761014081015163ffffffff42811691161015806132b2575b6132885780613246610c7092614010565b60c0820151602083015190610160840151926132606105fe565b948552602085015260408401526060830152608082015260243560a082015260443590614df4565b60046040517fc3a9b9d0000000000000000000000000000000000000000000000000000000008152fd5b506132c06040820151614972565b73ffffffffffffffffffffffffffffffffffffffff16331415613235565b60046040517f7b21f8aa000000000000000000000000000000000000000000000000000000008152fd5b610160807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57610104356133418161048b565b6101243561334e8161048b565b6101443567ffffffffffffffff81116103fe5761336f903690600401611b04565b63ffffffff946133828642169586613a9a565b9361338b614228565b61086b549160ff8360e81c16610794576133be6133cb96612c63610c709a6110c99660c01c1699612c07612bb78c613ffb565b86019063ffffffff169052565b6101808201526154f0565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b61086c90815481101561343d576003915f52027f71cd7344f4eb2efc8e30291f6dbdb44d618ca368ea5425d217c1d604bf26b84d01905f90565b6133d6565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561086c548110156103fe5761348a604091613403565b506001815491015482519182526020820152f35b346103fe5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356134d98161048b565b61355d6024356134e881610460565b6044356134f481610460565b6064359161350183610460565b5f549461352560ff8760081c161580978198613611575b81156135f1575b5061398e565b8561355460017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b6135bd57614108565b61356357005b61358e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff5f54165f55565b604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249890602090a1005b6135ec6101007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff5f5416175f55565b614108565b303b15915081613603575b505f61351f565b6001915060ff16145f6135fc565b600160ff8216109150613518565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561365a81610460565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5761078d906126e6614228565b91906136a8614228565b6020810191825146036137ec576136d06136d4918360016136c888613403565b500154614592565b1590565b6137c2577ff4ad92585b1bc117fbdd644990adf0827bc4c95baeae8a23322af807b6d0020e606082019261371561370f855163ffffffff1690565b8661466d565b80516137b5845192604086019561379a61377f61376e89519661373c8c5163ffffffff1690565b9760808601986137608a5173ffffffffffffffffffffffffffffffffffffffff1690565b9160a088019b8c51946146f6565b925193519851995163ffffffff1690565b945173ffffffffffffffffffffffffffffffffffffffff1690565b945163ffffffff9586604051978897169b1699339487613892565b0390a46104896001606555565b60046040517fb05e92fa000000000000000000000000000000000000000000000000000000008152fd5b60046040517f7a47c9a2000000000000000000000000000000000000000000000000000000008152fd5b9081518082526020808093019301915f5b828110613835575050505090565b835185529381019392810192600101613827565b9081518082526020808093019301915f5b828110613868575050505090565b835173ffffffffffffffffffffffffffffffffffffffff168552938101939281019260010161385a565b94969591936138b460a0956138df93885260c0602089015260c0880190613816565b9073ffffffffffffffffffffffffffffffffffffffff80951660408801528682036060880152613849565b951515608085015216910152565b356106e481610460565b356106e48161048b565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1813603018212156103fe570180359067ffffffffffffffff82116103fe576020019181360383136103fe57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b6003111561398957565b613952565b156103fe57565b805182101561343d5760209160051b010190565b9082101561343d576114889160051b810190613901565b908092918237015f815290565b3d156139f7573d906139de82610659565b916139ec60405193846105bd565b82523d5f602084013e565b606090565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b94929093613a5f926106e49795875260208701526080604087015260808601916139fc565b9260608185039101526139fc565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b91909163ffffffff80809416911601918211613ab257565b613a6d565b96949290916104899b9a9998969492613ad763ffffffff42169889613a9a565b985b9593919b999897969492909b613aed614228565b61086b549660ff8860e81c16610794578760c01c63ffffffff16613b1090613ffb565b613b649061086b907fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff7bffffffff00000000000000000000000000000000000000000000000083549260c01b169116179055565b613b6c61063f565b9d73ffffffffffffffffffffffffffffffffffffffff8f9216825273ffffffffffffffffffffffffffffffffffffffff16906020015273ffffffffffffffffffffffffffffffffffffffff1660408d015273ffffffffffffffffffffffffffffffffffffffff1660608c015260808b015260a08a015260c089015273ffffffffffffffffffffffffffffffffffffffff1660e088015260c01c63ffffffff16610100870152610120860190613c26919063ffffffff169052565b63ffffffff1661014085015263ffffffff166101608401523690613c4992610693565b610180820152613c58906154f0565b6104896001606555565b91604051917fffffffffffffffffffffffffffffffffffffffff000000000000000000000000602084019460601b1684526034830152605482015260548152613caa8161054d565b51902090565b939291602091613cc8916040875260408701916139fc565b930152565b908160209103126103fe57604051906020820182811067ffffffffffffffff8211176104fb5760405235815290565b6106e49161018090825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015190820152613d71610120808501519083019063ffffffff169052565b6101408381015163ffffffff169082015281610160809401519382015201906114ad565b613dad60409295949395606083526060830190613cfc565b9460208201520152565b9060206106e49281815201906114ad565b9c9a9998979695949392919096613ddd614228565b60ff61086b5460e81c1661079457613df6908e33613c62565b96604051809e613e0582610500565b81526020015260408d015260608c015260808b015260a08a015260c089015260e088015261010087015263ffffffff16610120860152613c26565b979290959391969497613e51614228565b60ff61086b5460e01c166132de57613e6c61014082016138f7565b63ffffffff8042169116101580613f0a575b61328857613ef3613f0596613eeb613c589b613e9d6110473687612f14565b9a613ea66105fe565b9b613eb13688612f14565b8d5260208d01528660408d01528760608d0152613ecf368b84610693565b60808d015260a08c0152613ee38535614972565b983691610693565b953691610693565b9461010060e0830135920135906153a3565b614df4565b50613f186040820135614972565b73ffffffffffffffffffffffffffffffffffffffff16331415613e7e565b90613f40826108d2565b613f4d60405191826105bd565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0613f7b82946108d2565b01905f5b828110613f8b57505050565b806060602080938501015201613f7f565b6020818303126103fe5780519067ffffffffffffffff82116103fe570181601f820112156103fe578051613fcf81610659565b92613fdd60405194856105bd565b818452602082840101116103fe576106e4916020808501910161148c565b63ffffffff809116908114613ab25760010190565b604051613caa8161402d6020820194604086526060830190613cfc565b466040830152037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826105bd565b91909161406a614228565b60ff61086b5460e01c166132de5761014081015163ffffffff42811691161015806140dc575b61328857613c58926140a182614010565b60c0830151602084015190610160850151926140bb6105fe565b958652602086015260408501526060840152608083015260a0820152614df4565b506140ea6040820151614972565b73ffffffffffffffffffffffffffffffffffffffff16331415614090565b9290919260ff5f5460081c16156103fe5761416d9061086b907fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff7bffffffff00000000000000000000000000000000000000000000000083549260c01b169116179055565b6040519061417a826104df565b6009825260208201917f4143524f53532d5632000000000000000000000000000000000000000000000083527f312e302e3000000000000000000000000000000000000000000000000000000060206040516141d5816104df565b60058152015260ff5f5460081c16156103fe5761048994611802936126e69251902061047f557f06c015bd22b4c69690933c1058878ebdfef31f9aaae40bbe86d8a09fe1b2972c610480556126d96158d5565b6002606554146103fe576002606555565b91908203918211613ab257565b6040513d5f823e3d90fd5b926106e49695929491946101409585525f60208601526040850152606084015263ffffffff809116608084015260a08301525f60c083015260e08201525f6101008201528161012082015201906114ad565b919394969095966142f16136d06142ea886142dd8973ffffffffffffffffffffffffffffffffffffffff165f5261086d60205260405f2090565b905f5260205260405f2090565b5460ff1690565b6145685760070b906706f05b59d3b2000061430b83615ab2565b101561453e576ec097ce7bc90715b34b9f100000000084116145145763ffffffff93614339858a1642614239565b857f000000000000000000000000000000000000000000000000000000000000000016106144ea5761086b5460c01c63ffffffff169861437b612bb78b613ffb565b73ffffffffffffffffffffffffffffffffffffffff9586807f000000000000000000000000000000000000000000000000000000000000000016981692888414806144e1575b156144a55780340361447b57883b156103fe575f6004996040519a8b80927fd0e30db000000000000000000000000000000000000000000000000000000000825234905af198891561447657614445614458978a927f32ed1a409ef04c7b0227189c3a103dc5ac10e775a15b785dcc510201f7c25ad39c61445d575b505b83615b26565b92604051998a99169d169b169387614251565b0390a4565b8061446a6144709261051d565b806103f4565b5f61443d565b614246565b60046040517f6452a35d000000000000000000000000000000000000000000000000000000008152fd5b7f32ed1a409ef04c7b0227189c3a103dc5ac10e775a15b785dcc510201f7c25ad3985087614445614458976144dc8430338a615ac1565b61443f565b503415156143c1565b60046040517ff722177f000000000000000000000000000000000000000000000000000000008152fd5b60046040517fc45b6b52000000000000000000000000000000000000000000000000000000008152fd5b60046040517fa13c425c000000000000000000000000000000000000000000000000000000008152fd5b60046040517f2a58c4f3000000000000000000000000000000000000000000000000000000008152fd5b6106e4929160405161466481614638602082019460208652805160408401526020810151606084015260a06145d7604083015160c06080870152610100860190613816565b9163ffffffff6060820151168286015273ffffffffffffffffffffffffffffffffffffffff60808201511660c086015201517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08483030160e0850152613849565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826105bd565b51902091615b5c565b614678600291613403565b500162ffffff8260081c16805f5281602052600160ff60405f205494161b80809416146146b0575f5260205260405f20908154179055565b60046040517f954476d9000000000000000000000000000000000000000000000000000000008152fd5b908160209103126103fe575190565b91908201809211613ab257565b91959495939092935f96815190818151036149485781614782575b50505082614720575b50505050565b73ffffffffffffffffffffffffffffffffffffffff816147617ffa7fa7cf6d7dde5f9be65a67e6a1a747e7aa864dcd2d793353c722d80fbbb3579386615c45565b6040805195865233602087015291169463ffffffff1693a45f80808061471a565b604080517f70a0823100000000000000000000000000000000000000000000000000000000815230600480830191909152919060208160248173ffffffffffffffffffffffffffffffffffffffff8b165afa908115614476575f91614919575b505f805b8681106147f7575050505050614711565b6148018189613995565b5161480f575b6001016147e6565b906148259061481e838a613995565b51906146e9565b908282116148f05761486c6136d061485a614840848a613995565b5173ffffffffffffffffffffffffffffffffffffffff1690565b614864848c613995565b51908c615bad565b15614807579c50876148e66148de8f6148bc6148406148b561488e848f613995565b519673ffffffffffffffffffffffffffffffffffffffff165f5261087360205260405f2090565b928b613995565b73ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b9182546146e9565b905560019c614807565b505050517f5bb55062000000000000000000000000000000000000000000000000000000008152fd5b61493b915060203d602011614941575b61493381836105bd565b8101906146da565b5f6147e2565b503d614929565b60046040517fcd298b38000000000000000000000000000000000000000000000000000000008152fd5b73ffffffffffffffffffffffffffffffffffffffff9061499181615e1e565b1690565b916136d090614a2c928451604080960151918651916149b383610531565b82526146646149ce6020840192468452898501958652613403565b50549388519283916149f36020840196602088525160608d86015260a0850190613cfc565b91516060840152516080830152037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826105bd565b614a335750565b600490517fb05e92fa000000000000000000000000000000000000000000000000000000008152fd5b614a658261397f565b52565b9a989693919c9b9997959492909c6101e08c019d8c5260208c015260408b015260608a0152608089015263ffffffff80921660a08901521660c087015260e08601526101008501526101208401526101408301528051610160830152602081015161018083015260408101516101a08301526060015190614ae88261397f565b6101c00152565b906106e4949360809373ffffffffffffffffffffffffffffffffffffffff8093168452602084015216604082015281606082015201906114ad565b905f82516101208101614b41815163ffffffff1690565b63ffffffff42911610614dca576020850151906002614b69835f5261087260205260405f2090565b5414614da057614b8386925f5261087260205260405f2090565b6002905560608301519060808401519160a08501519260c0860151918560a0810151938860e0810151956101008201519751614bc29063ffffffff1690565b61014083015163ffffffff166040840151918451936020860151956101600151614beb9061507b565b966060890151986080019e8f51614c019061507b565b906040015190614c0f61064c565b9a8b5260208b015260408a0152600260608a01526040519d8e9b614c339b8d614a68565b037f44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208905f94a46080820151614c6790614972565b9060408601519560600151614c7b90614972565b9260800151614c8990614972565b73ffffffffffffffffffffffffffffffffffffffff919082167f0000000000000000000000000000000000000000000000000000000000000000831603614d8b5784614d78575b614cdc87838616615e51565b51928351151580614d6e575b614cf6575b50505050509050565b1690813b15614d6a5783614d3d9596604051968795869485937f3a5be8cb000000000000000000000000000000000000000000000000000000008552339160048601614aef565b03925af1801561447657614d57575b808080808594614ced565b8061446a614d649261051d565b5f614d4c565b8380fd5b50803b1515614ce8565b614d86873033858716615ac1565b614cd0565b5f9450614d9b8785858516615a26565b614cdc565b60046040517f8f260c60000000000000000000000000000000000000000000000000000000008152fd5b60046040517fd642b7d9000000000000000000000000000000000000000000000000000000008152fd5b8051916101208301614e0a815163ffffffff1690565b63ffffffff42911610614dca5760208301516001614e31825f5261087260205260405f2090565b5403615074576001905b6002614e50825f5261087260205260405f2090565b5414614da057614e6c614e72915f5261087260205260405f2090565b60029055565b7f44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa7503746901372086060860151608087015190614f3f8760a08a0151958a60c08101519760a08401519860e083015199614ecf6101008501519c5163ffffffff1690565b61014085015163ffffffff1691604086015193865195614f33614efb61016060208b01519a015161507b565b9960608c01519b6040614f11608083015161507b565b910151906020614f1f61064c565b9e8f528e015260408d015260608c01614a5c565b6040519c8d9c8d614a68565b0390a4614f4f6080830151614972565b916040820151916080614f7181614f696060850151614972565b940151614972565b73ffffffffffffffffffffffffffffffffffffffff929083167f000000000000000000000000000000000000000000000000000000000000000084160361506157614fc0853033868a16615ac1565b614fcc85848616615e51565b0151918251151580615057575b614fe5575b5050505050565b16803b156103fe5761502c935f8094604051968795869485937f3a5be8cb000000000000000000000000000000000000000000000000000000008552339160048601614aef565b03925af1801561447657615044575b80808080614fde565b8061446a6150519261051d565b5f61503b565b50803b1515614fd9565b61506f858533868a16615ac1565b614fcc565b5f90614e3b565b805190816150895750505f90565b6020012090565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff16156150c4576104899150615f38565b73ffffffffffffffffffffffffffffffffffffffff81166040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481855afa5f9181615202575b5061511b575f80fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc036103fe5761514a82615f38565b7fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28151158015906151fb575b615181575050565b5f806151f8937f206661696c656400000000000000000000000000000000000000000000000000604080516151b581610531565b602781527f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c60208201520152602081519101845af46151f26139cd565b9161651d565b50565b505f615179565b61521c91925060203d6020116149415761493381836105bd565b905f615112565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff1615615257576104899150615f38565b73ffffffffffffffffffffffffffffffffffffffff81166040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481855afa5f918161531b575b506152ae575f80fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc036103fe576152dd82615f38565b7fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a281511580159061531357615181575050565b506001615179565b61533591925060203d6020116149415761493381836105bd565b905f6152a5565b73ffffffffffffffffffffffffffffffffffffffff16610c5a817fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557fdc4a5f4c066ad14c1306e624550b42395e08f992a76b416cc7b1ad11503d376c5f80a2565b9392604293610489979660208151910120906040519260208401947f8d1994e2bbbd77564cdca06dd819e7ee2a5efa06c80dcb59a4a7b6e39edc538f86526040850152856060850152608084015260a083015260c082015260c0815261540881610585565b5190209061047f549061048054906040519160208301937fc2f8787176b8ac6bf7215b4adcc1e069bf4ab82d9ab1df05a57a91d425935b6e85526040840152606083015260808201526080815261545e816105a1565b51902090604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090615fa0565b96926106e49a9996949198959261014099895260208901526040880152606087015263ffffffff928380921660808801521660a08601521660c084015260e08301526101008201528161012082015201906114ad565b6154fa8151615e1e565b6040908181019061553361550e8351614972565b73ffffffffffffffffffffffffffffffffffffffff165f5261086d60205260405f2090565b926155506136d06142ea60c085019687515f5260205260405f2090565b6158ac5761012082019261557461556b855163ffffffff1690565b63ffffffff1690565b804210908115615873575b5061584a57610140830192615598845163ffffffff1690565b9163ffffffff92836155cc817f000000000000000000000000000000000000000000000000000000000000000016426146e9565b9116116158215761016082015163ffffffff1692808416806157c5575b505080519373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016809514806157bc575b1561573e576080830151340361571557843b156103fe575f6004958251968780927fd0e30db000000000000000000000000000000000000000000000000000000000825234905af1918215614476577f32ed1a409ef04c7b0227189c3a103dc5ac10e775a15b785dcc510201f7c25ad39561445893615702575b505b519260608101519460808201519060a08301519a51986156e26156d76101008601519c5163ffffffff1690565b915163ffffffff1690565b9084519c60208601519461018060e088015197015197519a8b9a8b61549a565b8061446a61570f9261051d565b5f6156a8565b600490517f6452a35d000000000000000000000000000000000000000000000000000000008152fd5b9192935034615793577f32ed1a409ef04c7b0227189c3a103dc5ac10e775a15b785dcc510201f7c25ad39392918161578e61577f61295e6144589551614972565b60808601519030903390615ac1565b6156aa565b600482517f6452a35d000000000000000000000000000000000000000000000000000000008152fd5b5034151561562e565b6301e13380101561580c575b5060e0820151156157e3575f806155e9565b600484517f495d907f000000000000000000000000000000000000000000000000000000008152fd5b9261581a9193421690613a9a565b915f6157d1565b600484517f582e3889000000000000000000000000000000000000000000000000000000008152fd5b600482517ff722177f000000000000000000000000000000000000000000000000000000008152fd5b61587e915042614239565b63ffffffff7f000000000000000000000000000000000000000000000000000000000000000016105f61557f565b600490517f2a58c4f3000000000000000000000000000000000000000000000000000000008152fd5b60ff5f5460081c16156103fe57565b60ff5f5460081c16156103fe576001606555565b73ffffffffffffffffffffffffffffffffffffffff16801561596557610869817fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557fa9e8c42c9e7fca7f62755189a16b2f5314d43d8fb24e91ba54e6d65f9314e8495f80a2565b60046040517fba97b39d000000000000000000000000000000000000000000000000000000008152fd5b73ffffffffffffffffffffffffffffffffffffffff1680156159fc5761086a817fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557fa73e8909f8616742d7fe701153d82666f7b7cd480552e23ebb05d358c22fd04e5f80a2565b60046040517fb6061256000000000000000000000000000000000000000000000000000000008152fd5b6040517fa9059cbb00000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff9092166024830152604482019290925261048991615aad82606481015b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018452836105bd565b6160bc565b5f8112615abc5790565b5f0390565b909261048993604051937f23b872dd00000000000000000000000000000000000000000000000000000000602086015273ffffffffffffffffffffffffffffffffffffffff8092166024860152166044840152606483015260648252615aad826105a1565b90670de0b6b3a7640000915f828403921283831281169084841390151617613ab257818102918183041490151715613ab2570490565b929091905f915b8451831015615ba557615b768386613995565b519081811015615b94575f52602052600160405f205b920191615b63565b905f52602052600160405f20615b8c565b915092501490565b6040517fa9059cbb00000000000000000000000000000000000000000000000000000000602082810191825273ffffffffffffffffffffffffffffffffffffffff9094166024830152604482019490945290925f91615c0f8160648101614638565b519082855af1903d5f519083615c26575b50505090565b91925090615c3b57503b15155b5f8080615c20565b6001915014615c33565b9073ffffffffffffffffffffffffffffffffffffffff90817f000000000000000000000000000000000000000000000000000000000000000016151580615df1575b15615cb757505061048990615cb261086a5473ffffffffffffffffffffffffffffffffffffffff1690565b616159565b915f91615d10615d06615cec615dc59673ffffffffffffffffffffffffffffffffffffffff165f52610c5b60205260405f2090565b5473ffffffffffffffffffffffffffffffffffffffff1690565b918216151561398e565b615d3661295e61295e610c5a5473ffffffffffffffffffffffffffffffffffffffff1690565b9083615d5861086a5473ffffffffffffffffffffffffffffffffffffffff1690565b6040517f7b3a3c8b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9384166004820152921660248301526044820193909352608060648201525f60848201529384928391829060a4820190565b03925af1801561447657615dd65750565b6151f8903d805f833e615de981836105bd565b810190613f9c565b50817f00000000000000000000000000000000000000000000000000000000000000001682821614615c87565b60a01c615e2757565b60046040517ff3d81dae000000000000000000000000000000000000000000000000000000008152fd5b73ffffffffffffffffffffffffffffffffffffffff90811690813b15615e9e579061048992917f000000000000000000000000000000000000000000000000000000000000000016615a26565b7f000000000000000000000000000000000000000000000000000000000000000016803b156103fe575f80916024604051809481937f2e1a7d4d0000000000000000000000000000000000000000000000000000000083528860048401525af1801561447657615f29575b508147106103fe575f80809381935af1615f216139cd565b50156103fe57565b615f329061051d565b5f615f09565b803b156103fe5773ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc91167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b615faa83836163fc565b600581959295101561398957159384616099575b508315615ffa575b50505015615fd057565b60046040517f938a1821000000000000000000000000000000000000000000000000000000008152fd5b5f92935090829160405161604b8161463860208201947f1626ba7e00000000000000000000000000000000000000000000000000000000998a875260248401526040604484015260648301906114ad565b51915afa906160586139cd565b8261608b575b8261606e575b50505f8080615fc6565b616083919250602080825183010191016146da565b145f80616064565b91506020825110159161605e565b73ffffffffffffffffffffffffffffffffffffffff83811691161493505f615fbe565b905f8073ffffffffffffffffffffffffffffffffffffffff6161209416927f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65646020604051616109816104df565b818152015260208151910182855af16151f26139cd565b8051908115918215616136575b5050156103fe57565b81925090602091810103126103fe576020015161615281610c7a565b5f8061612d565b73ffffffffffffffffffffffffffffffffffffffff809116917f000000000000000000000000000000000000000000000000000000000000000090827f0000000000000000000000000000000000000000000000000000000000000000166161c282828561642d565b604090604051917fcb75c11c0000000000000000000000000000000000000000000000000000000083526020936004958585600481875afa94851561447657869189915f97616398575b501697604051958680927fa56ec632000000000000000000000000000000000000000000000000000000008252816162648d6004830191909173ffffffffffffffffffffffffffffffffffffffff6020820193169052565b0392165afa938415614476575f94616379575b5092947f000000000000000000000000000000000000000000000000000000000000000093805b6162ad57505050505050505050565b61632490878111156163735787905b84517f6fd3504e00000000000000000000000000000000000000000000000000000000815284810183815263ffffffff89166020820152604081018d905273ffffffffffffffffffffffffffffffffffffffff8c166060820152909389918591829160800190565b03815f8a5af19283156144765761634093616346575b50614239565b8061629e565b61636590893d8b1161636c575b61635d81836105bd565b8101906163dc565b505f61633a565b503d616353565b806162bc565b616391919450853d87116149415761493381836105bd565b925f616277565b6163b9919750833d85116163c0575b6163b181836105bd565b8101906163c7565b955f61620c565b503d6163a7565b908160209103126103fe57516106e481610460565b908160209103126103fe575167ffffffffffffffff811681036103fe5790565b9060418151145f146164245761148891602082015190606060408401519301515f1a90616546565b50505f90600290565b60449192602073ffffffffffffffffffffffffffffffffffffffff604051948580927fdd62ed3e000000000000000000000000000000000000000000000000000000008252306004830152808916602483015286165afa928315614476575f936164fc575b508201809211613ab2576040517f095ea7b300000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff909316602484015260448301919091526104899190615aad8260648101615a81565b61651691935060203d6020116149415761493381836105bd565b915f616492565b90156165375781511561652e575090565b3b156103fe5790565b5080519081156103fe57602001fd5b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a084116165c3576020935f9360ff60809460405194855216868401526040830152606082015282805260015afa15614476575f5173ffffffffffffffffffffffffffffffffffffffff8116156165bb57905f90565b505f90600190565b505050505f9060039056fea2646970667358221220494b12c51e59175a026d94cb62b3bf5960ebfbeef6e44633842b367034511cc964736f6c63430008170033",
  "deployedBytecode": "0x6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c8063079bd2c7146103ef5780631186ec33146103ea57806311eac855146103e557806315348e441461036d57806317fcb39b146103e05780631b3d5559146103db5780631fab657c146103d6578063272751c7146103d157806329cb924d146103cc5780632e378115146103c75780632e63e59a146103c257806333a84ff0146103bd578063364f01a6146103b85780633659cfe6146103b3578063437b9116146103ae578063490e49ef146103a9578063493a4f84146103a45780634e3485c81461039f5780634f1ef2861461039a5780635249fef1146103955780635285e0581461039057806352d1902d1461038b578063541f4f1414610386578063577f51f81461038157806357f6dcb81461037c5780636068d6cb14610377578063670fa8ac146103725780636bbbcd2e1461036d5780636e40098314610368578063738b62e5146103635780637aef642c1461035e5780637b939232146103595780637ef413e11461035457806382e2c43f1461034f5780638a7860ce1461034a5780638b15788e146103455780639748cf7c1461034057806397943aa91461033b578063979f2bc21461033657806399cc2968146103315780639a8a05921461032c578063a1244c6714610327578063a18a096e14610322578063ac9650d81461031d578063ad5425c614610318578063adb5a6a6146102d2578063b370b7f514610313578063babb6aac1461030e578063c35c83fc14610309578063c835685914610304578063ceb4c987146102ff578063d7e1583a146102fa578063daf9c210146102f5578063dda52113146102f0578063ddd224f1146102eb578063de7eba78146102e6578063deff4b24146102e1578063ea86bd46146102dc578063ee2a53f8146102d7578063f79f29ed146102d2578063fb6bf74c146102cd5763fc8a584f0361000e5761361f565b61349e565b612c88565b613442565b613308565b6131b8565b613139565b6130f2565b6130ae565b613044565b612ff0565b612ed8565b612e86565b612e3d565b612d3b565b612ce9565b612b01565b612a61565b612865565b612820565b6127e8565b6126eb565b61256d565b6124cf565b612461565b6123c5565b6122e6565b612145565b6120f0565b61202a565b611f6c565b611e6e565b611e10565b61082c565b611db8565b611d74565b611d16565b611b32565b611a51565b6119bc565b61196a565b6118f1565b611807565b611783565b6116ad565b611671565b611586565b611361565b6112a9565b61120e565b610f91565b610dd2565b610d8b565b610c84565b610b44565b610a1d565b610864565b6107be565b6106e7565b610402565b5f9103126103fe57565b5f80fd5b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b73ffffffffffffffffffffffffffffffffffffffff8116036103fe57565b359061048982610460565b565b63ffffffff8116036103fe57565b61014435906104898261048b565b35906104898261048b565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6040810190811067ffffffffffffffff8211176104fb57604052565b6104b2565b6101a0810190811067ffffffffffffffff8211176104fb57604052565b67ffffffffffffffff81116104fb57604052565b6060810190811067ffffffffffffffff8211176104fb57604052565b6080810190811067ffffffffffffffff8211176104fb57604052565b6020810190811067ffffffffffffffff8211176104fb57604052565b60e0810190811067ffffffffffffffff8211176104fb57604052565b60a0810190811067ffffffffffffffff8211176104fb57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176104fb57604052565b6040519060c0820182811067ffffffffffffffff8211176104fb57604052565b60405190610180820182811067ffffffffffffffff8211176104fb57604052565b6040519061048982610500565b604051906104898261054d565b67ffffffffffffffff81116104fb57601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b92919261069f82610659565b916106ad60405193846105bd565b8294818452818301116103fe578281602093845f960137010152565b9080601f830112156103fe578160206106e493359101610693565b90565b6101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561071e81610460565b60243561072a81610460565b6084358060070b81036103fe5760a435906107448261048b565b60c43567ffffffffffffffff81116103fe576107649036906004016106c9565b9261076d614228565b60ff61086b5460e81c166107945761078d946064359160443591336142a3565b6001606555005b60046040517f5a65d188000000000000000000000000000000000000000000000000000000008152fd5b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040515f8152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b67ffffffffffffffff81116104fb5760051b60200190565b9080601f830112156103fe576020908235610904816108d2565b9361091260405195866105bd565b81855260208086019260051b8201019283116103fe57602001905b82821061093b575050505090565b8135815290830190830161092d565b9080601f830112156103fe576020908235610964816108d2565b9361097260405195866105bd565b81855260208086019260051b8201019283116103fe57602001905b82821061099b575050505090565b83809183356109a981610460565b81520191019061098d565b92916109bf826108d2565b916109cd60405193846105bd565b829481845260208094019160051b81019283116103fe57905b8282106109f35750505050565b813581529083019083016109e6565b9080601f830112156103fe578160206106e4933591016109b4565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc6060813601126103fe57600435610a548161048b565b60243567ffffffffffffffff928382116103fe5760c09082360301126103fe57610a7c6105fe565b90806004013582526024810135602083015260448101358481116103fe57610aaa90600436918401016108ea565b6040830152610abb606482016104a7565b6060830152610acc6084820161047e565b608083015260a4810135908482116103fe576004610aed923692010161094a565b60a08201526044359283116103fe57610b0d610018933690600401610a02565b9161369e565b9181601f840112156103fe5782359167ffffffffffffffff83116103fe576020808501948460051b0101116103fe57565b346103fe577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc6060813601126103fe5760043567ffffffffffffffff8082116103fe576060823603938401126103fe5760243590610ba18261048b565b6044359081116103fe57610bb9903690600401610b13565b919093610bc4614228565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe7d846004013591018112156103fe57610c7094610c6b93610c0e610c649360043691890101612f14565b95610c1c6080880151614972565b50610c2687614010565b9060446020890151916101608a015193610c3e6105fe565b9a8b5260208b015201356040890152606088015260808701525f60a087015236916109b4565b9083614995565b614b2a565b6100186001606555565b801515036103fe57565b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435610cbf81610460565b6024359060443590610cd082610c7a565b73ffffffffffffffffffffffffffffffffffffffff9081731111000000000000000000000000000000001111816108695416011633036103fe577f0a21fdd43d0ad0c62689ee7230a47309a050755bcc52eba00310add65297692a91602091610d37614228565b1692835f5261086d825260405f20855f52825260405f20901515907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0081541660ff8316179055604051908152a36001606555005b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576020604051428152f35b90816101809103126103fe5790565b346103fe5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043567ffffffffffffffff81116103fe57610e21903690600401610dc3565b610e2a816138ed565b73ffffffffffffffffffffffffffffffffffffffff1690610e4d602082016138ed565b73ffffffffffffffffffffffffffffffffffffffff1691610e70604083016138ed565b73ffffffffffffffffffffffffffffffffffffffff16610e92606084016138ed565b73ffffffffffffffffffffffffffffffffffffffff1692610eb5608082016138ed565b73ffffffffffffffffffffffffffffffffffffffff1690610100610eda8183016138f7565b9061012090610eea8483016138f7565b9261014094858101610efb906138f7565b966101609a8b8301610f0d9084613901565b9a909b610f1861061e565b9e8f91825260208201526040015260608d015260808c015260a081013560a08c015260c081013560c08c015260e0013560e08b015263ffffffff1690890152870190610f69919063ffffffff169052565b63ffffffff909116908501523690610f8092610693565b90820152336024356100189261405f565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004803567ffffffffffffffff81116103fe57610fe09036908301610dc3565b610fe8614228565b60ff61086b5460e01c166111e55763ffffffff8042169261014083019361102181611012876138f7565b63ffffffff9182169116101590565b6111bc57610120840192611034846138f7565b16106111945761104c6110473685612f14565b614010565b90611060825f5261087260205260405f2090565b5461116c57506110af7f3cee3e290f36226751cd0b3321b213890fe9c768e922f267fa6111836ce05c32926110aa6110a46110b5945f5261087260205260405f2090565b60019055565b6138f7565b936138f7565b6110d56110d06110c9610160860186613901565b3691610693565b61507b565b9061115f6040519283926101008701359760e08801359760208101359281359260408301359260c08101359060a081013590606060808201359101358b9693909a999895919261012098959361014089019c895260208901526040880152606087015263ffffffff80921660808701521660a085015260c084015260e08301526101008201520152565b0390a36100186001606555565b6040517f012f9e44000000000000000000000000000000000000000000000000000000008152fd5b6040517fd642b7d9000000000000000000000000000000000000000000000000000000008152fd5b506040517f09deb9ec000000000000000000000000000000000000000000000000000000008152fd5b506040517f7b21f8aa000000000000000000000000000000000000000000000000000000008152fd5b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040517f9c6dfd61d811b9950a4f2b9adf46357b717c816d22c420d0bde8f2360148f7cd8152f35b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60409101126103fe5760043561129c81610460565b906024356106e481610460565b346103fe576112b736611266565b9073ffffffffffffffffffffffffffffffffffffffff9081731111000000000000000000000000000000001111816108695416011633036103fe5781906112fc614228565b1690815f52610c5b60205260405f20921691827fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557f8d7f294eaa476236fe8cb5629376a12cd37dace3d21e6a7b98f1641c4ed5f09e5f80a36001606555005b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561139c81610460565b73ffffffffffffffffffffffffffffffffffffffff807f0000000000000000000000000000000000000000000000000000000000000000168030146103fe57817f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416036103fe57731111000000000000000000000000000000001111816108695416011633036103fe576040516100189161143782610569565b5f8252615090565b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126103fe576004359067ffffffffffffffff82116103fe5761148891600401610b13565b9091565b5f5b83811061149d5750505f910152565b818101518382015260200161148e565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f6020936114e98151809281875287808801910161148c565b0116010190565b6020808201908083528351809252604092604081018260408560051b8401019601945f925b858410611526575050505050505090565b909192939495968580611575837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0866001960301885286838d51805115158452015191818582015201906114ad565b990194019401929594939190611515565b346103fe576115943661143f565b61159d816108d2565b9160406115ad60405194856105bd565b8284527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06115da846108d2565b015f5b81811061164e5750505f5b83811061160157604051806115fd87826114f0565b0390f35b8061164861161160019388613995565b515f8061161f858a8a6139a9565b9061162e8951809381936139c0565b0390305af49061163c6139cd565b60208201529015159052565b016115e8565b602090835161165c816104df565b5f8152826060818301528289010152016115dd565b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040516301e133808152f35b346103fe5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356024359073ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe57611723614228565b61086c8054680100000000000000008110156104fb5763ffffffff916001820190558361174f82613403565b5084600182015555167fc86ba04c55bc5eb2f2876b91c438849a296dbec7b08751c3074d92e04f0a77af5f80a46001606555005b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356117be81610460565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5761078d90611802614228565b61533c565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561183d81610460565b60243567ffffffffffffffff81116103fe5761185d9036906004016106c9565b73ffffffffffffffffffffffffffffffffffffffff807f0000000000000000000000000000000000000000000000000000000000000000168030146103fe57817f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416036103fe57731111000000000000000000000000000000001111816108695416011633036103fe5761001891615223565b346103fe5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5773ffffffffffffffffffffffffffffffffffffffff60043561194181610460565b165f5261086d60205260405f206024355f52602052602060ff60405f2054166040519015158152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602073ffffffffffffffffffffffffffffffffffffffff6108695416604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036103fe5760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b6101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435611a8881610460565b60243590611a9582610460565b60443591611aa283610460565b60a4358060070b81036103fe5760c43591611abc8361048b565b60e43567ffffffffffffffff81116103fe57611adc9036906004016106c9565b93611ae5614228565b60ff61086b5460e81c166107945761078d9560843592606435926142a3565b9181601f840112156103fe5782359167ffffffffffffffff83116103fe57602083818601950101116103fe57565b346103fe5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435611b6d81610460565b60243560443591606435611b8081610460565b67ffffffffffffffff916084358381116103fe57611ba2903690600401611b04565b60a4949194359182116103fe577f45e04bc8f121ba11466985789ca2822a91109f31bb8ac85504a37b7eaf873c2694611be2611d11933690600401611b04565b92909173ffffffffffffffffffffffffffffffffffffffff8097168a611d05611c0c368686610693565b60428d611c1a368b8b610693565b92602081519101209460409586519160208301937f9c6dfd61d811b9950a4f2b9adf46357b717c816d22c420d0bde8f2360148f7cd85528884015246606084015260808301528760a083015260c082015260c08152611c7881610585565b51902061047f546104805486519060208201927fc2f8787176b8ac6bf7215b4adcc1e069bf4ab82d9ab1df05a57a91d425935b6e845288830152606082015246608082015260808152611cca816105a1565b519020908551917f1901000000000000000000000000000000000000000000000000000000000000835260028301526022820152208a615fa0565b51978897169a87613a3a565b0390a3005b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060ff61086b5460e81c166040519015158152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040517f8d1994e2bbbd77564cdca06dd819e7ee2a5efa06c80dcb59a4a7b6e39edc538f8152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405163ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435611ea981610c7a565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5760207fe88463c2f254e2b070013a2dc7ee1e099f9bc00534cbdf03af551dc26ae4921991611f0d614228565b151561086b80547fffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7dff00000000000000000000000000000000000000000000000000000000008460e81b169116179055604051908152a16001606555005b6101607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57600435611fa381610460565b60243590611fb082610460565b604435611fbc81610460565b60643590611fc982610460565b60e435611fd581610460565b6101043590611fe38261048b565b6101243592611ff18461048b565b610144359667ffffffffffffffff88116103fe57612016610018983690600401611b04565b97909660c4359360a4359360843593613ab7565b6101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561206181610460565b6024359061206e82610460565b60443561207a81610460565b6064359061208782610460565b60e43561209381610460565b610104356120a08161048b565b61012435916120ae8361048b565b6120b6610499565b93610164359767ffffffffffffffff89116103fe576120dc610018993690600401611b04565b98909760c4359360a4359360843593613ad9565b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602061213d60043561213081610460565b6044359060243590613c62565b604051908152f35b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5767ffffffffffffffff6024358181116103fe57612195903690600401611b04565b916044359081116103fe576121ae903690600401611b04565b90604051936020850194806121c54684888a613cb0565b03956121f77fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0978881018452836105bd565b60043591519020036122bc575f946122266122619361221d8761226d958a990190612fca565b95810190613ccd565b519360405193849160208301967fdeff4b24000000000000000000000000000000000000000000000000000000008852339160248501613d95565b039081018352826105bd565b5190305af461227a6139cd565b901561228257005b6122b8906040519182917fb8fe37a700000000000000000000000000000000000000000000000000000000835260048301613db7565b0390fd5b60046040517f1e191e8e000000000000000000000000000000000000000000000000000000008152fd5b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043573ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe57612358614228565b61236181613403565b612399576001815f80935501557f7c1af0646963afc3343245b103731965735a893347bfa0d58a5dc77a77ae691c5f80a26001606555005b7f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b6101a07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57610124356123fd8161048b565b6101443561240a8161048b565b61016435916124188361048b565b610184359267ffffffffffffffff84116103fe5761243d610018943690600401611b04565b9390926101043560e43560c43560a435608435606435604435602435600435613dc8565b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346103fe5760e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5767ffffffffffffffff6004358181116103fe5761251f903690600401610dc3565b60a4358281116103fe57612537903690600401611b04565b60c4929192359384116103fe57612555610018943690600401611b04565b93909260843590606435906044359060243590613e40565b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356125a88161048b565b602435906125b582610460565b604435906125c282610460565b60ff5f5460081c16156103fe576126239061086b907fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff7bffffffff00000000000000000000000000000000000000000000000083549260c01b169116179055565b60405161262f816104df565b6009815260208101927f4143524f53532d5632000000000000000000000000000000000000000000000084527f312e302e30000000000000000000000000000000000000000000000000000000602060405161268a816104df565b60058152015260ff5f5460081c16156103fe57610018936126e69251902061047f557f06c015bd22b4c69690933c1058878ebdfef31f9aaae40bbe86d8a09fe1b2972c610480556126d96158d5565b6126e16158e4565b6158f8565b61598f565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561272681610c7a565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5760207f2d5b62420992e5a4afce0e77742636ca2608ef58289fd2e1baa5161ef6e7e41e9161278a614228565b151561086b80547fffffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffff7cff000000000000000000000000000000000000000000000000000000008460e01b169116179055604051908152a16001606555005b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576020604051468152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602063ffffffff61086b5460c01c16604051908152f35b346103fe5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356024356128a382615e1e565b73ffffffffffffffffffffffffffffffffffffffff82165f526108736020526128ec60405f203373ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b549182156129b6575f61294d3361292a61290585614972565b73ffffffffffffffffffffffffffffffffffffffff165f5261087360205260405f2090565b9073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b556129868361297761295e84614972565b73ffffffffffffffffffffffffffffffffffffffff1690565b61298085614972565b90615a26565b60405192835233927f6c172ea51018fb2eb2118f3f8a507c4df71eb519b8c0052834dc3c920182fef490602090a4005b60046040517fd950afdc000000000000000000000000000000000000000000000000000000008152fd5b6020808201906020835283518092526040830192602060408460051b8301019501935f915b848310612a155750505050505090565b9091929394958480612a51837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc086600196030187528a516114ad565b9801930193019194939290612a05565b346103fe57612a6f3661143f565b90612a7982613f36565b915f5b818110612a9157604051806115fd86826129e0565b5f80612a9e8385876139a9565b90612aae604051809381936139c0565b0390305af4612abb6139cd565b9015612ae15790600191612acf8287613995565b52612ada8186613995565b5001612a7c565b60448151106103fe578060046103fe920151602480918301019101613f9c565b610180807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5761010435612b3a8161048b565b6101243591612b488361048b565b6101443592612b568461048b565b6101643567ffffffffffffffff81116103fe57612b77903690600401611b04565b612b7f614228565b61086b549260ff8460e81c1661079457610c7096612c716110c992612c6363ffffffff612c7f9860c01c1699612c07612bb78c613ffb565b61086b907fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff7bffffffff00000000000000000000000000000000000000000000000083549260c01b169116179055565b612c0f61063f565b9a6004358c5260243560208d015260443560408d015260643560608d015260843560808d015260a43560a08d015260c43560c08d015260e43560e08d01526101008c01526101208b019063ffffffff169052565b63ffffffff16610140890152565b63ffffffff16610160870152565b908201526154f0565b346103fe576020612ce073ffffffffffffffffffffffffffffffffffffffff612cb036611266565b91165f52610873835260405f209073ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b54604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602073ffffffffffffffffffffffffffffffffffffffff61086a5416604051908152f35b346103fe5760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043560243567ffffffffffffffff6064356044356084358381116103fe57612d97903690600401611b04565b60a4949194359182116103fe577f45e04bc8f121ba11466985789ca2822a91109f31bb8ac85504a37b7eaf873c2694612dd7612e33933690600401611b04565b929091612de2614228565b612deb8a615e1e565b612e27898b8989612dfd368888610693565b92612e09368b8b610693565b9473ffffffffffffffffffffffffffffffffffffffff4692166153a3565b60405196879687613a3a565b0390a36001606555005b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004355f52610872602052602060405f2054604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602073ffffffffffffffffffffffffffffffffffffffff610c5a5416604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060405163ffffffff8152f35b9190610180838203126103fe57612f2961061e565b92803584526020810135602085015260408101356040850152606081013560608501526080810135608085015260a081013560a085015260c081013560c085015260e081013560e08501526101008082013590850152610120612f8d8183016104a7565b90850152610140612f9f8183016104a7565b90850152610160918282013567ffffffffffffffff81116103fe57612fc492016106c9565b90830152565b906020828203126103fe57813567ffffffffffffffff81116103fe576106e49201612f14565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043567ffffffffffffffff81116103fe5761213d6110476020923690600401612f14565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060043561308181610460565b73ffffffffffffffffffffffffffffffffffffffff8091165f52610c5b825260405f205416604051908152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57602060ff61086b5460e01c166040519015158152f35b346103fe575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760206040516ec097ce7bc90715b34b9f10000000008152f35b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561317481610460565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5761078d906126e1614228565b346103fe5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043567ffffffffffffffff81116103fe57613207903690600401612f14565b61320f614228565b60ff61086b5460e01c166132de5761014081015163ffffffff42811691161015806132b2575b6132885780613246610c7092614010565b60c0820151602083015190610160840151926132606105fe565b948552602085015260408401526060830152608082015260243560a082015260443590614df4565b60046040517fc3a9b9d0000000000000000000000000000000000000000000000000000000008152fd5b506132c06040820151614972565b73ffffffffffffffffffffffffffffffffffffffff16331415613235565b60046040517f7b21f8aa000000000000000000000000000000000000000000000000000000008152fd5b610160807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe57610104356133418161048b565b6101243561334e8161048b565b6101443567ffffffffffffffff81116103fe5761336f903690600401611b04565b63ffffffff946133828642169586613a9a565b9361338b614228565b61086b549160ff8360e81c16610794576133be6133cb96612c63610c709a6110c99660c01c1699612c07612bb78c613ffb565b86019063ffffffff169052565b6101808201526154f0565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b61086c90815481101561343d576003915f52027f71cd7344f4eb2efc8e30291f6dbdb44d618ca368ea5425d217c1d604bf26b84d01905f90565b6133d6565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561086c548110156103fe5761348a604091613403565b506001815491015482519182526020820152f35b346103fe5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe576004356134d98161048b565b61355d6024356134e881610460565b6044356134f481610460565b6064359161350183610460565b5f549461352560ff8760081c161580978198613611575b81156135f1575b5061398e565b8561355460017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b6135bd57614108565b61356357005b61358e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff5f54165f55565b604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249890602090a1005b6135ec6101007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff5f5416175f55565b614108565b303b15915081613603575b505f61351f565b6001915060ff16145f6135fc565b600160ff8216109150613518565b346103fe5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103fe5760043561365a81610460565b73ffffffffffffffffffffffffffffffffffffffff731111000000000000000000000000000000001111816108695416011633036103fe5761078d906126e6614228565b91906136a8614228565b6020810191825146036137ec576136d06136d4918360016136c888613403565b500154614592565b1590565b6137c2577ff4ad92585b1bc117fbdd644990adf0827bc4c95baeae8a23322af807b6d0020e606082019261371561370f855163ffffffff1690565b8661466d565b80516137b5845192604086019561379a61377f61376e89519661373c8c5163ffffffff1690565b9760808601986137608a5173ffffffffffffffffffffffffffffffffffffffff1690565b9160a088019b8c51946146f6565b925193519851995163ffffffff1690565b945173ffffffffffffffffffffffffffffffffffffffff1690565b945163ffffffff9586604051978897169b1699339487613892565b0390a46104896001606555565b60046040517fb05e92fa000000000000000000000000000000000000000000000000000000008152fd5b60046040517f7a47c9a2000000000000000000000000000000000000000000000000000000008152fd5b9081518082526020808093019301915f5b828110613835575050505090565b835185529381019392810192600101613827565b9081518082526020808093019301915f5b828110613868575050505090565b835173ffffffffffffffffffffffffffffffffffffffff168552938101939281019260010161385a565b94969591936138b460a0956138df93885260c0602089015260c0880190613816565b9073ffffffffffffffffffffffffffffffffffffffff80951660408801528682036060880152613849565b951515608085015216910152565b356106e481610460565b356106e48161048b565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1813603018212156103fe570180359067ffffffffffffffff82116103fe576020019181360383136103fe57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b6003111561398957565b613952565b156103fe57565b805182101561343d5760209160051b010190565b9082101561343d576114889160051b810190613901565b908092918237015f815290565b3d156139f7573d906139de82610659565b916139ec60405193846105bd565b82523d5f602084013e565b606090565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b94929093613a5f926106e49795875260208701526080604087015260808601916139fc565b9260608185039101526139fc565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b91909163ffffffff80809416911601918211613ab257565b613a6d565b96949290916104899b9a9998969492613ad763ffffffff42169889613a9a565b985b9593919b999897969492909b613aed614228565b61086b549660ff8860e81c16610794578760c01c63ffffffff16613b1090613ffb565b613b649061086b907fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff7bffffffff00000000000000000000000000000000000000000000000083549260c01b169116179055565b613b6c61063f565b9d73ffffffffffffffffffffffffffffffffffffffff8f9216825273ffffffffffffffffffffffffffffffffffffffff16906020015273ffffffffffffffffffffffffffffffffffffffff1660408d015273ffffffffffffffffffffffffffffffffffffffff1660608c015260808b015260a08a015260c089015273ffffffffffffffffffffffffffffffffffffffff1660e088015260c01c63ffffffff16610100870152610120860190613c26919063ffffffff169052565b63ffffffff1661014085015263ffffffff166101608401523690613c4992610693565b610180820152613c58906154f0565b6104896001606555565b91604051917fffffffffffffffffffffffffffffffffffffffff000000000000000000000000602084019460601b1684526034830152605482015260548152613caa8161054d565b51902090565b939291602091613cc8916040875260408701916139fc565b930152565b908160209103126103fe57604051906020820182811067ffffffffffffffff8211176104fb5760405235815290565b6106e49161018090825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e08201526101008084015190820152613d71610120808501519083019063ffffffff169052565b6101408381015163ffffffff169082015281610160809401519382015201906114ad565b613dad60409295949395606083526060830190613cfc565b9460208201520152565b9060206106e49281815201906114ad565b9c9a9998979695949392919096613ddd614228565b60ff61086b5460e81c1661079457613df6908e33613c62565b96604051809e613e0582610500565b81526020015260408d015260608c015260808b015260a08a015260c089015260e088015261010087015263ffffffff16610120860152613c26565b979290959391969497613e51614228565b60ff61086b5460e01c166132de57613e6c61014082016138f7565b63ffffffff8042169116101580613f0a575b61328857613ef3613f0596613eeb613c589b613e9d6110473687612f14565b9a613ea66105fe565b9b613eb13688612f14565b8d5260208d01528660408d01528760608d0152613ecf368b84610693565b60808d015260a08c0152613ee38535614972565b983691610693565b953691610693565b9461010060e0830135920135906153a3565b614df4565b50613f186040820135614972565b73ffffffffffffffffffffffffffffffffffffffff16331415613e7e565b90613f40826108d2565b613f4d60405191826105bd565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0613f7b82946108d2565b01905f5b828110613f8b57505050565b806060602080938501015201613f7f565b6020818303126103fe5780519067ffffffffffffffff82116103fe570181601f820112156103fe578051613fcf81610659565b92613fdd60405194856105bd565b818452602082840101116103fe576106e4916020808501910161148c565b63ffffffff809116908114613ab25760010190565b604051613caa8161402d6020820194604086526060830190613cfc565b466040830152037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826105bd565b91909161406a614228565b60ff61086b5460e01c166132de5761014081015163ffffffff42811691161015806140dc575b61328857613c58926140a182614010565b60c0830151602084015190610160850151926140bb6105fe565b958652602086015260408501526060840152608083015260a0820152614df4565b506140ea6040820151614972565b73ffffffffffffffffffffffffffffffffffffffff16331415614090565b9290919260ff5f5460081c16156103fe5761416d9061086b907fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff7bffffffff00000000000000000000000000000000000000000000000083549260c01b169116179055565b6040519061417a826104df565b6009825260208201917f4143524f53532d5632000000000000000000000000000000000000000000000083527f312e302e3000000000000000000000000000000000000000000000000000000060206040516141d5816104df565b60058152015260ff5f5460081c16156103fe5761048994611802936126e69251902061047f557f06c015bd22b4c69690933c1058878ebdfef31f9aaae40bbe86d8a09fe1b2972c610480556126d96158d5565b6002606554146103fe576002606555565b91908203918211613ab257565b6040513d5f823e3d90fd5b926106e49695929491946101409585525f60208601526040850152606084015263ffffffff809116608084015260a08301525f60c083015260e08201525f6101008201528161012082015201906114ad565b919394969095966142f16136d06142ea886142dd8973ffffffffffffffffffffffffffffffffffffffff165f5261086d60205260405f2090565b905f5260205260405f2090565b5460ff1690565b6145685760070b906706f05b59d3b2000061430b83615ab2565b101561453e576ec097ce7bc90715b34b9f100000000084116145145763ffffffff93614339858a1642614239565b857f000000000000000000000000000000000000000000000000000000000000000016106144ea5761086b5460c01c63ffffffff169861437b612bb78b613ffb565b73ffffffffffffffffffffffffffffffffffffffff9586807f000000000000000000000000000000000000000000000000000000000000000016981692888414806144e1575b156144a55780340361447b57883b156103fe575f6004996040519a8b80927fd0e30db000000000000000000000000000000000000000000000000000000000825234905af198891561447657614445614458978a927f32ed1a409ef04c7b0227189c3a103dc5ac10e775a15b785dcc510201f7c25ad39c61445d575b505b83615b26565b92604051998a99169d169b169387614251565b0390a4565b8061446a6144709261051d565b806103f4565b5f61443d565b614246565b60046040517f6452a35d000000000000000000000000000000000000000000000000000000008152fd5b7f32ed1a409ef04c7b0227189c3a103dc5ac10e775a15b785dcc510201f7c25ad3985087614445614458976144dc8430338a615ac1565b61443f565b503415156143c1565b60046040517ff722177f000000000000000000000000000000000000000000000000000000008152fd5b60046040517fc45b6b52000000000000000000000000000000000000000000000000000000008152fd5b60046040517fa13c425c000000000000000000000000000000000000000000000000000000008152fd5b60046040517f2a58c4f3000000000000000000000000000000000000000000000000000000008152fd5b6106e4929160405161466481614638602082019460208652805160408401526020810151606084015260a06145d7604083015160c06080870152610100860190613816565b9163ffffffff6060820151168286015273ffffffffffffffffffffffffffffffffffffffff60808201511660c086015201517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08483030160e0850152613849565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826105bd565b51902091615b5c565b614678600291613403565b500162ffffff8260081c16805f5281602052600160ff60405f205494161b80809416146146b0575f5260205260405f20908154179055565b60046040517f954476d9000000000000000000000000000000000000000000000000000000008152fd5b908160209103126103fe575190565b91908201809211613ab257565b91959495939092935f96815190818151036149485781614782575b50505082614720575b50505050565b73ffffffffffffffffffffffffffffffffffffffff816147617ffa7fa7cf6d7dde5f9be65a67e6a1a747e7aa864dcd2d793353c722d80fbbb3579386615c45565b6040805195865233602087015291169463ffffffff1693a45f80808061471a565b604080517f70a0823100000000000000000000000000000000000000000000000000000000815230600480830191909152919060208160248173ffffffffffffffffffffffffffffffffffffffff8b165afa908115614476575f91614919575b505f805b8681106147f7575050505050614711565b6148018189613995565b5161480f575b6001016147e6565b906148259061481e838a613995565b51906146e9565b908282116148f05761486c6136d061485a614840848a613995565b5173ffffffffffffffffffffffffffffffffffffffff1690565b614864848c613995565b51908c615bad565b15614807579c50876148e66148de8f6148bc6148406148b561488e848f613995565b519673ffffffffffffffffffffffffffffffffffffffff165f5261087360205260405f2090565b928b613995565b73ffffffffffffffffffffffffffffffffffffffff165f5260205260405f2090565b9182546146e9565b905560019c614807565b505050517f5bb55062000000000000000000000000000000000000000000000000000000008152fd5b61493b915060203d602011614941575b61493381836105bd565b8101906146da565b5f6147e2565b503d614929565b60046040517fcd298b38000000000000000000000000000000000000000000000000000000008152fd5b73ffffffffffffffffffffffffffffffffffffffff9061499181615e1e565b1690565b916136d090614a2c928451604080960151918651916149b383610531565b82526146646149ce6020840192468452898501958652613403565b50549388519283916149f36020840196602088525160608d86015260a0850190613cfc565b91516060840152516080830152037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018352826105bd565b614a335750565b600490517fb05e92fa000000000000000000000000000000000000000000000000000000008152fd5b614a658261397f565b52565b9a989693919c9b9997959492909c6101e08c019d8c5260208c015260408b015260608a0152608089015263ffffffff80921660a08901521660c087015260e08601526101008501526101208401526101408301528051610160830152602081015161018083015260408101516101a08301526060015190614ae88261397f565b6101c00152565b906106e4949360809373ffffffffffffffffffffffffffffffffffffffff8093168452602084015216604082015281606082015201906114ad565b905f82516101208101614b41815163ffffffff1690565b63ffffffff42911610614dca576020850151906002614b69835f5261087260205260405f2090565b5414614da057614b8386925f5261087260205260405f2090565b6002905560608301519060808401519160a08501519260c0860151918560a0810151938860e0810151956101008201519751614bc29063ffffffff1690565b61014083015163ffffffff166040840151918451936020860151956101600151614beb9061507b565b966060890151986080019e8f51614c019061507b565b906040015190614c0f61064c565b9a8b5260208b015260408a0152600260608a01526040519d8e9b614c339b8d614a68565b037f44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa750374690137208905f94a46080820151614c6790614972565b9060408601519560600151614c7b90614972565b9260800151614c8990614972565b73ffffffffffffffffffffffffffffffffffffffff919082167f0000000000000000000000000000000000000000000000000000000000000000831603614d8b5784614d78575b614cdc87838616615e51565b51928351151580614d6e575b614cf6575b50505050509050565b1690813b15614d6a5783614d3d9596604051968795869485937f3a5be8cb000000000000000000000000000000000000000000000000000000008552339160048601614aef565b03925af1801561447657614d57575b808080808594614ced565b8061446a614d649261051d565b5f614d4c565b8380fd5b50803b1515614ce8565b614d86873033858716615ac1565b614cd0565b5f9450614d9b8785858516615a26565b614cdc565b60046040517f8f260c60000000000000000000000000000000000000000000000000000000008152fd5b60046040517fd642b7d9000000000000000000000000000000000000000000000000000000008152fd5b8051916101208301614e0a815163ffffffff1690565b63ffffffff42911610614dca5760208301516001614e31825f5261087260205260405f2090565b5403615074576001905b6002614e50825f5261087260205260405f2090565b5414614da057614e6c614e72915f5261087260205260405f2090565b60029055565b7f44b559f101f8fbcc8a0ea43fa91a05a729a5ea6e14a7c75aa7503746901372086060860151608087015190614f3f8760a08a0151958a60c08101519760a08401519860e083015199614ecf6101008501519c5163ffffffff1690565b61014085015163ffffffff1691604086015193865195614f33614efb61016060208b01519a015161507b565b9960608c01519b6040614f11608083015161507b565b910151906020614f1f61064c565b9e8f528e015260408d015260608c01614a5c565b6040519c8d9c8d614a68565b0390a4614f4f6080830151614972565b916040820151916080614f7181614f696060850151614972565b940151614972565b73ffffffffffffffffffffffffffffffffffffffff929083167f000000000000000000000000000000000000000000000000000000000000000084160361506157614fc0853033868a16615ac1565b614fcc85848616615e51565b0151918251151580615057575b614fe5575b5050505050565b16803b156103fe5761502c935f8094604051968795869485937f3a5be8cb000000000000000000000000000000000000000000000000000000008552339160048601614aef565b03925af1801561447657615044575b80808080614fde565b8061446a6150519261051d565b5f61503b565b50803b1515614fd9565b61506f858533868a16615ac1565b614fcc565b5f90614e3b565b805190816150895750505f90565b6020012090565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff16156150c4576104899150615f38565b73ffffffffffffffffffffffffffffffffffffffff81166040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481855afa5f9181615202575b5061511b575f80fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc036103fe5761514a82615f38565b7fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28151158015906151fb575b615181575050565b5f806151f8937f206661696c656400000000000000000000000000000000000000000000000000604080516151b581610531565b602781527f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c60208201520152602081519101845af46151f26139cd565b9161651d565b50565b505f615179565b61521c91925060203d6020116149415761493381836105bd565b905f615112565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff1615615257576104899150615f38565b73ffffffffffffffffffffffffffffffffffffffff81166040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481855afa5f918161531b575b506152ae575f80fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc036103fe576152dd82615f38565b7fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a281511580159061531357615181575050565b506001615179565b61533591925060203d6020116149415761493381836105bd565b905f6152a5565b73ffffffffffffffffffffffffffffffffffffffff16610c5a817fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557fdc4a5f4c066ad14c1306e624550b42395e08f992a76b416cc7b1ad11503d376c5f80a2565b9392604293610489979660208151910120906040519260208401947f8d1994e2bbbd77564cdca06dd819e7ee2a5efa06c80dcb59a4a7b6e39edc538f86526040850152856060850152608084015260a083015260c082015260c0815261540881610585565b5190209061047f549061048054906040519160208301937fc2f8787176b8ac6bf7215b4adcc1e069bf4ab82d9ab1df05a57a91d425935b6e85526040840152606083015260808201526080815261545e816105a1565b51902090604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090615fa0565b96926106e49a9996949198959261014099895260208901526040880152606087015263ffffffff928380921660808801521660a08601521660c084015260e08301526101008201528161012082015201906114ad565b6154fa8151615e1e565b6040908181019061553361550e8351614972565b73ffffffffffffffffffffffffffffffffffffffff165f5261086d60205260405f2090565b926155506136d06142ea60c085019687515f5260205260405f2090565b6158ac5761012082019261557461556b855163ffffffff1690565b63ffffffff1690565b804210908115615873575b5061584a57610140830192615598845163ffffffff1690565b9163ffffffff92836155cc817f000000000000000000000000000000000000000000000000000000000000000016426146e9565b9116116158215761016082015163ffffffff1692808416806157c5575b505080519373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016809514806157bc575b1561573e576080830151340361571557843b156103fe575f6004958251968780927fd0e30db000000000000000000000000000000000000000000000000000000000825234905af1918215614476577f32ed1a409ef04c7b0227189c3a103dc5ac10e775a15b785dcc510201f7c25ad39561445893615702575b505b519260608101519460808201519060a08301519a51986156e26156d76101008601519c5163ffffffff1690565b915163ffffffff1690565b9084519c60208601519461018060e088015197015197519a8b9a8b61549a565b8061446a61570f9261051d565b5f6156a8565b600490517f6452a35d000000000000000000000000000000000000000000000000000000008152fd5b9192935034615793577f32ed1a409ef04c7b0227189c3a103dc5ac10e775a15b785dcc510201f7c25ad39392918161578e61577f61295e6144589551614972565b60808601519030903390615ac1565b6156aa565b600482517f6452a35d000000000000000000000000000000000000000000000000000000008152fd5b5034151561562e565b6301e13380101561580c575b5060e0820151156157e3575f806155e9565b600484517f495d907f000000000000000000000000000000000000000000000000000000008152fd5b9261581a9193421690613a9a565b915f6157d1565b600484517f582e3889000000000000000000000000000000000000000000000000000000008152fd5b600482517ff722177f000000000000000000000000000000000000000000000000000000008152fd5b61587e915042614239565b63ffffffff7f000000000000000000000000000000000000000000000000000000000000000016105f61557f565b600490517f2a58c4f3000000000000000000000000000000000000000000000000000000008152fd5b60ff5f5460081c16156103fe57565b60ff5f5460081c16156103fe576001606555565b73ffffffffffffffffffffffffffffffffffffffff16801561596557610869817fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557fa9e8c42c9e7fca7f62755189a16b2f5314d43d8fb24e91ba54e6d65f9314e8495f80a2565b60046040517fba97b39d000000000000000000000000000000000000000000000000000000008152fd5b73ffffffffffffffffffffffffffffffffffffffff1680156159fc5761086a817fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790557fa73e8909f8616742d7fe701153d82666f7b7cd480552e23ebb05d358c22fd04e5f80a2565b60046040517fb6061256000000000000000000000000000000000000000000000000000000008152fd5b6040517fa9059cbb00000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff9092166024830152604482019290925261048991615aad82606481015b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018452836105bd565b6160bc565b5f8112615abc5790565b5f0390565b909261048993604051937f23b872dd00000000000000000000000000000000000000000000000000000000602086015273ffffffffffffffffffffffffffffffffffffffff8092166024860152166044840152606483015260648252615aad826105a1565b90670de0b6b3a7640000915f828403921283831281169084841390151617613ab257818102918183041490151715613ab2570490565b929091905f915b8451831015615ba557615b768386613995565b519081811015615b94575f52602052600160405f205b920191615b63565b905f52602052600160405f20615b8c565b915092501490565b6040517fa9059cbb00000000000000000000000000000000000000000000000000000000602082810191825273ffffffffffffffffffffffffffffffffffffffff9094166024830152604482019490945290925f91615c0f8160648101614638565b519082855af1903d5f519083615c26575b50505090565b91925090615c3b57503b15155b5f8080615c20565b6001915014615c33565b9073ffffffffffffffffffffffffffffffffffffffff90817f000000000000000000000000000000000000000000000000000000000000000016151580615df1575b15615cb757505061048990615cb261086a5473ffffffffffffffffffffffffffffffffffffffff1690565b616159565b915f91615d10615d06615cec615dc59673ffffffffffffffffffffffffffffffffffffffff165f52610c5b60205260405f2090565b5473ffffffffffffffffffffffffffffffffffffffff1690565b918216151561398e565b615d3661295e61295e610c5a5473ffffffffffffffffffffffffffffffffffffffff1690565b9083615d5861086a5473ffffffffffffffffffffffffffffffffffffffff1690565b6040517f7b3a3c8b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9384166004820152921660248301526044820193909352608060648201525f60848201529384928391829060a4820190565b03925af1801561447657615dd65750565b6151f8903d805f833e615de981836105bd565b810190613f9c565b50817f00000000000000000000000000000000000000000000000000000000000000001682821614615c87565b60a01c615e2757565b60046040517ff3d81dae000000000000000000000000000000000000000000000000000000008152fd5b73ffffffffffffffffffffffffffffffffffffffff90811690813b15615e9e579061048992917f000000000000000000000000000000000000000000000000000000000000000016615a26565b7f000000000000000000000000000000000000000000000000000000000000000016803b156103fe575f80916024604051809481937f2e1a7d4d0000000000000000000000000000000000000000000000000000000083528860048401525af1801561447657615f29575b508147106103fe575f80809381935af1615f216139cd565b50156103fe57565b615f329061051d565b5f615f09565b803b156103fe5773ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc91167fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055565b615faa83836163fc565b600581959295101561398957159384616099575b508315615ffa575b50505015615fd057565b60046040517f938a1821000000000000000000000000000000000000000000000000000000008152fd5b5f92935090829160405161604b8161463860208201947f1626ba7e00000000000000000000000000000000000000000000000000000000998a875260248401526040604484015260648301906114ad565b51915afa906160586139cd565b8261608b575b8261606e575b50505f8080615fc6565b616083919250602080825183010191016146da565b145f80616064565b91506020825110159161605e565b73ffffffffffffffffffffffffffffffffffffffff83811691161493505f615fbe565b905f8073ffffffffffffffffffffffffffffffffffffffff6161209416927f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65646020604051616109816104df565b818152015260208151910182855af16151f26139cd565b8051908115918215616136575b5050156103fe57565b81925090602091810103126103fe576020015161615281610c7a565b5f8061612d565b73ffffffffffffffffffffffffffffffffffffffff809116917f000000000000000000000000000000000000000000000000000000000000000090827f0000000000000000000000000000000000000000000000000000000000000000166161c282828561642d565b604090604051917fcb75c11c0000000000000000000000000000000000000000000000000000000083526020936004958585600481875afa94851561447657869189915f97616398575b501697604051958680927fa56ec632000000000000000000000000000000000000000000000000000000008252816162648d6004830191909173ffffffffffffffffffffffffffffffffffffffff6020820193169052565b0392165afa938415614476575f94616379575b5092947f000000000000000000000000000000000000000000000000000000000000000093805b6162ad57505050505050505050565b61632490878111156163735787905b84517f6fd3504e00000000000000000000000000000000000000000000000000000000815284810183815263ffffffff89166020820152604081018d905273ffffffffffffffffffffffffffffffffffffffff8c166060820152909389918591829160800190565b03815f8a5af19283156144765761634093616346575b50614239565b8061629e565b61636590893d8b1161636c575b61635d81836105bd565b8101906163dc565b505f61633a565b503d616353565b806162bc565b616391919450853d87116149415761493381836105bd565b925f616277565b6163b9919750833d85116163c0575b6163b181836105bd565b8101906163c7565b955f61620c565b503d6163a7565b908160209103126103fe57516106e481610460565b908160209103126103fe575167ffffffffffffffff811681036103fe5790565b9060418151145f146164245761148891602082015190606060408401519301515f1a90616546565b50505f90600290565b60449192602073ffffffffffffffffffffffffffffffffffffffff604051948580927fdd62ed3e000000000000000000000000000000000000000000000000000000008252306004830152808916602483015286165afa928315614476575f936164fc575b508201809211613ab2576040517f095ea7b300000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff909316602484015260448301919091526104899190615aad8260648101615a81565b61651691935060203d6020116149415761493381836105bd565b915f616492565b90156165375781511561652e575090565b3b156103fe5790565b5080519081156103fe57602001fd5b7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a084116165c3576020935f9360ff60809460405194855216868401526040830152606082015282805260015afa15614476575f5173ffffffffffffffffffffffffffffffffffffffff8116156165bb57905f90565b505f90600190565b505050505f9060039056fea2646970667358221220494b12c51e59175a026d94cb62b3bf5960ebfbeef6e44633842b367034511cc964736f6c63430008170033",
  "devdoc": {
    "custom:security-contact": "bugs@across.to",
    "events": {
      "AdminChanged(address,address)": {
        "details": "Emitted when the admin account has changed."
      },
      "BeaconUpgraded(address)": {
        "details": "Emitted when the beacon is changed."
      },
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "Upgraded(address)": {
        "details": "Emitted when the implementation is upgraded."
      }
    },
    "kind": "dev",
    "methods": {
      "__SpokePool_init(uint32,address,address)": {
        "params": {
          "_crossDomainAdmin": "Cross domain admin to set. Can be changed by admin.",
          "_initialDepositId": "Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate relay hash collisions.",
          "_withdrawalRecipient": "Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will likely be the hub pool."
        }
      },
      "chainId()": {
        "details": "Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this."
      },
      "claimRelayerRefund(bytes32,bytes32)": {
        "params": {
          "l2TokenAddress": "Address of the L2 token to claim refunds for.",
          "refundAddress": "Address to send the refund to."
        }
      },
      "constructor": {
        "custom:oz-upgrades-unsafe-allow": "constructor"
      },
      "deposit(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint32,uint32,uint32,bytes)": {
        "details": "On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so modifying any params in it will result in a different hash and a different deposit. The hash will comprise all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by this contract.",
        "params": {
          "depositor": "The account credited with the deposit who can request to \"speed up\" this deposit by modifying the output amount, recipient, and message.",
          "destinationChainId": "The destination chain identifier. Must be enabled along with the input token as a valid deposit route from this spoke pool or this transaction will revert.",
          "exclusiveRelayer": "The relayer that will be exclusively allowed to fill this deposit before the exclusivity deadline timestamp. This must be a valid, non-zero address if the exclusivity deadline is greater than the current block.timestamp. If the exclusivity deadline is < currentTime, then this must be address(0), and vice versa if this is address(0).",
          "exclusivityParameter": "This value is used to set the exclusivity deadline timestamp in the emitted deposit event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address), can fill this deposit. There are three ways to use this parameter:     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,        meaning that there is no exclusivity period.     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed        due to a chain-reorg, which would also change the exclusivity timestamp.     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp. which is the deadline for the exclusiveRelayer to fill the deposit.",
          "fillDeadline": "The deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where currentTime is block.timestamp on this chain or this transaction will revert.",
          "inputAmount": "The amount of input tokens to pull from the caller's account and lock into this contract. This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic challenge window in the HubPool, less a system fee.",
          "inputToken": "The token pulled from the caller's account and locked into this contract to initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as msg.value, as long as msg.value = inputTokenAmount.",
          "message": "The message to send to the recipient on the destination chain if the recipient is a contract. If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.",
          "outputAmount": "The amount of output tokens that the relayer will send to the recipient on the destination.",
          "outputToken": "The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.",
          "quoteTimestamp": "The HubPool timestamp that is used to determine the system fee paid by the depositor.  This must be set to some time between [currentTime - depositQuoteTimeBuffer, currentTime] where currentTime is block.timestamp on this chain or this transaction will revert.",
          "recipient": "The account receiving funds on the destination chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive native token if an EOA or wrapped native token if a contract."
        }
      },
      "depositDeprecated_5947912356(address,address,uint256,uint256,int64,uint32,bytes,uint256)": {
        "details": "DEPRECATION NOTICE: this function is deprecated and will be removed in the future.      Please use deposit (under DEPOSITOR FUNCTIONS below) or depositV3 instead.Produces a FundsDeposited event with an infinite expiry, meaning that this deposit can never expire. Moreover, the event's outputToken is set to 0x0 meaning that this deposit can always be slow filled.",
        "params": {
          "amount": "Amount of tokens to deposit. Will be amount of tokens to receive less fees.",
          "destinationChainId": "Denotes network where user will receive funds from SpokePool by a relayer.",
          "message": "Arbitrary data that can be used to pass additional information to the recipient along with the tokens. Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.",
          "originToken": "Token to lock into this contract to initiate deposit.",
          "quoteTimestamp": "Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.",
          "recipient": "Address to receive funds at on destination chain.",
          "relayerFeePct": "% of deposit amount taken out to incentivize a fast relayer."
        }
      },
      "depositFor(address,address,address,uint256,uint256,int64,uint32,bytes,uint256)": {
        "details": "DEPRECATION NOTICE: this function is deprecated and will be removed in the future.      Please use the other deposit or depositV3 instead.",
        "params": {
          "amount": "Amount of tokens to deposit. Will be amount of tokens to receive less fees.",
          "depositor": "Address who is credited for depositing funds on origin chain and can speed up the deposit.",
          "destinationChainId": "Denotes network where user will receive funds from SpokePool by a relayer.",
          "message": "Arbitrary data that can be used to pass additional information to the recipient along with the tokens. Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.",
          "originToken": "Token to lock into this contract to initiate deposit.",
          "quoteTimestamp": "Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.",
          "recipient": "Address to receive funds at on destination chain.",
          "relayerFeePct": "% of deposit amount taken out to incentivize a fast relayer."
        }
      },
      "depositNow(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint32,uint32,bytes)": {
        "params": {
          "depositor": "The account credited with the deposit who can request to \"speed up\" this deposit by modifying the output amount, recipient, and message.",
          "destinationChainId": "The destination chain identifier. Must be enabled along with the input token as a valid deposit route from this spoke pool or this transaction will revert.",
          "exclusiveRelayer": "The relayer that will be exclusively allowed to fill this deposit before the exclusivity deadline timestamp.",
          "exclusivityParameter": "See identically named parameter in deposit() comments.",
          "fillDeadlineOffset": "Added to the current time to set the fill deadline, which is the deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the destination chain.",
          "inputAmount": "The amount of input tokens to pull from the caller's account and lock into this contract. This amount will be sent to the relayer on their repayment chain of choice as a refund following an optimistic challenge window in the HubPool, plus a system fee.",
          "inputToken": "The token pulled from the caller's account and locked into this contract to initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal to the wrapped native token then the caller can optionally pass in native token as msg.value, as long as msg.value = inputTokenAmount.",
          "message": "The message to send to the recipient on the destination chain if the recipient is a contract. If the message is not empty, the recipient contract must implement handleV3AcrossMessage() or the fill will revert.",
          "outputAmount": "The amount of output tokens that the relayer will send to the recipient on the destination.",
          "outputToken": "The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.",
          "recipient": "The account receiving funds on the destination chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive native token if an EOA or wrapped native token if a contract."
        }
      },
      "depositV3(address,address,address,address,uint256,uint256,uint256,address,uint32,uint32,uint32,bytes)": {
        "details": "This version mirrors the original `depositV3` function, but uses `address` types for `depositor`, `recipient`, `inputToken`, `outputToken`, and `exclusiveRelayer` for compatibility with contracts using the `address` type. The key functionality and logic remain identical, ensuring interoperability across both versions.",
        "params": {
          "depositor": "The account credited with the deposit who can request to \"speed up\" this deposit by modifying the output amount, recipient, and message.",
          "destinationChainId": "The destination chain identifier. Must be enabled along with the input token as a valid deposit route from this spoke pool or this transaction will revert.",
          "exclusiveRelayer": "The relayer exclusively allowed to fill this deposit before the exclusivity deadline.",
          "exclusivityParameter": "This value is used to set the exclusivity deadline timestamp in the emitted deposit event. Before this destination chain timestamp, only the exclusiveRelayer (if set to a non-zero address), can fill this deposit. There are three ways to use this parameter:     1. NO EXCLUSIVITY: If this value is set to 0, then a timestamp of 0 will be emitted,        meaning that there is no exclusivity period.     2. OFFSET: If this value is less than MAX_EXCLUSIVITY_PERIOD_SECONDS, then add this value to        the block.timestamp to derive the exclusive relayer deadline. Note that using the parameter in this way        will expose the filler of the deposit to the risk that the block.timestamp of this event gets changed        due to a chain-reorg, which would also change the exclusivity timestamp.     3. TIMESTAMP: Otherwise, set this value as the exclusivity deadline timestamp. which is the deadline for the exclusiveRelayer to fill the deposit.",
          "fillDeadline": "The deadline for the relayer to fill the deposit. After this destination chain timestamp, the fill will revert on the destination chain. Must be set before currentTime + fillDeadlineBuffer, where currentTime is block.timestamp on this chain.",
          "inputAmount": "The amount of input tokens pulled from the caller's account and locked into this contract. This amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, less a system fee.",
          "inputToken": "The token pulled from the caller's account and locked into this contract to initiate the deposit. The equivalent of this token on the relayer's repayment chain of choice will be sent as a refund. If this is equal to the wrapped native token, the caller can optionally pass in native token as msg.value, provided msg.value = inputTokenAmount.",
          "message": "The message to send to the recipient on the destination chain if the recipient is a contract. If the message is not empty, the recipient contract must implement `handleV3AcrossMessage()` or the fill will revert.",
          "outputAmount": "The amount of output tokens that the relayer will send to the recipient on the destination.",
          "outputToken": "The token that the relayer will send to the recipient on the destination chain. Must be an ERC20.",
          "quoteTimestamp": "The HubPool timestamp that determines the system fee paid by the depositor. This must be set between [currentTime - depositQuoteTimeBuffer, currentTime] where currentTime is block.timestamp on this chain.",
          "recipient": "The account receiving funds on the destination chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive native token if an EOA or wrapped native token if a contract."
        }
      },
      "depositV3Now(address,address,address,address,uint256,uint256,uint256,address,uint32,uint32,bytes)": {
        "details": "This version is identical to the original `depositV3Now` but uses `address` types for `depositor`, `recipient`, `inputToken`, `outputToken`, and `exclusiveRelayer` to support compatibility with older systems. It maintains the same logic and purpose, ensuring interoperability with both versions.",
        "params": {
          "depositor": "The account credited with the deposit, who can request to \"speed up\" this deposit by modifying the output amount, recipient, and message.",
          "destinationChainId": "The destination chain identifier. Must be enabled with the input token as a valid deposit route from this spoke pool, or the transaction will revert.",
          "exclusiveRelayer": "The relayer exclusively allowed to fill the deposit before the exclusivity deadline.",
          "exclusivityParameter": "See identically named parameter in deposit() comments.",
          "fillDeadlineOffset": "Added to the current time to set the fill deadline. After this timestamp, fills on the destination chain will revert.",
          "inputAmount": "The amount of input tokens pulled from the caller's account and locked into this contract. This amount will be sent to the relayer as a refund following an optimistic challenge window in the HubPool, plus a system fee.",
          "inputToken": "The token pulled from the caller's account and locked into this contract to initiate the deposit. Equivalent tokens on the relayer's repayment chain will be sent as a refund. If this is the wrapped native token, msg.value must equal inputTokenAmount when passed.",
          "message": "The message to send to the recipient on the destination chain. If the recipient is a contract, it must implement `handleV3AcrossMessage()` if the message is not empty, or the fill will revert.",
          "outputAmount": "The amount of output tokens the relayer will send to the recipient on the destination.",
          "outputToken": "The token the relayer will send to the recipient on the destination chain. Must be an ERC20.",
          "recipient": "The account receiving funds on the destination chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive the native token if an EOA or wrapped native token if a contract."
        }
      },
      "emergencyDeleteRootBundle(uint256)": {
        "params": {
          "rootBundleId": "Index of the root bundle that needs to be deleted. Note: this is intentionally a uint256 to ensure that a small input range doesn't limit which indices this method is able to reach."
        }
      },
      "executeRelayerRefundLeaf(uint32,(uint256,uint256,uint256[],uint32,address,address[]),bytes32[])": {
        "params": {
          "proof": "Inclusion proof for this leaf in relayer refund root in root bundle.",
          "relayerRefundLeaf": "Contains all data necessary to reconstruct leaf contained in root bundle and to refund relayer. This data structure is explained in detail in the SpokePoolInterface.",
          "rootBundleId": "Unique ID of root bundle containing relayer refund root that this leaf is contained in."
        }
      },
      "executeSlowRelayLeaf(((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,uint256),uint32,bytes32[])": {
        "details": "Executing a slow fill leaf is equivalent to filling the relayData so this function cannot be used to double fill a recipient. The relayData that is filled is included in the slowFillLeaf and is hashed like any other fill sent through a fill method.There is no relayer credited with filling this relay since funds are sent directly out of this contract.",
        "params": {
          "proof": "Inclusion proof for this leaf in slow relay root in root bundle.",
          "rootBundleId": "Unique ID of root bundle containing slow relay root that this leaf is contained in.",
          "slowFillLeaf": "Contains all data necessary to uniquely identify a relay for this chain. This struct is hashed and included in a merkle root that is relayed to all spoke pools. - relayData: struct containing all the data needed to identify the original deposit to be slow filled. - chainId: chain identifier where slow fill leaf should be executed. If this doesn't match this chain's chainId, then this function will revert. - updatedOutputAmount: Amount to be sent to recipient out of this contract's balance. Can be set differently from relayData.outputAmount to charge a different fee because this deposit was \"slow\" filled. Usually, this will be set higher to reimburse the recipient for waiting for the slow fill."
        }
      },
      "fill(bytes32,bytes,bytes)": {
        "details": "ERC-7683 fill function.",
        "params": {
          "fillerData": "Data provided by the filler to inform the fill or express their preferences",
          "orderId": "Unique order identifier for this order",
          "originData": "Data emitted on the origin to parameterize the fill"
        }
      },
      "fillRelay((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,bytes32)": {
        "details": "The fee paid to relayers and the system should be captured in the spread between output amount and input amount when adjusted to be denominated in the input token. A relayer on the destination chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment chain of their choice. Therefore, the fee should account for destination fee transaction costs, the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge window in the HubPool, and a system fee charged to relayers.The hash of the relayData will be used to uniquely identify the deposit to fill, so modifying any params in it will result in a different hash and a different deposit. The hash will comprise all parameters passed to deposit() on the origin chain along with that chain's chainId(). This chain's chainId() must therefore match the destinationChainId passed into deposit. Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by the origin SpokePool therefore the relayer should not modify any params in relayData.Cannot fill more than once. Partial fills are not supported.",
        "params": {
          "relayData": "struct containing all the data needed to identify the deposit to be filled. Should match all the same-named parameters emitted in the origin chain FundsDeposited event. - depositor: The account credited with the deposit who can request to \"speed up\" this deposit by modifying the output amount, recipient, and message. - recipient The account receiving funds on this chain. Can be an EOA or a contract. If the output token is the wrapped native token for the chain, then the recipient will receive native token if an EOA or wrapped native token if a contract. - inputToken: The token pulled from the caller's account to initiate the deposit. The equivalent of this token on the repayment chain will be sent as a refund to the caller. - outputToken The token that the caller will send to the recipient on the destination chain. Must be an ERC20. - inputAmount: This amount, less a system fee, will be sent to the caller on their repayment chain of choice as a refund following an optimistic challenge window in the HubPool. - outputAmount: The amount of output tokens that the caller will send to the recipient. - originChainId: The origin chain identifier. - exclusiveRelayer The relayer that will be exclusively allowed to fill this deposit before the exclusivity deadline timestamp. - fillDeadline The deadline for the caller to fill the deposit. After this timestamp, the fill will revert on the destination chain. - exclusivityDeadline: The deadline for the exclusive relayer to fill the deposit. After this timestamp, anyone can fill this deposit. Note that if this value was set in deposit by adding an offset to the deposit's block.timestamp, there is re-org risk for the caller of this method because the event's block.timestamp can change. Read the comments in `deposit` about the `exclusivityParameter` for more details. - message The message to send to the recipient if the recipient is a contract that implements a handleV3AcrossMessage() public function",
          "repaymentAddress": "Address the relayer wants to be receive their refund at.",
          "repaymentChainId": "Chain of SpokePool where relayer wants to be refunded after the challenge window has passed. Will receive inputAmount of the equivalent token to inputToken on the repayment chain."
        }
      },
      "fillRelayWithUpdatedDeposit((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,bytes32,uint256,bytes32,bytes,bytes)": {
        "details": "Subject to same exclusivity deadline rules as fillV3Relay().",
        "params": {
          "depositorSignature": "Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account.",
          "relayData": "struct containing all the data needed to identify the deposit to be filled. See fillV3Relay().",
          "repaymentAddress": "Address the relayer wants to be receive their refund at.",
          "repaymentChainId": "Chain of SpokePool where relayer wants to be refunded after the challenge window has passed. See fillV3Relay().",
          "updatedMessage": "New message to use for this deposit.",
          "updatedOutputAmount": "New output amount to use for this deposit.",
          "updatedRecipient": "New recipient to use for this deposit."
        }
      },
      "getCurrentTime()": {
        "returns": {
          "_0": "uint for the current timestamp."
        }
      },
      "getUnsafeDepositId(address,bytes32,uint256)": {
        "details": "msgSender and depositor are both used as inputs to allow passthrough depositors to create unique deposit hash spaces for unique depositors.",
        "params": {
          "depositNonce": "The nonce used as input to produce the deposit ID.",
          "depositor": "The depositor address used as input to produce the deposit ID.",
          "msgSender": "The caller of the transaction used as input to produce the deposit ID."
        },
        "returns": {
          "_0": "The deposit ID for the unsafe deposit."
        }
      },
      "initialize(uint32,address,address,address)": {
        "params": {
          "_crossDomainAdmin": "Cross domain admin to set. Can be changed by admin.",
          "_initialDepositId": "Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate relay hash collisions.",
          "_l2GatewayRouter": "Address of L2 token gateway. Can be reset by admin.",
          "_withdrawalRecipient": "Address which receives token withdrawals. Can be changed by admin. For Spoke Pools on L2, this will likely be the hub pool."
        }
      },
      "pauseDeposits(bool)": {
        "details": "Affects `deposit()` but not `speedUpDeposit()`, so that existing deposits can be sped up and still relayed.",
        "params": {
          "pause": "true if the call is meant to pause the system, false if the call is meant to unpause it."
        }
      },
      "pauseFills(bool)": {
        "details": "Affects fillRelayWithUpdatedDeposit() and fillRelay().",
        "params": {
          "pause": "true if the call is meant to pause the system, false if the call is meant to unpause it."
        }
      },
      "proxiableUUID()": {
        "details": "Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."
      },
      "relayRootBundle(bytes32,bytes32)": {
        "params": {
          "relayerRefundRoot": "Merkle root containing relayer refund leaves that can be individually executed via executeRelayerRefundLeaf().",
          "slowRelayRoot": "Merkle root containing slow relay fulfillment leaves that can be individually executed via executeSlowRelayLeaf()."
        }
      },
      "requestSlowFill((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes))": {
        "details": "Slow fills are not possible unless the input and output tokens are \"equivalent\", i.e. they route to the same L1 token via PoolRebalanceRoutes.Slow fills are created by inserting slow fill objects into a merkle tree that is included in the next HubPool \"root bundle\". Once the optimistic challenge window has passed, the HubPool will relay the slow root to this chain via relayRootBundle(). Once the slow root is relayed, the slow fill can be executed by anyone who calls executeSlowRelayLeaf().Cannot request a slow fill if the fill deadline has passed.Cannot request a slow fill if the relay has already been filled or a slow fill has already been requested.",
        "params": {
          "relayData": "struct containing all the data needed to identify the deposit that should be slow filled. If any of the params are missing or different from the origin chain deposit, then Across will not include a slow fill for the intended deposit."
        }
      },
      "setCrossDomainAdmin(address)": {
        "params": {
          "newCrossDomainAdmin": "New cross domain admin."
        }
      },
      "setEnableRoute(address,uint256,bool)": {
        "params": {
          "destinationChainId": "Chain ID for where depositor wants to receive funds.",
          "enabled": "True to enable deposits, False otherwise.",
          "originToken": "Token that depositor can deposit to this contract."
        }
      },
      "setL2GatewayRouter(address)": {
        "params": {
          "newL2GatewayRouter": "New L2 gateway router."
        }
      },
      "setWithdrawalRecipient(address)": {
        "params": {
          "newWithdrawalRecipient": "New withdrawal recipient address."
        }
      },
      "speedUpDeposit(bytes32,uint256,uint256,bytes32,bytes,bytes)": {
        "details": "the depositor and depositId must match the params in a FundsDeposited event that the depositor wants to speed up. The relayer has the option but not the obligation to use this updated information when filling the deposit via fillRelayWithUpdatedDeposit().",
        "params": {
          "depositId": "Deposit ID to speed up.",
          "depositor": "Depositor that must sign the depositorSignature and was the original depositor.",
          "depositorSignature": "Signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account. If depositor is a contract, then should implement EIP1271 to sign as a contract. See _verifyUpdateV3DepositMessage() for more details about how this signature should be constructed.",
          "updatedMessage": "New message to use for this deposit. Can be modified if the recipient is a contract that expects to receive a message from the relay and for some reason needs to be modified.",
          "updatedOutputAmount": "New output amount to use for this deposit. Should be lower than previous value otherwise relayer has no incentive to use this updated value.",
          "updatedRecipient": "New recipient to use for this deposit. Can be modified if the recipient is a contract that expects to receive a message from the relay and for some reason needs to be modified."
        }
      },
      "speedUpV3Deposit(address,uint256,uint256,address,bytes,bytes)": {
        "details": "The `depositor` and `depositId` must match the parameters in a `FundsDeposited` event that the depositor wants to speed up. The relayer is not obligated but has the option to use this updated information when filling the deposit using `fillRelayWithUpdatedDeposit()`. This version uses `address` types for compatibility with systems relying on `address`-based implementations.",
        "params": {
          "depositId": "The deposit ID to speed up.",
          "depositor": "The depositor that must sign the `depositorSignature` and was the original depositor.",
          "depositorSignature": "The signed EIP712 hashstruct containing the deposit ID. Should be signed by the depositor account. If the depositor is a contract, it should implement EIP1271 to sign as a contract. See `_verifyUpdateV3DepositMessage()` for more details on how the signature should be constructed.",
          "updatedMessage": "The new message for this deposit. Can be modified if the recipient is a contract that expects to receive a message from the relay and needs to be updated.",
          "updatedOutputAmount": "The new output amount to use for this deposit. It should be lower than the previous value, otherwise the relayer has no incentive to use this updated value.",
          "updatedRecipient": "The new recipient for this deposit. Can be modified if the original recipient is a contract that expects to receive a message from the relay and needs to be changed."
        }
      },
      "unsafeDeposit(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint256,uint32,uint32,uint32,bytes)": {
        "details": "This is labeled \"unsafe\" because there is no guarantee that the depositId emitted in the resultant FundsDeposited event is unique which means that the corresponding fill might collide with an existing relay hash on the destination chain SpokePool, which would make this deposit unfillable. In this case, the depositor would subsequently receive a refund of `inputAmount` of `inputToken` on the origin chain after the fill deadline.On the destination chain, the hash of the deposit data will be used to uniquely identify this deposit, so modifying any params in it will result in a different hash and a different deposit. The hash will comprise all parameters to this function along with this chain's chainId(). Relayers are only refunded for filling deposits with deposit hashes that map exactly to the one emitted by this contract.",
        "params": {
          "depositNonce": "The nonce that uniquely identifies this deposit. This function will combine this parameter with the msg.sender address to create a unique uint256 depositNonce and ensure that the msg.sender cannot use this function to front-run another depositor's unsafe deposit. This function guarantees that the resultant deposit nonce will not collide with a safe uint256 deposit nonce whose 24 most significant bytes are always 0.",
          "depositor": "See identically named parameter in depositV3() comments.",
          "destinationChainId": "See identically named parameter in depositV3() comments.",
          "exclusiveRelayer": "See identically named parameter in depositV3() comments.",
          "exclusivityParameter": "See identically named parameter in depositV3() comments.",
          "fillDeadline": "See identically named parameter in depositV3() comments.",
          "inputAmount": "See identically named parameter in depositV3() comments.",
          "inputToken": "See identically named parameter in depositV3() comments.",
          "message": "See identically named parameter in depositV3() comments.",
          "outputAmount": "See identically named parameter in depositV3() comments.",
          "outputToken": "See identically named parameter in depositV3() comments.",
          "quoteTimestamp": "See identically named parameter in depositV3() comments.",
          "recipient": "See identically named parameter in depositV3() comments."
        }
      },
      "upgradeTo(address)": {
        "custom:oz-upgrades-unsafe-allow-reachable": "delegatecall",
        "details": "Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      },
      "upgradeToAndCall(address,bytes)": {
        "custom:oz-upgrades-unsafe-allow-reachable": "delegatecall",
        "details": "Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      },
      "whitelistToken(address,address)": {
        "params": {
          "l1Token": "Ethereum version of l2Token.",
          "l2Token": "Arbitrum token."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "__SpokePool_init(uint32,address,address)": {
        "notice": "Construct the base SpokePool."
      },
      "chainId()": {
        "notice": "Returns chain ID for this network."
      },
      "claimRelayerRefund(bytes32,bytes32)": {
        "notice": "Enables a relayer to claim outstanding repayments. Should virtually never be used, unless for some reason relayer repayment transfer fails for reasons such as token transfer reverts due to blacklisting. In this case, the relayer can still call this method and claim the tokens to a new address."
      },
      "deposit(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint32,uint32,uint32,bytes)": {
        "notice": "Previously, this function allowed the caller to specify the exclusivityDeadline, otherwise known as the as exact timestamp on the destination chain before which only the exclusiveRelayer could fill the deposit. Now, the caller is expected to pass in a number that will be interpreted either as an offset or a fixed timestamp depending on its value.Request to bridge input token cross chain to a destination chain and receive a specified amount of output tokens. The fee paid to relayers and the system should be captured in the spread between output amount and input amount when adjusted to be denominated in the input token. A relayer on the destination chain will send outputAmount of outputTokens to the recipient and receive inputTokens on a repayment chain of their choice. Therefore, the fee should account for destination fee transaction costs, the relayer's opportunity cost of capital while they wait to be refunded following an optimistic challenge window in the HubPool, and the system fee that they'll be charged."
      },
      "depositDeprecated_5947912356(address,address,uint256,uint256,int64,uint32,bytes,uint256)": {
        "notice": "Called by user to bridge funds from origin to destination chain. Depositor will effectively lock tokens in this contract and receive a destination token on the destination chain. The origin => destination token mapping is stored on the L1 HubPool.The caller must first approve this contract to spend amount of originToken.The originToken => destinationChainId must be enabled.This method is payable because the caller is able to deposit native token if the originToken is wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken."
      },
      "depositFor(address,address,address,uint256,uint256,int64,uint32,bytes,uint256)": {
        "notice": "The only difference between depositFor and deposit is that the depositor address stored in the relay hash can be overridden by the caller. This means that the passed in depositor can speed up the deposit, which is useful if the deposit is taken from the end user to a middle layer contract, like an aggregator or the SpokePoolVerifier, before calling deposit on this contract.The caller must first approve this contract to spend amount of originToken.The originToken => destinationChainId must be enabled.This method is payable because the caller is able to deposit native token if the originToken is wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken."
      },
      "depositNow(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint32,uint32,bytes)": {
        "notice": "Submits deposit and sets quoteTimestamp to current Time. Sets fill and exclusivity deadlines as offsets added to the current time. This function is designed to be called by users such as Multisig contracts who do not have certainty when their transaction will mine."
      },
      "depositV3(address,address,address,address,uint256,uint256,uint256,address,uint32,uint32,uint32,bytes)": {
        "notice": "A version of `deposit` that accepts `address` types for backward compatibility. This function allows bridging of input tokens cross-chain to a destination chain, receiving a specified amount of output tokens. The relayer is refunded in input tokens on a repayment chain of their choice, minus system fees, after an optimistic challenge window. The exclusivity period is specified as an offset from the current block timestamp."
      },
      "depositV3Now(address,address,address,address,uint256,uint256,uint256,address,uint32,uint32,bytes)": {
        "notice": "A version of `depositNow` that supports addresses as input types for backward compatibility. This function submits a deposit and sets `quoteTimestamp` to the current time. The `fill` and `exclusivity` deadlines are set as offsets added to the current time. It is designed to be called by users, including Multisig contracts, who may not have certainty when their transaction will be mined."
      },
      "emergencyDeleteRootBundle(uint256)": {
        "notice": "This method is intended to only be used in emergencies where a bad root bundle has reached the SpokePool."
      },
      "executeRelayerRefundLeaf(uint32,(uint256,uint256,uint256[],uint32,address,address[]),bytes32[])": {
        "notice": "Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they sent to the recipient plus a relayer fee."
      },
      "executeSlowRelayLeaf(((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,uint256),uint32,bytes32[])": {
        "notice": "Executes a slow relay leaf stored as part of a root bundle relayed by the HubPool."
      },
      "fill(bytes32,bytes,bytes)": {
        "notice": "Fills a single leg of a particular order on the destination chain"
      },
      "fillRelay((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,bytes32)": {
        "notice": "Fulfill request to bridge cross chain by sending specified output tokens to the recipient."
      },
      "fillRelayWithUpdatedDeposit((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes),uint256,bytes32,uint256,bytes32,bytes,bytes)": {
        "notice": "Identical to fillV3Relay except that the relayer wants to use a depositor's updated output amount, recipient, and/or message. The relayer should only use this function if they can supply a message signed by the depositor that contains the fill's matching deposit ID along with updated relay parameters. If the signature can be verified, then this function will emit a FilledV3Event that will be used by the system for refund verification purposes. In other words, this function is an alternative way to fill a a deposit than fillV3Relay."
      },
      "getCurrentTime()": {
        "notice": "Gets the current time."
      },
      "getUnsafeDepositId(address,bytes32,uint256)": {
        "notice": "Returns the deposit ID for an unsafe deposit. This function is used to compute the deposit ID in unsafeDeposit and is provided as a convenience."
      },
      "initialize(uint32,address,address,address)": {
        "notice": "Construct the AVM SpokePool."
      },
      "pauseDeposits(bool)": {
        "notice": "Pauses deposit-related functions. This is intended to be used if this contract is deprecated or when something goes awry."
      },
      "pauseFills(bool)": {
        "notice": "Pauses fill-related functions. This is intended to be used if this contract is deprecated or when something goes awry."
      },
      "relayRootBundle(bytes32,bytes32)": {
        "notice": "This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method."
      },
      "requestSlowFill((bytes32,bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,uint256,uint32,uint32,bytes))": {
        "notice": "Request Across to send LP funds to this contract to fulfill a slow fill relay for a deposit in the next bundle."
      },
      "setCrossDomainAdmin(address)": {
        "notice": "Change cross domain admin address. Callable by admin only."
      },
      "setEnableRoute(address,uint256,bool)": {
        "notice": "Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only."
      },
      "setL2GatewayRouter(address)": {
        "notice": "Change L2 gateway router. Callable only by admin."
      },
      "setWithdrawalRecipient(address)": {
        "notice": "Change L1 withdrawal recipient address. Callable by admin only."
      },
      "speedUpDeposit(bytes32,uint256,uint256,bytes32,bytes,bytes)": {
        "notice": "Depositor can use this function to signal to relayer to use updated output amount, recipient, and/or message."
      },
      "speedUpV3Deposit(address,uint256,uint256,address,bytes,bytes)": {
        "notice": "A version of `speedUpDeposit` using `address` types for backward compatibility. This function allows the depositor to signal to the relayer to use updated output amount, recipient, and/or message when filling a deposit. This can be useful when the deposit needs to be modified after the original transaction has been mined."
      },
      "unsafeDeposit(bytes32,bytes32,bytes32,bytes32,uint256,uint256,uint256,bytes32,uint256,uint32,uint32,uint32,bytes)": {
        "notice": "See deposit for details. This function is identical to deposit except that it does not use the global deposit ID counter as a deposit nonce, instead allowing the caller to pass in a deposit nonce. This function is designed to be used by anyone who wants to pre-compute their resultant relay data hash, which could be useful for filling a deposit faster and avoiding any risk of a relay hash unexpectedly changing due to another deposit front-running this one and incrementing the global deposit ID counter."
      },
      "whitelistToken(address,address)": {
        "notice": "Add L2 -> L1 token mapping. Callable only by admin."
      }
    },
    "notice": "AVM specific SpokePool. Uses AVM cross-domain-enabled logic to implement admin only access to functions.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 599,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 602,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 581,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 897,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "__gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 913,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "_status",
        "offset": 0,
        "slot": "101",
        "type": "t_uint256"
      },
      {
        "astId": 982,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 14887,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "__gap",
        "offset": 0,
        "slot": "151",
        "type": "t_array(t_uint256)1000_storage"
      },
      {
        "astId": 14619,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "_HASHED_NAME",
        "offset": 0,
        "slot": "1151",
        "type": "t_bytes32"
      },
      {
        "astId": 14621,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "_HASHED_VERSION",
        "offset": 0,
        "slot": "1152",
        "type": "t_bytes32"
      },
      {
        "astId": 14720,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "__gap",
        "offset": 0,
        "slot": "1153",
        "type": "t_array(t_uint256)1000_storage"
      },
      {
        "astId": 9294,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "crossDomainAdmin",
        "offset": 0,
        "slot": "2153",
        "type": "t_address"
      },
      {
        "astId": 9296,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "withdrawalRecipient",
        "offset": 0,
        "slot": "2154",
        "type": "t_address"
      },
      {
        "astId": 9299,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "DEPRECATED_wrappedNativeToken",
        "offset": 0,
        "slot": "2155",
        "type": "t_contract(WETH9Interface)12816"
      },
      {
        "astId": 9301,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "DEPRECATED_depositQuoteTimeBuffer",
        "offset": 20,
        "slot": "2155",
        "type": "t_uint32"
      },
      {
        "astId": 9303,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "numberOfDeposits",
        "offset": 24,
        "slot": "2155",
        "type": "t_uint32"
      },
      {
        "astId": 9305,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "pausedFills",
        "offset": 28,
        "slot": "2155",
        "type": "t_bool"
      },
      {
        "astId": 9307,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "pausedDeposits",
        "offset": 29,
        "slot": "2155",
        "type": "t_bool"
      },
      {
        "astId": 9311,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "rootBundles",
        "offset": 0,
        "slot": "2156",
        "type": "t_array(t_struct(RootBundle)13249_storage)dyn_storage"
      },
      {
        "astId": 9317,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "enabledDepositRoutes",
        "offset": 0,
        "slot": "2157",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_bool))"
      },
      {
        "astId": 9321,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "DEPRECATED_relayFills",
        "offset": 0,
        "slot": "2158",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 9325,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "DEPRECATED_fillCounter",
        "offset": 0,
        "slot": "2159",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9329,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "DEPRECATED_depositCounter",
        "offset": 0,
        "slot": "2160",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9333,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "DEPRECATED_refundsRequested",
        "offset": 0,
        "slot": "2161",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 9337,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "fillStatuses",
        "offset": 0,
        "slot": "2162",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 9343,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "relayerRefund",
        "offset": 0,
        "slot": "2163",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 11886,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "__gap",
        "offset": 0,
        "slot": "2164",
        "type": "t_array(t_uint256)998_storage"
      },
      {
        "astId": 6898,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "l2GatewayRouter",
        "offset": 0,
        "slot": "3162",
        "type": "t_address"
      },
      {
        "astId": 6902,
        "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
        "label": "whitelistedTokens",
        "offset": 0,
        "slot": "3163",
        "type": "t_mapping(t_address,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(RootBundle)13249_storage)dyn_storage": {
        "base": "t_struct(RootBundle)13249_storage",
        "encoding": "dynamic_array",
        "label": "struct SpokePoolInterface.RootBundle[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)1000_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[1000]",
        "numberOfBytes": "32000"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_array(t_uint256)998_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[998]",
        "numberOfBytes": "31936"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(WETH9Interface)12816": {
        "encoding": "inplace",
        "label": "contract WETH9Interface",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bool)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(RootBundle)13249_storage": {
        "encoding": "inplace",
        "label": "struct SpokePoolInterface.RootBundle",
        "members": [
          {
            "astId": 13242,
            "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
            "label": "slowRelayRoot",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 13244,
            "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
            "label": "relayerRefundRoot",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          },
          {
            "astId": 13248,
            "contract": "contracts/AlephZero_SpokePool.sol:AlephZero_SpokePool",
            "label": "claimedBitmap",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_uint256)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}
