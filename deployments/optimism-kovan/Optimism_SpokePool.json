{
  "address": "0x54e38A62ED3dC88e2B80cBA50deB940580511D26",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_crossDomainAdmin",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_hubPool",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "timerAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "originToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "enabled",
          "type": "bool"
        }
      ],
      "name": "EnabledDepositRoute",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountToReturn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "refundAmounts",
          "type": "uint256[]"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "rootBundleId",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "leafId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "l2TokenAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "refundAddresses",
          "type": "address[]"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "ExecutedRelayerRefundRoot",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "relayHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalFilledAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fillAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "relayerFeePct",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "realizedLpFeePct",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "destinationToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "ExecutedSlowRelayRoot",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "relayHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalFilledAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fillAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "repaymentChainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "relayerFeePct",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "realizedLpFeePct",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "destinationToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "relayer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "FilledRelay",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "relayerFeePct",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "originToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        }
      ],
      "name": "FundsDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "l2Token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "numberOfTokensBridged",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "l1Gas",
          "type": "uint256"
        }
      ],
      "name": "OptimismTokensBridged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "rootBundleId",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "relayerRefundRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "slowRelayRoot",
          "type": "bytes32"
        }
      ],
      "name": "RelayedRootBundle",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newRelayerFeePct",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "depositorSignature",
          "type": "bytes"
        }
      ],
      "name": "RequestedSpeedUpDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newBuffer",
          "type": "uint32"
        }
      ],
      "name": "SetDepositQuoteTimeBuffer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newHubPool",
          "type": "address"
        }
      ],
      "name": "SetHubPool",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "newL1Gas",
          "type": "uint32"
        }
      ],
      "name": "SetL1Gas",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "SetXDomainAdmin",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountToReturn",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "leafId",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "l2TokenAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "TokensBridged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "chainId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "crossDomainAdmin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "deploymentTime",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "originToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "relayerFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "depositQuoteTimeBuffer",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "enabledDepositRoutes",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "rootBundleId",
          "type": "uint32"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "amountToReturn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "refundAmounts",
              "type": "uint256[]"
            },
            {
              "internalType": "uint32",
              "name": "leafId",
              "type": "uint32"
            },
            {
              "internalType": "address",
              "name": "l2TokenAddress",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "refundAddresses",
              "type": "address[]"
            }
          ],
          "internalType": "struct SpokePoolInterface.RelayerRefundLeaf",
          "name": "relayerRefundLeaf",
          "type": "tuple"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "executeRelayerRefundRoot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "destinationToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "totalRelayAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "realizedLpFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "relayerFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "rootBundleId",
          "type": "uint32"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "executeSlowRelayRoot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "destinationToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxTokensToSend",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "repaymentChainId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "realizedLpFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "relayerFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        }
      ],
      "name": "fillRelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "destinationToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxTokensToSend",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "repaymentChainId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "originChainId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "realizedLpFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "relayerFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "newRelayerFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "depositorSignature",
          "type": "bytes"
        }
      ],
      "name": "fillRelayWithUpdatedFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hubPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "l1Gas",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "l2Eth",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "messenger",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "numberOfDeposits",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "relayFills",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "relayerRefundRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "slowRelayRoot",
          "type": "bytes32"
        }
      ],
      "name": "relayRootBundle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "rootBundles",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "slowRelayRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "relayerRefundRoot",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newCrossDomainAdmin",
          "type": "address"
        }
      ],
      "name": "setCrossDomainAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "time",
          "type": "uint256"
        }
      ],
      "name": "setCurrentTime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "newDepositQuoteTimeBuffer",
          "type": "uint32"
        }
      ],
      "name": "setDepositQuoteTimeBuffer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "originToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "enabled",
          "type": "bool"
        }
      ],
      "name": "setEnableRoute",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newHubPool",
          "type": "address"
        }
      ],
      "name": "setHubPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "newl1Gas",
          "type": "uint32"
        }
      ],
      "name": "setL1GasLimit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "newRelayerFeePct",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "depositId",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "depositorSignature",
          "type": "bytes"
        }
      ],
      "name": "speedUpDeposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "timerAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "weth",
      "outputs": [
        {
          "internalType": "contract WETH9",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0xde4efd99cde6b3ac97dc427c9d935360fccaa7b46d401a7a0e8613581a2fa7d6",
  "receipt": {
    "to": null,
    "from": "0x9A8f92a830A5cB89a3816e3D267CB7791c16b04D",
    "contractAddress": "0x54e38A62ED3dC88e2B80cBA50deB940580511D26",
    "transactionIndex": 0,
    "gasUsed": "3866535",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000200000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000200000000000000000000000000001000000800000000000000000000000000000000000000000000000000000000000040020000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000080000000000000000000000020000000000000000000000000000000000000000400000000000000000000000000",
    "blockHash": "0x9ff49961a05e9e7fa7dbc4ca53259536d339e27266ab16ebf991d12cb4ff479e",
    "transactionHash": "0xde4efd99cde6b3ac97dc427c9d935360fccaa7b46d401a7a0e8613581a2fa7d6",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 1393953,
        "transactionHash": "0xde4efd99cde6b3ac97dc427c9d935360fccaa7b46d401a7a0e8613581a2fa7d6",
        "address": "0x54e38A62ED3dC88e2B80cBA50deB940580511D26",
        "topics": [
          "0xa9e8c42c9e7fca7f62755189a16b2f5314d43d8fb24e91ba54e6d65f9314e849",
          "0x0000000000000000000000001467332ad6c534b8f3e3aee27dff216df94bc227"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x9ff49961a05e9e7fa7dbc4ca53259536d339e27266ab16ebf991d12cb4ff479e"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 1393953,
        "transactionHash": "0xde4efd99cde6b3ac97dc427c9d935360fccaa7b46d401a7a0e8613581a2fa7d6",
        "address": "0x54e38A62ED3dC88e2B80cBA50deB940580511D26",
        "topics": [
          "0x1f17a88f67b0f49060a34bec1a4723a563620e6aa265eb640b5046dcee0759a0",
          "0x0000000000000000000000001467332ad6c534b8f3e3aee27dff216df94bc227"
        ],
        "data": "0x",
        "logIndex": 1,
        "blockHash": "0x9ff49961a05e9e7fa7dbc4ca53259536d339e27266ab16ebf991d12cb4ff479e"
      }
    ],
    "blockNumber": 1393953,
    "cumulativeGasUsed": "3866535",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1467332AD6C534B8F3e3aee27DFf216Df94BC227",
    "0x1467332AD6C534B8F3e3aee27DFf216Df94BC227",
    "0x0000000000000000000000000000000000000000"
  ],
  "numDeployments": 1,
  "solcInputHash": "983bbb6073f39aed5d267ccd9a13909e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.11+commit.d7f03943\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_crossDomainAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hubPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"timerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"EnabledDepositRoute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToReturn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"refundAmounts\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"rootBundleId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"leafId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"l2TokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"refundAddresses\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ExecutedRelayerRefundRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"relayHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFilledAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fillAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"relayerFeePct\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ExecutedSlowRelayRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"relayHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFilledAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fillAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"repaymentChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"relayerFeePct\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"FilledRelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"relayerFeePct\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"FundsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfTokensBridged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"l1Gas\",\"type\":\"uint256\"}],\"name\":\"OptimismTokensBridged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"rootBundleId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"relayerRefundRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"slowRelayRoot\",\"type\":\"bytes32\"}],\"name\":\"RelayedRootBundle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newRelayerFeePct\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"depositorSignature\",\"type\":\"bytes\"}],\"name\":\"RequestedSpeedUpDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newBuffer\",\"type\":\"uint32\"}],\"name\":\"SetDepositQuoteTimeBuffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newHubPool\",\"type\":\"address\"}],\"name\":\"SetHubPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"newL1Gas\",\"type\":\"uint32\"}],\"name\":\"SetL1Gas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"SetXDomainAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToReturn\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"leafId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2TokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"TokensBridged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crossDomainAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"relayerFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositQuoteTimeBuffer\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"enabledDepositRoutes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"rootBundleId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountToReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"refundAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32\",\"name\":\"leafId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"l2TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"refundAddresses\",\"type\":\"address[]\"}],\"internalType\":\"struct SpokePoolInterface.RelayerRefundLeaf\",\"name\":\"relayerRefundLeaf\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"executeRelayerRefundRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalRelayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"relayerFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"rootBundleId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"executeSlowRelayRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokensToSend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repaymentChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"relayerFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"}],\"name\":\"fillRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokensToSend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repaymentChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"relayerFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"newRelayerFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"depositorSignature\",\"type\":\"bytes\"}],\"name\":\"fillRelayWithUpdatedFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hubPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l1Gas\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2Eth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfDeposits\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"relayFills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"relayerRefundRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slowRelayRoot\",\"type\":\"bytes32\"}],\"name\":\"relayRootBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rootBundles\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"slowRelayRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"relayerRefundRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCrossDomainAdmin\",\"type\":\"address\"}],\"name\":\"setCrossDomainAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newDepositQuoteTimeBuffer\",\"type\":\"uint32\"}],\"name\":\"setDepositQuoteTimeBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setEnableRoute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newHubPool\",\"type\":\"address\"}],\"name\":\"setHubPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newl1Gas\",\"type\":\"uint32\"}],\"name\":\"setL1GasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"newRelayerFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"depositorSignature\",\"type\":\"bytes\"}],\"name\":\"speedUpDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract WETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"chainId()\":{\"details\":\"Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\"},\"constructor\":{\"params\":{\"_crossDomainAdmin\":\"Cross domain admin to set. Can be changed by admin.\",\"_hubPool\":\"Hub pool address to set. Can be changed by admin.\",\"timerAddress\":\"Timer address to set.\"}},\"deposit(address,address,uint256,uint256,uint64,uint32)\":{\"params\":{\"amount\":\"Amount of tokens to deposit. Will be amount of tokens to receive less fees.\",\"destinationChainId\":\"Denotes network where user will receive funds from SpokePool by a relayer.\",\"originToken\":\"Token to lock into this contract to initiate deposit.\",\"quoteTimestamp\":\"Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.\",\"recipient\":\"Address to receive funds at on destination chain.\",\"relayerFeePct\":\"% of deposit amount taken out to incentivize a fast relayer.\"}},\"executeRelayerRefundRoot(uint32,(uint256,uint256,uint256[],uint32,address,address[]),bytes32[])\":{\"params\":{\"proof\":\"Inclusion proof for this leaf in relayer refund root in root bundle.\",\"relayerRefundLeaf\":\"Contains all data neccessary to reconstruct leaf contained in root bundle and to refund relayer. This data structure is explained in detail in the SpokePoolInterface.\",\"rootBundleId\":\"Unique ID of root bundle containing relayer refund root that this leaf is contained in.\"}},\"executeSlowRelayRoot(address,address,address,uint256,uint256,uint64,uint64,uint32,uint32,bytes32[])\":{\"params\":{\"amount\":\"Full size of the deposit.\",\"depositId\":\"Unique deposit ID on origin spoke pool.\",\"depositor\":\"Depositor on origin chain who set this chain as the destination chain.\",\"destinationToken\":\"Token to send to recipient. Should be mapped to the origin token, origin chain ID and this chain ID via a mapping on the HubPool.\",\"originChainId\":\"Chain of SpokePool where deposit originated.\",\"proof\":\"Inclusion proof for this leaf in slow relay root in root bundle.\",\"realizedLpFeePct\":\"Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on quote time.\",\"recipient\":\"Specified recipient on this chain.\",\"relayerFeePct\":\"Original fee % to keep as relayer set by depositor.\",\"rootBundleId\":\"Unique ID of root bundle containing slow relay root that this leaf is contained in.\"}},\"fillRelay(address,address,address,uint256,uint256,uint256,uint256,uint64,uint64,uint32)\":{\"params\":{\"amount\":\"Full size of the deposit.\",\"depositId\":\"Unique deposit ID on origin spoke pool.\",\"depositor\":\"Depositor on origin chain who set this chain as the destination chain.\",\"destinationToken\":\"Token to send to recipient. Should be mapped to the origin token, origin chain ID and this chain ID via a mapping on the HubPool.\",\"maxTokensToSend\":\"Max amount of tokens to send recipient. If higher than amount, then caller will send recipient the full relay amount.\",\"originChainId\":\"Chain of SpokePool where deposit originated.\",\"realizedLpFeePct\":\"Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on quote time.\",\"recipient\":\"Specified recipient on this chain.\",\"relayerFeePct\":\"Fee % to keep as relayer, specified by depositor.\",\"repaymentChainId\":\"Chain of SpokePool where relayer wants to be refunded after the challenge window has passed.\"}},\"fillRelayWithUpdatedFee(address,address,address,uint256,uint256,uint256,uint256,uint64,uint64,uint64,uint32,bytes)\":{\"params\":{\"amount\":\"Full size of the deposit.\",\"depositId\":\"Unique deposit ID on origin spoke pool.\",\"depositor\":\"Depositor on origin chain who set this chain as the destination chain.\",\"depositorSignature\":\"Depositor-signed message containing updated fee %.\",\"destinationToken\":\"Token to send to recipient. Should be mapped to the origin token, origin chain ID and this chain ID via a mapping on the HubPool.\",\"maxTokensToSend\":\"Max amount of tokens to send recipient. If higher than amount, then caller will send recipient the full relay amount.\",\"newRelayerFeePct\":\"New fee % to keep as relayer also specified by depositor.\",\"originChainId\":\"Chain of SpokePool where deposit originated.\",\"realizedLpFeePct\":\"Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on quote time.\",\"recipient\":\"Specified recipient on this chain.\",\"relayerFeePct\":\"Original fee % to keep as relayer set by depositor.\",\"repaymentChainId\":\"Chain of SpokePool where relayer wants to be refunded after the challenge window has passed.\"}},\"getCurrentTime()\":{\"returns\":{\"_0\":\"uint for the current Testable timestamp.\"}},\"relayRootBundle(bytes32,bytes32)\":{\"params\":{\"relayerRefundRoot\":\"Merkle root containing relayer refund leaves that can be individually executed via executeRelayerRefundRoot().\",\"slowRelayRoot\":\"Merkle root containing slow relay fulfillment leaves that can be individually executed via executeSlowRelayRoot().\"}},\"setCrossDomainAdmin(address)\":{\"params\":{\"newCrossDomainAdmin\":\"New cross domain admin.\"}},\"setCurrentTime(uint256)\":{\"details\":\"Will revert if not running in test mode.\",\"params\":{\"time\":\"timestamp to set current Testable time to.\"}},\"setDepositQuoteTimeBuffer(uint32)\":{\"params\":{\"newDepositQuoteTimeBuffer\":\"New quote time buffer.\"}},\"setEnableRoute(address,uint256,bool)\":{\"params\":{\"destinationChainId\":\"Chain ID for where depositor wants to receive funds.\",\"enabled\":\"True to enable deposits, False otherwise.\",\"originToken\":\"Token that depositor can deposit to this contract.\"}},\"setHubPool(address)\":{\"params\":{\"newHubPool\":\"New hub pool.\"}},\"setL1GasLimit(uint32)\":{\"params\":{\"newl1Gas\":\"New L1 gas limit to set.\"}},\"speedUpDeposit(address,uint64,uint32,bytes)\":{\"params\":{\"depositId\":\"Deposit to update fee for that originated in this contract.\",\"depositor\":\"Signer of the update fee message who originally submitted the deposit. If the deposit doesn't exist, then the relayer will not be able to fill any relay, so the caller should validate that the depositor did in fact submit a relay.\",\"depositorSignature\":\"Signed message containing the depositor address, this contract chain ID, the updated relayer fee %, and the deposit ID. This signature is produced by signing a hash of data according to the EIP-191 standard. See more in the _verifyUpdateRelayerFeeMessage() comments.\",\"newRelayerFeePct\":\"New relayer fee that relayers can use.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"chainId()\":{\"notice\":\"Returns chain ID for this network.\"},\"constructor\":{\"notice\":\"Construct the OVM SpokePool.\"},\"deposit(address,address,uint256,uint256,uint64,uint32)\":{\"notice\":\"Called by user to bridge funds from origin to destination chain. Depositor will effectively lock tokens in this contract and receive a destination token on the destination chain. The origin => destination token mapping is stored on the L1 HubPool.The caller must first approve this contract to spend amount of originToken.The originToken => destinationChainId must be enabled.This method is payable because the caller is able to deposit ETH if the originToken is WETH and this function will handle wrapping ETH.\"},\"executeRelayerRefundRoot(uint32,(uint256,uint256,uint256[],uint32,address,address[]),bytes32[])\":{\"notice\":\"Wraps any ETH into WETH before executing base function. This is necessary because SpokePool receives ETH over the canonical token bridge instead of WETH.\"},\"executeSlowRelayRoot(address,address,address,uint256,uint256,uint64,uint64,uint32,uint32,bytes32[])\":{\"notice\":\"Wraps any ETH into WETH before executing base function. This is neccessary because SpokePool receives ETH over the canonical token bridge instead of WETH.\"},\"fillRelay(address,address,address,uint256,uint256,uint256,uint256,uint64,uint64,uint32)\":{\"notice\":\"Called by relayer to fulfill part of a deposit by sending destination tokens to the receipient. Relayer is expected to pass in unique identifying information for deposit that they want to fulfill, and this relay submission will be validated by off-chain data workers who can dispute this relay if any part is invalid. If the relay is valid, then the relayer will be refunded on their desired repayment chain. If relay is invalid, then relayer will not receive any refund.All of the deposit data can be found via on-chain events from the origin SpokePool, except for the realizedLpFeePct which is a function of the HubPool's utilization at the deposit quote time. This fee % is deterministic based on the quote time, so the relayer should just compute it using the canonical algorithm as described in a UMIP linked to the HubPool's identifier.\"},\"fillRelayWithUpdatedFee(address,address,address,uint256,uint256,uint256,uint256,uint64,uint64,uint64,uint32,bytes)\":{\"notice\":\"Called by relayer to execute same logic as calling fillRelay except that relayer is using an updated relayer fee %. The fee % must have been emitted in a message cryptographically signed by the depositor.By design, the depositor probably emitted the message with the updated fee by calling speedUpRelay().\"},\"getCurrentTime()\":{\"notice\":\"Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.\"},\"relayRootBundle(bytes32,bytes32)\":{\"notice\":\"This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\"},\"setCrossDomainAdmin(address)\":{\"notice\":\"Change cross domain admin address. Callable by admin only.\"},\"setCurrentTime(uint256)\":{\"notice\":\"Sets the current time.\"},\"setDepositQuoteTimeBuffer(uint32)\":{\"notice\":\"Change allowance for deposit quote time to differ from current block time. Callable by admin only.\"},\"setEnableRoute(address,uint256,bool)\":{\"notice\":\"Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only.\"},\"setHubPool(address)\":{\"notice\":\"Change L1 hub pool address. Callable by admin only.\"},\"setL1GasLimit(uint32)\":{\"notice\":\"Change L1 gas limit. Callable only by admin.\"},\"speedUpDeposit(address,uint64,uint32,bytes)\":{\"notice\":\"Convenience method that depositor can use to signal to relayer to use updated fee.Relayer should only use events emitted by this function to submit fills with updated fees, otherwise they risk their fills getting disputed for being invalid, for example if the depositor never actually signed the update fee message.This function will revert if the depositor did not sign a message containing the updated fee for the deposit ID stored in this contract. If the deposit ID is for another contract, or the depositor address is incorrect, or the updated fee is incorrect, then the signature will not match and this function will revert.\"}},\"notice\":\"OVM specific SpokePool. Uses OVM cross-domain-enabled logic to implement admin only access to functions.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Optimism_SpokePool.sol\":\"Optimism_SpokePool\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title IL2ERC20Bridge\\n */\\ninterface IL2ERC20Bridge {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event WithdrawalInitiated(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event DepositFinalized(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event DepositFailed(\\n        address indexed _l1Token,\\n        address indexed _l2Token,\\n        address indexed _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @dev get the address of the corresponding L1 bridge contract.\\n     * @return Address of the corresponding L1 bridge contract.\\n     */\\n    function l1TokenBridge() external returns (address);\\n\\n    /**\\n     * @dev initiate a withdraw of some tokens to the caller's account on L1\\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\\n     * @param _amount Amount of the token to withdraw.\\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\\n     * @param _data Optional data to forward to L1. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function withdraw(\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _l1Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n     * @dev initiate a withdraw of some token to a recipient's account on L1.\\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\\n     * @param _to L1 adress to credit the withdrawal to.\\n     * @param _amount Amount of the token to withdraw.\\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\\n     * @param _data Optional data to forward to L1. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function withdrawTo(\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _l1Gas,\\n        bytes calldata _data\\n    ) external;\\n\\n    /*************************\\n     * Cross-chain Functions *\\n     *************************/\\n\\n    /**\\n     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this\\n     * L2 token. This call will fail if it did not originate from a corresponding deposit in\\n     * L1StandardTokenBridge.\\n     * @param _l1Token Address for the l1 token this is called with\\n     * @param _l2Token Address for the l2 token this is called with\\n     * @param _from Account to pull the deposit from on L2.\\n     * @param _to Address to receive the withdrawal at\\n     * @param _amount Amount of the token to withdraw\\n     * @param _data Data provider by the sender on L1. This data is provided\\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\\n     *        length, these contracts provide no guarantees about its content.\\n     */\\n    function finalizeDeposit(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x4674c3c8733ca0db16c2b81d58227560df36a07ded3b637a0793564d90ac0475\",\"license\":\"MIT\"},\"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Interface Imports */\\nimport { ICrossDomainMessenger } from \\\"./ICrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title CrossDomainEnabled\\n * @dev Helper contract for contracts performing cross-domain communications\\n *\\n * Compiler used: defined by inheriting contract\\n */\\ncontract CrossDomainEnabled {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // Messenger contract used to send and recieve messages from the other domain.\\n    address public messenger;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\\n     */\\n    constructor(address _messenger) {\\n        messenger = _messenger;\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Enforces that the modified function is only callable by a specific cross-domain account.\\n     * @param _sourceDomainAccount The only account on the originating domain which is\\n     *  authenticated to call this function.\\n     */\\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\\n        require(\\n            msg.sender == address(getCrossDomainMessenger()),\\n            \\\"OVM_XCHAIN: messenger contract unauthenticated\\\"\\n        );\\n\\n        require(\\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\\n            \\\"OVM_XCHAIN: wrong sender of cross-domain message\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\\n     * needs to override.\\n     * @return The address of the cross-domain messenger contract which should be used.\\n     */\\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\\n        return ICrossDomainMessenger(messenger);\\n    }\\n\\n    /**q\\n     * Sends a message to an account on another domain\\n     * @param _crossDomainTarget The intended recipient on the destination domain\\n     * @param _message The data to send to the target (usually calldata to a function with\\n     *  `onlyFromCrossDomainAccount()`)\\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\\n     */\\n    function sendCrossDomainMessage(\\n        address _crossDomainTarget,\\n        uint32 _gasLimit,\\n        bytes memory _message\\n    ) internal {\\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\\n    }\\n}\\n\",\"keccak256\":\"0x9c3cc8b7047c68a403529b15769a21c2e2668ea71db7bef51f123288009811ea\",\"license\":\"MIT\"},\"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title ICrossDomainMessenger\\n */\\ninterface ICrossDomainMessenger {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(\\n        address indexed target,\\n        address sender,\\n        bytes message,\\n        uint256 messageNonce,\\n        uint256 gasLimit\\n    );\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\",\"keccak256\":\"0x8f29ae23021345a20ccac7b5edb3fc38268aef943b65adc8a32e74b80bf1833a\",\"license\":\"MIT\"},\"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_PredeployAddresses\\n */\\nlibrary Lib_PredeployAddresses {\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\\n        0x4200000000000000000000000000000000000007;\\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\\n        0x4200000000000000000000000000000000000012;\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n}\\n\",\"keccak256\":\"0x2bc28307af93e9716151a41a81694b56cbe513ef5eb335fb1d81f35e5db8edfa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x0705a4b1b86d7b0bd8432118f226ba139c44b9dcaba0a6eafba2dd7d0639c544\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x3c07f43e60e099b3b157243b3152722e73b80eeb7985c2cd73712828d7f7da29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xea64fbaccbf9d8c235cf6838240ddcebb97f9fc383660289e9dff32e4fb85f7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../Address.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\\n    }\\n}\\n\",\"keccak256\":\"0xc8add71d80d05a1390e1c656686a0ea10ffaebfcc433cc397a63fd725f376b7e\",\"license\":\"MIT\"},\"@uma/core/contracts/common/implementation/MultiCaller.sol\":{\"content\":\"// This contract is taken from Uniswaps's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\\npragma solidity ^0.8.0;\\n\\n/// @title MultiCaller\\n/// @notice Enables calling multiple methods in a single call to the contract\\ncontract MultiCaller {\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {\\n        require(msg.value == 0, \\\"Only multicall with 0 value\\\");\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x31f18055b14fd9eeb459c6d6a88d1a60921bf3755031f6db4b709c3e01d078f7\"},\"@uma/core/contracts/common/implementation/Testable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Timer.sol\\\";\\n\\n/**\\n * @title Base class that provides time overrides, but only if being run in test mode.\\n */\\nabstract contract Testable {\\n    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.\\n    // Note: this variable should be set on construction and never modified.\\n    address public timerAddress;\\n\\n    /**\\n     * @notice Constructs the Testable contract. Called by child contracts.\\n     * @param _timerAddress Contract that stores the current time in a testing environment.\\n     * Must be set to 0x0 for production environments that use live time.\\n     */\\n    constructor(address _timerAddress) {\\n        timerAddress = _timerAddress;\\n    }\\n\\n    /**\\n     * @notice Reverts if not running in test mode.\\n     */\\n    modifier onlyIfTest {\\n        require(timerAddress != address(0x0));\\n        _;\\n    }\\n\\n    /**\\n     * @notice Sets the current time.\\n     * @dev Will revert if not running in test mode.\\n     * @param time timestamp to set current Testable time to.\\n     */\\n    function setCurrentTime(uint256 time) external onlyIfTest {\\n        Timer(timerAddress).setCurrentTime(time);\\n    }\\n\\n    /**\\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\\n     * Otherwise, it will return the block timestamp.\\n     * @return uint for the current Testable timestamp.\\n     */\\n    function getCurrentTime() public view virtual returns (uint256) {\\n        if (timerAddress != address(0x0)) {\\n            return Timer(timerAddress).getCurrentTime();\\n        } else {\\n            return block.timestamp; // solhint-disable-line not-rely-on-time\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0254b45747293bb800373a58d123969adec0428f7be79dc941cab10fcad09918\",\"license\":\"AGPL-3.0-only\"},\"@uma/core/contracts/common/implementation/Timer.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Universal store of current contract time for testing environments.\\n */\\ncontract Timer {\\n    uint256 private currentTime;\\n\\n    constructor() {\\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /**\\n     * @notice Sets the current time.\\n     * @dev Will revert if not running in test mode.\\n     * @param time timestamp to set `currentTime` to.\\n     */\\n    function setCurrentTime(uint256 time) external {\\n        currentTime = time;\\n    }\\n\\n    /**\\n     * @notice Gets the currentTime variable set in the Timer.\\n     * @return uint256 for the current Testable timestamp.\\n     */\\n    function getCurrentTime() public view returns (uint256) {\\n        return currentTime;\\n    }\\n}\\n\",\"keccak256\":\"0x9e0dd7389718bd5d1da910273a6f4cee98ee22bfc0c92bde0f0955c0e23adb5e\",\"license\":\"AGPL-3.0-only\"},\"contracts/HubPoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/AdapterInterface.sol\\\";\\n\\n/**\\n * @notice Concise list of functions in HubPool implementation.\\n */\\ninterface HubPoolInterface {\\n    // This leaf is meant to be decoded in the HubPool to rebalance tokens between HubPool and SpokePool.\\n    struct PoolRebalanceLeaf {\\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to sent to).\\n        uint256 chainId;\\n        // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\\n        uint256[] bundleLpFees;\\n        // This array is grouped with the two above, and it represents the amount to send or request back from the\\n        // SpokePool. If positive, the pool will pay the SpokePool. If negative the SpokePool will pay the HubPool.\\n        // There can be arbitrarily complex rebalancing rules defined offchain. This number is only nonzero\\n        // when the rules indicate that a rebalancing action should occur. When a rebalance does not occur,\\n        // runningBalances for this token should change by the total relays - deposits in this bundle. When a rebalance\\n        // does occur, runningBalances should be set to zero for this token and the netSendAmounts should be set to the\\n        // previous runningBalances + relays - deposits in this bundle.\\n        int256[] netSendAmounts;\\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1 pool.\\n        // A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that the\\n        // SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts\\n        int256[] runningBalances;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint8 leafId;\\n        // The following arrays are required to be the same length. They are parallel arrays for the given chainId and\\n        // should be ordered by the l1Tokens field. All whitelisted tokens with nonzero relays on this chain in this\\n        // bundle in the order of whitelisting.\\n        address[] l1Tokens;\\n    }\\n\\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData) external;\\n\\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct) external;\\n\\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\\n\\n    function setLiveness(uint32 newLiveness) external;\\n\\n    function setIdentifier(bytes32 newIdentifier) external;\\n\\n    function setCrossChainContracts(\\n        uint256 l2ChainId,\\n        address adapter,\\n        address spokePool\\n    ) external;\\n\\n    function whitelistRoute(\\n        uint256 originChainId,\\n        uint256 destinationChainId,\\n        address originToken,\\n        address destinationToken\\n    ) external;\\n\\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\\n\\n    function removeLiquidity(\\n        address l1Token,\\n        uint256 lpTokenAmount,\\n        bool sendEth\\n    ) external;\\n\\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationPostRelay(address token, uint256 relayedAmount) external returns (uint256);\\n\\n    function sync(address l1Token) external;\\n\\n    function proposeRootBundle(\\n        uint256[] memory bundleEvaluationBlockNumbers,\\n        uint8 poolRebalanceLeafCount,\\n        bytes32 poolRebalanceRoot,\\n        bytes32 relayerRefundRoot,\\n        bytes32 slowRelayRoot\\n    ) external;\\n\\n    function executeRootBundle(PoolRebalanceLeaf memory poolRebalanceLeaf, bytes32[] memory proof) external;\\n\\n    function disputeRootBundle() external;\\n\\n    function claimProtocolFeesCaptured(address l1Token) external;\\n\\n    function getRootBundleProposalAncillaryData() external view returns (bytes memory ancillaryData);\\n\\n    function whitelistedRoute(\\n        uint256 originChainId,\\n        address originToken,\\n        uint256 destinationChainId\\n    ) external view returns (address);\\n\\n    function loadEthForL2Calls() external payable;\\n}\\n\",\"keccak256\":\"0x86f4f3366c0dbd5465bc572bb2e4d660a911377b5bceabb0d18b1d70b85fdb4b\",\"license\":\"GPL-3.0-only\"},\"contracts/Lockable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\n * @dev The reason why we use this local contract instead of importing from uma/contracts is because of the addition\\n * of the internal method `functionCallStackOriginatesFromOutsideThisContract` which doesn't exist in the one exported\\n * by uma/contracts.\\n */\\ncontract Lockable {\\n    bool internal _notEntered;\\n\\n    constructor() {\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\n        // refund coming into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a nonReentrant function from another nonReentrant function is not supported. It is possible to\\n     * prevent this from happening by making the nonReentrant function external, and making it call a private\\n     * function that does the actual state modification.\\n     */\\n    modifier nonReentrant() {\\n        _preEntranceCheck();\\n        _preEntranceSet();\\n        _;\\n        _postEntranceReset();\\n    }\\n\\n    /**\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a nonReentrant() state-changing method.\\n     */\\n    modifier nonReentrantView() {\\n        _preEntranceCheck();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is currently in a non-entered state, meaning that the origination of the call\\n     * came from outside the contract. This is relevant with fallback/receive methods to see if the call came from ETH\\n     * being dropped onto the contract externally or due to ETH dropped on the the contract from within a method in this\\n     * contract, such as unwrapping WETH to ETH within the contract.\\n     */\\n    function functionCallStackOriginatesFromOutsideThisContract() internal view returns (bool) {\\n        return _notEntered;\\n    }\\n\\n    // Internal methods are used to avoid copying the require statement's bytecode to every nonReentrant() method.\\n    // On entry into a function, _preEntranceCheck() should always be called to check if the function is being\\n    // re-entered. Then, if the function modifies state, it should call _postEntranceSet(), perform its logic, and\\n    // then call _postEntranceReset().\\n    // View-only methods can simply call _preEntranceCheck() to make sure that it is not being re-entered.\\n    function _preEntranceCheck() internal view {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n\\n    function _preEntranceSet() internal {\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n    }\\n\\n    function _postEntranceReset() internal {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\",\"keccak256\":\"0xef490be5cb859c97c6f600f3b0db0d50c6e18f334d3c74c6d9e693a260eaec3e\",\"license\":\"AGPL-3.0-only\"},\"contracts/MerkleLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"./SpokePoolInterface.sol\\\";\\nimport \\\"./HubPoolInterface.sol\\\";\\n\\n/**\\n * @notice Library to help with merkle roots, proofs, and claims.\\n */\\nlibrary MerkleLib {\\n    /**\\n     * @notice Verifies that a repayment is contained within a merkle root.\\n     * @param root the merkle root.\\n     * @param rebalance the rebalance struct.\\n     * @param proof the merkle proof.\\n     */\\n    function verifyPoolRebalance(\\n        bytes32 root,\\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\\n        bytes32[] memory proof\\n    ) internal pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));\\n    }\\n\\n    /**\\n     * @notice Verifies that a relayer refund is contained within a merkle root.\\n     * @param root the merkle root.\\n     * @param refund the refund struct.\\n     * @param proof the merkle proof.\\n     */\\n    function verifyRelayerRefund(\\n        bytes32 root,\\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\\n        bytes32[] memory proof\\n    ) internal pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(refund)));\\n    }\\n\\n    /**\\n     * @notice Verifies that a distribution is contained within a merkle root.\\n     * @param root the merkle root.\\n     * @param slowRelayFulfillment the relayData fulfullment struct.\\n     * @param proof the merkle proof.\\n     */\\n    function verifySlowRelayFulfillment(\\n        bytes32 root,\\n        SpokePoolInterface.RelayData memory slowRelayFulfillment,\\n        bytes32[] memory proof\\n    ) internal pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\\n    }\\n\\n    // The following functions are primarily copied from\\n    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.\\n\\n    /**\\n     * @notice Tests whether a claim is contained within a claimedBitMap mapping.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\\n     * @param index the index to check in the bitmap.\\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\\n     */\\n    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal view returns (bool) {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\\n        uint256 mask = (1 << claimedBitIndex);\\n        return claimedWord & mask == mask;\\n    }\\n\\n    /**\\n     * @notice Marks an index in a claimedBitMap as claimed.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\\n     * @param index the index to mark in the bitmap.\\n     */\\n    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\\n    }\\n\\n    /**\\n     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.\\n     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.\\n     * @param index the index to check in the bitmap.\\n     \\\\* @return bool indicating if the index within the claimedBitMap has been marked as claimed.\\n     */\\n    function isClaimed1D(uint256 claimedBitMap, uint256 index) internal pure returns (bool) {\\n        uint256 mask = (1 << index);\\n        return claimedBitMap & mask == mask;\\n    }\\n\\n    /**\\n     * @notice Marks an index in a claimedBitMap as claimed.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\\n     * @param index the index to mark in the bitmap.\\n     */\\n    function setClaimed1D(uint256 claimedBitMap, uint256 index) internal pure returns (uint256) {\\n        require(index <= 255, \\\"Index out of bounds\\\");\\n        return claimedBitMap | (1 << index % 256);\\n    }\\n}\\n\",\"keccak256\":\"0xfec238b342924f5226ab994aa108a9917bc840a89cd34c2ee6c6806161ef3e0c\",\"license\":\"GPL-3.0-only\"},\"contracts/Optimism_SpokePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/WETH9.sol\\\";\\n\\nimport \\\"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\\\";\\nimport \\\"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\\\";\\nimport \\\"@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol\\\";\\nimport \\\"./SpokePool.sol\\\";\\nimport \\\"./SpokePoolInterface.sol\\\";\\n\\n/**\\n * @notice OVM specific SpokePool. Uses OVM cross-domain-enabled logic to implement admin only access to functions.\\n */\\ncontract Optimism_SpokePool is CrossDomainEnabled, SpokePool {\\n    // \\\"l1Gas\\\" parameter used in call to bridge tokens from this contract back to L1 via IL2ERC20Bridge. Currently\\n    // unused by bridge but included for future compatibility.\\n    uint32 public l1Gas = 5_000_000;\\n\\n    // ETH is an ERC20 on OVM.\\n    address public l2Eth = address(Lib_PredeployAddresses.OVM_ETH);\\n\\n    event OptimismTokensBridged(address indexed l2Token, address target, uint256 numberOfTokensBridged, uint256 l1Gas);\\n    event SetL1Gas(uint32 indexed newL1Gas);\\n\\n    /**\\n     * @notice Construct the OVM SpokePool.\\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\\n     * @param _hubPool Hub pool address to set. Can be changed by admin.\\n     * @param timerAddress Timer address to set.\\n     */\\n    constructor(\\n        address _crossDomainAdmin,\\n        address _hubPool,\\n        address timerAddress\\n    )\\n        CrossDomainEnabled(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER)\\n        SpokePool(_crossDomainAdmin, _hubPool, 0x4200000000000000000000000000000000000006, timerAddress)\\n    {}\\n\\n    /*******************************************\\n     *    OPTIMISM-SPECIFIC ADMIN FUNCTIONS    *\\n     *******************************************/\\n\\n    /**\\n     * @notice Change L1 gas limit. Callable only by admin.\\n     * @param newl1Gas New L1 gas limit to set.\\n     */\\n    function setL1GasLimit(uint32 newl1Gas) public onlyAdmin {\\n        l1Gas = newl1Gas;\\n        emit SetL1Gas(newl1Gas);\\n    }\\n\\n    /**************************************\\n     *         DATA WORKER FUNCTIONS      *\\n     **************************************/\\n\\n    /**\\n     * @notice Wraps any ETH into WETH before executing base function. This is neccessary because SpokePool receives\\n     * ETH over the canonical token bridge instead of WETH.\\n     * @inheritdoc SpokePool\\n     */\\n    function executeSlowRelayRoot(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 totalRelayAmount,\\n        uint256 originChainId,\\n        uint64 realizedLpFeePct,\\n        uint64 relayerFeePct,\\n        uint32 depositId,\\n        uint32 rootBundleId,\\n        bytes32[] memory proof\\n    ) public override(SpokePool) nonReentrant {\\n        if (destinationToken == address(weth)) _depositEthToWeth();\\n\\n        _executeSlowRelayRoot(\\n            depositor,\\n            recipient,\\n            destinationToken,\\n            totalRelayAmount,\\n            originChainId,\\n            realizedLpFeePct,\\n            relayerFeePct,\\n            depositId,\\n            rootBundleId,\\n            proof\\n        );\\n    }\\n\\n    /**\\n     * @notice Wraps any ETH into WETH before executing base function. This is necessary because SpokePool receives\\n     * ETH over the canonical token bridge instead of WETH.\\n     * @inheritdoc SpokePool\\n     */\\n    function executeRelayerRefundRoot(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) public override(SpokePool) nonReentrant {\\n        if (relayerRefundLeaf.l2TokenAddress == address(weth)) _depositEthToWeth();\\n\\n        _executeRelayerRefundRoot(rootBundleId, relayerRefundLeaf, proof);\\n    }\\n\\n    /**************************************\\n     *        INTERNAL FUNCTIONS          *\\n     **************************************/\\n\\n    // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is necessary because\\n    // this SpokePool will receive ETH from the canonical token bridge instead of WETH. Its not sufficient to execute\\n    // this logic inside a fallback method that executes when this contract receives ETH because ETH is an ERC20\\n    // on the OVM.\\n    function _depositEthToWeth() internal {\\n        if (address(this).balance > 0) weth.deposit{ value: address(this).balance }();\\n    }\\n\\n    function _bridgeTokensToHubPool(RelayerRefundLeaf memory relayerRefundLeaf) internal override {\\n        // If the token being bridged is WETH then we need to first unwrap it to ETH and then send ETH over the\\n        // canonical bridge. On Optimism, this is address 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\\n        if (relayerRefundLeaf.l2TokenAddress == address(weth)) {\\n            WETH9(relayerRefundLeaf.l2TokenAddress).withdraw(relayerRefundLeaf.amountToReturn); // Unwrap into ETH.\\n            relayerRefundLeaf.l2TokenAddress = l2Eth; // Set the l2TokenAddress to ETH.\\n        }\\n        IL2ERC20Bridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo(\\n            relayerRefundLeaf.l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\\n            hubPool, // _to. Withdraw, over the bridge, to the l1 pool contract.\\n            relayerRefundLeaf.amountToReturn, // _amount.\\n            l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\\n            \\\"\\\" // _data. We don't need to send any data for the bridging action.\\n        );\\n\\n        emit OptimismTokensBridged(relayerRefundLeaf.l2TokenAddress, hubPool, relayerRefundLeaf.amountToReturn, l1Gas);\\n    }\\n\\n    // Apply OVM-specific transformation to cross domain admin address on L1.\\n    function _requireAdminSender() internal override onlyFromCrossDomainAccount(crossDomainAdmin) {}\\n}\\n\",\"keccak256\":\"0xe1bb1d3ad243bbaf99c97699e163439852657e1254686cf8f592f7c08b226a5b\",\"license\":\"GPL-3.0-only\"},\"contracts/SpokePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"./MerkleLib.sol\\\";\\nimport \\\"./interfaces/WETH9.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"@uma/core/contracts/common/implementation/Testable.sol\\\";\\nimport \\\"@uma/core/contracts/common/implementation/MultiCaller.sol\\\";\\nimport \\\"./Lockable.sol\\\";\\nimport \\\"./MerkleLib.sol\\\";\\nimport \\\"./SpokePoolInterface.sol\\\";\\n\\n/**\\n * @title SpokePool\\n * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to\\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.\\n * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a \\\"data worker\\\",\\n * submits a proof that the relayer correctly submitted a relay on this SpokePool.\\n */\\nabstract contract SpokePool is SpokePoolInterface, Testable, Lockable, MultiCaller {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n\\n    // Address of the L1 contract that acts as the owner of this SpokePool. If this contract is deployed on Ethereum,\\n    // then this address should be set to the same owner as the HubPool and the whole system.\\n    address public crossDomainAdmin;\\n\\n    // Address of the L1 contract that will send tokens to and receive tokens from this contract to fund relayer\\n    // refunds and slow relays.\\n    address public hubPool;\\n\\n    // Address of WETH contract for this network. If an origin token matches this, then the caller can optionally\\n    // instruct this contract to wrap ETH when depositing.\\n    WETH9 public weth;\\n\\n    // Timestamp when contract was constructed. Relays cannot have a quote time before this.\\n    uint32 public deploymentTime;\\n\\n    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces\\n    // caller to use an approximately \\\"current\\\" realized fee. Defaults to 10 minutes.\\n    uint32 public depositQuoteTimeBuffer = 600;\\n\\n    // Count of deposits is used to construct a unique deposit identifier for this spoke pool.\\n    uint32 public numberOfDeposits;\\n\\n    // Origin token to destination token routings can be turned on or off, which can enable or disable deposits.\\n    // A reverse mapping is stored on the L1 HubPool to enable or disable rebalance transfers from the HubPool to this\\n    // contract.\\n    mapping(address => mapping(uint256 => bool)) public enabledDepositRoutes;\\n\\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\\n    // by \\\"data workers\\\" via inclusion proofs to execute leaves in the roots.\\n    struct RootBundle {\\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\\n        bytes32 slowRelayRoot;\\n        // Merkle root of relayer refunds for successful relays.\\n        bytes32 relayerRefundRoot;\\n        // This is a 2D bitmap tracking which leafs in the relayer refund root have been claimed, with max size of\\n        // 256x256 leaves per root.\\n        mapping(uint256 => uint256) claimedBitmap;\\n    }\\n\\n    // This contract can store as many root bundles as the HubPool chooses to publish here.\\n    RootBundle[] public rootBundles;\\n\\n    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay\\n    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to\\n    // relay, the fees, and the agents are all parameters included in the hash key.\\n    mapping(bytes32 => uint256) public relayFills;\\n\\n    /****************************************\\n     *                EVENTS                *\\n     ****************************************/\\n    event SetXDomainAdmin(address indexed newAdmin);\\n    event SetHubPool(address indexed newHubPool);\\n    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);\\n    event SetDepositQuoteTimeBuffer(uint32 newBuffer);\\n    event FundsDeposited(\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        uint64 relayerFeePct,\\n        uint32 indexed depositId,\\n        uint32 quoteTimestamp,\\n        address indexed originToken,\\n        address recipient,\\n        address indexed depositor\\n    );\\n    event RequestedSpeedUpDeposit(\\n        uint64 newRelayerFeePct,\\n        uint32 indexed depositId,\\n        address indexed depositor,\\n        bytes depositorSignature\\n    );\\n    event FilledRelay(\\n        bytes32 indexed relayHash,\\n        uint256 amount,\\n        uint256 totalFilledAmount,\\n        uint256 fillAmount,\\n        uint256 indexed repaymentChainId,\\n        uint256 originChainId,\\n        uint64 relayerFeePct,\\n        uint64 realizedLpFeePct,\\n        uint32 depositId,\\n        address destinationToken,\\n        address indexed relayer,\\n        address depositor,\\n        address recipient\\n    );\\n    event ExecutedSlowRelayRoot(\\n        bytes32 indexed relayHash,\\n        uint256 amount,\\n        uint256 totalFilledAmount,\\n        uint256 fillAmount,\\n        uint256 originChainId,\\n        uint64 relayerFeePct,\\n        uint64 realizedLpFeePct,\\n        uint32 depositId,\\n        address destinationToken,\\n        address indexed caller,\\n        address depositor,\\n        address recipient\\n    );\\n    event RelayedRootBundle(uint32 indexed rootBundleId, bytes32 relayerRefundRoot, bytes32 slowRelayRoot);\\n    event ExecutedRelayerRefundRoot(\\n        uint256 amountToReturn,\\n        uint256 chainId,\\n        uint256[] refundAmounts,\\n        uint32 indexed rootBundleId,\\n        uint32 indexed leafId,\\n        address l2TokenAddress,\\n        address[] refundAddresses,\\n        address indexed caller\\n    );\\n    event TokensBridged(\\n        uint256 amountToReturn,\\n        uint256 indexed chainId,\\n        uint32 indexed leafId,\\n        address indexed l2TokenAddress,\\n        address caller\\n    );\\n\\n    /**\\n     * @notice Construct the base SpokePool.\\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\\n     * @param _hubPool Hub pool address to set. Can be changed by admin.\\n     * @param _wethAddress Weth address for this network to set.\\n     * @param timerAddress Timer address to set.\\n     */\\n    constructor(\\n        address _crossDomainAdmin,\\n        address _hubPool,\\n        address _wethAddress,\\n        address timerAddress\\n    ) Testable(timerAddress) {\\n        _setCrossDomainAdmin(_crossDomainAdmin);\\n        _setHubPool(_hubPool);\\n        deploymentTime = uint32(getCurrentTime());\\n        weth = WETH9(_wethAddress);\\n    }\\n\\n    /****************************************\\n     *               MODIFIERS              *\\n     ****************************************/\\n\\n    modifier onlyEnabledRoute(address originToken, uint256 destinationId) {\\n        require(enabledDepositRoutes[originToken][destinationId], \\\"Disabled route\\\");\\n        _;\\n    }\\n\\n    // Implementing contract needs to override _requireAdminSender() to ensure that admin functions are protected\\n    // appropriately.\\n    modifier onlyAdmin() {\\n        _requireAdminSender();\\n        _;\\n    }\\n\\n    /**************************************\\n     *          ADMIN FUNCTIONS           *\\n     **************************************/\\n\\n    /**\\n     * @notice Change cross domain admin address. Callable by admin only.\\n     * @param newCrossDomainAdmin New cross domain admin.\\n     */\\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyAdmin {\\n        _setCrossDomainAdmin(newCrossDomainAdmin);\\n    }\\n\\n    /**\\n     * @notice Change L1 hub pool address. Callable by admin only.\\n     * @param newHubPool New hub pool.\\n     */\\n    function setHubPool(address newHubPool) public override onlyAdmin {\\n        _setHubPool(newHubPool);\\n    }\\n\\n    /**\\n     * @notice Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only.\\n     * @param originToken Token that depositor can deposit to this contract.\\n     * @param destinationChainId Chain ID for where depositor wants to receive funds.\\n     * @param enabled True to enable deposits, False otherwise.\\n     */\\n    function setEnableRoute(\\n        address originToken,\\n        uint256 destinationChainId,\\n        bool enabled\\n    ) public override onlyAdmin {\\n        enabledDepositRoutes[originToken][destinationChainId] = enabled;\\n        emit EnabledDepositRoute(originToken, destinationChainId, enabled);\\n    }\\n\\n    /**\\n     * @notice Change allowance for deposit quote time to differ from current block time. Callable by admin only.\\n     * @param newDepositQuoteTimeBuffer New quote time buffer.\\n     */\\n    function setDepositQuoteTimeBuffer(uint32 newDepositQuoteTimeBuffer) public override onlyAdmin {\\n        depositQuoteTimeBuffer = newDepositQuoteTimeBuffer;\\n        emit SetDepositQuoteTimeBuffer(newDepositQuoteTimeBuffer);\\n    }\\n\\n    /**\\n     * @notice This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill\\n     * slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is\\n     * designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method.\\n     * @param relayerRefundRoot Merkle root containing relayer refund leaves that can be individually executed via\\n     * executeRelayerRefundRoot().\\n     * @param slowRelayRoot Merkle root containing slow relay fulfillment leaves that can be individually executed via\\n     * executeSlowRelayRoot().\\n     */\\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) public override onlyAdmin {\\n        uint32 rootBundleId = uint32(rootBundles.length);\\n        RootBundle storage rootBundle = rootBundles.push();\\n        rootBundle.relayerRefundRoot = relayerRefundRoot;\\n        rootBundle.slowRelayRoot = slowRelayRoot;\\n        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayRoot);\\n    }\\n\\n    /**************************************\\n     *         DEPOSITOR FUNCTIONS        *\\n     **************************************/\\n\\n    /**\\n     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock\\n     * tokens in this contract and receive a destination token on the destination chain. The origin => destination\\n     * token mapping is stored on the L1 HubPool.\\n     * @notice The caller must first approve this contract to spend amount of originToken.\\n     * @notice The originToken => destinationChainId must be enabled.\\n     * @notice This method is payable because the caller is able to deposit ETH if the originToken is WETH and this\\n     * function will handle wrapping ETH.\\n     * @param recipient Address to receive funds at on destination chain.\\n     * @param originToken Token to lock into this contract to initiate deposit.\\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\\n     * to LP pool on HubPool.\\n     */\\n    function deposit(\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        uint64 relayerFeePct,\\n        uint32 quoteTimestamp\\n    ) public payable override onlyEnabledRoute(originToken, destinationChainId) nonReentrant {\\n        // We limit the relay fees to prevent the user spending all their funds on fees.\\n        require(relayerFeePct < 0.5e18, \\\"invalid relayer fee\\\");\\n        // This function assumes that L2 timing cannot be compared accurately and consistently to L1 timing. Therefore,\\n        // block.timestamp is different from the L1 EVM's. Therefore, the quoteTimestamp must be within a configurable\\n        // buffer of this contract's block time to allow for this variance.\\n        // Note also that quoteTimestamp cannot be less than the buffer otherwise the following arithmetic can result\\n        // in underflow. This isn't a problem as the deposit will revert, but the error might be unexpected for clients.\\n        require(\\n            getCurrentTime() >= quoteTimestamp - depositQuoteTimeBuffer &&\\n                getCurrentTime() <= quoteTimestamp + depositQuoteTimeBuffer,\\n            \\\"invalid quote time\\\"\\n        );\\n        // If the address of the origin token is a WETH contract and there is a msg.value with the transaction\\n        // then the user is sending ETH. In this case, the ETH should be deposited to WETH.\\n        if (originToken == address(weth) && msg.value > 0) {\\n            require(msg.value == amount, \\\"msg.value must match amount\\\");\\n            weth.deposit{ value: msg.value }();\\n            // Else, it is a normal ERC20. In this case pull the token from the users wallet as per normal.\\n            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them.\\n            // In this case the msg.value will be set to 0, indicating a \\\"normal\\\" ERC20 bridging action.\\n        } else IERC20(originToken).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit FundsDeposited(\\n            amount,\\n            destinationChainId,\\n            relayerFeePct,\\n            numberOfDeposits,\\n            quoteTimestamp,\\n            originToken,\\n            recipient,\\n            msg.sender\\n        );\\n\\n        // Increment count of deposits so that deposit ID for this spoke pool is unique.\\n        numberOfDeposits += 1;\\n    }\\n\\n    /**\\n     * @notice Convenience method that depositor can use to signal to relayer to use updated fee.\\n     * @notice Relayer should only use events emitted by this function to submit fills with updated fees, otherwise they\\n     * risk their fills getting disputed for being invalid, for example if the depositor never actually signed the\\n     * update fee message.\\n     * @notice This function will revert if the depositor did not sign a message containing the updated fee for the\\n     * deposit ID stored in this contract. If the deposit ID is for another contract, or the depositor address is\\n     * incorrect, or the updated fee is incorrect, then the signature will not match and this function will revert.\\n     * @param depositor Signer of the update fee message who originally submitted the deposit. If the deposit doesn't\\n     * exist, then the relayer will not be able to fill any relay, so the caller should validate that the depositor\\n     * did in fact submit a relay.\\n     * @param newRelayerFeePct New relayer fee that relayers can use.\\n     * @param depositId Deposit to update fee for that originated in this contract.\\n     * @param depositorSignature Signed message containing the depositor address, this contract chain ID, the updated\\n     * relayer fee %, and the deposit ID. This signature is produced by signing a hash of data according to the\\n     * EIP-191 standard. See more in the _verifyUpdateRelayerFeeMessage() comments.\\n     */\\n    function speedUpDeposit(\\n        address depositor,\\n        uint64 newRelayerFeePct,\\n        uint32 depositId,\\n        bytes memory depositorSignature\\n    ) public override nonReentrant {\\n        _verifyUpdateRelayerFeeMessage(depositor, chainId(), newRelayerFeePct, depositId, depositorSignature);\\n\\n        // Assuming the above checks passed, a relayer can take the signature and the updated relayer fee information\\n        // from the following event to submit a fill with an updated fee %.\\n        emit RequestedSpeedUpDeposit(newRelayerFeePct, depositId, depositor, depositorSignature);\\n    }\\n\\n    /**************************************\\n     *         RELAYER FUNCTIONS          *\\n     **************************************/\\n\\n    /**\\n     * @notice Called by relayer to fulfill part of a deposit by sending destination tokens to the receipient.\\n     * Relayer is expected to pass in unique identifying information for deposit that they want to fulfill, and this\\n     * relay submission will be validated by off-chain data workers who can dispute this relay if any part is invalid.\\n     * If the relay is valid, then the relayer will be refunded on their desired repayment chain. If relay is invalid,\\n     * then relayer will not receive any refund.\\n     * @notice All of the deposit data can be found via on-chain events from the origin SpokePool, except for the\\n     * realizedLpFeePct which is a function of the HubPool's utilization at the deposit quote time. This fee %\\n     * is deterministic based on the quote time, so the relayer should just compute it using the canonical algorithm\\n     * as described in a UMIP linked to the HubPool's identifier.\\n     * @param depositor Depositor on origin chain who set this chain as the destination chain.\\n     * @param recipient Specified recipient on this chain.\\n     * @param destinationToken Token to send to recipient. Should be mapped to the origin token, origin chain ID\\n     * and this chain ID via a mapping on the HubPool.\\n     * @param amount Full size of the deposit.\\n     * @param maxTokensToSend Max amount of tokens to send recipient. If higher than amount, then caller will\\n     * send recipient the full relay amount.\\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\\n     * passed.\\n     * @param originChainId Chain of SpokePool where deposit originated.\\n     * @param realizedLpFeePct Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on\\n     * quote time.\\n     * @param relayerFeePct Fee % to keep as relayer, specified by depositor.\\n     * @param depositId Unique deposit ID on origin spoke pool.\\n     */\\n    function fillRelay(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 maxTokensToSend,\\n        uint256 repaymentChainId,\\n        uint256 originChainId,\\n        uint64 realizedLpFeePct,\\n        uint64 relayerFeePct,\\n        uint32 depositId\\n    ) public nonReentrant {\\n        // Each relay attempt is mapped to the hash of data uniquely identifying it, which includes the deposit data\\n        // such as the origin chain ID and the deposit ID, and the data in a relay attempt such as who the recipient\\n        // is, which chain and currency the recipient wants to receive funds on, and the relay fees.\\n        SpokePoolInterface.RelayData memory relayData = SpokePoolInterface.RelayData({\\n            depositor: depositor,\\n            recipient: recipient,\\n            destinationToken: destinationToken,\\n            amount: amount,\\n            realizedLpFeePct: realizedLpFeePct,\\n            relayerFeePct: relayerFeePct,\\n            depositId: depositId,\\n            originChainId: originChainId\\n        });\\n        bytes32 relayHash = _getRelayHash(relayData);\\n\\n        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, maxTokensToSend, relayerFeePct, false);\\n\\n        _emitFillRelay(relayHash, fillAmountPreFees, repaymentChainId, relayerFeePct, relayData);\\n    }\\n\\n    /**\\n     * @notice Called by relayer to execute same logic as calling fillRelay except that relayer is using an updated\\n     * relayer fee %. The fee % must have been emitted in a message cryptographically signed by the depositor.\\n     * @notice By design, the depositor probably emitted the message with the updated fee by calling speedUpRelay().\\n     * @param depositor Depositor on origin chain who set this chain as the destination chain.\\n     * @param recipient Specified recipient on this chain.\\n     * @param destinationToken Token to send to recipient. Should be mapped to the origin token, origin chain ID\\n     * and this chain ID via a mapping on the HubPool.\\n     * @param amount Full size of the deposit.\\n     * @param maxTokensToSend Max amount of tokens to send recipient. If higher than amount, then caller will\\n     * send recipient the full relay amount.\\n     * @param repaymentChainId Chain of SpokePool where relayer wants to be refunded after the challenge window has\\n     * passed.\\n     * @param originChainId Chain of SpokePool where deposit originated.\\n     * @param realizedLpFeePct Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on\\n     * quote time.\\n     * @param relayerFeePct Original fee % to keep as relayer set by depositor.\\n     * @param newRelayerFeePct New fee % to keep as relayer also specified by depositor.\\n     * @param depositId Unique deposit ID on origin spoke pool.\\n     * @param depositorSignature Depositor-signed message containing updated fee %.\\n     */\\n    function fillRelayWithUpdatedFee(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 maxTokensToSend,\\n        uint256 repaymentChainId,\\n        uint256 originChainId,\\n        uint64 realizedLpFeePct,\\n        uint64 relayerFeePct,\\n        uint64 newRelayerFeePct,\\n        uint32 depositId,\\n        bytes memory depositorSignature\\n    ) public override nonReentrant {\\n        _verifyUpdateRelayerFeeMessage(depositor, originChainId, newRelayerFeePct, depositId, depositorSignature);\\n\\n        // Now follow the default fillRelay flow with the updated fee and the original relay hash.\\n        RelayData memory relayData = RelayData({\\n            depositor: depositor,\\n            recipient: recipient,\\n            destinationToken: destinationToken,\\n            amount: amount,\\n            realizedLpFeePct: realizedLpFeePct,\\n            relayerFeePct: relayerFeePct,\\n            depositId: depositId,\\n            originChainId: originChainId\\n        });\\n        bytes32 relayHash = _getRelayHash(relayData);\\n        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, maxTokensToSend, newRelayerFeePct, false);\\n\\n        _emitFillRelay(relayHash, fillAmountPreFees, repaymentChainId, newRelayerFeePct, relayData);\\n    }\\n\\n    /**************************************\\n     *         DATA WORKER FUNCTIONS      *\\n     **************************************/\\n\\n    /**\\n     * @notice Executes a slow relay leaf stored as part of a root bundle. Will send the full amount remaining in the\\n     * relay to the recipient, less fees.\\n     * @param depositor Depositor on origin chain who set this chain as the destination chain.\\n     * @param recipient Specified recipient on this chain.\\n     * @param destinationToken Token to send to recipient. Should be mapped to the origin token, origin chain ID\\n     * and this chain ID via a mapping on the HubPool.\\n     * @param amount Full size of the deposit.\\n     * @param originChainId Chain of SpokePool where deposit originated.\\n     * @param realizedLpFeePct Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on\\n     * quote time.\\n     * @param relayerFeePct Original fee % to keep as relayer set by depositor.\\n     * @param depositId Unique deposit ID on origin spoke pool.\\n     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.\\n     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.\\n     */\\n    function executeSlowRelayRoot(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 originChainId,\\n        uint64 realizedLpFeePct,\\n        uint64 relayerFeePct,\\n        uint32 depositId,\\n        uint32 rootBundleId,\\n        bytes32[] memory proof\\n    ) public virtual override nonReentrant {\\n        _executeSlowRelayRoot(\\n            depositor,\\n            recipient,\\n            destinationToken,\\n            amount,\\n            originChainId,\\n            realizedLpFeePct,\\n            relayerFeePct,\\n            depositId,\\n            rootBundleId,\\n            proof\\n        );\\n    }\\n\\n    /**\\n     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they\\n     * sent to the recipient plus a relayer fee.\\n     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.\\n     * @param relayerRefundLeaf Contains all data neccessary to reconstruct leaf contained in root bundle and to\\n     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.\\n     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.\\n     */\\n    function executeRelayerRefundRoot(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) public virtual override nonReentrant {\\n        _executeRelayerRefundRoot(rootBundleId, relayerRefundLeaf, proof);\\n    }\\n\\n    /**************************************\\n     *           VIEW FUNCTIONS           *\\n     **************************************/\\n\\n    /**\\n     * @notice Returns chain ID for this network.\\n     * @dev Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this.\\n     */\\n    function chainId() public view override returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    /**************************************\\n     *         INTERNAL FUNCTIONS         *\\n     **************************************/\\n\\n    // Verifies inclusion proof of leaf in root, sends relayer their refund, and sends to HubPool any rebalance\\n    // transfers.\\n    function _executeRelayerRefundRoot(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) internal {\\n        // Check integrity of leaf structure:\\n        require(relayerRefundLeaf.chainId == chainId(), \\\"Invalid chainId\\\");\\n        require(relayerRefundLeaf.refundAddresses.length == relayerRefundLeaf.refundAmounts.length, \\\"invalid leaf\\\");\\n\\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\\n\\n        // Check that inclusionProof proves that relayerRefundLeaf is contained within the relayer refund root.\\n        // Note: This should revert if the relayerRefundRoot is uninitialized.\\n        require(MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof), \\\"Bad Proof\\\");\\n\\n        // Verify the leafId in the leaf has not yet been claimed.\\n        require(!MerkleLib.isClaimed(rootBundle.claimedBitmap, relayerRefundLeaf.leafId), \\\"Already claimed\\\");\\n\\n        // Set leaf as claimed in bitmap. This is passed by reference to the storage rootBundle.\\n        MerkleLib.setClaimed(rootBundle.claimedBitmap, relayerRefundLeaf.leafId);\\n\\n        // Send each relayer refund address the associated refundAmount for the L2 token address.\\n        // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.\\n        for (uint32 i = 0; i < relayerRefundLeaf.refundAmounts.length; i++) {\\n            uint256 amount = relayerRefundLeaf.refundAmounts[i];\\n            if (amount > 0)\\n                IERC20(relayerRefundLeaf.l2TokenAddress).safeTransfer(relayerRefundLeaf.refundAddresses[i], amount);\\n        }\\n\\n        // If leaf's amountToReturn is positive, then send L2 --> L1 message to bridge tokens back via\\n        // chain-specific bridging method.\\n        if (relayerRefundLeaf.amountToReturn > 0) {\\n            _bridgeTokensToHubPool(relayerRefundLeaf);\\n\\n            emit TokensBridged(\\n                relayerRefundLeaf.amountToReturn,\\n                relayerRefundLeaf.chainId,\\n                relayerRefundLeaf.leafId,\\n                relayerRefundLeaf.l2TokenAddress,\\n                msg.sender\\n            );\\n        }\\n\\n        emit ExecutedRelayerRefundRoot(\\n            relayerRefundLeaf.amountToReturn,\\n            relayerRefundLeaf.chainId,\\n            relayerRefundLeaf.refundAmounts,\\n            rootBundleId,\\n            relayerRefundLeaf.leafId,\\n            relayerRefundLeaf.l2TokenAddress,\\n            relayerRefundLeaf.refundAddresses,\\n            msg.sender\\n        );\\n    }\\n\\n    // Verifies inclusion proof of leaf in root and sends recipient remainder of relay. Marks relay as filled.\\n    function _executeSlowRelayRoot(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 originChainId,\\n        uint64 realizedLpFeePct,\\n        uint64 relayerFeePct,\\n        uint32 depositId,\\n        uint32 rootBundleId,\\n        bytes32[] memory proof\\n    ) internal {\\n        RelayData memory relayData = RelayData({\\n            depositor: depositor,\\n            recipient: recipient,\\n            destinationToken: destinationToken,\\n            amount: amount,\\n            originChainId: originChainId,\\n            realizedLpFeePct: realizedLpFeePct,\\n            relayerFeePct: relayerFeePct,\\n            depositId: depositId\\n        });\\n\\n        require(\\n            MerkleLib.verifySlowRelayFulfillment(rootBundles[rootBundleId].slowRelayRoot, relayData, proof),\\n            \\\"Invalid proof\\\"\\n        );\\n\\n        bytes32 relayHash = _getRelayHash(relayData);\\n\\n        // Note: use relayAmount as the max amount to send, so the relay is always completely filled by the contract's\\n        // funds in all cases.\\n        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, relayData.amount, relayerFeePct, true);\\n\\n        _emitExecutedSlowRelayRoot(relayHash, fillAmountPreFees, relayData);\\n    }\\n\\n    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {\\n        require(newCrossDomainAdmin != address(0), \\\"Bad bridge router address\\\");\\n        crossDomainAdmin = newCrossDomainAdmin;\\n        emit SetXDomainAdmin(crossDomainAdmin);\\n    }\\n\\n    function _setHubPool(address newHubPool) internal {\\n        require(newHubPool != address(0), \\\"Bad hub pool address\\\");\\n        hubPool = newHubPool;\\n        emit SetHubPool(hubPool);\\n    }\\n\\n    // Should be overriden by implementing contract depending on how L2 handles sending tokens to L1.\\n    function _bridgeTokensToHubPool(SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf) internal virtual;\\n\\n    function _verifyUpdateRelayerFeeMessage(\\n        address depositor,\\n        uint256 originChainId,\\n        uint64 newRelayerFeePct,\\n        uint32 depositId,\\n        bytes memory depositorSignature\\n    ) internal view {\\n        // A depositor can request to speed up an un-relayed deposit by signing a hash containing the relayer\\n        // fee % to update to and information uniquely identifying the deposit to relay. This information ensures\\n        // that this signature cannot be re-used for other deposits. The version string is included as a precaution\\n        // in case this contract is upgraded.\\n        // Note: we use encode instead of encodePacked because it is more secure, more in the \\\"warning\\\" section\\n        // here: https://docs.soliditylang.org/en/v0.8.11/abi-spec.html#non-standard-packed-mode\\n        bytes32 expectedDepositorMessageHash = keccak256(\\n            abi.encode(\\\"ACROSS-V2-FEE-1.0\\\", newRelayerFeePct, depositId, originChainId)\\n        );\\n\\n        // Check the hash corresponding to the https://eth.wiki/json-rpc/API#eth_sign[eth_sign]\\n        // JSON-RPC method as part of EIP-191. We use OZ's signature checker library which adds support for\\n        // EIP-1271 which can verify messages signed by smart contract wallets like Argent and Gnosis safes.\\n        // If the depositor signed a message with a different updated fee (or any other param included in the\\n        // above keccak156 hash), then this will revert.\\n        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(expectedDepositorMessageHash);\\n\\n        _verifyDepositorUpdateFeeMessage(depositor, ethSignedMessageHash, depositorSignature);\\n    }\\n\\n    // This function is isolated and made virtual to allow different L2's to implement chain specific recovery of\\n    // signers from signatures because some L2s might not support ecrecover, such as those with account abstraction\\n    // like ZKSync.\\n    function _verifyDepositorUpdateFeeMessage(\\n        address depositor,\\n        bytes32 ethSignedMessageHash,\\n        bytes memory depositorSignature\\n    ) internal view virtual {\\n        // Note: no need to worry about reentrancy from contract deployed at depositor address since\\n        // SignatureChecker.isValidSignatureNow is a non state-modifying STATICCALL:\\n        // - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/63b466901fb015538913f811c5112a2775042177/contracts/utils/cryptography/SignatureChecker.sol#L35\\n        // - https://github.com/ethereum/EIPs/pull/214\\n        require(\\n            SignatureChecker.isValidSignatureNow(depositor, ethSignedMessageHash, depositorSignature),\\n            \\\"invalid signature\\\"\\n        );\\n    }\\n\\n    function _computeAmountPreFees(uint256 amount, uint64 feesPct) private pure returns (uint256) {\\n        return (1e18 * amount) / (1e18 - feesPct);\\n    }\\n\\n    function _computeAmountPostFees(uint256 amount, uint64 feesPct) private pure returns (uint256) {\\n        return (amount * (1e18 - feesPct)) / 1e18;\\n    }\\n\\n    function _getRelayHash(SpokePoolInterface.RelayData memory relayData) private pure returns (bytes32) {\\n        return keccak256(abi.encode(relayData));\\n    }\\n\\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends WETH.\\n    function _unwrapWETHTo(address payable to, uint256 amount) internal {\\n        if (address(to).isContract()) {\\n            IERC20(address(weth)).safeTransfer(to, amount);\\n        } else {\\n            weth.withdraw(amount);\\n            to.transfer(amount);\\n        }\\n    }\\n\\n    // @notice Caller specifies the max amount of tokens to send to user. Based on this amount and the amount of the\\n    // relay remaining (as stored in the relayFills mapping), pull the amount of tokens from the caller ancillaryData\\n    // and send to the caller.\\n    // @dev relayFills keeps track of pre-fee fill amounts as a convenience to relayers who want to specify round\\n    // numbers for the maxTokensToSend parameter or convenient numbers like 100 (i.e. relayers who will fully\\n    // fill any relay up to 100 tokens, and partial fill with 100 tokens for larger relays).\\n    function _fillRelay(\\n        bytes32 relayHash,\\n        RelayData memory relayData,\\n        uint256 maxTokensToSend,\\n        uint64 updatableRelayerFeePct,\\n        bool useContractFunds\\n    ) internal returns (uint256 fillAmountPreFees) {\\n        // We limit the relay fees to prevent the user spending all their funds on fees. Note that 0.5e18 (i.e. 50%)\\n        // fees are just magic numbers. The important point is to prevent the total fee from being 100%, otherwise\\n        // computing the amount pre fees runs into divide-by-0 issues.\\n        require(updatableRelayerFeePct < 0.5e18 && relayData.realizedLpFeePct < 0.5e18, \\\"invalid fees\\\");\\n\\n        // Check that the relay has not already been completely filled. Note that the relays mapping will point to\\n        // the amount filled so far for a particular relayHash, so this will start at 0 and increment with each fill.\\n        require(relayFills[relayHash] < relayData.amount, \\\"relay filled\\\");\\n\\n        // Stores the equivalent amount to be sent by the relayer before fees have been taken out.\\n        if (maxTokensToSend == 0) return 0;\\n\\n        // Derive the amount of the relay filled if the caller wants to send exactly maxTokensToSend tokens to\\n        // the recipient. For example, if the user wants to send 10 tokens to the recipient, the full relay amount\\n        // is 100, and the fee %'s total 5%, then this computation would return ~10.5, meaning that to fill 10.5/100\\n        // of the full relay size, the caller would need to send 10 tokens to the user.\\n        fillAmountPreFees = _computeAmountPreFees(\\n            maxTokensToSend,\\n            (relayData.realizedLpFeePct + updatableRelayerFeePct)\\n        );\\n        // If user's specified max amount to send is greater than the amount of the relay remaining pre-fees,\\n        // we'll pull exactly enough tokens to complete the relay.\\n        uint256 amountToSend = maxTokensToSend;\\n        uint256 amountRemainingInRelay = relayData.amount - relayFills[relayHash];\\n        if (amountRemainingInRelay < fillAmountPreFees) {\\n            fillAmountPreFees = amountRemainingInRelay;\\n\\n            // The user will fulfill the remainder of the relay, so we need to compute exactly how many tokens post-fees\\n            // that they need to send to the recipient.\\n            amountToSend = _computeAmountPostFees(\\n                fillAmountPreFees,\\n                relayData.realizedLpFeePct + updatableRelayerFeePct\\n            );\\n        }\\n\\n        // relayFills keeps track of pre-fee fill amounts as a convenience to relayers who want to specify round\\n        // numbers for the maxTokensToSend parameter or convenient numbers like 100 (i.e. relayers who will fully\\n        // fill any relay up to 100 tokens, and partial fill with 100 tokens for larger relays).\\n        relayFills[relayHash] += fillAmountPreFees;\\n\\n        // If relay token is weth then unwrap and send eth.\\n        if (relayData.destinationToken == address(weth)) {\\n            // Note: useContractFunds is True if we want to send funds to the recipient directly out of this contract,\\n            // otherwise we expect the caller to send funds to the recipient. If useContractFunds is True and the\\n            // recipient wants WETH, then we can assume that WETH is already in the contract, otherwise we'll need the\\n            // the user to send WETH to this contract. Regardless, we'll need to unwrap it before sending to the user.\\n            if (!useContractFunds)\\n                IERC20(relayData.destinationToken).safeTransferFrom(msg.sender, address(this), amountToSend);\\n            _unwrapWETHTo(payable(relayData.recipient), amountToSend);\\n            // Else, this is a normal ERC20 token. Send to recipient.\\n        } else {\\n            // Note: Similar to note above, send token directly from the contract to the user in the slow relay case.\\n            if (!useContractFunds)\\n                IERC20(relayData.destinationToken).safeTransferFrom(msg.sender, relayData.recipient, amountToSend);\\n            else IERC20(relayData.destinationToken).safeTransfer(relayData.recipient, amountToSend);\\n        }\\n    }\\n\\n    // The following internal methods emit events with many params to overcome solidity stack too deep issues.\\n    function _emitFillRelay(\\n        bytes32 relayHash,\\n        uint256 fillAmount,\\n        uint256 repaymentChainId,\\n        uint64 relayerFeePct,\\n        RelayData memory relayData\\n    ) internal {\\n        emit FilledRelay(\\n            relayHash,\\n            relayData.amount,\\n            relayFills[relayHash],\\n            fillAmount,\\n            repaymentChainId,\\n            relayData.originChainId,\\n            relayerFeePct,\\n            relayData.realizedLpFeePct,\\n            relayData.depositId,\\n            relayData.destinationToken,\\n            msg.sender,\\n            relayData.depositor,\\n            relayData.recipient\\n        );\\n    }\\n\\n    function _emitExecutedSlowRelayRoot(\\n        bytes32 relayHash,\\n        uint256 fillAmount,\\n        RelayData memory relayData\\n    ) internal {\\n        emit ExecutedSlowRelayRoot(\\n            relayHash,\\n            relayData.amount,\\n            relayFills[relayHash],\\n            fillAmount,\\n            relayData.originChainId,\\n            relayData.relayerFeePct,\\n            relayData.realizedLpFeePct,\\n            relayData.depositId,\\n            relayData.destinationToken,\\n            msg.sender,\\n            relayData.depositor,\\n            relayData.recipient\\n        );\\n    }\\n\\n    // Implementing contract needs to override this to ensure that only the appropriate cross chain admin can execute\\n    // certain admin functions. For L2 contracts, the cross chain admin refers to some L1 address or contract, and for\\n    // L1, this would just be the same admin of the HubPool.\\n    function _requireAdminSender() internal virtual;\\n\\n    // Added to enable the this contract to receive ETH. Used when unwrapping Weth.\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x137c07e512cb744003d95dc1d0856cb2c2dad0b8e38d964a5a5d847e937db33e\",\"license\":\"GPL-3.0-only\"},\"contracts/SpokePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Contains common data structures and functions used by all SpokePool implementations.\\n */\\ninterface SpokePoolInterface {\\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\\n    struct RelayerRefundLeaf {\\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that is\\n        // negative. This is just that value inverted.\\n        uint256 amountToReturn;\\n        // Used to verify that this is being executed on the correct destination chainId.\\n        uint256 chainId;\\n        // This array designates how much each of those addresses should be refunded.\\n        uint256[] refundAmounts;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint32 leafId;\\n        // The associated L2TokenAddress that these claims apply to.\\n        address l2TokenAddress;\\n        // Must be same length as refundAmounts and designates each address that must be refunded.\\n        address[] refundAddresses;\\n    }\\n\\n    // This struct represents the data to fully specify a relay. If any portion of this data differs, the relay is\\n    // considered to be completely distinct. Only one relay for a particular depositId, chainId pair should be\\n    // considered valid and repaid. This data is hashed and inserted into a the slow relay merkle root so that an off\\n    // chain validator can choose when to refund slow relayers.\\n    struct RelayData {\\n        // The address that made the deposit on the origin chain.\\n        address depositor;\\n        // The recipient address on the destination chain.\\n        address recipient;\\n        // The corresponding token address on the destination chain.\\n        address destinationToken;\\n        // The total relay amount before fees are taken out.\\n        uint256 amount;\\n        // Origin chain id.\\n        uint256 originChainId;\\n        // The LP Fee percentage computed by the relayer based on the deposit's quote timestamp\\n        // and the HubPool's utilization.\\n        uint64 realizedLpFeePct;\\n        // The relayer fee percentage specified in the deposit.\\n        uint64 relayerFeePct;\\n        // The id uniquely identifying this deposit on the origin chain.\\n        uint32 depositId;\\n    }\\n\\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\\n\\n    function setHubPool(address newHubPool) external;\\n\\n    function setEnableRoute(\\n        address originToken,\\n        uint256 destinationChainId,\\n        bool enable\\n    ) external;\\n\\n    function setDepositQuoteTimeBuffer(uint32 buffer) external;\\n\\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\\n\\n    function deposit(\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        uint64 relayerFeePct,\\n        uint32 quoteTimestamp\\n    ) external payable;\\n\\n    function speedUpDeposit(\\n        address depositor,\\n        uint64 newRelayerFeePct,\\n        uint32 depositId,\\n        bytes memory depositorSignature\\n    ) external;\\n\\n    function fillRelay(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 maxTokensToSend,\\n        uint256 repaymentChainId,\\n        uint256 originChainId,\\n        uint64 realizedLpFeePct,\\n        uint64 relayerFeePct,\\n        uint32 depositId\\n    ) external;\\n\\n    function fillRelayWithUpdatedFee(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 maxTokensToSend,\\n        uint256 repaymentChainId,\\n        uint256 originChainId,\\n        uint64 realizedLpFeePct,\\n        uint64 relayerFeePct,\\n        uint64 newRelayerFeePct,\\n        uint32 depositId,\\n        bytes memory depositorSignature\\n    ) external;\\n\\n    function executeSlowRelayRoot(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 originChainId,\\n        uint64 realizedLpFeePct,\\n        uint64 relayerFeePct,\\n        uint32 depositId,\\n        uint32 rootBundleId,\\n        bytes32[] memory proof\\n    ) external;\\n\\n    function executeRelayerRefundRoot(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) external;\\n\\n    function chainId() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x33257e146b1f3aecadcefded630c6a8d1308518d1992d84b963a734745ab96a5\",\"license\":\"GPL-3.0-only\"},\"contracts/interfaces/AdapterInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\\n */\\n\\ninterface AdapterInterface {\\n    event HubPoolChanged(address newHubPool);\\n\\n    event MessageRelayed(address target, bytes message);\\n\\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\\n\\n    function relayMessage(address target, bytes memory message) external payable;\\n\\n    function relayTokens(\\n        address l1Token,\\n        address l2Token,\\n        uint256 amount,\\n        address to\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x60e1ed2205f90655fe4152a90709be15bc9550fb3faeaf9835fee22c095bab11\",\"license\":\"AGPL-3.0-only\"},\"contracts/interfaces/WETH9.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface WETH9 {\\n    function withdraw(uint256 wad) external;\\n\\n    function deposit() external payable;\\n\\n    function balanceOf(address guy) external view returns (uint256 wad);\\n\\n    function transfer(address guy, uint256 wad) external;\\n}\\n\",\"keccak256\":\"0x7b444d0840b1f76eee9bf39d74830f70644395613b96cce2d80fc50785a82eaa\",\"license\":\"GPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x60806040526004805463ffffffff60c01b1916604b60c31b179055600880546001600160c01b03191677deaddeaddeaddeaddeaddeaddeaddeaddead0000004c4b401790553480156200005157600080fd5b50604051620046573803806200465783398101604081905262000074916200033d565b600080546001600160a01b031916734200000000000000000000000000000000000007179055600180546001600160a81b0319166001600160a01b03831617600160a01b179055828273420000000000000000000000000000000000000683620000de846200013f565b620000e983620001e5565b620000f362000287565b600480546001600160a01b039094166001600160a01b031963ffffffff93909316600160a01b02929092166001600160c01b0319909416939093171790915550620003a1945050505050565b6001600160a01b0381166200019b5760405162461bcd60e51b815260206004820152601960248201527f4261642062726964676520726f7574657220616464726573730000000000000060448201526064015b60405180910390fd5b600280546001600160a01b0319166001600160a01b0383169081179091556040517fa9e8c42c9e7fca7f62755189a16b2f5314d43d8fb24e91ba54e6d65f9314e84990600090a250565b6001600160a01b0381166200023d5760405162461bcd60e51b815260206004820152601460248201527f4261642068756220706f6f6c2061646472657373000000000000000000000000604482015260640162000192565b600380546001600160a01b0319166001600160a01b0383169081179091556040517f1f17a88f67b0f49060a34bec1a4723a563620e6aa265eb640b5046dcee0759a090600090a250565b6001546000906001600160a01b0316156200031b57600160009054906101000a90046001600160a01b03166001600160a01b03166329cb924d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015620002f0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000316919062000387565b905090565b504290565b80516001600160a01b03811681146200033857600080fd5b919050565b6000806000606084860312156200035357600080fd5b6200035e8462000320565b92506200036e6020850162000320565b91506200037e6040850162000320565b90509250925092565b6000602082840312156200039a57600080fd5b5051919050565b6142a680620003b16000396000f3fe6080604052600436106101c65760003560e01c8063766e0703116100f7578063e190440211610095578063ee2a53f811610064578063ee2a53f8146105e5578063f06850f61461061a578063f500697c14610647578063ffc351a31461066757600080fd5b8063e19044021461052e578063e282d5b91461055b578063e32292111461057b578063ecda10f5146105b057600080fd5b8063a1244c67116100d1578063a1244c6714610491578063ac9650d8146104ce578063c894c0ca146104ee578063de7eba781461050e57600080fd5b8063766e07031461044157806389a153cc1461045e5780639a8a05921461047e57600080fd5b80633cb747bf11610164578063493a4f841161013e578063493a4f841461035b5780635249fef11461037b5780635285e058146103c657806357f6dcb8146103f357600080fd5b80633cb747bf146102ee5780633fc8cef31461031b578063492289781461034857600080fd5b806322f8e566116101a057806322f8e5661461026b578063272751c71461028b5780632752042e146102ab57806329cb924d146102cb57600080fd5b80630eaac9f0146101d25780631c39c38d146101f45780631dfb2d021461024b57600080fd5b366101cd57005b600080fd5b3480156101de57600080fd5b506101f26101ed366004613364565b610687565b005b34801561020057600080fd5b506001546102219073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b34801561025757600080fd5b506101f26102663660046133ac565b6106ee565b34801561027757600080fd5b506101f26102863660046133c9565b610702565b34801561029757600080fd5b506101f26102a63660046133f0565b6107ab565b3480156102b757600080fd5b506101f26102c6366004613364565b61084a565b3480156102d757600080fd5b506102e06108d9565b604051908152602001610242565b3480156102fa57600080fd5b506000546102219073ffffffffffffffffffffffffffffffffffffffff1681565b34801561032757600080fd5b506004546102219073ffffffffffffffffffffffffffffffffffffffff1681565b6101f261035636600461344a565b610995565b34801561036757600080fd5b506101f26103763660046134b4565b610e46565b34801561038757600080fd5b506103b66103963660046134d6565b600560209081526000928352604080842090915290825290205460ff1681565b6040519015158152602001610242565b3480156103d257600080fd5b506002546102219073ffffffffffffffffffffffffffffffffffffffff1681565b3480156103ff57600080fd5b5060045461042c907801000000000000000000000000000000000000000000000000900463ffffffff1681565b60405163ffffffff9091168152602001610242565b34801561044d57600080fd5b5060085461042c9063ffffffff1681565b34801561046a57600080fd5b506101f2610479366004613502565b610ef4565b34801561048a57600080fd5b50466102e0565b34801561049d57600080fd5b5060045461042c907c0100000000000000000000000000000000000000000000000000000000900463ffffffff1681565b6104e16104dc3660046135a6565b611042565b6040516102429190613691565b3480156104fa57600080fd5b506101f26105093660046138ab565b61121c565b34801561051a57600080fd5b506101f26105293660046133ac565b6112d5565b34801561053a57600080fd5b506003546102219073ffffffffffffffffffffffffffffffffffffffff1681565b34801561056757600080fd5b506101f2610576366004613a3e565b6112e6565b34801561058757600080fd5b5060085461022190640100000000900473ffffffffffffffffffffffffffffffffffffffff1681565b3480156105bc57600080fd5b5060045461042c9074010000000000000000000000000000000000000000900463ffffffff1681565b3480156105f157600080fd5b506106056106003660046133c9565b6113c9565b60408051928352602083019190915201610242565b34801561062657600080fd5b506102e06106353660046133c9565b60076020526000908152604090205481565b34801561065357600080fd5b506101f2610662366004613aaf565b6113f7565b34801561067357600080fd5b506101f2610682366004613b7c565b6114ad565b61068f61160a565b600880547fffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000001663ffffffff83169081179091556040517fe486a5c4bd7b36eabbfe274c99b39130277417be8d2209b4dae04c4fba64ee3a90600090a250565b6106f661160a565b6106ff81611843565b50565b60015473ffffffffffffffffffffffffffffffffffffffff1661072457600080fd5b6001546040517f22f8e5660000000000000000000000000000000000000000000000000000000081526004810183905273ffffffffffffffffffffffffffffffffffffffff909116906322f8e56690602401600060405180830381600087803b15801561079057600080fd5b505af11580156107a4573d6000803e3d6000fd5b5050505050565b6107b361160a565b73ffffffffffffffffffffffffffffffffffffffff8316600081815260056020908152604080832086845282529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001685151590811790915591519182528492917f0a21fdd43d0ad0c62689ee7230a47309a050755bcc52eba00310add65297692a91015b60405180910390a3505050565b61085261160a565b600480547fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff16780100000000000000000000000000000000000000000000000063ffffffff8416908102919091179091556040519081527f0e55dd180fa793d9036c804d0a116e6a7617a48e72cee1f83d92793a793fcc039060200160405180910390a150565b60015460009073ffffffffffffffffffffffffffffffffffffffff161561099057600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166329cb924d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610967573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061098b9190613c5a565b905090565b504290565b73ffffffffffffffffffffffffffffffffffffffff851660009081526005602090815260408083208684529091529020548590849060ff16610a38576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f44697361626c656420726f75746500000000000000000000000000000000000060448201526064015b60405180910390fd5b610a4061192f565b610a6d600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b6706f05b59d3b200008467ffffffffffffffff1610610ae8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f696e76616c69642072656c6179657220666565000000000000000000000000006044820152606401610a2f565b600454610b17907801000000000000000000000000000000000000000000000000900463ffffffff1684613ca2565b63ffffffff16610b256108d9565b10158015610b6e5750600454610b5d907801000000000000000000000000000000000000000000000000900463ffffffff1684613cc7565b63ffffffff16610b6b6108d9565b11155b610bd4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f696e76616c69642071756f74652074696d6500000000000000000000000000006044820152606401610a2f565b60045473ffffffffffffffffffffffffffffffffffffffff8881169116148015610bfe5750600034115b15610cf557853414610c6c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f6d73672e76616c7565206d757374206d6174636820616d6f756e7400000000006044820152606401610a2f565b60048054604080517fd0e30db0000000000000000000000000000000000000000000000000000000008152905173ffffffffffffffffffffffffffffffffffffffff9092169263d0e30db0923492808301926000929182900301818588803b158015610cd757600080fd5b505af1158015610ceb573d6000803e3d6000fd5b5050505050610d17565b610d1773ffffffffffffffffffffffffffffffffffffffff88163330896119b5565b600454604080518881526020810188905267ffffffffffffffff87168183015263ffffffff868116606083015273ffffffffffffffffffffffffffffffffffffffff8c8116608084015292513394938c16937c01000000000000000000000000000000000000000000000000000000009004909116917ffc53c5b967d467d4136291c639720626f3d6dda97b4364da813e6858ad48a721919081900360a00190a460016004601c8282829054906101000a900463ffffffff16610dda9190613cc7565b92506101000a81548163ffffffff021916908363ffffffff160217905550610e3c600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b5050505050505050565b610e4e61160a565b60068054600181018255600091909152600381027ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d4081018490557ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f01828155604080518581526020810185905263ffffffff8416917fc86ba04c55bc5eb2f2876b91c438849a296dbec7b08751c3074d92e04f0a77af910160405180910390a250505050565b610efc61192f565b610f29600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b60006040518061010001604052808c73ffffffffffffffffffffffffffffffffffffffff1681526020018b73ffffffffffffffffffffffffffffffffffffffff1681526020018a73ffffffffffffffffffffffffffffffffffffffff1681526020018981526020018681526020018567ffffffffffffffff1681526020018467ffffffffffffffff1681526020018363ffffffff1681525090506000610fce82611a91565b90506000610fe082848b886000611ac1565b9050610fef82828a8887611d4f565b505050611036600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b50505050505050505050565b606034156110ac576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f4f6e6c79206d756c746963616c6c207769746820302076616c756500000000006044820152606401610a2f565b8167ffffffffffffffff8111156110c5576110c5613711565b6040519080825280602002602001820160405280156110f857816020015b60608152602001906001900390816110e35790505b50905060005b82811015611215576000803086868581811061111c5761111c613cef565b905060200281019061112e9190613d1e565b60405161113c929190613d83565b600060405180830381855af49150503d8060008114611177576040519150601f19603f3d011682016040523d82523d6000602084013e61117c565b606091505b5091509150816111e25760448151101561119557600080fd5b600481019050808060200190518101906111af9190613d93565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a2f9190613e01565b808484815181106111f5576111f5613cef565b60200260200101819052505050808061120d90613e14565b9150506110fe565b5092915050565b61122461192f565b611251600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b600454608083015173ffffffffffffffffffffffffffffffffffffffff9081169116141561128157611281611e54565b61128c838383611ec5565b6112d0600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b505050565b6112dd61160a565b6106ff816122a1565b6112ee61192f565b61131b600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b611328844685858561238d565b8373ffffffffffffffffffffffffffffffffffffffff168263ffffffff167fb9de16bf376724405019a10ef4fedac57fecd292bf86c08d81d7c42d394d5d378584604051611377929190613e4d565b60405180910390a36113c3600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b50505050565b600681815481106113d957600080fd5b60009182526020909120600390910201805460019091015490915082565b6113ff61192f565b61142c600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b60045473ffffffffffffffffffffffffffffffffffffffff8981169116141561145757611457611e54565b6114698a8a8a8a8a8a8a8a8a8a61242a565b611036600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b6114b561192f565b6114e2600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b6114ef8c8785858561238d565b60006040518061010001604052808e73ffffffffffffffffffffffffffffffffffffffff1681526020018d73ffffffffffffffffffffffffffffffffffffffff1681526020018c73ffffffffffffffffffffffffffffffffffffffff1681526020018b81526020018881526020018767ffffffffffffffff1681526020018667ffffffffffffffff1681526020018463ffffffff168152509050600061159482611a91565b905060006115a682848d896000611ac1565b90506115b582828c8987611d4f565b5050506115fc600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b505050505050505050505050565b60025473ffffffffffffffffffffffffffffffffffffffff1661164260005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146116fc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f4f564d5f58434841494e3a206d657373656e67657220636f6e7472616374207560448201527f6e61757468656e746963617465640000000000000000000000000000000000006064820152608401610a2f565b8073ffffffffffffffffffffffffffffffffffffffff1661173260005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff16636e296e456040518163ffffffff1660e01b8152600401602060405180830381865afa15801561177c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117a09190613e70565b73ffffffffffffffffffffffffffffffffffffffff16146106ff576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4f564d5f58434841494e3a2077726f6e672073656e646572206f662063726f7360448201527f732d646f6d61696e206d657373616765000000000000000000000000000000006064820152608401610a2f565b73ffffffffffffffffffffffffffffffffffffffff81166118c0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4261642068756220706f6f6c20616464726573730000000000000000000000006044820152606401610a2f565b600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f1f17a88f67b0f49060a34bec1a4723a563620e6aa265eb640b5046dcee0759a090600090a250565b60015474010000000000000000000000000000000000000000900460ff166119b3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610a2f565b565b60405173ffffffffffffffffffffffffffffffffffffffff808516602483015283166044820152606481018290526113c39085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261259c565b600081604051602001611aa49190613e8d565b604051602081830303815290604052805190602001209050919050565b60006706f05b59d3b200008367ffffffffffffffff16108015611af957506706f05b59d3b200008560a0015167ffffffffffffffff16105b611b5f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f696e76616c6964206665657300000000000000000000000000000000000000006044820152606401610a2f565b606085015160008781526007602052604090205410611bda576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f72656c61792066696c6c656400000000000000000000000000000000000000006044820152606401610a2f565b83611be757506000611d46565b611c0084848760a00151611bfb9190613f19565b6126a8565b60008781526007602052604081205460608801519293508692611c239190613f3c565b905082811015611c4c57809250611c4983868960a00151611c449190613f19565b6126e9565b91505b60008881526007602052604081208054859290611c6a908490613f53565b9091555050600454604088015173ffffffffffffffffffffffffffffffffffffffff90811691161415611cd65783611cc3576040870151611cc39073ffffffffffffffffffffffffffffffffffffffff163330856119b5565b611cd1876020015183612712565b611d43565b83611d1057611cd1338860200151848a6040015173ffffffffffffffffffffffffffffffffffffffff166119b5909392919063ffffffff16565b611d43876020015183896040015173ffffffffffffffffffffffffffffffffffffffff1661281c9092919063ffffffff16565b50505b95945050505050565b3373ffffffffffffffffffffffffffffffffffffffff1683867f393f1765f382b5310a9186fa707a84040f8241b280a30b74112689a92a156f698460600151600760008b815260200190815260200160002054898760800151898960a001518a60e001518b604001518c600001518d60200151604051611e459a99989796959493929190998a5260208a01989098526040890196909652606088019490945267ffffffffffffffff9283166080880152911660a086015263ffffffff1660c085015273ffffffffffffffffffffffffffffffffffffffff90811660e0850152908116610100840152166101208201526101400190565b60405180910390a45050505050565b47156119b35760048054604080517fd0e30db0000000000000000000000000000000000000000000000000000000008152905173ffffffffffffffffffffffffffffffffffffffff9092169263d0e30db0924792808301926000929182900301818588803b15801561079057600080fd5b46826020015114611f32576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f496e76616c696420636861696e496400000000000000000000000000000000006044820152606401610a2f565b8160400151518260a001515114611fa5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f696e76616c6964206c65616600000000000000000000000000000000000000006044820152606401610a2f565b600060068463ffffffff1681548110611fc057611fc0613cef565b90600052602060002090600302019050611fdf81600101548484612872565b612045576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4261642050726f6f6600000000000000000000000000000000000000000000006044820152606401610a2f565b61205c81600201846060015163ffffffff166128ad565b156120c3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f416c726561647920636c61696d656400000000000000000000000000000000006044820152606401610a2f565b6120da81600201846060015163ffffffff166128ee565b60005b8360400151518163ffffffff16101561218657600084604001518263ffffffff168151811061210e5761210e613cef565b602002602001015190506000811115612173576121738560a001518363ffffffff168151811061214057612140613cef565b602002602001015182876080015173ffffffffffffffffffffffffffffffffffffffff1661281c9092919063ffffffff16565b508061217e81613f6b565b9150506120dd565b5082511561221f576121978361292c565b826080015173ffffffffffffffffffffffffffffffffffffffff16836060015163ffffffff1684602001517f828fc203220356df8f072a91681caee7d5c75095e2a95e80ed5a14b384697f7186600001513360405161221692919091825273ffffffffffffffffffffffffffffffffffffffff16602082015260400190565b60405180910390a45b3373ffffffffffffffffffffffffffffffffffffffff16836060015163ffffffff168563ffffffff167ff8bd640004bcec1b89657020f561d0b070cbdf662d0b158db9dccb0a8301bfab86600001518760200151886040015189608001518a60a00151604051612293959493929190614010565b60405180910390a450505050565b73ffffffffffffffffffffffffffffffffffffffff811661231e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4261642062726964676520726f757465722061646472657373000000000000006044820152606401610a2f565b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517fa9e8c42c9e7fca7f62755189a16b2f5314d43d8fb24e91ba54e6d65f9314e84990600090a250565b60408051608060208201819052601160a08301527f4143524f53532d56322d4645452d312e3000000000000000000000000000000060c083015267ffffffffffffffff86169282019290925263ffffffff8416606082015290810185905260009060e001604051602081830303815290604052805190602001209050600061241482612b43565b9050612421878285612b7e565b50505050505050565b60006040518061010001604052808c73ffffffffffffffffffffffffffffffffffffffff1681526020018b73ffffffffffffffffffffffffffffffffffffffff1681526020018a73ffffffffffffffffffffffffffffffffffffffff1681526020018981526020018881526020018767ffffffffffffffff1681526020018667ffffffffffffffff1681526020018563ffffffff1681525090506124f960068463ffffffff16815481106124e0576124e0613cef565b9060005260206000209060030201600001548284612bef565b61255f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f496e76616c69642070726f6f66000000000000000000000000000000000000006044820152606401610a2f565b600061256a82611a91565b90506000612580828485606001518a6001611ac1565b905061258d828285612c07565b50505050505050505050505050565b60006125fe826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff16612d009092919063ffffffff16565b8051909150156112d0578080602001905181019061261c919061405d565b6112d0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610a2f565b60006126bc82670de0b6b3a764000061407a565b67ffffffffffffffff166126d884670de0b6b3a764000061409b565b6126e29190614107565b9392505050565b6000670de0b6b3a76400006126fe838261407a565b6126d89067ffffffffffffffff168561409b565b73ffffffffffffffffffffffffffffffffffffffff82163b15612757576004546127539073ffffffffffffffffffffffffffffffffffffffff16838361281c565b5050565b600480546040517f2e1a7d4d00000000000000000000000000000000000000000000000000000000815291820183905273ffffffffffffffffffffffffffffffffffffffff1690632e1a7d4d90602401600060405180830381600087803b1580156127c157600080fd5b505af11580156127d5573d6000803e3d6000fd5b505060405173ffffffffffffffffffffffffffffffffffffffff8516925083156108fc02915083906000818181858888f193505050501580156112d0573d6000803e3d6000fd5b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526112d09084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401611a0f565b60006128a582858560405160200161288a919061411b565b60405160208183030381529060405280519060200120612d0f565b949350505050565b6000806128bc61010084614107565b905060006128cc610100856141b6565b6000928352602095909552506040902054600190931b92831690921492915050565b60006128fc61010083614107565b9050600061290c610100846141b6565b600092835260209490945250604090208054600190931b90921790915550565b600454608082015173ffffffffffffffffffffffffffffffffffffffff90811691161415612a0957608081015181516040517f2e1a7d4d00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff90921691632e1a7d4d916129b09160040190815260200190565b600060405180830381600087803b1580156129ca57600080fd5b505af11580156129de573d6000803e3d6000fd5b5050600854640100000000900473ffffffffffffffffffffffffffffffffffffffff16608084015250505b608081015160035482516008546040517fa3a7954800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9485166004820152939092166024840152604483015263ffffffff16606482015260a06084820152600060a48201527342000000000000000000000000000000000000109063a3a795489060c401600060405180830381600087803b158015612ab957600080fd5b505af1158015612acd573d6000803e3d6000fd5b50505050608081015160035482516008546040805173ffffffffffffffffffffffffffffffffffffffff9485168152602081019390935263ffffffff909116908201529116907f46b77e3c29797b94890fd3438da74f697480742358a3e26b9d13a227f1ac0ac99060600160405180910390a250565b6040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01611aa4565b612b89838383612d25565b6112d0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f696e76616c6964207369676e61747572650000000000000000000000000000006044820152606401610a2f565b60006128a582858560405160200161288a9190613e8d565b3373ffffffffffffffffffffffffffffffffffffffff16837fac5d07bd4046afd057f85211a1bec5e4dc2dc43d537b20d9dfcef5ce596215e6836060015160076000888152602001908152602001600020548686608001518760c001518860a001518960e001518a604001518b600001518c6020015160405161083d9a99989796959493929190998a5260208a01989098526040890196909652606088019490945267ffffffffffffffff9283166080880152911660a086015263ffffffff1660c085015273ffffffffffffffffffffffffffffffffffffffff90811660e0850152908116610100840152166101208201526101400190565b60606128a58484600085612f14565b600082612d1c85846130aa565b14949350505050565b6000806000612d34858561311e565b90925090506000816004811115612d4d57612d4d6141ca565b148015612d8557508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b15612d95576001925050506126e2565b6000808773ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8888604051602401612dca9291906141f9565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051612e539190614212565b600060405180830381855afa9150503d8060008114612e8e576040519150601f19603f3d011682016040523d82523d6000602084013e612e93565b606091505b5091509150818015612ea6575080516020145b8015612f08575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090612ee4908301602090810190840161422e565b7fffffffff0000000000000000000000000000000000000000000000000000000016145b98975050505050505050565b606082471015612fa6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401610a2f565b73ffffffffffffffffffffffffffffffffffffffff85163b613024576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610a2f565b6000808673ffffffffffffffffffffffffffffffffffffffff16858760405161304d9190614212565b60006040518083038185875af1925050503d806000811461308a576040519150601f19603f3d011682016040523d82523d6000602084013e61308f565b606091505b509150915061309f82828661318e565b979650505050505050565b600081815b84518110156131165760008582815181106130cc576130cc613cef565b602002602001015190508083116130f25760008381526020829052604090209250613103565b600081815260208490526040902092505b508061310e81613e14565b9150506130af565b509392505050565b6000808251604114156131555760208301516040840151606085015160001a613149878285856131e1565b94509450505050613187565b82516040141561317f57602083015160408401516131748683836132f9565b935093505050613187565b506000905060025b9250929050565b6060831561319d5750816126e2565b8251156131ad5782518084602001fd5b816040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a2f9190613e01565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561321857506000905060036132f0565b8460ff16601b1415801561323057508460ff16601c14155b1561324157506000905060046132f0565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015613295573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff81166132e9576000600192509250506132f0565b9150600090505b94509492505050565b6000807f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83168161332f60ff86901c601b613f53565b905061333d878288856131e1565b935093505050935093915050565b803563ffffffff8116811461335f57600080fd5b919050565b60006020828403121561337657600080fd5b6126e28261334b565b73ffffffffffffffffffffffffffffffffffffffff811681146106ff57600080fd5b803561335f8161337f565b6000602082840312156133be57600080fd5b81356126e28161337f565b6000602082840312156133db57600080fd5b5035919050565b80151581146106ff57600080fd5b60008060006060848603121561340557600080fd5b83356134108161337f565b9250602084013591506040840135613427816133e2565b809150509250925092565b803567ffffffffffffffff8116811461335f57600080fd5b60008060008060008060c0878903121561346357600080fd5b863561346e8161337f565b9550602087013561347e8161337f565b9450604087013593506060870135925061349a60808801613432565b91506134a860a0880161334b565b90509295509295509295565b600080604083850312156134c757600080fd5b50508035926020909101359150565b600080604083850312156134e957600080fd5b82356134f48161337f565b946020939093013593505050565b6000806000806000806000806000806101408b8d03121561352257600080fd5b8a3561352d8161337f565b995060208b013561353d8161337f565b985060408b013561354d8161337f565b975060608b0135965060808b0135955060a08b0135945060c08b0135935061357760e08c01613432565b92506135866101008c01613432565b91506135956101208c0161334b565b90509295989b9194979a5092959850565b600080602083850312156135b957600080fd5b823567ffffffffffffffff808211156135d157600080fd5b818501915085601f8301126135e557600080fd5b8135818111156135f457600080fd5b8660208260051b850101111561360957600080fd5b60209290920196919550909350505050565b60005b8381101561363657818101518382015260200161361e565b838111156113c35750506000910152565b6000815180845261365f81602086016020860161361b565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015613704577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08886030184526136f2858351613647565b945092850192908501906001016136b8565b5092979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160c0810167ffffffffffffffff8111828210171561376357613763613711565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156137b0576137b0613711565b604052919050565b600067ffffffffffffffff8211156137d2576137d2613711565b5060051b60200190565b600082601f8301126137ed57600080fd5b813560206138026137fd836137b8565b613769565b82815260059290921b8401810191818101908684111561382157600080fd5b8286015b8481101561383c5780358352918301918301613825565b509695505050505050565b600082601f83011261385857600080fd5b813560206138686137fd836137b8565b82815260059290921b8401810191818101908684111561388757600080fd5b8286015b8481101561383c57803561389e8161337f565b835291830191830161388b565b6000806000606084860312156138c057600080fd5b6138c98461334b565b9250602084013567ffffffffffffffff808211156138e657600080fd5b9085019060c082880312156138fa57600080fd5b613902613740565b823581526020830135602082015260408301358281111561392257600080fd5b61392e898286016137dc565b6040830152506139406060840161334b565b6060820152613951608084016133a1565b608082015260a08301358281111561396857600080fd5b61397489828601613847565b60a0830152509350604086013591508082111561399057600080fd5b5061399d868287016137dc565b9150509250925092565b600067ffffffffffffffff8211156139c1576139c1613711565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f8301126139fe57600080fd5b8135613a0c6137fd826139a7565b818152846020838601011115613a2157600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215613a5457600080fd5b8435613a5f8161337f565b9350613a6d60208601613432565b9250613a7b6040860161334b565b9150606085013567ffffffffffffffff811115613a9757600080fd5b613aa3878288016139ed565b91505092959194509250565b6000806000806000806000806000806101408b8d031215613acf57600080fd5b8a35613ada8161337f565b995060208b0135613aea8161337f565b985060408b0135613afa8161337f565b975060608b0135965060808b01359550613b1660a08c01613432565b9450613b2460c08c01613432565b9350613b3260e08c0161334b565b9250613b416101008c0161334b565b91506101208b013567ffffffffffffffff811115613b5e57600080fd5b613b6a8d828e016137dc565b9150509295989b9194979a5092959850565b6000806000806000806000806000806000806101808d8f031215613b9f57600080fd5b613ba88d6133a1565b9b50613bb660208e016133a1565b9a50613bc460408e016133a1565b995060608d0135985060808d0135975060a08d0135965060c08d01359550613bee60e08e01613432565b9450613bfd6101008e01613432565b9350613c0c6101208e01613432565b9250613c1b6101408e0161334b565b915067ffffffffffffffff6101608e01351115613c3757600080fd5b613c488e6101608f01358f016139ed565b90509295989b509295989b509295989b565b600060208284031215613c6c57600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600063ffffffff83811690831681811015613cbf57613cbf613c73565b039392505050565b600063ffffffff808316818516808303821115613ce657613ce6613c73565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613d5357600080fd5b83018035915067ffffffffffffffff821115613d6e57600080fd5b60200191503681900382131561318757600080fd5b8183823760009101908152919050565b600060208284031215613da557600080fd5b815167ffffffffffffffff811115613dbc57600080fd5b8201601f81018413613dcd57600080fd5b8051613ddb6137fd826139a7565b818152856020838501011115613df057600080fd5b611d4682602083016020860161361b565b6020815260006126e26020830184613647565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415613e4657613e46613c73565b5060010190565b67ffffffffffffffff831681526040602082015260006128a56040830184613647565b600060208284031215613e8257600080fd5b81516126e28161337f565b60006101008201905073ffffffffffffffffffffffffffffffffffffffff80845116835280602085015116602084015280604085015116604084015250606083015160608301526080830151608083015260a083015167ffffffffffffffff80821660a08501528060c08601511660c0850152505060e083015161121560e084018263ffffffff169052565b600067ffffffffffffffff808316818516808303821115613ce657613ce6613c73565b600082821015613f4e57613f4e613c73565b500390565b60008219821115613f6657613f66613c73565b500190565b600063ffffffff80831681811415613f8557613f85613c73565b6001019392505050565b600081518084526020808501945080840160005b83811015613fbf57815187529582019590820190600101613fa3565b509495945050505050565b600081518084526020808501945080840160005b83811015613fbf57815173ffffffffffffffffffffffffffffffffffffffff1687529582019590820190600101613fde565b85815284602082015260a06040820152600061402f60a0830186613f8f565b73ffffffffffffffffffffffffffffffffffffffff851660608401528281036080840152612f088185613fca565b60006020828403121561406f57600080fd5b81516126e2816133e2565b600067ffffffffffffffff83811690831681811015613cbf57613cbf613c73565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156140d3576140d3613c73565b500290565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082614116576141166140d8565b500490565b6020815281516020820152602082015160408201526000604083015160c0606084015261414b60e0840182613f8f565b905063ffffffff606085015116608084015273ffffffffffffffffffffffffffffffffffffffff60808501511660a084015260a08401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08483030160c0850152611d468282613fca565b6000826141c5576141c56140d8565b500690565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8281526040602082015260006128a56040830184613647565b6000825161422481846020870161361b565b9190910192915050565b60006020828403121561424057600080fd5b81517fffffffff00000000000000000000000000000000000000000000000000000000811681146126e257600080fdfea2646970667358221220bc43612fcdf1f2cafe850f1d34a162c0683ff96afabb66afdc083b86b56f83e264736f6c634300080b0033",
  "deployedBytecode": "0x6080604052600436106101c65760003560e01c8063766e0703116100f7578063e190440211610095578063ee2a53f811610064578063ee2a53f8146105e5578063f06850f61461061a578063f500697c14610647578063ffc351a31461066757600080fd5b8063e19044021461052e578063e282d5b91461055b578063e32292111461057b578063ecda10f5146105b057600080fd5b8063a1244c67116100d1578063a1244c6714610491578063ac9650d8146104ce578063c894c0ca146104ee578063de7eba781461050e57600080fd5b8063766e07031461044157806389a153cc1461045e5780639a8a05921461047e57600080fd5b80633cb747bf11610164578063493a4f841161013e578063493a4f841461035b5780635249fef11461037b5780635285e058146103c657806357f6dcb8146103f357600080fd5b80633cb747bf146102ee5780633fc8cef31461031b578063492289781461034857600080fd5b806322f8e566116101a057806322f8e5661461026b578063272751c71461028b5780632752042e146102ab57806329cb924d146102cb57600080fd5b80630eaac9f0146101d25780631c39c38d146101f45780631dfb2d021461024b57600080fd5b366101cd57005b600080fd5b3480156101de57600080fd5b506101f26101ed366004613364565b610687565b005b34801561020057600080fd5b506001546102219073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b34801561025757600080fd5b506101f26102663660046133ac565b6106ee565b34801561027757600080fd5b506101f26102863660046133c9565b610702565b34801561029757600080fd5b506101f26102a63660046133f0565b6107ab565b3480156102b757600080fd5b506101f26102c6366004613364565b61084a565b3480156102d757600080fd5b506102e06108d9565b604051908152602001610242565b3480156102fa57600080fd5b506000546102219073ffffffffffffffffffffffffffffffffffffffff1681565b34801561032757600080fd5b506004546102219073ffffffffffffffffffffffffffffffffffffffff1681565b6101f261035636600461344a565b610995565b34801561036757600080fd5b506101f26103763660046134b4565b610e46565b34801561038757600080fd5b506103b66103963660046134d6565b600560209081526000928352604080842090915290825290205460ff1681565b6040519015158152602001610242565b3480156103d257600080fd5b506002546102219073ffffffffffffffffffffffffffffffffffffffff1681565b3480156103ff57600080fd5b5060045461042c907801000000000000000000000000000000000000000000000000900463ffffffff1681565b60405163ffffffff9091168152602001610242565b34801561044d57600080fd5b5060085461042c9063ffffffff1681565b34801561046a57600080fd5b506101f2610479366004613502565b610ef4565b34801561048a57600080fd5b50466102e0565b34801561049d57600080fd5b5060045461042c907c0100000000000000000000000000000000000000000000000000000000900463ffffffff1681565b6104e16104dc3660046135a6565b611042565b6040516102429190613691565b3480156104fa57600080fd5b506101f26105093660046138ab565b61121c565b34801561051a57600080fd5b506101f26105293660046133ac565b6112d5565b34801561053a57600080fd5b506003546102219073ffffffffffffffffffffffffffffffffffffffff1681565b34801561056757600080fd5b506101f2610576366004613a3e565b6112e6565b34801561058757600080fd5b5060085461022190640100000000900473ffffffffffffffffffffffffffffffffffffffff1681565b3480156105bc57600080fd5b5060045461042c9074010000000000000000000000000000000000000000900463ffffffff1681565b3480156105f157600080fd5b506106056106003660046133c9565b6113c9565b60408051928352602083019190915201610242565b34801561062657600080fd5b506102e06106353660046133c9565b60076020526000908152604090205481565b34801561065357600080fd5b506101f2610662366004613aaf565b6113f7565b34801561067357600080fd5b506101f2610682366004613b7c565b6114ad565b61068f61160a565b600880547fffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000001663ffffffff83169081179091556040517fe486a5c4bd7b36eabbfe274c99b39130277417be8d2209b4dae04c4fba64ee3a90600090a250565b6106f661160a565b6106ff81611843565b50565b60015473ffffffffffffffffffffffffffffffffffffffff1661072457600080fd5b6001546040517f22f8e5660000000000000000000000000000000000000000000000000000000081526004810183905273ffffffffffffffffffffffffffffffffffffffff909116906322f8e56690602401600060405180830381600087803b15801561079057600080fd5b505af11580156107a4573d6000803e3d6000fd5b5050505050565b6107b361160a565b73ffffffffffffffffffffffffffffffffffffffff8316600081815260056020908152604080832086845282529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001685151590811790915591519182528492917f0a21fdd43d0ad0c62689ee7230a47309a050755bcc52eba00310add65297692a91015b60405180910390a3505050565b61085261160a565b600480547fffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff16780100000000000000000000000000000000000000000000000063ffffffff8416908102919091179091556040519081527f0e55dd180fa793d9036c804d0a116e6a7617a48e72cee1f83d92793a793fcc039060200160405180910390a150565b60015460009073ffffffffffffffffffffffffffffffffffffffff161561099057600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166329cb924d6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610967573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061098b9190613c5a565b905090565b504290565b73ffffffffffffffffffffffffffffffffffffffff851660009081526005602090815260408083208684529091529020548590849060ff16610a38576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f44697361626c656420726f75746500000000000000000000000000000000000060448201526064015b60405180910390fd5b610a4061192f565b610a6d600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b6706f05b59d3b200008467ffffffffffffffff1610610ae8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f696e76616c69642072656c6179657220666565000000000000000000000000006044820152606401610a2f565b600454610b17907801000000000000000000000000000000000000000000000000900463ffffffff1684613ca2565b63ffffffff16610b256108d9565b10158015610b6e5750600454610b5d907801000000000000000000000000000000000000000000000000900463ffffffff1684613cc7565b63ffffffff16610b6b6108d9565b11155b610bd4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f696e76616c69642071756f74652074696d6500000000000000000000000000006044820152606401610a2f565b60045473ffffffffffffffffffffffffffffffffffffffff8881169116148015610bfe5750600034115b15610cf557853414610c6c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f6d73672e76616c7565206d757374206d6174636820616d6f756e7400000000006044820152606401610a2f565b60048054604080517fd0e30db0000000000000000000000000000000000000000000000000000000008152905173ffffffffffffffffffffffffffffffffffffffff9092169263d0e30db0923492808301926000929182900301818588803b158015610cd757600080fd5b505af1158015610ceb573d6000803e3d6000fd5b5050505050610d17565b610d1773ffffffffffffffffffffffffffffffffffffffff88163330896119b5565b600454604080518881526020810188905267ffffffffffffffff87168183015263ffffffff868116606083015273ffffffffffffffffffffffffffffffffffffffff8c8116608084015292513394938c16937c01000000000000000000000000000000000000000000000000000000009004909116917ffc53c5b967d467d4136291c639720626f3d6dda97b4364da813e6858ad48a721919081900360a00190a460016004601c8282829054906101000a900463ffffffff16610dda9190613cc7565b92506101000a81548163ffffffff021916908363ffffffff160217905550610e3c600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b5050505050505050565b610e4e61160a565b60068054600181018255600091909152600381027ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d4081018490557ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f01828155604080518581526020810185905263ffffffff8416917fc86ba04c55bc5eb2f2876b91c438849a296dbec7b08751c3074d92e04f0a77af910160405180910390a250505050565b610efc61192f565b610f29600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b60006040518061010001604052808c73ffffffffffffffffffffffffffffffffffffffff1681526020018b73ffffffffffffffffffffffffffffffffffffffff1681526020018a73ffffffffffffffffffffffffffffffffffffffff1681526020018981526020018681526020018567ffffffffffffffff1681526020018467ffffffffffffffff1681526020018363ffffffff1681525090506000610fce82611a91565b90506000610fe082848b886000611ac1565b9050610fef82828a8887611d4f565b505050611036600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b50505050505050505050565b606034156110ac576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f4f6e6c79206d756c746963616c6c207769746820302076616c756500000000006044820152606401610a2f565b8167ffffffffffffffff8111156110c5576110c5613711565b6040519080825280602002602001820160405280156110f857816020015b60608152602001906001900390816110e35790505b50905060005b82811015611215576000803086868581811061111c5761111c613cef565b905060200281019061112e9190613d1e565b60405161113c929190613d83565b600060405180830381855af49150503d8060008114611177576040519150601f19603f3d011682016040523d82523d6000602084013e61117c565b606091505b5091509150816111e25760448151101561119557600080fd5b600481019050808060200190518101906111af9190613d93565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a2f9190613e01565b808484815181106111f5576111f5613cef565b60200260200101819052505050808061120d90613e14565b9150506110fe565b5092915050565b61122461192f565b611251600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b600454608083015173ffffffffffffffffffffffffffffffffffffffff9081169116141561128157611281611e54565b61128c838383611ec5565b6112d0600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b505050565b6112dd61160a565b6106ff816122a1565b6112ee61192f565b61131b600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b611328844685858561238d565b8373ffffffffffffffffffffffffffffffffffffffff168263ffffffff167fb9de16bf376724405019a10ef4fedac57fecd292bf86c08d81d7c42d394d5d378584604051611377929190613e4d565b60405180910390a36113c3600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b50505050565b600681815481106113d957600080fd5b60009182526020909120600390910201805460019091015490915082565b6113ff61192f565b61142c600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b60045473ffffffffffffffffffffffffffffffffffffffff8981169116141561145757611457611e54565b6114698a8a8a8a8a8a8a8a8a8a61242a565b611036600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b6114b561192f565b6114e2600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff169055565b6114ef8c8785858561238d565b60006040518061010001604052808e73ffffffffffffffffffffffffffffffffffffffff1681526020018d73ffffffffffffffffffffffffffffffffffffffff1681526020018c73ffffffffffffffffffffffffffffffffffffffff1681526020018b81526020018881526020018767ffffffffffffffff1681526020018667ffffffffffffffff1681526020018463ffffffff168152509050600061159482611a91565b905060006115a682848d896000611ac1565b90506115b582828c8987611d4f565b5050506115fc600180547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1674010000000000000000000000000000000000000000179055565b505050505050505050505050565b60025473ffffffffffffffffffffffffffffffffffffffff1661164260005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146116fc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f4f564d5f58434841494e3a206d657373656e67657220636f6e7472616374207560448201527f6e61757468656e746963617465640000000000000000000000000000000000006064820152608401610a2f565b8073ffffffffffffffffffffffffffffffffffffffff1661173260005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff16636e296e456040518163ffffffff1660e01b8152600401602060405180830381865afa15801561177c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117a09190613e70565b73ffffffffffffffffffffffffffffffffffffffff16146106ff576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f4f564d5f58434841494e3a2077726f6e672073656e646572206f662063726f7360448201527f732d646f6d61696e206d657373616765000000000000000000000000000000006064820152608401610a2f565b73ffffffffffffffffffffffffffffffffffffffff81166118c0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4261642068756220706f6f6c20616464726573730000000000000000000000006044820152606401610a2f565b600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517f1f17a88f67b0f49060a34bec1a4723a563620e6aa265eb640b5046dcee0759a090600090a250565b60015474010000000000000000000000000000000000000000900460ff166119b3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610a2f565b565b60405173ffffffffffffffffffffffffffffffffffffffff808516602483015283166044820152606481018290526113c39085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261259c565b600081604051602001611aa49190613e8d565b604051602081830303815290604052805190602001209050919050565b60006706f05b59d3b200008367ffffffffffffffff16108015611af957506706f05b59d3b200008560a0015167ffffffffffffffff16105b611b5f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f696e76616c6964206665657300000000000000000000000000000000000000006044820152606401610a2f565b606085015160008781526007602052604090205410611bda576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f72656c61792066696c6c656400000000000000000000000000000000000000006044820152606401610a2f565b83611be757506000611d46565b611c0084848760a00151611bfb9190613f19565b6126a8565b60008781526007602052604081205460608801519293508692611c239190613f3c565b905082811015611c4c57809250611c4983868960a00151611c449190613f19565b6126e9565b91505b60008881526007602052604081208054859290611c6a908490613f53565b9091555050600454604088015173ffffffffffffffffffffffffffffffffffffffff90811691161415611cd65783611cc3576040870151611cc39073ffffffffffffffffffffffffffffffffffffffff163330856119b5565b611cd1876020015183612712565b611d43565b83611d1057611cd1338860200151848a6040015173ffffffffffffffffffffffffffffffffffffffff166119b5909392919063ffffffff16565b611d43876020015183896040015173ffffffffffffffffffffffffffffffffffffffff1661281c9092919063ffffffff16565b50505b95945050505050565b3373ffffffffffffffffffffffffffffffffffffffff1683867f393f1765f382b5310a9186fa707a84040f8241b280a30b74112689a92a156f698460600151600760008b815260200190815260200160002054898760800151898960a001518a60e001518b604001518c600001518d60200151604051611e459a99989796959493929190998a5260208a01989098526040890196909652606088019490945267ffffffffffffffff9283166080880152911660a086015263ffffffff1660c085015273ffffffffffffffffffffffffffffffffffffffff90811660e0850152908116610100840152166101208201526101400190565b60405180910390a45050505050565b47156119b35760048054604080517fd0e30db0000000000000000000000000000000000000000000000000000000008152905173ffffffffffffffffffffffffffffffffffffffff9092169263d0e30db0924792808301926000929182900301818588803b15801561079057600080fd5b46826020015114611f32576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f496e76616c696420636861696e496400000000000000000000000000000000006044820152606401610a2f565b8160400151518260a001515114611fa5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f696e76616c6964206c65616600000000000000000000000000000000000000006044820152606401610a2f565b600060068463ffffffff1681548110611fc057611fc0613cef565b90600052602060002090600302019050611fdf81600101548484612872565b612045576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4261642050726f6f6600000000000000000000000000000000000000000000006044820152606401610a2f565b61205c81600201846060015163ffffffff166128ad565b156120c3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f416c726561647920636c61696d656400000000000000000000000000000000006044820152606401610a2f565b6120da81600201846060015163ffffffff166128ee565b60005b8360400151518163ffffffff16101561218657600084604001518263ffffffff168151811061210e5761210e613cef565b602002602001015190506000811115612173576121738560a001518363ffffffff168151811061214057612140613cef565b602002602001015182876080015173ffffffffffffffffffffffffffffffffffffffff1661281c9092919063ffffffff16565b508061217e81613f6b565b9150506120dd565b5082511561221f576121978361292c565b826080015173ffffffffffffffffffffffffffffffffffffffff16836060015163ffffffff1684602001517f828fc203220356df8f072a91681caee7d5c75095e2a95e80ed5a14b384697f7186600001513360405161221692919091825273ffffffffffffffffffffffffffffffffffffffff16602082015260400190565b60405180910390a45b3373ffffffffffffffffffffffffffffffffffffffff16836060015163ffffffff168563ffffffff167ff8bd640004bcec1b89657020f561d0b070cbdf662d0b158db9dccb0a8301bfab86600001518760200151886040015189608001518a60a00151604051612293959493929190614010565b60405180910390a450505050565b73ffffffffffffffffffffffffffffffffffffffff811661231e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4261642062726964676520726f757465722061646472657373000000000000006044820152606401610a2f565b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040517fa9e8c42c9e7fca7f62755189a16b2f5314d43d8fb24e91ba54e6d65f9314e84990600090a250565b60408051608060208201819052601160a08301527f4143524f53532d56322d4645452d312e3000000000000000000000000000000060c083015267ffffffffffffffff86169282019290925263ffffffff8416606082015290810185905260009060e001604051602081830303815290604052805190602001209050600061241482612b43565b9050612421878285612b7e565b50505050505050565b60006040518061010001604052808c73ffffffffffffffffffffffffffffffffffffffff1681526020018b73ffffffffffffffffffffffffffffffffffffffff1681526020018a73ffffffffffffffffffffffffffffffffffffffff1681526020018981526020018881526020018767ffffffffffffffff1681526020018667ffffffffffffffff1681526020018563ffffffff1681525090506124f960068463ffffffff16815481106124e0576124e0613cef565b9060005260206000209060030201600001548284612bef565b61255f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f496e76616c69642070726f6f66000000000000000000000000000000000000006044820152606401610a2f565b600061256a82611a91565b90506000612580828485606001518a6001611ac1565b905061258d828285612c07565b50505050505050505050505050565b60006125fe826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff16612d009092919063ffffffff16565b8051909150156112d0578080602001905181019061261c919061405d565b6112d0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610a2f565b60006126bc82670de0b6b3a764000061407a565b67ffffffffffffffff166126d884670de0b6b3a764000061409b565b6126e29190614107565b9392505050565b6000670de0b6b3a76400006126fe838261407a565b6126d89067ffffffffffffffff168561409b565b73ffffffffffffffffffffffffffffffffffffffff82163b15612757576004546127539073ffffffffffffffffffffffffffffffffffffffff16838361281c565b5050565b600480546040517f2e1a7d4d00000000000000000000000000000000000000000000000000000000815291820183905273ffffffffffffffffffffffffffffffffffffffff1690632e1a7d4d90602401600060405180830381600087803b1580156127c157600080fd5b505af11580156127d5573d6000803e3d6000fd5b505060405173ffffffffffffffffffffffffffffffffffffffff8516925083156108fc02915083906000818181858888f193505050501580156112d0573d6000803e3d6000fd5b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526112d09084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401611a0f565b60006128a582858560405160200161288a919061411b565b60405160208183030381529060405280519060200120612d0f565b949350505050565b6000806128bc61010084614107565b905060006128cc610100856141b6565b6000928352602095909552506040902054600190931b92831690921492915050565b60006128fc61010083614107565b9050600061290c610100846141b6565b600092835260209490945250604090208054600190931b90921790915550565b600454608082015173ffffffffffffffffffffffffffffffffffffffff90811691161415612a0957608081015181516040517f2e1a7d4d00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff90921691632e1a7d4d916129b09160040190815260200190565b600060405180830381600087803b1580156129ca57600080fd5b505af11580156129de573d6000803e3d6000fd5b5050600854640100000000900473ffffffffffffffffffffffffffffffffffffffff16608084015250505b608081015160035482516008546040517fa3a7954800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9485166004820152939092166024840152604483015263ffffffff16606482015260a06084820152600060a48201527342000000000000000000000000000000000000109063a3a795489060c401600060405180830381600087803b158015612ab957600080fd5b505af1158015612acd573d6000803e3d6000fd5b50505050608081015160035482516008546040805173ffffffffffffffffffffffffffffffffffffffff9485168152602081019390935263ffffffff909116908201529116907f46b77e3c29797b94890fd3438da74f697480742358a3e26b9d13a227f1ac0ac99060600160405180910390a250565b6040517f19457468657265756d205369676e6564204d6573736167653a0a3332000000006020820152603c8101829052600090605c01611aa4565b612b89838383612d25565b6112d0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f696e76616c6964207369676e61747572650000000000000000000000000000006044820152606401610a2f565b60006128a582858560405160200161288a9190613e8d565b3373ffffffffffffffffffffffffffffffffffffffff16837fac5d07bd4046afd057f85211a1bec5e4dc2dc43d537b20d9dfcef5ce596215e6836060015160076000888152602001908152602001600020548686608001518760c001518860a001518960e001518a604001518b600001518c6020015160405161083d9a99989796959493929190998a5260208a01989098526040890196909652606088019490945267ffffffffffffffff9283166080880152911660a086015263ffffffff1660c085015273ffffffffffffffffffffffffffffffffffffffff90811660e0850152908116610100840152166101208201526101400190565b60606128a58484600085612f14565b600082612d1c85846130aa565b14949350505050565b6000806000612d34858561311e565b90925090506000816004811115612d4d57612d4d6141ca565b148015612d8557508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b15612d95576001925050506126e2565b6000808773ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8888604051602401612dca9291906141f9565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051612e539190614212565b600060405180830381855afa9150503d8060008114612e8e576040519150601f19603f3d011682016040523d82523d6000602084013e612e93565b606091505b5091509150818015612ea6575080516020145b8015612f08575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090612ee4908301602090810190840161422e565b7fffffffff0000000000000000000000000000000000000000000000000000000016145b98975050505050505050565b606082471015612fa6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401610a2f565b73ffffffffffffffffffffffffffffffffffffffff85163b613024576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610a2f565b6000808673ffffffffffffffffffffffffffffffffffffffff16858760405161304d9190614212565b60006040518083038185875af1925050503d806000811461308a576040519150601f19603f3d011682016040523d82523d6000602084013e61308f565b606091505b509150915061309f82828661318e565b979650505050505050565b600081815b84518110156131165760008582815181106130cc576130cc613cef565b602002602001015190508083116130f25760008381526020829052604090209250613103565b600081815260208490526040902092505b508061310e81613e14565b9150506130af565b509392505050565b6000808251604114156131555760208301516040840151606085015160001a613149878285856131e1565b94509450505050613187565b82516040141561317f57602083015160408401516131748683836132f9565b935093505050613187565b506000905060025b9250929050565b6060831561319d5750816126e2565b8251156131ad5782518084602001fd5b816040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a2f9190613e01565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561321857506000905060036132f0565b8460ff16601b1415801561323057508460ff16601c14155b1561324157506000905060046132f0565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015613295573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff81166132e9576000600192509250506132f0565b9150600090505b94509492505050565b6000807f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83168161332f60ff86901c601b613f53565b905061333d878288856131e1565b935093505050935093915050565b803563ffffffff8116811461335f57600080fd5b919050565b60006020828403121561337657600080fd5b6126e28261334b565b73ffffffffffffffffffffffffffffffffffffffff811681146106ff57600080fd5b803561335f8161337f565b6000602082840312156133be57600080fd5b81356126e28161337f565b6000602082840312156133db57600080fd5b5035919050565b80151581146106ff57600080fd5b60008060006060848603121561340557600080fd5b83356134108161337f565b9250602084013591506040840135613427816133e2565b809150509250925092565b803567ffffffffffffffff8116811461335f57600080fd5b60008060008060008060c0878903121561346357600080fd5b863561346e8161337f565b9550602087013561347e8161337f565b9450604087013593506060870135925061349a60808801613432565b91506134a860a0880161334b565b90509295509295509295565b600080604083850312156134c757600080fd5b50508035926020909101359150565b600080604083850312156134e957600080fd5b82356134f48161337f565b946020939093013593505050565b6000806000806000806000806000806101408b8d03121561352257600080fd5b8a3561352d8161337f565b995060208b013561353d8161337f565b985060408b013561354d8161337f565b975060608b0135965060808b0135955060a08b0135945060c08b0135935061357760e08c01613432565b92506135866101008c01613432565b91506135956101208c0161334b565b90509295989b9194979a5092959850565b600080602083850312156135b957600080fd5b823567ffffffffffffffff808211156135d157600080fd5b818501915085601f8301126135e557600080fd5b8135818111156135f457600080fd5b8660208260051b850101111561360957600080fd5b60209290920196919550909350505050565b60005b8381101561363657818101518382015260200161361e565b838111156113c35750506000910152565b6000815180845261365f81602086016020860161361b565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015613704577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08886030184526136f2858351613647565b945092850192908501906001016136b8565b5092979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160c0810167ffffffffffffffff8111828210171561376357613763613711565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156137b0576137b0613711565b604052919050565b600067ffffffffffffffff8211156137d2576137d2613711565b5060051b60200190565b600082601f8301126137ed57600080fd5b813560206138026137fd836137b8565b613769565b82815260059290921b8401810191818101908684111561382157600080fd5b8286015b8481101561383c5780358352918301918301613825565b509695505050505050565b600082601f83011261385857600080fd5b813560206138686137fd836137b8565b82815260059290921b8401810191818101908684111561388757600080fd5b8286015b8481101561383c57803561389e8161337f565b835291830191830161388b565b6000806000606084860312156138c057600080fd5b6138c98461334b565b9250602084013567ffffffffffffffff808211156138e657600080fd5b9085019060c082880312156138fa57600080fd5b613902613740565b823581526020830135602082015260408301358281111561392257600080fd5b61392e898286016137dc565b6040830152506139406060840161334b565b6060820152613951608084016133a1565b608082015260a08301358281111561396857600080fd5b61397489828601613847565b60a0830152509350604086013591508082111561399057600080fd5b5061399d868287016137dc565b9150509250925092565b600067ffffffffffffffff8211156139c1576139c1613711565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f8301126139fe57600080fd5b8135613a0c6137fd826139a7565b818152846020838601011115613a2157600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060808587031215613a5457600080fd5b8435613a5f8161337f565b9350613a6d60208601613432565b9250613a7b6040860161334b565b9150606085013567ffffffffffffffff811115613a9757600080fd5b613aa3878288016139ed565b91505092959194509250565b6000806000806000806000806000806101408b8d031215613acf57600080fd5b8a35613ada8161337f565b995060208b0135613aea8161337f565b985060408b0135613afa8161337f565b975060608b0135965060808b01359550613b1660a08c01613432565b9450613b2460c08c01613432565b9350613b3260e08c0161334b565b9250613b416101008c0161334b565b91506101208b013567ffffffffffffffff811115613b5e57600080fd5b613b6a8d828e016137dc565b9150509295989b9194979a5092959850565b6000806000806000806000806000806000806101808d8f031215613b9f57600080fd5b613ba88d6133a1565b9b50613bb660208e016133a1565b9a50613bc460408e016133a1565b995060608d0135985060808d0135975060a08d0135965060c08d01359550613bee60e08e01613432565b9450613bfd6101008e01613432565b9350613c0c6101208e01613432565b9250613c1b6101408e0161334b565b915067ffffffffffffffff6101608e01351115613c3757600080fd5b613c488e6101608f01358f016139ed565b90509295989b509295989b509295989b565b600060208284031215613c6c57600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600063ffffffff83811690831681811015613cbf57613cbf613c73565b039392505050565b600063ffffffff808316818516808303821115613ce657613ce6613c73565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613d5357600080fd5b83018035915067ffffffffffffffff821115613d6e57600080fd5b60200191503681900382131561318757600080fd5b8183823760009101908152919050565b600060208284031215613da557600080fd5b815167ffffffffffffffff811115613dbc57600080fd5b8201601f81018413613dcd57600080fd5b8051613ddb6137fd826139a7565b818152856020838501011115613df057600080fd5b611d4682602083016020860161361b565b6020815260006126e26020830184613647565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415613e4657613e46613c73565b5060010190565b67ffffffffffffffff831681526040602082015260006128a56040830184613647565b600060208284031215613e8257600080fd5b81516126e28161337f565b60006101008201905073ffffffffffffffffffffffffffffffffffffffff80845116835280602085015116602084015280604085015116604084015250606083015160608301526080830151608083015260a083015167ffffffffffffffff80821660a08501528060c08601511660c0850152505060e083015161121560e084018263ffffffff169052565b600067ffffffffffffffff808316818516808303821115613ce657613ce6613c73565b600082821015613f4e57613f4e613c73565b500390565b60008219821115613f6657613f66613c73565b500190565b600063ffffffff80831681811415613f8557613f85613c73565b6001019392505050565b600081518084526020808501945080840160005b83811015613fbf57815187529582019590820190600101613fa3565b509495945050505050565b600081518084526020808501945080840160005b83811015613fbf57815173ffffffffffffffffffffffffffffffffffffffff1687529582019590820190600101613fde565b85815284602082015260a06040820152600061402f60a0830186613f8f565b73ffffffffffffffffffffffffffffffffffffffff851660608401528281036080840152612f088185613fca565b60006020828403121561406f57600080fd5b81516126e2816133e2565b600067ffffffffffffffff83811690831681811015613cbf57613cbf613c73565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156140d3576140d3613c73565b500290565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082614116576141166140d8565b500490565b6020815281516020820152602082015160408201526000604083015160c0606084015261414b60e0840182613f8f565b905063ffffffff606085015116608084015273ffffffffffffffffffffffffffffffffffffffff60808501511660a084015260a08401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08483030160c0850152611d468282613fca565b6000826141c5576141c56140d8565b500690565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8281526040602082015260006128a56040830184613647565b6000825161422481846020870161361b565b9190910192915050565b60006020828403121561424057600080fd5b81517fffffffff00000000000000000000000000000000000000000000000000000000811681146126e257600080fdfea2646970667358221220bc43612fcdf1f2cafe850f1d34a162c0683ff96afabb66afdc083b86b56f83e264736f6c634300080b0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "chainId()": {
        "details": "Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the implementer to override this."
      },
      "constructor": {
        "params": {
          "_crossDomainAdmin": "Cross domain admin to set. Can be changed by admin.",
          "_hubPool": "Hub pool address to set. Can be changed by admin.",
          "timerAddress": "Timer address to set."
        }
      },
      "deposit(address,address,uint256,uint256,uint64,uint32)": {
        "params": {
          "amount": "Amount of tokens to deposit. Will be amount of tokens to receive less fees.",
          "destinationChainId": "Denotes network where user will receive funds from SpokePool by a relayer.",
          "originToken": "Token to lock into this contract to initiate deposit.",
          "quoteTimestamp": "Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.",
          "recipient": "Address to receive funds at on destination chain.",
          "relayerFeePct": "% of deposit amount taken out to incentivize a fast relayer."
        }
      },
      "executeRelayerRefundRoot(uint32,(uint256,uint256,uint256[],uint32,address,address[]),bytes32[])": {
        "params": {
          "proof": "Inclusion proof for this leaf in relayer refund root in root bundle.",
          "relayerRefundLeaf": "Contains all data neccessary to reconstruct leaf contained in root bundle and to refund relayer. This data structure is explained in detail in the SpokePoolInterface.",
          "rootBundleId": "Unique ID of root bundle containing relayer refund root that this leaf is contained in."
        }
      },
      "executeSlowRelayRoot(address,address,address,uint256,uint256,uint64,uint64,uint32,uint32,bytes32[])": {
        "params": {
          "amount": "Full size of the deposit.",
          "depositId": "Unique deposit ID on origin spoke pool.",
          "depositor": "Depositor on origin chain who set this chain as the destination chain.",
          "destinationToken": "Token to send to recipient. Should be mapped to the origin token, origin chain ID and this chain ID via a mapping on the HubPool.",
          "originChainId": "Chain of SpokePool where deposit originated.",
          "proof": "Inclusion proof for this leaf in slow relay root in root bundle.",
          "realizedLpFeePct": "Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on quote time.",
          "recipient": "Specified recipient on this chain.",
          "relayerFeePct": "Original fee % to keep as relayer set by depositor.",
          "rootBundleId": "Unique ID of root bundle containing slow relay root that this leaf is contained in."
        }
      },
      "fillRelay(address,address,address,uint256,uint256,uint256,uint256,uint64,uint64,uint32)": {
        "params": {
          "amount": "Full size of the deposit.",
          "depositId": "Unique deposit ID on origin spoke pool.",
          "depositor": "Depositor on origin chain who set this chain as the destination chain.",
          "destinationToken": "Token to send to recipient. Should be mapped to the origin token, origin chain ID and this chain ID via a mapping on the HubPool.",
          "maxTokensToSend": "Max amount of tokens to send recipient. If higher than amount, then caller will send recipient the full relay amount.",
          "originChainId": "Chain of SpokePool where deposit originated.",
          "realizedLpFeePct": "Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on quote time.",
          "recipient": "Specified recipient on this chain.",
          "relayerFeePct": "Fee % to keep as relayer, specified by depositor.",
          "repaymentChainId": "Chain of SpokePool where relayer wants to be refunded after the challenge window has passed."
        }
      },
      "fillRelayWithUpdatedFee(address,address,address,uint256,uint256,uint256,uint256,uint64,uint64,uint64,uint32,bytes)": {
        "params": {
          "amount": "Full size of the deposit.",
          "depositId": "Unique deposit ID on origin spoke pool.",
          "depositor": "Depositor on origin chain who set this chain as the destination chain.",
          "depositorSignature": "Depositor-signed message containing updated fee %.",
          "destinationToken": "Token to send to recipient. Should be mapped to the origin token, origin chain ID and this chain ID via a mapping on the HubPool.",
          "maxTokensToSend": "Max amount of tokens to send recipient. If higher than amount, then caller will send recipient the full relay amount.",
          "newRelayerFeePct": "New fee % to keep as relayer also specified by depositor.",
          "originChainId": "Chain of SpokePool where deposit originated.",
          "realizedLpFeePct": "Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on quote time.",
          "recipient": "Specified recipient on this chain.",
          "relayerFeePct": "Original fee % to keep as relayer set by depositor.",
          "repaymentChainId": "Chain of SpokePool where relayer wants to be refunded after the challenge window has passed."
        }
      },
      "getCurrentTime()": {
        "returns": {
          "_0": "uint for the current Testable timestamp."
        }
      },
      "relayRootBundle(bytes32,bytes32)": {
        "params": {
          "relayerRefundRoot": "Merkle root containing relayer refund leaves that can be individually executed via executeRelayerRefundRoot().",
          "slowRelayRoot": "Merkle root containing slow relay fulfillment leaves that can be individually executed via executeSlowRelayRoot()."
        }
      },
      "setCrossDomainAdmin(address)": {
        "params": {
          "newCrossDomainAdmin": "New cross domain admin."
        }
      },
      "setCurrentTime(uint256)": {
        "details": "Will revert if not running in test mode.",
        "params": {
          "time": "timestamp to set current Testable time to."
        }
      },
      "setDepositQuoteTimeBuffer(uint32)": {
        "params": {
          "newDepositQuoteTimeBuffer": "New quote time buffer."
        }
      },
      "setEnableRoute(address,uint256,bool)": {
        "params": {
          "destinationChainId": "Chain ID for where depositor wants to receive funds.",
          "enabled": "True to enable deposits, False otherwise.",
          "originToken": "Token that depositor can deposit to this contract."
        }
      },
      "setHubPool(address)": {
        "params": {
          "newHubPool": "New hub pool."
        }
      },
      "setL1GasLimit(uint32)": {
        "params": {
          "newl1Gas": "New L1 gas limit to set."
        }
      },
      "speedUpDeposit(address,uint64,uint32,bytes)": {
        "params": {
          "depositId": "Deposit to update fee for that originated in this contract.",
          "depositor": "Signer of the update fee message who originally submitted the deposit. If the deposit doesn't exist, then the relayer will not be able to fill any relay, so the caller should validate that the depositor did in fact submit a relay.",
          "depositorSignature": "Signed message containing the depositor address, this contract chain ID, the updated relayer fee %, and the deposit ID. This signature is produced by signing a hash of data according to the EIP-191 standard. See more in the _verifyUpdateRelayerFeeMessage() comments.",
          "newRelayerFeePct": "New relayer fee that relayers can use."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "chainId()": {
        "notice": "Returns chain ID for this network."
      },
      "constructor": {
        "notice": "Construct the OVM SpokePool."
      },
      "deposit(address,address,uint256,uint256,uint64,uint32)": {
        "notice": "Called by user to bridge funds from origin to destination chain. Depositor will effectively lock tokens in this contract and receive a destination token on the destination chain. The origin => destination token mapping is stored on the L1 HubPool.The caller must first approve this contract to spend amount of originToken.The originToken => destinationChainId must be enabled.This method is payable because the caller is able to deposit ETH if the originToken is WETH and this function will handle wrapping ETH."
      },
      "executeRelayerRefundRoot(uint32,(uint256,uint256,uint256[],uint32,address,address[]),bytes32[])": {
        "notice": "Wraps any ETH into WETH before executing base function. This is necessary because SpokePool receives ETH over the canonical token bridge instead of WETH."
      },
      "executeSlowRelayRoot(address,address,address,uint256,uint256,uint64,uint64,uint32,uint32,bytes32[])": {
        "notice": "Wraps any ETH into WETH before executing base function. This is neccessary because SpokePool receives ETH over the canonical token bridge instead of WETH."
      },
      "fillRelay(address,address,address,uint256,uint256,uint256,uint256,uint64,uint64,uint32)": {
        "notice": "Called by relayer to fulfill part of a deposit by sending destination tokens to the receipient. Relayer is expected to pass in unique identifying information for deposit that they want to fulfill, and this relay submission will be validated by off-chain data workers who can dispute this relay if any part is invalid. If the relay is valid, then the relayer will be refunded on their desired repayment chain. If relay is invalid, then relayer will not receive any refund.All of the deposit data can be found via on-chain events from the origin SpokePool, except for the realizedLpFeePct which is a function of the HubPool's utilization at the deposit quote time. This fee % is deterministic based on the quote time, so the relayer should just compute it using the canonical algorithm as described in a UMIP linked to the HubPool's identifier."
      },
      "fillRelayWithUpdatedFee(address,address,address,uint256,uint256,uint256,uint256,uint64,uint64,uint64,uint32,bytes)": {
        "notice": "Called by relayer to execute same logic as calling fillRelay except that relayer is using an updated relayer fee %. The fee % must have been emitted in a message cryptographically signed by the depositor.By design, the depositor probably emitted the message with the updated fee by calling speedUpRelay()."
      },
      "getCurrentTime()": {
        "notice": "Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp."
      },
      "relayRootBundle(bytes32,bytes32)": {
        "notice": "This method stores a new root bundle in this contract that can be executed to refund relayers, fulfill slow relays, and send funds back to the HubPool on L1. This method can only be called by the admin and is designed to be called as part of a cross-chain message from the HubPool's executeRootBundle method."
      },
      "setCrossDomainAdmin(address)": {
        "notice": "Change cross domain admin address. Callable by admin only."
      },
      "setCurrentTime(uint256)": {
        "notice": "Sets the current time."
      },
      "setDepositQuoteTimeBuffer(uint32)": {
        "notice": "Change allowance for deposit quote time to differ from current block time. Callable by admin only."
      },
      "setEnableRoute(address,uint256,bool)": {
        "notice": "Enable/Disable an origin token => destination chain ID route for deposits. Callable by admin only."
      },
      "setHubPool(address)": {
        "notice": "Change L1 hub pool address. Callable by admin only."
      },
      "setL1GasLimit(uint32)": {
        "notice": "Change L1 gas limit. Callable only by admin."
      },
      "speedUpDeposit(address,uint64,uint32,bytes)": {
        "notice": "Convenience method that depositor can use to signal to relayer to use updated fee.Relayer should only use events emitted by this function to submit fills with updated fees, otherwise they risk their fills getting disputed for being invalid, for example if the depositor never actually signed the update fee message.This function will revert if the depositor did not sign a message containing the updated fee for the deposit ID stored in this contract. If the deposit ID is for another contract, or the depositor address is incorrect, or the updated fee is incorrect, then the signature will not match and this function will revert."
      }
    },
    "notice": "OVM specific SpokePool. Uses OVM cross-domain-enabled logic to implement admin only access to functions.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 241,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "messenger",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 5884,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "timerAddress",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 7104,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "_notEntered",
        "offset": 20,
        "slot": "1",
        "type": "t_bool"
      },
      {
        "astId": 8144,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "crossDomainAdmin",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 8146,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "hubPool",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 8149,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "weth",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(WETH9)10630"
      },
      {
        "astId": 8151,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "deploymentTime",
        "offset": 20,
        "slot": "4",
        "type": "t_uint32"
      },
      {
        "astId": 8154,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "depositQuoteTimeBuffer",
        "offset": 24,
        "slot": "4",
        "type": "t_uint32"
      },
      {
        "astId": 8156,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "numberOfDeposits",
        "offset": 28,
        "slot": "4",
        "type": "t_uint32"
      },
      {
        "astId": 8162,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "enabledDepositRoutes",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_bool))"
      },
      {
        "astId": 8175,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "rootBundles",
        "offset": 0,
        "slot": "6",
        "type": "t_array(t_struct(RootBundle)8171_storage)dyn_storage"
      },
      {
        "astId": 8179,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "relayFills",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 7495,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "l1Gas",
        "offset": 0,
        "slot": "8",
        "type": "t_uint32"
      },
      {
        "astId": 7502,
        "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
        "label": "l2Eth",
        "offset": 4,
        "slot": "8",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(RootBundle)8171_storage)dyn_storage": {
        "base": "t_struct(RootBundle)8171_storage",
        "encoding": "dynamic_array",
        "label": "struct SpokePool.RootBundle[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(WETH9)10630": {
        "encoding": "inplace",
        "label": "contract WETH9",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bool)"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(RootBundle)8171_storage": {
        "encoding": "inplace",
        "label": "struct SpokePool.RootBundle",
        "members": [
          {
            "astId": 8164,
            "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
            "label": "slowRelayRoot",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 8166,
            "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
            "label": "relayerRefundRoot",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          },
          {
            "astId": 8170,
            "contract": "contracts/Optimism_SpokePool.sol:Optimism_SpokePool",
            "label": "claimedBitmap",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_uint256)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}
