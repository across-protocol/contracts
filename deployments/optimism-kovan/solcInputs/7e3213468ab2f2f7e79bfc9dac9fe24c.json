{
  "language": "Solidity",
  "sources": {
    "contracts/Arbitrum_SpokePool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./SpokePoolInterface.sol\";\n\ninterface StandardBridgeLike {\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n\n/**\n * @notice AVM specific SpokePool.\n * @dev Uses AVM cross-domain-enabled logic for access control.\n */\n\ncontract Arbitrum_SpokePool is SpokePoolInterface, SpokePool {\n    // Address of the Arbitrum L2 token gateway.\n    address public l2GatewayRouter;\n\n    // Admin controlled mapping of arbitrum tokens to L1 counterpart. L1 counterpart addresses\n    // are neccessary to bridge tokens to L1.\n    mapping(address => address) public whitelistedTokens;\n\n    event ArbitrumTokensBridged(address indexed l1Token, address target, uint256 numberOfTokensBridged);\n    event SetL2GatewayRouter(address indexed newL2GatewayRouter);\n    event WhitelistedTokens(address indexed l2Token, address indexed l1Token);\n\n    constructor(\n        address _l2GatewayRouter,\n        address _crossDomainAdmin,\n        address _hubPool,\n        address _wethAddress,\n        address timerAddress\n    ) SpokePool(_crossDomainAdmin, _hubPool, _wethAddress, timerAddress) {\n        _setL2GatewayRouter(_l2GatewayRouter);\n    }\n\n    modifier onlyFromCrossDomainAdmin() {\n        require(msg.sender == _applyL1ToL2Alias(crossDomainAdmin), \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /**************************************\n     *    CROSS-CHAIN ADMIN FUNCTIONS     *\n     **************************************/\n\n    function setL2GatewayRouter(address newL2GatewayRouter) public onlyFromCrossDomainAdmin nonReentrant {\n        _setL2GatewayRouter(newL2GatewayRouter);\n    }\n\n    function whitelistToken(address l2Token, address l1Token) public onlyFromCrossDomainAdmin nonReentrant {\n        _whitelistToken(l2Token, l1Token);\n    }\n\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyFromCrossDomainAdmin nonReentrant {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function setHubPool(address newHubPool) public override onlyFromCrossDomainAdmin nonReentrant {\n        _setHubPool(newHubPool);\n    }\n\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enable\n    ) public override onlyFromCrossDomainAdmin nonReentrant {\n        _setEnableRoute(originToken, destinationChainId, enable);\n    }\n\n    function setDepositQuoteTimeBuffer(uint32 buffer) public override onlyFromCrossDomainAdmin nonReentrant {\n        _setDepositQuoteTimeBuffer(buffer);\n    }\n\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayFulfillmentRoot)\n        public\n        override\n        onlyFromCrossDomainAdmin\n        nonReentrant\n    {\n        _relayRootBundle(relayerRefundRoot, slowRelayFulfillmentRoot);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _bridgeTokensToHubPool(RelayerRefundLeaf memory relayerRefundLeaf) internal override {\n        StandardBridgeLike(l2GatewayRouter).outboundTransfer(\n            whitelistedTokens[relayerRefundLeaf.l2TokenAddress], // _l1Token. Address of the L1 token to bridge over.\n            hubPool, // _to. Withdraw, over the bridge, to the l1 hub pool contract.\n            relayerRefundLeaf.amountToReturn, // _amount.\n            \"\" // _data. We don't need to send any data for the bridging action.\n        );\n        emit ArbitrumTokensBridged(address(0), hubPool, relayerRefundLeaf.amountToReturn);\n    }\n\n    function _setL2GatewayRouter(address _l2GatewayRouter) internal {\n        l2GatewayRouter = _l2GatewayRouter;\n        emit SetL2GatewayRouter(l2GatewayRouter);\n    }\n\n    function _whitelistToken(address _l2Token, address _l1Token) internal {\n        whitelistedTokens[_l2Token] = _l1Token;\n        emit WhitelistedTokens(_l2Token, _l1Token);\n    }\n\n    // l1 addresses are transformed during l1->l2 calls. See https://developer.offchainlabs.com/docs/l1_l2_messages#address-aliasing for more information.\n    function _applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + uint160(0x1111000000000000000000000000000000001111));\n        }\n    }\n}\n"
    },
    "contracts/SpokePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./MerkleLib.sol\";\nimport \"./interfaces/WETH9.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"@uma/core/contracts/common/implementation/Testable.sol\";\nimport \"@uma/core/contracts/common/implementation/Lockable.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport \"./MerkleLib.sol\";\nimport \"./SpokePoolInterface.sol\";\n\n/**\n * @title SpokePool\n * @notice Contract deployed on source and destination chains enabling depositors to transfer assets from source to\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1.\n * @dev This contract is designed to be deployed to L2's, not mainnet.\n */\nabstract contract SpokePool is SpokePoolInterface, Testable, Lockable, MultiCaller {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // Address of the L1 contract that acts as the owner of this SpokePool.\n    address public crossDomainAdmin;\n\n    // Address of the L1 contract that will send tokens to and receive tokens from this contract.\n    address public hubPool;\n\n    // Address of WETH contract for this network. If an origin token matches this, then the caller can optionally\n    // instruct this contract to wrap ETH when depositing.\n    WETH9 public weth;\n\n    // Timestamp when contract was constructed. Relays cannot have a quote time before this.\n    uint32 public deploymentTime;\n\n    // Any deposit quote times greater than or less than this value to the current contract time is blocked. Forces\n    // caller to use an up to date realized fee. Defaults to 10 minutes.\n    uint32 public depositQuoteTimeBuffer = 600;\n\n    // Use count of deposits as unique deposit identifier.\n    uint32 public numberOfDeposits;\n\n    // Origin token to destination token routings can be turned on or off.\n    mapping(address => mapping(uint256 => bool)) public enabledDepositRoutes;\n\n    struct RootBundle {\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\n        bytes32 slowRelayFulfillmentRoot;\n        // Merkle root of relayer refunds.\n        bytes32 relayerRefundRoot;\n        // This is a 2D bitmap tracking which leafs in the relayer refund root have been claimed, with max size of\n        // 256x256 leaves per root.\n        mapping(uint256 => uint256) claimedBitmap;\n    }\n    RootBundle[] public rootBundles;\n\n    // Each relay is associated with the hash of parameters that uniquely identify the original deposit and a relay\n    // attempt for that deposit. The relay itself is just represented as the amount filled so far. The total amount to\n    // relay, the fees, and the agents are all parameters included in the hash key.\n    mapping(bytes32 => uint256) public relayFills;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n    event SetXDomainAdmin(address indexed newAdmin);\n    event SetHubPool(address indexed newHubPool);\n    event EnabledDepositRoute(address indexed originToken, uint256 indexed destinationChainId, bool enabled);\n    event SetDepositQuoteTimeBuffer(uint32 newBuffer);\n    event FundsDeposited(\n        uint256 amount,\n        uint256 destinationChainId,\n        uint64 relayerFeePct,\n        uint32 indexed depositId,\n        uint32 quoteTimestamp,\n        address indexed originToken,\n        address recipient,\n        address indexed depositor\n    );\n    event FilledRelay(\n        bytes32 indexed relayHash,\n        uint256 totalRelayAmount,\n        uint256 totalFilledAmount,\n        uint256 fillAmount,\n        uint256 indexed repaymentChain,\n        uint256 originChainId,\n        uint64 relayerFeePct,\n        uint64 realizedLpFeePct,\n        uint32 depositId,\n        address destinationToken,\n        address indexed relayer,\n        address depositor,\n        address recipient\n    );\n    event ExecutedSlowRelayFulfillmentRoot(\n        bytes32 indexed relayHash,\n        uint256 totalRelayAmount,\n        uint256 totalFilledAmount,\n        uint256 fillAmount,\n        uint256 originChainId,\n        uint64 relayerFeePct,\n        uint64 realizedLpFeePct,\n        uint32 depositId,\n        address destinationToken,\n        address indexed caller,\n        address depositor,\n        address recipient\n    );\n    event RelayedRootBundle(uint32 indexed rootBundleId, bytes32 relayerRefundRoot, bytes32 slowRelayFulfillmentRoot);\n    event ExecutedRelayerRefundRoot(\n        uint256 amountToReturn,\n        uint256 chainId,\n        uint256[] refundAmounts,\n        uint32 indexed rootBundleId,\n        uint32 indexed leafId,\n        address l2TokenAddress,\n        address[] refundAddresses,\n        address indexed caller\n    );\n    event TokensBridged(\n        uint256 amountToReturn,\n        uint256 indexed chainId,\n        uint32 indexed leafId,\n        address indexed l2TokenAddress,\n        address caller\n    );\n\n    constructor(\n        address _crossDomainAdmin,\n        address _hubPool,\n        address _wethAddress,\n        address timerAddress\n    ) Testable(timerAddress) {\n        _setCrossDomainAdmin(_crossDomainAdmin);\n        _setHubPool(_hubPool);\n        deploymentTime = uint32(getCurrentTime());\n        weth = WETH9(_wethAddress);\n    }\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    modifier onlyEnabledRoute(address originToken, uint256 destinationId) {\n        require(enabledDepositRoutes[originToken][destinationId], \"Disabled route\");\n        _;\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    function _setCrossDomainAdmin(address newCrossDomainAdmin) internal {\n        require(newCrossDomainAdmin != address(0), \"Bad bridge router address\");\n        crossDomainAdmin = newCrossDomainAdmin;\n        emit SetXDomainAdmin(crossDomainAdmin);\n    }\n\n    function _setHubPool(address newHubPool) internal {\n        require(newHubPool != address(0), \"Bad hub pool address\");\n        hubPool = newHubPool;\n        emit SetHubPool(hubPool);\n    }\n\n    function _setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enabled\n    ) internal {\n        enabledDepositRoutes[originToken][destinationChainId] = enabled;\n        emit EnabledDepositRoute(originToken, destinationChainId, enabled);\n    }\n\n    function _setDepositQuoteTimeBuffer(uint32 _depositQuoteTimeBuffer) internal {\n        depositQuoteTimeBuffer = _depositQuoteTimeBuffer;\n        emit SetDepositQuoteTimeBuffer(_depositQuoteTimeBuffer);\n    }\n\n    /**************************************\n     *         DEPOSITOR FUNCTIONS        *\n     **************************************/\n\n    /**\n     * @notice Called by user to bridge funds from origin to destination chain.\n     * @dev The caller must first approve this contract to spend `amount` of `originToken`.\n     */\n    function deposit(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        uint64 relayerFeePct,\n        uint32 quoteTimestamp\n    ) public payable onlyEnabledRoute(originToken, destinationChainId) nonReentrant {\n        // We limit the relay fees to prevent the user spending all their funds on fees.\n        require(relayerFeePct <= 0.5e18, \"invalid relayer fee\");\n        // Note We assume that L2 timing cannot be compared accurately and consistently to L1 timing. Therefore,\n        // `block.timestamp` is different from the L1 EVM's. Therefore, the quoteTimestamp must be within a configurable\n        // buffer to allow for this variance.\n        // Note also that `quoteTimestamp` cannot be less than the buffer otherwise the following arithmetic can result\n        // in underflow. This isn't a problem as the deposit will revert, but the error might be unexpected for clients.\n        require(\n            getCurrentTime() >= quoteTimestamp - depositQuoteTimeBuffer &&\n                getCurrentTime() <= quoteTimestamp + depositQuoteTimeBuffer,\n            \"invalid quote time\"\n        );\n        // If the address of the origin token is a WETH contract and there is a msg.value with the transaction\n        // then the user is sending ETH. In this case, the ETH should be deposited to WETH.\n        if (originToken == address(weth) && msg.value > 0) {\n            require(msg.value == amount, \"msg.value must match amount\");\n            weth.deposit{ value: msg.value }();\n        } else {\n            // Else, it is a normal ERC20. In this case pull the token from the users wallet as per normal.\n            // Note: this includes the case where the L2 user has WETH (already wrapped ETH) and wants to bridge them. In\n            // this case the msg.value will be set to 0, indicating a \"normal\" ERC20 bridging action.\n            IERC20(originToken).safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit FundsDeposited(\n            amount,\n            destinationChainId,\n            relayerFeePct,\n            numberOfDeposits,\n            quoteTimestamp,\n            originToken,\n            recipient,\n            msg.sender\n        );\n\n        numberOfDeposits += 1;\n    }\n\n    /**************************************\n     *         RELAYER FUNCTIONS          *\n     **************************************/\n\n    function fillRelay(\n        address depositor,\n        address recipient,\n        address destinationToken,\n        uint256 totalRelayAmount,\n        uint256 maxTokensToSend,\n        uint256 repaymentChain,\n        uint256 originChainId,\n        uint64 realizedLpFeePct,\n        uint64 relayerFeePct,\n        uint32 depositId\n    ) public nonReentrant {\n        // Each relay attempt is mapped to the hash of data uniquely identifying it, which includes the deposit data\n        // such as the origin chain ID and the deposit ID, and the data in a relay attempt such as who the recipient\n        // is, which chain and currency the recipient wants to receive funds on, and the relay fees.\n        SpokePoolInterface.RelayData memory relayData = SpokePoolInterface.RelayData({\n            depositor: depositor,\n            recipient: recipient,\n            destinationToken: destinationToken,\n            relayAmount: totalRelayAmount,\n            realizedLpFeePct: realizedLpFeePct,\n            relayerFeePct: relayerFeePct,\n            depositId: depositId,\n            originChainId: originChainId\n        });\n        bytes32 relayHash = _getRelayHash(relayData);\n\n        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, maxTokensToSend, relayerFeePct, false);\n\n        _emitFillRelay(relayHash, fillAmountPreFees, repaymentChain, relayerFeePct, relayData);\n    }\n\n    function fillRelayWithUpdatedFee(\n        address depositor,\n        address recipient,\n        address destinationToken,\n        uint256 totalRelayAmount,\n        uint256 maxTokensToSend,\n        uint256 repaymentChain,\n        uint256 originChainId,\n        uint64 realizedLpFeePct,\n        uint64 relayerFeePct,\n        uint64 newRelayerFeePct,\n        uint32 depositId,\n        bytes memory depositorSignature\n    ) public nonReentrant {\n        // Grouping the signature validation logic into brackets to address stack too deep error.\n        {\n            // Depositor should have signed a hash of the relayer fee % to update to and information uniquely identifying\n            // the deposit to relay. This ensures that this signature cannot be re-used for other deposits. The version\n            // string is included as a precaution in case this contract is upgraded.\n            // Note: we use encode instead of encodePacked because it is more secure, more in the \"warning\" section\n            // here: https://docs.soliditylang.org/en/v0.8.11/abi-spec.html#non-standard-packed-mode\n            bytes32 expectedDepositorMessageHash = keccak256(\n                abi.encode(\"ACROSS-V2-FEE-1.0\", newRelayerFeePct, depositId, originChainId)\n            );\n\n            // Check the hash corresponding to the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n            // JSON-RPC method as part of EIP-191. We use OZ's signature checker library with adds support for\n            // EIP-1271 which can verify messages signed by smart contract wallets like Argent and Gnosis safes.\n            // If the depositor signed a message with a different updated fee (or any other param included in the\n            // above keccak156 hash), then this will revert.\n            bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(expectedDepositorMessageHash);\n\n            _verifyDepositorUpdateFeeMessage(depositor, ethSignedMessageHash, depositorSignature);\n        }\n\n        // Now follow the default `fillRelay` flow with the updated fee and the original relay hash.\n        RelayData memory relayData = RelayData({\n            depositor: depositor,\n            recipient: recipient,\n            destinationToken: destinationToken,\n            relayAmount: totalRelayAmount,\n            realizedLpFeePct: realizedLpFeePct,\n            relayerFeePct: relayerFeePct,\n            depositId: depositId,\n            originChainId: originChainId\n        });\n        bytes32 relayHash = _getRelayHash(relayData);\n        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, maxTokensToSend, newRelayerFeePct, false);\n\n        _emitFillRelay(relayHash, fillAmountPreFees, repaymentChain, newRelayerFeePct, relayData);\n    }\n\n    /**************************************\n     *         DATA WORKER FUNCTIONS      *\n     **************************************/\n    function executeSlowRelayFulfillmentRoot(\n        address depositor,\n        address recipient,\n        address destinationToken,\n        uint256 totalRelayAmount,\n        uint256 originChainId,\n        uint64 realizedLpFeePct,\n        uint64 relayerFeePct,\n        uint32 depositId,\n        uint32 rootBundleId,\n        bytes32[] memory proof\n    ) public nonReentrant {\n        RelayData memory relayData = RelayData({\n            depositor: depositor,\n            recipient: recipient,\n            destinationToken: destinationToken,\n            relayAmount: totalRelayAmount,\n            originChainId: originChainId,\n            realizedLpFeePct: realizedLpFeePct,\n            relayerFeePct: relayerFeePct,\n            depositId: depositId\n        });\n\n        require(\n            MerkleLib.verifySlowRelayFulfillment(rootBundles[rootBundleId].slowRelayFulfillmentRoot, relayData, proof),\n            \"Invalid proof\"\n        );\n\n        bytes32 relayHash = _getRelayHash(relayData);\n\n        // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is neccessary because\n        // some SpokePools will receive ETH from the canonical token bridge instead of WETH.\n        if (address(this).balance > 0) weth.deposit{ value: address(this).balance }();\n\n        // Note: use relayAmount as the max amount to send, so the relay is always completely filled by the contract's\n        // funds in all cases.\n        uint256 fillAmountPreFees = _fillRelay(relayHash, relayData, relayData.relayAmount, relayerFeePct, true);\n\n        _emitExecutedSlowRelayFulfillmentRoot(relayHash, fillAmountPreFees, relayData);\n    }\n\n    function executeRelayerRefundRoot(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public nonReentrant {\n        // Check integrity of leaf structure:\n        require(relayerRefundLeaf.chainId == chainId(), \"Invalid chainId\");\n        require(relayerRefundLeaf.refundAddresses.length == relayerRefundLeaf.refundAmounts.length, \"invalid leaf\");\n\n        RootBundle storage rootBundle = rootBundles[rootBundleId];\n\n        // Check that `inclusionProof` proves that `relayerRefundLeaf` is contained within the relayer refund root.\n        // Note: This should revert if the `relayerRefundRoot` is uninitialized.\n        require(MerkleLib.verifyRelayerRefund(rootBundle.relayerRefundRoot, relayerRefundLeaf, proof), \"Bad Proof\");\n\n        // Verify the leafId in the leaf has not yet been claimed.\n        require(!MerkleLib.isClaimed(rootBundle.claimedBitmap, relayerRefundLeaf.leafId), \"Already claimed\");\n\n        // Set leaf as claimed in bitmap.\n        MerkleLib.setClaimed(rootBundle.claimedBitmap, relayerRefundLeaf.leafId);\n\n        // Wrap any ETH owned by this contract so we can send expected L2 token to recipient. This is neccessary because\n        // some SpokePools will receive ETH from the canonical token bridge instead of WETH.\n        if (address(this).balance > 0) weth.deposit{ value: address(this).balance }();\n\n        // Send each relayer refund address the associated refundAmount for the L2 token address.\n        // Note: Even if the L2 token is not enabled on this spoke pool, we should still refund relayers.\n        for (uint32 i = 0; i < relayerRefundLeaf.refundAmounts.length; i++) {\n            uint256 amount = relayerRefundLeaf.refundAmounts[i];\n            if (amount > 0)\n                IERC20(relayerRefundLeaf.l2TokenAddress).safeTransfer(relayerRefundLeaf.refundAddresses[i], amount);\n        }\n\n        // If leaf's `amountToReturn` is positive, then send L2 --> L1 message to bridge tokens back via\n        // chain-specific bridging method.\n        if (relayerRefundLeaf.amountToReturn > 0) {\n            _bridgeTokensToHubPool(relayerRefundLeaf);\n\n            emit TokensBridged(\n                relayerRefundLeaf.amountToReturn,\n                relayerRefundLeaf.chainId,\n                relayerRefundLeaf.leafId,\n                relayerRefundLeaf.l2TokenAddress,\n                msg.sender\n            );\n        }\n\n        emit ExecutedRelayerRefundRoot(\n            relayerRefundLeaf.amountToReturn,\n            relayerRefundLeaf.chainId,\n            relayerRefundLeaf.refundAmounts,\n            rootBundleId,\n            relayerRefundLeaf.leafId,\n            relayerRefundLeaf.l2TokenAddress,\n            relayerRefundLeaf.refundAddresses,\n            msg.sender\n        );\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    // Some L2s like ZKSync don't support the CHAIN_ID opcode so we allow the caller to manually set this.\n    function chainId() public view virtual returns (uint256) {\n        return block.chainid;\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    function _bridgeTokensToHubPool(SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf) internal virtual;\n\n    // Allow L2 to implement chain specific recovering of signers from signatures because some L2s might not support\n    // ecrecover, such as those with account abstraction like ZKSync.\n    function _verifyDepositorUpdateFeeMessage(\n        address depositor,\n        bytes32 ethSignedMessageHash,\n        bytes memory depositorSignature\n    ) internal view virtual {\n        // Note: no need to worry about reentrancy from contract deployed at `depositor` address since\n        // `SignatureChecker.isValidSignatureNow` is a non state-modifying STATICCALL:\n        // - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/63b466901fb015538913f811c5112a2775042177/contracts/utils/cryptography/SignatureChecker.sol#L35\n        // - https://github.com/ethereum/EIPs/pull/214\n        require(\n            SignatureChecker.isValidSignatureNow(depositor, ethSignedMessageHash, depositorSignature),\n            \"invalid signature\"\n        );\n    }\n\n    function _computeAmountPreFees(uint256 amount, uint64 feesPct) private pure returns (uint256) {\n        return (1e18 * amount) / (1e18 - feesPct);\n    }\n\n    function _computeAmountPostFees(uint256 amount, uint64 feesPct) private pure returns (uint256) {\n        return (amount * (1e18 - feesPct)) / 1e18;\n    }\n\n    // Should we make this public for the relayer's convenience?\n    function _getRelayHash(SpokePoolInterface.RelayData memory relayData) private pure returns (bytes32) {\n        return keccak256(abi.encode(relayData));\n    }\n\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends WETH.\n    function _unwrapWETHTo(address payable to, uint256 amount) internal {\n        if (address(to).isContract()) {\n            IERC20(address(weth)).safeTransfer(to, amount);\n        } else {\n            weth.withdraw(amount);\n            to.transfer(amount);\n        }\n    }\n\n    // This internal method should be called by an external \"relayRootBundle\" function that validates the\n    // cross domain sender is the HubPool. This validation step differs for each L2, which is why the implementation\n    // specifics are left to the implementor of this abstract contract.\n    // Once this method is executed and a distribution root is stored in this contract, then `distributeRootBundle`\n    // can be called to execute each leaf in the root.\n    function _relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayFulfillmentRoot) internal {\n        uint32 rootBundleId = uint32(rootBundles.length);\n        RootBundle storage rootBundle = rootBundles.push();\n        rootBundle.relayerRefundRoot = relayerRefundRoot;\n        rootBundle.slowRelayFulfillmentRoot = slowRelayFulfillmentRoot;\n        emit RelayedRootBundle(rootBundleId, relayerRefundRoot, slowRelayFulfillmentRoot);\n    }\n\n    function _fillRelay(\n        bytes32 relayHash,\n        RelayData memory relayData,\n        uint256 maxTokensToSend,\n        uint64 updatableRelayerFeePct,\n        bool isSlowRelay\n    ) internal returns (uint256 fillAmountPreFees) {\n        // We limit the relay fees to prevent the user spending all their funds on fees. Note that 0.5e18 (i.e. 50%)\n        // fees are just magic numbers. The important point is to prevent the total fee from being 100%, otherwise\n        // computing the amount pre fees runs into divide-by-0 issues.\n        require(updatableRelayerFeePct < 0.5e18 && relayData.realizedLpFeePct < 0.5e18, \"invalid fees\");\n\n        // Check that the relay has not already been completely filled. Note that the `relays` mapping will point to\n        // the amount filled so far for a particular `relayHash`, so this will start at 0 and increment with each fill.\n        require(relayFills[relayHash] < relayData.relayAmount, \"relay filled\");\n\n        // Stores the equivalent amount to be sent by the relayer before fees have been taken out.\n        fillAmountPreFees = 0;\n\n        // Adding brackets \"stack too deep\" solidity error.\n        if (maxTokensToSend > 0) {\n            fillAmountPreFees = _computeAmountPreFees(\n                maxTokensToSend,\n                (relayData.realizedLpFeePct + updatableRelayerFeePct)\n            );\n            // If user's specified max amount to send is greater than the amount of the relay remaining pre-fees,\n            // we'll pull exactly enough tokens to complete the relay.\n            uint256 amountToSend = maxTokensToSend;\n            if (relayData.relayAmount - relayFills[relayHash] < fillAmountPreFees) {\n                fillAmountPreFees = relayData.relayAmount - relayFills[relayHash];\n                amountToSend = _computeAmountPostFees(\n                    fillAmountPreFees,\n                    relayData.realizedLpFeePct + updatableRelayerFeePct\n                );\n            }\n            relayFills[relayHash] += fillAmountPreFees;\n            // If relay token is weth then unwrap and send eth.\n            if (relayData.destinationToken == address(weth)) {\n                // Note: WETH is already in the contract in the slow relay case.\n                if (!isSlowRelay)\n                    IERC20(relayData.destinationToken).safeTransferFrom(msg.sender, address(this), amountToSend);\n                _unwrapWETHTo(payable(relayData.recipient), amountToSend);\n                // Else, this is a normal ERC20 token. Send to recipient.\n            } else {\n                // Note: send token directly from the contract to the user in the slow relay case.\n                if (!isSlowRelay)\n                    IERC20(relayData.destinationToken).safeTransferFrom(msg.sender, relayData.recipient, amountToSend);\n                else IERC20(relayData.destinationToken).safeTransfer(relayData.recipient, amountToSend);\n            }\n        }\n    }\n\n    function _emitFillRelay(\n        bytes32 relayHash,\n        uint256 fillAmount,\n        uint256 repaymentChain,\n        uint64 relayerFeePct,\n        RelayData memory relayData\n    ) internal {\n        emit FilledRelay(\n            relayHash,\n            relayData.relayAmount,\n            relayFills[relayHash],\n            fillAmount,\n            repaymentChain,\n            relayData.originChainId,\n            relayerFeePct,\n            relayData.realizedLpFeePct,\n            relayData.depositId,\n            relayData.destinationToken,\n            msg.sender,\n            relayData.depositor,\n            relayData.recipient\n        );\n    }\n\n    function _emitExecutedSlowRelayFulfillmentRoot(\n        bytes32 relayHash,\n        uint256 fillAmount,\n        RelayData memory relayData\n    ) internal {\n        emit ExecutedSlowRelayFulfillmentRoot(\n            relayHash,\n            relayData.relayAmount,\n            relayFills[relayHash],\n            fillAmount,\n            relayData.originChainId,\n            relayData.relayerFeePct,\n            relayData.realizedLpFeePct,\n            relayData.depositId,\n            relayData.destinationToken,\n            msg.sender,\n            relayData.depositor,\n            relayData.recipient\n        );\n    }\n\n    // Added to enable the this contract to receive ETH. Used when unwrapping Weth.\n    receive() external payable {}\n}\n"
    },
    "contracts/SpokePoolInterface.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\ninterface SpokePoolInterface {\n    // This leaf is meant to be decoded in the SpokePool in order to pay out individual relayers for this bundle.\n    struct RelayerRefundLeaf {\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that is\n        // negative. This is just that value inverted.\n        uint256 amountToReturn;\n        // Used to verify that this is being decoded on the correct chainId.\n        uint256 chainId;\n        // This array designates how much each of those addresses should be refunded.\n        uint256[] refundAmounts;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint32 leafId;\n        // The associated L2TokenAddress that these claims apply to.\n        address l2TokenAddress;\n        // These two arrays must be the same length and are parallel arrays. They should be order by refundAddresses.\n        // This array designates each address that must be refunded.\n        address[] refundAddresses;\n    }\n\n    // This struct represents the data to fully-specify a relay. If any portion of this data differs, the relay is\n    // considered to be completely distinct. Only one relay for a particular depositId, chainId pair should be\n    // considered valid and repaid.\n    struct RelayData {\n        // The address that made the deposit on the origin chain.\n        address depositor;\n        // The recipient address on the destination chain.\n        address recipient;\n        // The corresponding token address on the destination chain.\n        address destinationToken;\n        // The total relay amount before fees are taken out.\n        uint256 relayAmount;\n        // Origin chain id.\n        uint256 originChainId;\n        // The LP Fee percentage computed by the relayer based on the deposit's quote timestamp\n        // and the HubPool's utilization.\n        uint64 realizedLpFeePct;\n        // The relayer fee percentage specified in the deposit.\n        uint64 relayerFeePct;\n        // The id uniquely identifying this deposit on the origin chain.\n        uint32 depositId;\n    }\n\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\n\n    function setHubPool(address newHubPool) external;\n\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enable\n    ) external;\n\n    function setDepositQuoteTimeBuffer(uint32 buffer) external;\n\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\n}\n"
    },
    "contracts/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./SpokePoolInterface.sol\";\nimport \"./HubPoolInterface.sol\";\n\n/**\n * @notice Library to help with merkle roots, proofs, and claims.\n */\nlibrary MerkleLib {\n    /**\n     * @notice Verifies that a repayment is contained within a merkle root.\n     * @param root the merkle root.\n     * @param rebalance the rebalance struct.\n     * @param proof the merkle proof.\n     */\n    function verifyPoolRebalance(\n        bytes32 root,\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));\n    }\n\n    /**\n     * @notice Verifies that a relayer refund is contained within a merkle root.\n     * @param root the merkle root.\n     * @param refund the refund struct.\n     * @param proof the merkle proof.\n     */\n    function verifyRelayerRefund(\n        bytes32 root,\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(refund)));\n    }\n\n    /**\n     * @notice Verifies that a distribution is contained within a merkle root.\n     * @param root the merkle root.\n     * @param slowRelayFulfillment the relayData fulfullment struct.\n     * @param proof the merkle proof.\n     */\n    function verifySlowRelayFulfillment(\n        bytes32 root,\n        SpokePoolInterface.RelayData memory slowRelayFulfillment,\n        bytes32[] memory proof\n    ) internal pure returns (bool) {\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\n    }\n\n    // The following functions are primarily copied from\n    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.\n\n    /**\n     * @notice Tests whether a claim is contained within a claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to check in the bitmap.\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to mark in the bitmap.\n     */\n    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) internal {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    /**\n     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.\n     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.\n     * @param index the index to check in the bitmap.\n     \\* @return bool indicating if the index within the claimedBitMap has been marked as claimed.\n     */\n    function isClaimed1D(uint256 claimedBitMap, uint256 index) internal pure returns (bool) {\n        uint256 mask = (1 << index);\n        return claimedBitMap & mask == mask;\n    }\n\n    /**\n     * @notice Marks an index in a claimedBitMap as claimed.\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\n     * @param index the index to mark in the bitmap.\n     */\n    function setClaimed1D(uint256 claimedBitMap, uint256 index) internal pure returns (uint256) {\n        require(index <= 255, \"Index out of bounds\");\n        return claimedBitMap | (1 << index % 256);\n    }\n}\n"
    },
    "contracts/interfaces/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface WETH9 {\n    function withdraw(uint256 wad) external;\n\n    function deposit() external payable;\n\n    function balanceOf(address guy) external view returns (uint256 wad);\n\n    function transfer(address guy, uint256 wad) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../Address.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper: Provide a single mechanism to verify both private-key (EOA) ECDSA signature and\n * ERC1271 contract signatures. Using this instead of ECDSA.recover in your contract will make them compatible with\n * smart contract wallets such as Argent and Gnosis.\n *\n * Note: unlike ECDSA signatures, contract signature's are revocable, and the outcome of this function can thus change\n * through time. It could return true at block N and false at block N+1 (or the opposite).\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return true;\n        }\n\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/Testable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Timer.sol\";\n\n/**\n * @title Base class that provides time overrides, but only if being run in test mode.\n */\nabstract contract Testable {\n    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.\n    // Note: this variable should be set on construction and never modified.\n    address public timerAddress;\n\n    /**\n     * @notice Constructs the Testable contract. Called by child contracts.\n     * @param _timerAddress Contract that stores the current time in a testing environment.\n     * Must be set to 0x0 for production environments that use live time.\n     */\n    constructor(address _timerAddress) {\n        timerAddress = _timerAddress;\n    }\n\n    /**\n     * @notice Reverts if not running in test mode.\n     */\n    modifier onlyIfTest {\n        require(timerAddress != address(0x0));\n        _;\n    }\n\n    /**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set current Testable time to.\n     */\n    function setCurrentTime(uint256 time) external onlyIfTest {\n        Timer(timerAddress).setCurrentTime(time);\n    }\n\n    /**\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n     * Otherwise, it will return the block timestamp.\n     * @return uint for the current Testable timestamp.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        if (timerAddress != address(0x0)) {\n            return Timer(timerAddress).getCurrentTime();\n        } else {\n            return block.timestamp; // solhint-disable-line not-rely-on-time\n        }\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/Lockable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n */\ncontract Lockable {\n    bool private _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\n    // then call `_postEntranceReset()`.\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiCaller.sol": {
      "content": "// This contract is taken from Uniswaps's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\npragma solidity ^0.8.0;\n\n/// @title MultiCaller\n/// @notice Enables calling multiple methods in a single call to the contract\ncontract MultiCaller {\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {\n        require(msg.value == 0, \"Only multicall with 0 value\");\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "contracts/HubPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/AdapterInterface.sol\";\n\ninterface HubPoolInterface {\n    struct PoolRebalanceLeaf {\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to sent to).\n        uint256 chainId;\n        uint256[] bundleLpFees; // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\n        // This array is grouped with the two above, and it represents the amount to send or request back from the\n        // SpokePool. If positive, the pool will pay the SpokePool. If negative the SpokePool will pay the HubPool.\n        // There can be arbitrarily complex rebalancing rules defined offchain. This number is only nonzero\n        // when the rules indicate that a rebalancing action should occur. When a rebalance does not occur,\n        // runningBalances for this token should change by the total relays - deposits in this bundle. When a rebalance\n        // does occur, runningBalances should be set to zero for this token and the netSendAmounts should be set to the\n        // previous runningBalances + relays - deposits in this bundle.\n        int256[] netSendAmounts;\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1 pool.\n        // A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that the\n        // SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts\n        int256[] runningBalances;\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\n        uint8 leafId;\n        // The following arrays are required to be the same length. They are parallel arrays for the given chainId and should be ordered by the `l1Tokens` field.\n        // All whitelisted tokens with nonzero relays on this chain in this bundle in the order of whitelisting.\n        address[] l1Tokens;\n    }\n\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\n\n    function setCrossChainContracts(\n        uint256 l2ChainId,\n        address adapter,\n        address spokePool\n    ) external;\n\n    function whitelistRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        address destinationToken\n    ) external;\n\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\n\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\n\n    function removeLiquidity(\n        address l1Token,\n        uint256 lpTokenAmount,\n        bool sendEth\n    ) external;\n\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\n\n    function liquidityUtilizationPostRelay(address token, uint256 relayedAmount) external returns (uint256);\n\n    function proposeRootBundle(\n        uint256[] memory bundleEvaluationBlockNumbers,\n        uint8 poolRebalanceLeafCount,\n        bytes32 poolRebalanceRoot,\n        bytes32 relayerRefundRoot,\n        bytes32 slowRelayFulfillmentRoot\n    ) external;\n\n    function executeRootBundle(PoolRebalanceLeaf memory poolRebalanceLeaf, bytes32[] memory proof) external;\n\n    function disputeRootBundle() external;\n}\n"
    },
    "contracts/interfaces/AdapterInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\n */\n\ninterface AdapterInterface {\n    event HubPoolChanged(address newHubPool);\n\n    event MessageRelayed(address target, bytes message);\n\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\n\n    function relayMessage(address target, bytes memory message) external payable;\n\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/Timer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Universal store of current contract time for testing environments.\n */\ncontract Timer {\n    uint256 private currentTime;\n\n    constructor() {\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set `currentTime` to.\n     */\n    function setCurrentTime(uint256 time) external {\n        currentTime = time;\n    }\n\n    /**\n     * @notice Gets the currentTime variable set in the Timer.\n     * @return uint256 for the current Testable timestamp.\n     */\n    function getCurrentTime() public view returns (uint256) {\n        return currentTime;\n    }\n}\n"
    },
    "contracts/test/MockSpokePool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"../SpokePool.sol\";\nimport \"../SpokePoolInterface.sol\";\n\n/**\n * @title MockSpokePool\n * @notice Implements admin internal methods to test internal logic.\n */\ncontract MockSpokePool is SpokePoolInterface, SpokePool {\n    constructor(\n        address _crossDomainAdmin,\n        address _hubPool,\n        address _wethAddress,\n        address timerAddress\n    ) SpokePool(_crossDomainAdmin, _hubPool, _wethAddress, timerAddress) {}\n\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function setHubPool(address newHubPool) public override {\n        _setHubPool(newHubPool);\n    }\n\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enable\n    ) public override {\n        _setEnableRoute(originToken, destinationChainId, enable);\n    }\n\n    function setDepositQuoteTimeBuffer(uint32 buffer) public override {\n        _setDepositQuoteTimeBuffer(buffer);\n    }\n\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayFulfillmentRoot) public override {\n        _relayRootBundle(relayerRefundRoot, slowRelayFulfillmentRoot);\n    }\n\n    function _bridgeTokensToHubPool(RelayerRefundLeaf memory relayerRefundLeaf) internal override {}\n}\n"
    },
    "contracts/Optimism_SpokePool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./interfaces/WETH9.sol\";\n\nimport \"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\nimport \"@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol\";\nimport \"./SpokePool.sol\";\nimport \"./SpokePoolInterface.sol\";\n\n/**\n * @notice OVM specific SpokePool.\n * @dev Uses OVM cross-domain-enabled logic for access control.\n */\n\ncontract Optimism_SpokePool is CrossDomainEnabled, SpokePoolInterface, SpokePool {\n    // \"l1Gas\" parameter used in call to bridge tokens from this contract back to L1 via `IL2ERC20Bridge`.\n    uint32 public l1Gas = 5_000_000;\n\n    address public l2Eth = address(Lib_PredeployAddresses.OVM_ETH);\n\n    event OptimismTokensBridged(address indexed l2Token, address target, uint256 numberOfTokensBridged, uint256 l1Gas);\n    event SetL1Gas(uint32 indexed newL1Gas);\n\n    constructor(\n        address _crossDomainAdmin,\n        address _hubPool,\n        address timerAddress\n    )\n        CrossDomainEnabled(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER)\n        SpokePool(_crossDomainAdmin, _hubPool, 0x4200000000000000000000000000000000000006, timerAddress)\n    {}\n\n    /**************************************\n     *    CROSS-CHAIN ADMIN FUNCTIONS     *\n     **************************************/\n\n    function setL1GasLimit(uint32 newl1Gas) public onlyFromCrossDomainAccount(crossDomainAdmin) {\n        _setL1GasLimit(newl1Gas);\n    }\n\n    function setCrossDomainAdmin(address newCrossDomainAdmin)\n        public\n        override\n        onlyFromCrossDomainAccount(crossDomainAdmin)\n        nonReentrant\n    {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function setHubPool(address newHubPool) public override onlyFromCrossDomainAccount(crossDomainAdmin) nonReentrant {\n        _setHubPool(newHubPool);\n    }\n\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enable\n    ) public override onlyFromCrossDomainAccount(crossDomainAdmin) nonReentrant {\n        _setEnableRoute(originToken, destinationChainId, enable);\n    }\n\n    function setDepositQuoteTimeBuffer(uint32 buffer)\n        public\n        override\n        onlyFromCrossDomainAccount(crossDomainAdmin)\n        nonReentrant\n    {\n        _setDepositQuoteTimeBuffer(buffer);\n    }\n\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayFulfillmentRoot)\n        public\n        override\n        onlyFromCrossDomainAccount(crossDomainAdmin)\n        nonReentrant\n    {\n        _relayRootBundle(relayerRefundRoot, slowRelayFulfillmentRoot);\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _setL1GasLimit(uint32 _l1Gas) internal {\n        l1Gas = _l1Gas;\n        emit SetL1Gas(l1Gas);\n    }\n\n    function _bridgeTokensToHubPool(RelayerRefundLeaf memory relayerRefundLeaf) internal override {\n        // If the token being bridged is WETH then we need to first unwrap it to ETH and then send ETH over the\n        // canonical bridge. On Optimism, this is address 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000.\n        if (relayerRefundLeaf.l2TokenAddress == address(weth)) {\n            WETH9(relayerRefundLeaf.l2TokenAddress).withdraw(relayerRefundLeaf.amountToReturn); // Unwrap ETH.\n            relayerRefundLeaf.l2TokenAddress = l2Eth; // Set the l2TokenAddress to ETH.\n        }\n        IL2ERC20Bridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo(\n            relayerRefundLeaf.l2TokenAddress, // _l2Token. Address of the L2 token to bridge over.\n            hubPool, // _to. Withdraw, over the bridge, to the l1 pool contract.\n            relayerRefundLeaf.amountToReturn, // _amount.\n            l1Gas, // _l1Gas. Unused, but included for potential forward compatibility considerations\n            \"\" // _data. We don't need to send any data for the bridging action.\n        );\n\n        emit OptimismTokensBridged(relayerRefundLeaf.l2TokenAddress, hubPool, relayerRefundLeaf.amountToReturn, l1Gas);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"./ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @dev Helper contract for contracts performing cross-domain communications\n *\n * Compiler used: defined by inheriting contract\n */\ncontract CrossDomainEnabled {\n    /*************\n     * Variables *\n     *************/\n\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public messenger;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {\n        messenger = _messenger;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Enforces that the modified function is only callable by a specific cross-domain account.\n     * @param _sourceDomainAccount The only account on the originating domain which is\n     *  authenticated to call this function.\n     */\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\n        require(\n            msg.sender == address(getCrossDomainMessenger()),\n            \"OVM_XCHAIN: messenger contract unauthenticated\"\n        );\n\n        require(\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\n            \"OVM_XCHAIN: wrong sender of cross-domain message\"\n        );\n\n        _;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\n        return ICrossDomainMessenger(messenger);\n    }\n\n    /**q\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  `onlyFromCrossDomainAccount()`)\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes memory _message\n    ) internal {\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title IL2ERC20Bridge\n */\ninterface IL2ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event WithdrawalInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFailed(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L1 bridge contract.\n     * @return Address of the corresponding L1 bridge contract.\n     */\n    function l1TokenBridge() external returns (address);\n\n    /**\n     * @dev initiate a withdraw of some tokens to the caller's account on L1\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _amount Amount of the token to withdraw.\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev initiate a withdraw of some token to a recipient's account on L1.\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\n     * @param _to L1 adress to credit the withdrawal to.\n     * @param _amount Amount of the token to withdraw.\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this\n     * L2 token. This call will fail if it did not originate from a corresponding deposit in\n     * L1StandardTokenBridge.\n     * @param _l1Token Address for the l1 token this is called with\n     * @param _l2Token Address for the l2 token this is called with\n     * @param _from Account to pull the deposit from on L2.\n     * @param _to Address to receive the withdrawal at\n     * @param _amount Amount of the token to withdraw\n     * @param _data Data provider by the sender on L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "contracts/chain-adapters/Optimism_Adapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Base_Adapter.sol\";\nimport \"../interfaces/AdapterInterface.sol\";\nimport \"../interfaces/WETH9.sol\";\n\nimport \"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@uma/core/contracts/common/implementation/Lockable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Sends cross chain messages Optimism L2 network.\n * @dev This contract's owner should be set to the some multisig or admin contract. The Owner can simply set the L2 gas\n * and the HubPool. The HubPool is the only contract that can relay tokens and messages over the bridge.\n */\ncontract Optimism_Adapter is Base_Adapter, CrossDomainEnabled, Lockable {\n    uint32 public l2GasLimit = 5_000_000;\n\n    WETH9 public l1Weth;\n\n    IL1StandardBridge public l1StandardBridge;\n\n    event L2GasLimitSet(uint32 newGasLimit);\n\n    constructor(\n        WETH9 _l1Weth,\n        address _hubPool,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge\n    ) CrossDomainEnabled(_crossDomainMessenger) Base_Adapter(_hubPool) {\n        l1Weth = _l1Weth;\n        l1StandardBridge = _l1StandardBridge;\n    }\n\n    function setL2GasLimit(uint32 _l2GasLimit) public onlyOwner {\n        l2GasLimit = _l2GasLimit;\n        emit L2GasLimitSet(l2GasLimit);\n    }\n\n    function relayMessage(address target, bytes memory message) external payable override nonReentrant onlyHubPool {\n        sendCrossDomainMessage(target, uint32(l2GasLimit), message);\n        emit MessageRelayed(target, message);\n    }\n\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override nonReentrant onlyHubPool {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(l1Weth)) {\n            l1Weth.withdraw(amount);\n            l1StandardBridge.depositETHTo{ value: amount }(to, l2GasLimit, \"\");\n        } else {\n            IERC20(l1Token).approve(address(l1StandardBridge), amount);\n            l1StandardBridge.depositERC20To(l1Token, l2Token, to, amount, l2GasLimit, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    // Added to enable the Optimism_Adapter to receive ETH. used when unwrapping WETH.\n    receive() external payable {}\n}\n"
    },
    "contracts/chain-adapters/Base_Adapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\nimport \"../interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract Base_Adapter is Ownable, AdapterInterface {\n    address public hubPool;\n\n    modifier onlyHubPool() {\n        require(msg.sender == hubPool, \"Can only be called by hubPool\");\n        _;\n    }\n\n    constructor(address _hubPool) {\n        hubPool = _hubPool;\n    }\n\n    function setHubPool(address _hubPool) public onlyOwner {\n        hubPool = _hubPool;\n        emit HubPoolChanged(_hubPool);\n    }\n}\n"
    },
    "@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\nimport \"./IL1ERC20Bridge.sol\";\n\n/**\n * @title IL1StandardBridge\n */\ninterface IL1StandardBridge is IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev Deposit an amount of the ETH to the caller's balance on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called\n     * before the withdrawal is finalized.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@eth-optimism/contracts/L1/messaging/IL1ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IL1ERC20Bridge\n */\ninterface IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L2 bridge contract.\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external returns (address);\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _amount Amount of the ERC20 to deposit\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ERC20 token.\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\n     *\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Data provided by the sender on L2. This data is provided\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\n     *   length, these contracts provide no guarantees about its content.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/chain-adapters/L1_Adapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Base_Adapter.sol\";\nimport \"../interfaces/AdapterInterface.sol\";\nimport \"../interfaces/WETH9.sol\";\n\nimport \"@uma/core/contracts/common/implementation/Lockable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract L1_Adapter is Base_Adapter, Lockable {\n    using SafeERC20 for IERC20;\n\n    constructor(address _hubPool) Base_Adapter(_hubPool) {}\n\n    function relayMessage(address target, bytes memory message) external payable override nonReentrant onlyHubPool {\n        _executeCall(target, message);\n        emit MessageRelayed(target, message);\n    }\n\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for L1.\n        uint256 amount,\n        address to\n    ) external payable override nonReentrant onlyHubPool {\n        IERC20(l1Token).safeTransfer(to, amount);\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    // Note: this snippet of code is copied from Governor.sol.\n    function _executeCall(address to, bytes memory data) private {\n        // Note: this snippet of code is copied from Governor.sol and modified to not include any \"value\" field.\n        // solhint-disable-next-line no-inline-assembly\n\n        bool success;\n        assembly {\n            let inputData := add(data, 0x20)\n            let inputDataSize := mload(data)\n            // Hardcode value to be 0 for relayed governance calls in order to avoid addressing complexity of bridging\n            // value cross-chain.\n            success := call(gas(), to, 0, inputData, inputDataSize, 0, 0)\n        }\n        require(success, \"execute call failed\");\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/chain-adapters/Arbitrum_Adapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Base_Adapter.sol\";\nimport \"../interfaces/AdapterInterface.sol\";\nimport \"../interfaces/WETH9.sol\";\n\nimport \"@uma/core/contracts/common/implementation/Lockable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ArbitrumL1InboxLike {\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n}\n\ninterface ArbitrumL1ERC20GatewayLike {\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n\ncontract Arbitrum_Adapter is Base_Adapter, Lockable {\n    // Gas limit for immediate L2 execution attempt (can be estimated via NodeInterface.estimateRetryableTicket).\n    // NodeInterface precompile interface exists at L2 address 0x00000000000000000000000000000000000000C8\n    uint32 public l2GasLimit = 5_000_000;\n\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    uint256 public l2MaxSubmissionCost = 0.1e18;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public l2GasPrice = 10e9; // 10 gWei\n\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\n    address public l2RefundL2Address;\n\n    ArbitrumL1InboxLike public l1Inbox;\n\n    ArbitrumL1ERC20GatewayLike public l1ERC20Gateway;\n\n    event L2GasLimitSet(uint32 newL2GasLimit);\n\n    event L2MaxSubmissionCostSet(uint256 newL2MaxSubmissionCost);\n\n    event L2GasPriceSet(uint256 newL2GasPrice);\n\n    event L2RefundL2AddressSet(address newL2RefundL2Address);\n\n    constructor(\n        address _hubPool,\n        ArbitrumL1InboxLike _l1ArbitrumInbox,\n        ArbitrumL1ERC20GatewayLike _l1ERC20Gateway\n    ) Base_Adapter(_hubPool) {\n        l1Inbox = _l1ArbitrumInbox;\n        l1ERC20Gateway = _l1ERC20Gateway;\n\n        l2RefundL2Address = owner();\n    }\n\n    function setL2GasLimit(uint32 _l2GasLimit) public onlyOwner {\n        l2GasLimit = _l2GasLimit;\n        emit L2GasLimitSet(l2GasLimit);\n    }\n\n    function setL2MaxSubmissionCost(uint256 _l2MaxSubmissionCost) public onlyOwner {\n        l2MaxSubmissionCost = _l2MaxSubmissionCost;\n        emit L2MaxSubmissionCostSet(l2MaxSubmissionCost);\n    }\n\n    function setL2GasPrice(uint256 _l2GasPrice) public onlyOwner {\n        l2GasPrice = _l2GasPrice;\n        emit L2GasPriceSet(l2GasPrice);\n    }\n\n    function setL2RefundL2Address(address _l2RefundL2Address) public onlyOwner {\n        l2RefundL2Address = _l2RefundL2Address;\n        emit L2RefundL2AddressSet(l2RefundL2Address);\n    }\n\n    function relayMessage(address target, bytes memory message) external payable override nonReentrant onlyHubPool {\n        uint256 requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n\n        l1Inbox.createRetryableTicket{ value: requiredL1CallValue }(\n            target, // destAddr destination L2 contract address\n            0, // l2CallValue call value for retryable L2 message\n            l2MaxSubmissionCost, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n            l2RefundL2Address, // excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n            l2RefundL2Address, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            l2GasLimit, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            l2GasPrice, // gasPriceBid price bid for L2 execution\n            message // data ABI encoded data of L2 message\n        );\n\n        emit MessageRelayed(target, message);\n    }\n\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override nonReentrant onlyHubPool {\n        l1ERC20Gateway.outboundTransfer(l1Token, to, amount, l2GasLimit, l2GasPrice, \"\");\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    function getL1CallValue() public view returns (uint256) {\n        return l2MaxSubmissionCost + l2GasPrice * l2GasLimit;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/Ethereum_SpokePool.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./interfaces/WETH9.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./SpokePool.sol\";\nimport \"./SpokePoolInterface.sol\";\n\n/**\n * @notice Ethereum L1 specific SpokePool.\n * @dev Used on Ethereum L1 to facilitate L2->L1 transfers.\n */\n\ncontract Ethereum_SpokePool is SpokePoolInterface, SpokePool, Ownable {\n    constructor(\n        address _l1EthWrapper,\n        address _l2Eth,\n        address _crossDomainAdmin,\n        address _hubPool,\n        address _wethAddress,\n        address timerAddress\n    ) SpokePool(_crossDomainAdmin, _hubPool, _wethAddress, timerAddress) {}\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    function setCrossDomainAdmin(address newCrossDomainAdmin) public override onlyOwner nonReentrant {\n        _setCrossDomainAdmin(newCrossDomainAdmin);\n    }\n\n    function setHubPool(address newHubPool) public override onlyOwner nonReentrant {\n        _setHubPool(newHubPool);\n    }\n\n    function setEnableRoute(\n        address originToken,\n        uint256 destinationChainId,\n        bool enable\n    ) public override onlyOwner nonReentrant {\n        _setEnableRoute(originToken, destinationChainId, enable);\n    }\n\n    function setDepositQuoteTimeBuffer(uint32 buffer) public override onlyOwner nonReentrant {\n        _setDepositQuoteTimeBuffer(buffer);\n    }\n\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayFulfillmentRoot)\n        public\n        override\n        onlyOwner\n        nonReentrant\n    {\n        _relayRootBundle(relayerRefundRoot, slowRelayFulfillmentRoot);\n    }\n\n    function _bridgeTokensToHubPool(RelayerRefundLeaf memory relayerRefundLeaf) internal override {\n        IERC20(relayerRefundLeaf.l2TokenAddress).transfer(hubPool, relayerRefundLeaf.amountToReturn);\n    }\n}\n"
    },
    "contracts/chain-adapters/Mock_Adapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Base_Adapter.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @notice Sends cross chain messages Optimism L2 network.\n * @dev This contract's owner should be set to the BridgeAdmin deployed on the same L1 network so that only the\n * BridgeAdmin can call cross-chain administrative functions on the L2 SpokePool via this messenger.\n */\ncontract Mock_Adapter is Base_Adapter {\n    event RelayMessageCalled(address target, bytes message, address caller);\n\n    event RelayTokensCalled(address l1Token, address l2Token, uint256 amount, address to, address caller);\n\n    function relayMessage(address target, bytes memory message) external payable override onlyHubPool {\n        emit RelayMessageCalled(target, message, msg.sender);\n    }\n\n    constructor(address _hubPool) Base_Adapter(_hubPool) {}\n\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override onlyHubPool {\n        emit RelayTokensCalled(l1Token, l2Token, amount, to, msg.sender);\n    }\n}\n"
    },
    "contracts/test/MerkleLibTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../MerkleLib.sol\";\nimport \"../HubPoolInterface.sol\";\nimport \"../SpokePoolInterface.sol\";\n\n/**\n * @notice Contract to test the MerkleLib.\n */\ncontract MerkleLibTest {\n    mapping(uint256 => uint256) public claimedBitMap;\n\n    uint256 public claimedBitMap1D;\n\n    function verifyPoolRebalance(\n        bytes32 root,\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifyPoolRebalance(root, rebalance, proof);\n    }\n\n    function verifyRelayerRefund(\n        bytes32 root,\n        SpokePoolInterface.RelayerRefundLeaf memory refund,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifyRelayerRefund(root, refund, proof);\n    }\n\n    function verifySlowRelayFulfillment(\n        bytes32 root,\n        SpokePoolInterface.RelayData memory slowRelayFulfillment,\n        bytes32[] memory proof\n    ) public pure returns (bool) {\n        return MerkleLib.verifySlowRelayFulfillment(root, slowRelayFulfillment, proof);\n    }\n\n    function isClaimed(uint256 index) public view returns (bool) {\n        return MerkleLib.isClaimed(claimedBitMap, index);\n    }\n\n    function setClaimed(uint256 index) public {\n        MerkleLib.setClaimed(claimedBitMap, index);\n    }\n\n    function isClaimed1D(uint256 index) public view returns (bool) {\n        return MerkleLib.isClaimed1D(claimedBitMap1D, index);\n    }\n\n    function setClaimed1D(uint256 index) public {\n        claimedBitMap1D = MerkleLib.setClaimed1D(claimedBitMap1D, index);\n    }\n}\n"
    },
    "@uma/core/contracts/common/interfaces/ExpandedIERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title ERC20 interface that includes burn and mint methods.\n */\nabstract contract ExpandedIERC20 is IERC20 {\n    /**\n     * @notice Burns a specific amount of the caller's tokens.\n     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\n     */\n    function burn(uint256 value) external virtual;\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     */\n    function burnFrom(address recipient, uint256 value) external virtual returns (bool);\n\n    /**\n     * @notice Mints tokens and adds them to the balance of the `to` address.\n     * @dev This method should be permissioned to only allow designated parties to mint tokens.\n     */\n    function mint(address to, uint256 value) external virtual returns (bool);\n\n    function addMinter(address account) external virtual;\n\n    function addBurner(address account) external virtual;\n\n    function resetOwner(address account) external virtual;\n}\n"
    },
    "@uma/core/contracts/common/implementation/ExpandedERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./MultiRole.sol\";\nimport \"../interfaces/ExpandedIERC20.sol\";\n\n/**\n * @title An ERC20 with permissioned burning and minting. The contract deployer will initially\n * be the owner who is capable of adding new roles.\n */\ncontract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\n    enum Roles {\n        // Can set the minter and burner.\n        Owner,\n        // Addresses that can mint new tokens.\n        Minter,\n        // Addresses that can burn tokens that address owns.\n        Burner\n    }\n\n    uint8 _decimals;\n\n    /**\n     * @notice Constructs the ExpandedERC20.\n     * @param _tokenName The name which describes the new token.\n     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\n     * @param _tokenDecimals The number of decimals to define token precision.\n     */\n    constructor(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _tokenDecimals\n    ) ERC20(_tokenName, _tokenSymbol) {\n        _decimals = _tokenDecimals;\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));\n        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\n     * @param recipient address to mint to.\n     * @param value amount of tokens to mint.\n     * @return True if the mint succeeded, or False.\n     */\n    function mint(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Minter))\n        returns (bool)\n    {\n        _mint(recipient, value);\n        return true;\n    }\n\n    /**\n     * @dev Burns `value` tokens owned by `msg.sender`.\n     * @param value amount of tokens to burn.\n     */\n    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns `value` tokens owned by `recipient`.\n     * @param recipient address to burn tokens from.\n     * @param value amount of tokens to burn.\n     * @return True if the burn succeeded, or False.\n     */\n    function burnFrom(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Burner))\n        returns (bool)\n    {\n        _burn(recipient, value);\n        return true;\n    }\n\n    /**\n     * @notice Add Minter role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Minter role is added.\n     */\n    function addMinter(address account) external virtual override {\n        addMember(uint256(Roles.Minter), account);\n    }\n\n    /**\n     * @notice Add Burner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Burner role is added.\n     */\n    function addBurner(address account) external virtual override {\n        addMember(uint256(Roles.Burner), account);\n    }\n\n    /**\n     * @notice Reset Owner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The new holder of the Owner role.\n     */\n    function resetOwner(address account) external virtual override {\n        resetMember(uint256(Roles.Owner), account);\n    }\n}\n"
    },
    "@uma/core/contracts/common/implementation/MultiRole.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nlibrary Exclusive {\n    struct RoleMembership {\n        address member;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.member == memberToCheck;\n    }\n\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\n        roleMembership.member = newMember;\n    }\n\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\n        return roleMembership.member;\n    }\n\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\n        resetMember(roleMembership, initialMember);\n    }\n}\n\nlibrary Shared {\n    struct RoleMembership {\n        mapping(address => bool) members;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.members[memberToCheck];\n    }\n\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\n        require(memberToAdd != address(0x0), \"Cannot add 0x0 to a shared role\");\n        roleMembership.members[memberToAdd] = true;\n    }\n\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\n        roleMembership.members[memberToRemove] = false;\n    }\n\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\n        for (uint256 i = 0; i < initialMembers.length; i++) {\n            addMember(roleMembership, initialMembers[i]);\n        }\n    }\n}\n\n/**\n * @title Base class to manage permissions for the derived class.\n */\nabstract contract MultiRole {\n    using Exclusive for Exclusive.RoleMembership;\n    using Shared for Shared.RoleMembership;\n\n    enum RoleType { Invalid, Exclusive, Shared }\n\n    struct Role {\n        uint256 managingRole;\n        RoleType roleType;\n        Exclusive.RoleMembership exclusiveRoleMembership;\n        Shared.RoleMembership sharedRoleMembership;\n    }\n\n    mapping(uint256 => Role) private roles;\n\n    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\n\n    /**\n     * @notice Reverts unless the caller is a member of the specified roleId.\n     */\n    modifier onlyRoleHolder(uint256 roleId) {\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\n     */\n    modifier onlyRoleManager(uint256 roleId) {\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\n     */\n    modifier onlyExclusive(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\n     */\n    modifier onlyShared(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\n        _;\n    }\n\n    /**\n     * @notice Whether `memberToCheck` is a member of roleId.\n     * @dev Reverts if roleId does not correspond to an initialized role.\n     * @param roleId the Role to check.\n     * @param memberToCheck the address to check.\n     * @return True if `memberToCheck` is a member of `roleId`.\n     */\n    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        revert(\"Invalid roleId\");\n    }\n\n    /**\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n     * initialized, ExclusiveRole.\n     * @param roleId the ExclusiveRole membership to modify.\n     * @param newMember the new ExclusiveRole member.\n     */\n    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Gets the current holder of the exclusive role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n     * @param roleId the ExclusiveRole membership to check.\n     * @return the address of the current ExclusiveRole member.\n     */\n    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n        return roles[roleId].exclusiveRoleMembership.getMember();\n    }\n\n    /**\n     * @notice Adds `newMember` to the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param newMember the new SharedRole member.\n     */\n    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n        emit AddedSharedMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param memberToRemove the current SharedRole member to remove.\n     */\n    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n    }\n\n    /**\n     * @notice Removes caller from the role, `roleId`.\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n     * initialized, SharedRole.\n     * @param roleId the SharedRole membership to modify.\n     */\n    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Reverts if `roleId` is not initialized.\n     */\n    modifier onlyValidRole(uint256 roleId) {\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if `roleId` is initialized.\n     */\n    modifier onlyInvalidRole(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\n        _;\n    }\n\n    /**\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMembers` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createSharedRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address[] memory initialMembers\n    ) internal onlyInvalidRole(roleId) {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Shared;\n        role.managingRole = managingRoleId;\n        role.sharedRoleMembership.init(initialMembers);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage a shared role\"\n        );\n    }\n\n    /**\n     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMember` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createExclusiveRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address initialMember\n    ) internal onlyInvalidRole(roleId) {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Exclusive;\n        role.managingRole = managingRoleId;\n        role.exclusiveRoleMembership.init(initialMember);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage an exclusive role\"\n        );\n    }\n}\n"
    },
    "contracts/LpTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LpTokenFactoryInterface.sol\";\n\nimport \"@uma/core/contracts/common/implementation/ExpandedERC20.sol\";\n\ncontract LpTokenFactory is LpTokenFactoryInterface {\n    function createLpToken(address l1Token) public returns (address) {\n        ExpandedERC20 lpToken = new ExpandedERC20(\n            _append(\"Across \", IERC20Metadata(l1Token).name(), \" LP Token\"), // LP Token Name\n            _append(\"Av2-\", IERC20Metadata(l1Token).symbol(), \"-LP\"), // LP Token Symbol\n            IERC20Metadata(l1Token).decimals() // LP Token Decimals\n        );\n        lpToken.addMember(1, msg.sender); // Set this contract as the LP Token's minter.\n        lpToken.addMember(2, msg.sender); // Set this contract as the LP Token's burner.\n\n        return address(lpToken);\n    }\n\n    function _append(\n        string memory a,\n        string memory b,\n        string memory c\n    ) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b, c));\n    }\n}\n"
    },
    "contracts/interfaces/LpTokenFactoryInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface LpTokenFactoryInterface {\n    function createLpToken(address l1Token) external returns (address);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/SkinnyOptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/OptimisticOracleInterface.sol\";\n\n/**\n * @title Interface for the gas-cost-reduced version of the OptimisticOracle.\n * @notice Differences from normal OptimisticOracle:\n * - refundOnDispute: flag is removed, by default there are no refunds on disputes.\n * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset\n *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be\n *   set in `requestPrice`, which has an expanded input set.\n * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price\n *   can be fetched via the `Settle` event or the return value of `settle`.\n * - general changes to interface: Functions that interact with existing requests all require the parameters of the\n *   request to modify to be passed as input. These parameters must match with the existing request parameters or the\n *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the\n *   full request struct.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract SkinnyOptimisticOracleInterface {\n    // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\n    // in that refundOnDispute is removed.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n    // to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n     * @param customLiveness custom proposal liveness to set for request.\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward,\n        uint256 bond,\n        uint256 customLiveness\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * propose a price for.\n     * @param proposer address to set as the proposer.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        address proposer,\n        int256 proposedPrice\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value where caller is the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * propose a price for.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\n     * @dev The caller is the requester, but the proposer can be customized.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n     * @param customLiveness custom proposal liveness to set for request.\n     * @param proposer address to set as the proposer.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function requestAndProposePriceFor(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward,\n        uint256 bond,\n        uint256 customLiveness,\n        address proposer,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * dispute.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request,\n        address disputer,\n        address requester\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * dispute.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters whose hash must match the request that the caller wants to\n     * settle.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     * @return resolvedPrice the price that the request settled to.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (uint256 payout, int256 resolvedPrice);\n\n    /**\n     * @notice Computes the current state of a price request. See the State enum for more details.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters.\n     * @return the State.\n     */\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) external virtual returns (OptimisticOracleInterface.State);\n\n    /**\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\n     * will revert.\n     * @return boolean indicating true if price exists and false if not.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint32 timestamp,\n        bytes memory ancillaryData,\n        Request memory request\n    ) public virtual returns (bool);\n\n    /**\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param requester sender of the initial price request.\n     * @return the stamped ancillary bytes.\n     */\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        pure\n        virtual\n        returns (bytes memory);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/OptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OptimisticOracleInterface {\n    // Struct representing the state of a price request.\n    enum State {\n        Invalid, // Never requested.\n        Requested, // Requested, no other actions taken.\n        Proposed, // Proposed, but not expired or disputed yet.\n        Expired, // Proposed, not disputed, past liveness.\n        Disputed, // Disputed, but no DVM price returned yet.\n        Resolved, // Disputed and DVM price is available.\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\n    }\n\n    // Struct representing a price request.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n    // to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Set the proposal bond associated with a price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param bond custom bond amount to set.\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n     * changed again with a subsequent call to setBond().\n     */\n    function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 bond\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n     * bond, so there is still profit to be made even if the reward is refunded.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n    function setRefundOnDispute(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual;\n\n    /**\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n     * being auto-resolved.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param customLiveness new custom liveness.\n     */\n    function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external virtual;\n\n    /**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param proposer address to set as the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePriceFor(\n        address proposer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Proposes a price value for an existing price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n    function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\n     */\n    function disputePriceFor(\n        address disputer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Disputes a price value for an existing price request with an active proposal.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n    function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 totalBond);\n\n    /**\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n     * hasn't been settled.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return resolved price.\n     */\n    function settleAndGetPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (int256);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external virtual returns (uint256 payout);\n\n    /**\n     * @notice Gets the current data structure containing all information about a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the Request data structure.\n     */\n    function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (Request memory);\n\n    /**\n     * @notice Returns the state of a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the State enum value.\n     */\n    function getState(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (State);\n\n    /**\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return true if price has resolved or settled, false otherwise.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view virtual returns (bool);\n\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\n        public\n        view\n        virtual\n        returns (bytes memory);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/StoreInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\n\n/**\n * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\n */\ninterface StoreInterface {\n    /**\n     * @notice Pays Oracle fees in ETH to the store.\n     * @dev To be used by contracts whose margin currency is ETH.\n     */\n    function payOracleFees() external payable;\n\n    /**\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\n     * @param erc20Address address of the ERC20 token used to pay the fee.\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\n     */\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\n\n    /**\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\n     * @param startTime defines the beginning time from which the fee is paid.\n     * @param endTime end time until which the fee is paid.\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\n     * @return latePenalty for paying the fee after the deadline.\n     */\n    function computeRegularFee(\n        uint256 startTime,\n        uint256 endTime,\n        FixedPoint.Unsigned calldata pfc\n    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\n\n    /**\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\n     * @param currency token used to pay the final fee.\n     * @return finalFee amount due.\n     */\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\n}\n"
    },
    "@uma/core/contracts/common/implementation/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/FinderInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Provides addresses of the live contracts implementing certain interfaces.\n * @dev Examples are the Oracle or Store interfaces.\n */\ninterface FinderInterface {\n    /**\n     * @notice Updates the address of the contract that implements `interfaceName`.\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n     * @param implementationAddress address of the deployed contract that implements the interface.\n     */\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n\n    /**\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\n     * @param interfaceName queried interface.\n     * @return implementationAddress address of the deployed contract that implements the interface.\n     */\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n}\n"
    },
    "@uma/core/contracts/oracle/interfaces/IdentifierWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\n */\ninterface IdentifierWhitelistInterface {\n    /**\n     * @notice Adds the provided identifier as a supported identifier.\n     * @dev Price requests using this identifier will succeed after this call.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     */\n    function addSupportedIdentifier(bytes32 identifier) external;\n\n    /**\n     * @notice Removes the identifier from the whitelist.\n     * @dev Price requests using this identifier will no longer succeed after this call.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     */\n    function removeSupportedIdentifier(bytes32 identifier) external;\n\n    /**\n     * @notice Checks whether an identifier is on the whitelist.\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n     * @return bool if the identifier is supported (or not).\n     */\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\n}\n"
    },
    "@uma/core/contracts/common/interfaces/AddressWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface AddressWhitelistInterface {\n    function addToWhitelist(address newElement) external;\n\n    function removeFromWhitelist(address newElement) external;\n\n    function isOnWhitelist(address newElement) external view returns (bool);\n\n    function getWhitelist() external view returns (address[] memory);\n}\n"
    },
    "@uma/core/contracts/common/implementation/AncillaryData.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Library for encoding and decoding ancillary data for DVM price requests.\n * @notice  We assume that on-chain ancillary data can be formatted directly from bytes to utf8 encoding via\n * web3.utils.hexToUtf8, and that clients will parse the utf8-encoded ancillary data as a comma-delimitted key-value\n * dictionary. Therefore, this library provides internal methods that aid appending to ancillary data from Solidity\n * smart contracts. More details on UMA's ancillary data guidelines below:\n * https://docs.google.com/document/d/1zhKKjgY1BupBGPPrY_WOJvui0B6DMcd-xDR8-9-SPDw/edit\n */\nlibrary AncillaryData {\n    // This converts the bottom half of a bytes32 input to hex in a highly gas-optimized way.\n    // Source: the brilliant implementation at https://gitter.im/ethereum/solidity?at=5840d23416207f7b0ed08c9b.\n    function toUtf8Bytes32Bottom(bytes32 bytesIn) private pure returns (bytes32) {\n        unchecked {\n            uint256 x = uint256(bytesIn);\n\n            // Nibble interleave\n            x = x & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n            x = (x | (x * 2**64)) & 0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\n            x = (x | (x * 2**32)) & 0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\n            x = (x | (x * 2**16)) & 0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\n            x = (x | (x * 2**8)) & 0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\n            x = (x | (x * 2**4)) & 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n\n            // Hex encode\n            uint256 h = (x & 0x0808080808080808080808080808080808080808080808080808080808080808) / 8;\n            uint256 i = (x & 0x0404040404040404040404040404040404040404040404040404040404040404) / 4;\n            uint256 j = (x & 0x0202020202020202020202020202020202020202020202020202020202020202) / 2;\n            x = x + (h & (i | j)) * 0x27 + 0x3030303030303030303030303030303030303030303030303030303030303030;\n\n            // Return the result.\n            return bytes32(x);\n        }\n    }\n\n    /**\n     * @notice Returns utf8-encoded bytes32 string that can be read via web3.utils.hexToUtf8.\n     * @dev Will return bytes32 in all lower case hex characters and without the leading 0x.\n     * This has minor changes from the toUtf8BytesAddress to control for the size of the input.\n     * @param bytesIn bytes32 to encode.\n     * @return utf8 encoded bytes32.\n     */\n    function toUtf8Bytes(bytes32 bytesIn) internal pure returns (bytes memory) {\n        return abi.encodePacked(toUtf8Bytes32Bottom(bytesIn >> 128), toUtf8Bytes32Bottom(bytesIn));\n    }\n\n    /**\n     * @notice Returns utf8-encoded address that can be read via web3.utils.hexToUtf8.\n     * Source: https://ethereum.stackexchange.com/questions/8346/convert-address-to-string/8447#8447\n     * @dev Will return address in all lower case characters and without the leading 0x.\n     * @param x address to encode.\n     * @return utf8 encoded address bytes.\n     */\n    function toUtf8BytesAddress(address x) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(toUtf8Bytes32Bottom(bytes32(bytes20(x)) >> 128), bytes8(toUtf8Bytes32Bottom(bytes20(x))));\n    }\n\n    /**\n     * @notice Converts a uint into a base-10, UTF-8 representation stored in a `string` type.\n     * @dev This method is based off of this code: https://stackoverflow.com/a/65707309.\n     */\n    function toUtf8BytesUint(uint256 x) internal pure returns (bytes memory) {\n        if (x == 0) {\n            return \"0\";\n        }\n        uint256 j = x;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (x != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(x - (x / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            x /= 10;\n        }\n        return bstr;\n    }\n\n    function appendKeyValueBytes32(\n        bytes memory currentAncillaryData,\n        bytes memory key,\n        bytes32 value\n    ) internal pure returns (bytes memory) {\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8Bytes(value));\n    }\n\n    /**\n     * @notice Adds \"key:value\" to `currentAncillaryData` where `value` is an address that first needs to be converted\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\"k1:v1\"`, then this function will return\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\n     * @param value An address to set as the value in the key:value pair to append to `currentAncillaryData`.\n     * @return Newly appended ancillary data.\n     */\n    function appendKeyValueAddress(\n        bytes memory currentAncillaryData,\n        bytes memory key,\n        address value\n    ) internal pure returns (bytes memory) {\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesAddress(value));\n    }\n\n    /**\n     * @notice Adds \"key:value\" to `currentAncillaryData` where `value` is a uint that first needs to be converted\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\"k1:v1\"`, then this function will return\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\n     * @param value A uint to set as the value in the key:value pair to append to `currentAncillaryData`.\n     * @return Newly appended ancillary data.\n     */\n    function appendKeyValueUint(\n        bytes memory currentAncillaryData,\n        bytes memory key,\n        uint256 value\n    ) internal pure returns (bytes memory) {\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesUint(value));\n    }\n\n    /**\n     * @notice Helper method that returns the left hand side of a \"key:value\" pair plus the colon \":\" and a leading\n     * comma \",\" if the `currentAncillaryData` is not empty. The return value is intended to be prepended as a prefix to\n     * some utf8 value that is ultimately added to a comma-delimited, key-value dictionary.\n     */\n    function constructPrefix(bytes memory currentAncillaryData, bytes memory key) internal pure returns (bytes memory) {\n        if (currentAncillaryData.length > 0) {\n            return abi.encodePacked(\",\", key, \":\");\n        } else {\n            return abi.encodePacked(key, \":\");\n        }\n    }\n}\n"
    },
    "@uma/core/contracts/oracle/implementation/Constants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\n */\nlibrary OracleInterfaces {\n    bytes32 public constant Oracle = \"Oracle\";\n    bytes32 public constant IdentifierWhitelist = \"IdentifierWhitelist\";\n    bytes32 public constant Store = \"Store\";\n    bytes32 public constant FinancialContractsAdmin = \"FinancialContractsAdmin\";\n    bytes32 public constant Registry = \"Registry\";\n    bytes32 public constant CollateralWhitelist = \"CollateralWhitelist\";\n    bytes32 public constant OptimisticOracle = \"OptimisticOracle\";\n    bytes32 public constant Bridge = \"Bridge\";\n    bytes32 public constant GenericHandler = \"GenericHandler\";\n    bytes32 public constant SkinnyOptimisticOracle = \"SkinnyOptimisticOracle\";\n    bytes32 public constant ChildMessenger = \"ChildMessenger\";\n    bytes32 public constant OracleHub = \"OracleHub\";\n    bytes32 public constant OracleSpoke = \"OracleSpoke\";\n}\n\n/**\n * @title Commonly re-used values for contracts associated with the OptimisticOracle.\n */\nlibrary OptimisticOracleConstraints {\n    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible\n    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which\n    // refuses to accept a price request made with ancillary data length over a certain size.\n    uint256 public constant ancillaryBytesLimit = 8192;\n}\n"
    },
    "contracts/Lockable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n */\ncontract Lockable {\n    bool internal _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is currently in a non-entered state, meaning that the origination of the call\n     * came from outside the contract. This is relevant with fallback/receive methods to see if the call came from ETH\n     * being dropped onto the contract externally or due to ETH dropped on the the contract from within a method in this\n     * contract, such as unwrapping WETH to ETH within the contract.\n     */\n    function functionCallStackOriginatesFromOutsideThisContract() internal view returns (bool) {\n        return _notEntered;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\n    // then call `_postEntranceReset()`.\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
