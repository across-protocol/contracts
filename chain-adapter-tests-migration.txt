# Chain Adapter Tests Migration Progress

## Ethereum_Adapter

**Date**: 2026-01-07
**Status**: Completed

### Tests Migrated

| # | Hardhat Test Name | Foundry Test Name |
|---|------------------|-------------------|
| 1 | relayMessage calls spoke pool functions | test_relayMessage_CallsSpokePoolFunctions |
| 2 | Correctly transfers tokens when executing pool rebalance | test_relayTokens_TransfersTokensOnPoolRebalance |

### Mocks Used

- `MockSpokePool` from `contracts/test/MockSpokePool.sol` - Deployed as UUPS proxy via `ERC1967Proxy`

### New Mocks/Utilities Created

- None - used existing MockSpokePool

### Deviations from Original

- None significant. The Foundry test additionally verifies the DAI token balance change after pool rebalance execution.

### Notes

- Ethereum_Adapter is a pass-through adapter for same-chain communication (HubPool to Ethereum_SpokePool)
- The adapter's `relayMessage` directly calls the target contract
- The adapter's `relayTokens` uses safeTransfer to send tokens
- No external bridge mocks are needed as this is L1-to-L1 communication
- HubPool must be the owner of MockSpokePool since the adapter calls target directly via delegatecall context, and MockSpokePool's `_requireAdminSender` is `onlyOwner`
- MockSpokePool requires UUPS proxy deployment pattern: `new ERC1967Proxy(address(new MockSpokePool(weth)), abi.encodeCall(MockSpokePool.initialize, (...)))`
- Address constants used instead of inline `makeAddr()` calls

---

## Arbitrum_SendTokensAdapter

**Date**: 2026-01-07
**Status**: Completed

### Tests Migrated

| # | Hardhat Test Name | Foundry Test Name |
|---|------------------|-------------------|
| 1 | relayMessage sends desired ERC20 in specified amount to SpokePool | test_relayMessage_SendsDesiredERC20InSpecifiedAmountToSpokePool |

### Mocks Used

- `ArbitrumMockErc20GatewayRouter` from `contracts/test/ArbitrumMocks.sol`

### New Mocks/Utilities Created

- None - used existing ArbitrumMocks.sol

### Deviations from Original

- None. The test verifies the same behavior: event emission, ETH balance change, and WETH allowance set.

### Notes

- Arbitrum_SendTokensAdapter is an emergency adapter for sending tokens from HubPool to SpokePool
- Unlike the main Arbitrum_Adapter, this only implements `relayMessage` (not `relayTokens`)
- The message format is `abi.encode(address token, uint256 amount)`
- Uses `relaySpokePoolAdminFunction` instead of `executeRootBundle`
- The adapter approves the gateway (obtained via `getGateway`), not the router itself
- Constants match the adapter: `l2MaxSubmissionCost = 0.01 ether`, `l2GasPrice = 5 gwei`, `RELAY_TOKENS_L2_GAS_LIMIT = 300_000`

---

## Solana_Adapter

**Date**: 2026-01-07
**Status**: Completed

### Tests Migrated

| # | Hardhat Test Name | Foundry Test Name |
|---|------------------|-------------------|
| 1 | relayMessage calls spoke pool functions | test_relayMessage_CallsSpokePoolFunctions |
| 2 | Correctly calls the CCTP bridge adapter when attempting to bridge USDC | test_relayTokens_BridgesUsdcViaCCTP |

### Mocks Used

- `MockCCTPMinter` from `contracts/test/MockCCTP.sol`
- `MockCCTPMessenger` from `contracts/test/MockCCTP.sol`
- `MockCCTPMessageTransmitter` from `contracts/test/MockCCTP.sol` (newly added)

### New Mocks/Utilities Created

- `MockCCTPMessageTransmitter` in `contracts/test/MockCCTP.sol` - Implements `IMessageTransmitter.sendMessage()` for testing CCTP message relay functionality

### Deviations from Original

- None significant. The Foundry test verifies the same behavior and event emissions.

### Notes

- Solana_Adapter is a CCTP-only adapter for bridging to Solana (non-EVM chain)
- Uses `IMessageTransmitter.sendMessage()` for relaying messages via CCTP
- Uses `ITokenMessenger.depositForBurn()` for bridging USDC via CCTP
- Solana addresses are bytes32 (base58-decoded), converted to EVM address via `Bytes32ToAddress.toAddressUnchecked()` (lowest 20 bytes)
- Circle domain ID for Solana is 5 (`CircleDomainIds.Solana`)
- Test chain ID is a placeholder (1234567890) since Solana is not an EVM chain
- The adapter sends tokens to `solanaSpokePoolUsdcVaultBytes32` (the vault ATA), not directly to spoke pool
- Updated to use smock-style `lastXxxCall()` pattern for parameter verification (consistent with other adapter tests)

---

## Optimism_Adapter

**Date**: 2026-01-08
**Status**: Completed

### Tests Migrated

| # | Hardhat Test Name | Foundry Test Name |
|---|------------------|-------------------|
| 1 | relayMessage calls spoke pool functions | test_relayMessage_CallsSpokePoolFunctions |
| 2 | Correctly calls appropriate Optimism bridge functions when making ERC20 cross chain calls | test_relayTokens_BridgesERC20ViaStandardBridge |
| 3 | Correctly unwraps WETH and bridges ETH | test_relayTokens_UnwrapsWETHAndBridgesETH |
| 4 | Correctly calls the CCTP bridge adapter when attempting to bridge USDC | test_relayTokens_BridgesUsdcViaCCTP |

### Mocks Used

- `MockBedrockL1StandardBridge` from `contracts/test/MockBedrockStandardBridge.sol` (enhanced)
- `MockBedrockCrossDomainMessenger` from `contracts/test/MockBedrockStandardBridge.sol` (enhanced)
- `MockCCTPMinter` from `contracts/test/MockCCTP.sol`
- `MockCCTPMessenger` from `contracts/test/MockCCTP.sol`
- `MockSpokePool` from `contracts/test/MockSpokePool.sol`

### New Mocks/Utilities Created

- Enhanced `MockBedrockL1StandardBridge` with:
  - `depositERC20ToCallCount` - call counter
  - `depositETHToCallCount` - call counter
  - `lastDepositERC20ToCall` - struct storing last call parameters (smock-style)
  - `lastDepositETHToCall` - struct storing last call parameters (smock-style)

- Enhanced `MockBedrockCrossDomainMessenger` with:
  - `sendMessageCallCount` - call counter
  - `lastSendMessageCall` - struct storing last call parameters (smock-style)

- Enhanced `MockCCTPMessenger` with:
  - `lastDepositForBurnCall` - struct storing last call parameters (smock-style)

- Enhanced `MockCCTPMessageTransmitter` with:
  - `lastSendMessageCall` - struct storing last call parameters (smock-style)

### Deviations from Original

- None significant. The Foundry test verifies the same behavior using the smock-style `lastXxxCall()` pattern instead of `vm.expectEmit` due to event ordering complexity with HubPool's additional events (SpokePoolAdminFunctionTriggered, RootBundleExecuted). This pattern is closer to how Hardhat's smock library works with `calledWith` assertions.

### Notes

- Optimism_Adapter bridges via three mechanisms:
  1. L1CrossDomainMessenger.sendMessage() for admin messages
  2. L1StandardBridge.depositETHTo() for WETH (unwraps to ETH first)
  3. L1StandardBridge.depositERC20To() for ERC20 tokens (except USDC)
  4. CCTP depositForBurn() for USDC
- The adapter also supports custom bridges for DAI and SNX, but these are not tested in the Hardhat suite
- L2_GAS constant is 200,000
- WETH test requires extra ETH/WETH for the HubPool bond (BOND_AMOUNT = 5 ether)
- Circle domain ID for Optimism is obtained via `CircleDomainIds.Optimism`
- The adapter is called via delegatecall from HubPool, so events appear from HubPool's address

---

## Scroll_Adapter

**Date**: 2026-01-08
**Status**: Completed

### Tests Migrated

| # | Hardhat Test Name | Foundry Test Name |
|---|------------------|-------------------|
| 1 | relayMessage fails when there's not enough fees | test_relayMessage_RevertsWhenInsufficientFees |
| 2 | relayMessage calls spoke pool functions | test_relayMessage_CallsSpokePoolFunctions |
| 3 | Correctly calls appropriate scroll bridge functions when transferring tokens to different chains | test_relayTokens_BridgesTokensViaGatewayRouter |

### Mocks Used

- **No custom mock contracts** - uses `vm.mockCall` and `vm.expectCall` cheatcodes instead
- `MockSpokePool` from `contracts/test/MockSpokePool.sol` (still needed as a real target)

### New Mocks/Utilities Created

- None - this test demonstrates using Foundry's native mocking capabilities:
  - `vm.etch(address, hex"00")` - puts dummy bytecode at addresses to pass `extcodesize` checks
  - `vm.mockCall(address, selector, returnData)` - mocks return values for external calls
  - `vm.expectCall(address, value, calldata)` - verifies calls are made with correct parameters

### Deviations from Original

- Uses `vm.mockCall`/`vm.expectCall` instead of custom mock contracts (FakeContract equivalent)
- For the revert test, used `vm.expectRevert()` without specific error message since delegatecall context can strip error data

### Notes

- **Pattern: vm.mockCall + vm.expectCall as FakeContract alternative**
  - `vm.mockCall` replaces mock contracts that return specific values
  - `vm.expectCall` replaces call counters and parameter verification (smock's `calledWith`)
  - `vm.etch` ensures addresses have code (avoids extcodesize check failures)
  - Limitation: Cannot implement side effects (e.g., token transfers) - only mocks return values
- Scroll_Adapter bridges via two mechanisms:
  1. L1ScrollMessenger.sendMessage() for admin messages - pays relayer fee from gas price oracle
  2. L1GatewayRouter.depositERC20() for all ERC20 tokens including WETH - also pays relayer fee
- The adapter has configurable gas limits:
  - L2_MESSAGE_RELAY_GAS_LIMIT = 2,000,000 for messages
  - L2_TOKEN_RELAY_GAS_LIMIT = 250,000 for tokens
- Relayer fees are obtained from IL2GasPriceOracle.estimateCrossDomainMessageFee()
- Test chain ID is 534351 (Scroll Sepolia testnet, matching Hardhat test)
- Scroll uses the same gateway for WETH and ERC20s (no special WETH unwrapping like Optimism)

---

## PolygonZkEVM_Adapter

**Date**: 2026-01-08
**Status**: Completed

### Tests Migrated

| # | Hardhat Test Name | Foundry Test Name |
|---|------------------|-------------------|
| 1 | relayMessage calls spoke pool functions | test_relayMessage_CallsSpokePoolFunctions |
| 2 | Correctly calls appropriate bridge functions when making WETH cross chain calls | test_relayTokens_BridgesWethAsEth |
| 3 | Correctly calls appropriate bridge functions when making ERC20 cross chain calls | test_relayTokens_BridgesErc20 |

### Mocks Used

- **No custom mock contracts** - uses `vm.mockCall` and `vm.expectCall` cheatcodes
- `MockSpokePool` from `contracts/test/MockSpokePool.sol` (still needed as a real target)

### New Mocks/Utilities Created

- None - uses Foundry's native mocking capabilities (same pattern as Scroll_Adapter.t.sol)

### Deviations from Original

- None significant. Uses `vm.mockCall`/`vm.expectCall` instead of smock FakeContract, but verifies the same behavior.

### Notes

- **Pattern: vm.mockCall + vm.expectCall (following Scroll_Adapter precedent)**
  - `vm.etch(address, hex"00")` puts dummy bytecode at bridge address
  - `vm.mockCall` mocks `bridgeMessage` and `bridgeAsset` return values
  - `vm.expectCall` verifies calls with correct parameters and msg.value
- PolygonZkEVM_Adapter bridges via:
  1. `IPolygonZkEVMBridge.bridgeMessage()` for admin messages (no fee required)
  2. `IPolygonZkEVMBridge.bridgeAsset()` for tokens - with special WETH handling
- WETH bridging: Adapter unwraps WETH to ETH, calls `bridgeAsset{value: amount}` with `token=address(0)`
- ERC20 bridging: Adapter approves bridge, calls `bridgeAsset` with token address (no msg.value)
- Constants:
  - `POLYGON_ZKEVM_CHAIN_ID = 1101`
  - `POLYGON_ZKEVM_L2_NETWORK_ID = 1` (Polygon's internal network ID)
  - `forceUpdateGlobalExitRoot = true` (always set for immediate finality)
  - `permitData = ""` (not used in these tests)
- Unlike Scroll, no relayer fee is required - calls are made with msg.value=0 for messages

---

## Linea_Adapter

**Date**: 2026-01-08
**Status**: Completed

### Tests Migrated

| # | Hardhat Test Name | Foundry Test Name |
|---|------------------|-------------------|
| 1 | relayMessage calls spoke pool functions | test_relayMessage_CallsSpokePoolFunctions |
| 2 | Correctly calls appropriate bridge functions when making ERC20 cross chain calls | test_relayTokens_BridgesERC20ViaTokenBridge |
| 3 | Correctly calls the CCTP bridge adapter when attempting to bridge USDC | test_relayTokens_BridgesUsdcViaCCTP |
| 4 | Splits USDC into parts to stay under per-message limit when attempting to bridge USDC | test_relayTokens_SplitsUsdcWhenOverBurnLimit |
| 5 | Correctly unwraps WETH and bridges ETH | test_relayTokens_UnwrapsWETHAndBridgesETH |

### Mocks Used

- `MockCCTPMinter` from `contracts/test/MockCCTP.sol`
- `MockCCTPMessengerV2` from `contracts/test/MockCCTP.sol` (newly added)
- `MockSpokePool` from `contracts/test/MockSpokePool.sol`
- `vm.mockCall` pattern for Linea message service and token bridge

### New Mocks/Utilities Created

- `MockCCTPMessengerV2` in `contracts/test/MockCCTP.sol` - Implements CCTP V2 `depositForBurn()` interface with 7 parameters (amount, destinationDomain, mintRecipient, burnToken, destinationCaller, maxFee, minFinalityThreshold). Includes:
  - `feeRecipient()` - returns non-zero address for V2 detection
  - `localMinter()` - returns ITokenMinter
  - `depositForBurnCallCount` - call counter
  - `lastDepositForBurnCall` - struct for last call parameters
  - `depositForBurnCalls[]` - array of all calls for multi-call verification
  - `getDepositForBurnCall(index)` - getter for specific call parameters

### Deviations from Original

- None significant. The Foundry test verifies the same behavior.
- Uses `vm.mockCall`/`vm.expectCall` for Linea bridge contracts instead of smock FakeContract.

### Notes

- **CCTP V2 Detection**: The `CircleCCTPAdapter` detects V2 by checking if `feeRecipient()` returns a non-zero address. The mock must implement this for V2 behavior to activate.
- **CCTP V2 Parameters**: V2's `depositForBurn()` has additional parameters:
  - `destinationCaller = bytes32(0)` - anyone can call receiveMessage
  - `maxFee = 0` - standard transfer (no speedup fee)
  - `minFinalityThreshold = 2000` - standard finality threshold
- Linea_Adapter bridges via three mechanisms:
  1. `IMessageService.sendMessage()` for admin messages - fee is always 0 (Linea doesn't support auto-claiming for non-empty calldata)
  2. `ITokenBridge.bridgeToken()` for ERC20 tokens (except USDC and WETH)
  3. `IMessageService.sendMessage{value: amount}()` for WETH - unwraps to ETH first and sends via message service
  4. CCTP V2 `depositForBurn()` for USDC
- **USDC Splitting**: When USDC amount exceeds `burnLimitsPerMessage`, the adapter splits into multiple calls. Test covers:
  - Uneven split (limit = amount/2 - 1): 3 calls with amounts [limit, limit, 2]
  - Even split (limit = amount/2): 2 calls with amounts [limit, limit]
- Circle domain ID for Linea is 11 (`CircleDomainIds.Linea`)
- Chain ID: 59144 (Linea mainnet)

---
